[
  {
    "id": 0,
    "type": "Param",
    "comment": "@param petId ID of pet that needs to be updated",
    "code": "  public void  updatePetWithForm (Long petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1,
    "type": "Param",
    "comment": "@param prefered",
    "code": "    public static int availablePort(int preferred) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(preferred);\n        } catch (IOException ignored) {\n        }\n        return rtn;\n    }\n",
    "label": 1,
    "rec": "@param preferred preferred port"
  },
  {
    "id": 2,
    "type": "Param",
    "comment": "@param global",
    "code": "    public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) {\n        return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern);\n    }\n\n",
    "label": 1,
    "rec": "@param scenarioPattern"
  },
  {
    "id": 3,
    "type": "Param",
    "comment": "@param req the  HttpServletResponse",
    "code": "    protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    }\n",
    "label": 1,
    "rec": "@param req the  AtmosphereResponse"
  },
  {
    "id": 4,
    "type": "Param",
    "comment": "@param context the annotation binding context with access to the service registry and the annotation index",
    "code": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) {\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n",
    "label": 1,
    "rec": "@param bindingContext The binding context, giving access to needed services and information"
  },
  {
    "id": 5,
    "type": "Param",
    "comment": "@param semgrex the pattern string",
    "code": "  public static SemgrexPattern compile(String semgrex) {\n    // TODO: make this threadsafe by making SemgrexParser threadsafe.\n    // TODO: make semgrex parser objects non-public\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.setPatternString(semgrex);\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 6,
    "type": "Param",
    "comment": "@param body client model (required)",
    "code": "  public Client testClientModel(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 1,
    "rec": "@param client client model (required)"
  },
  {
    "id": 7,
    "type": "Param",
    "comment": "@param verbose whether or not to output verbose information.",
    "code": "  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 8,
    "type": "Param",
    "comment": "@param file file to upload (required)",
    "code": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 1,
    "rec": "@param requiredFile file to upload (required)"
  },
  {
    "id": 9,
    "type": "Param",
    "comment": "@param tabIdxName - The table/index identifier",
    "code": "  public double getLeadingRowCount(RexNode condition, String tabIdxName, DrillScanRelBase scanRel) {\n    String conditionAsStr = nullConditionAsString;\n    Map<String, StatisticsPayload> payloadMap;\n    if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan)\n        || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) {\n      if (condition == null && fullTableScanPayload != null) {\n        return fullTableScanPayload.getLeadingRowCount();\n      } else if (condition != null) {\n        conditionAsStr = convertRexToString(condition, scanRel.getRowType());\n        payloadMap = statsCache.get(conditionAsStr);\n        if (payloadMap != null) {\n          if (payloadMap.get(tabIdxName) != null) {\n            return payloadMap.get(tabIdxName).getLeadingRowCount();\n          }\n          // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is\n          // not found, we are out of luck!\n        }\n      }\n    }\n    if (statsAvailable) {\n      logger.debug(\"Statistics: Leading filter row count is UNKNOWN for filter: {}\", conditionAsStr);\n    }\n    return ROWCOUNT_UNKNOWN;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 10,
    "type": "Param",
    "comment": "@param month the month (1,12) to update the time to.",
    "code": "    public long set(long instant, int month) {\n        Utils.verifyValueBounds(this, month, MIN, MAX);\n        //\n        int thisYear = iChronology.year().get(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(instant);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 11,
    "type": "Param",
    "comment": "@param clazz",
    "code": "\tpublic Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {\n\t\tsetCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );\n\t\treturn this;\n\t}\n",
    "label": 1,
    "rec": "@param entityName The name of the entity to which we shoudl associate these cache settings"
  },
  {
    "id": 12,
    "type": "Param",
    "comment": "@param fs file system",
    "code": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 13,
    "type": "Param",
    "comment": "@param req the  HttpServletRequest",
    "code": "    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n",
    "label": 1,
    "rec": "@param req the  AtmosphereRequest"
  },
  {
    "id": 14,
    "type": "Param",
    "comment": "@param operator operator",
    "code": "    public static BooleanOperation predicate(Operator operation, Expression<?>... args) {\n        return new BooleanOperation(operation, args);\n    }\n",
    "label": 1,
    "rec": "@param operation"
  },
  {
    "id": 15,
    "type": "Param",
    "comment": "@param path",
    "code": "    private static File getKylinPropertiesFile(String path) {\n        if (path == null)\n            return null;\n        \n        File propFile = new File(path, KYLIN_CONF_PROPERTIES_FILE);\n        if (propFile.exists()) {\n            logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was found at \" + propFile.getAbsolutePath());\n        }\n        \n        logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was NOT found at \" + propFile.getAbsolutePath());\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 16,
    "type": "Param",
    "comment": "@param graphics",
    "code": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 17,
    "type": "Param",
    "comment": "@param file file to upload (required)",
    "code": "    public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n        com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, requiredFile, additionalMetadata, null, null);\n        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n",
    "label": 1,
    "rec": "@param requiredFile file to upload (required)"
  },
  {
    "id": 18,
    "type": "Param",
    "comment": "@param registry the SchemeRegistry",
    "code": "    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry, String name) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(metricRegistry,\n                                                  registry,\n                                                  ttl,\n                                                  TimeUnit.MILLISECONDS,\n                                                  resolver,\n                                                  name);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 19,
    "type": "Param",
    "comment": "@param s Input date string",
    "code": "  public static String normalizeDateString(String s, String ctxdate) {\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n\n    Pattern p;\n    Matcher m;\n    String ctxyear = \"XXXX\", ctxmonth = \"XX\", ctxday = \"XX\";\n\n    // set up context date\n    if (ctxdate != null) {\n      p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n      m = p.matcher(ctxdate);\n\n      if (m.find() && m.groupCount() == 3) {\n        ctxyear = m.group(1);\n        ctxmonth = m.group(2);\n        ctxday = m.group(3);\n      }\n    }\n\n    p = Pattern.compile(\"^\" + BIRTH_DECADE_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + \"X\");\n      res.append(\"-XX-XX\");\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + RELATIVE_TIME_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 20,
    "type": "Param",
    "comment": "@param implRestConnection network operating interface, The implementation of the network layer.",
    "code": "    public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {\n        return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 21,
    "type": "Param",
    "comment": "@param strings Expected expressions",
    "code": "  private static Consumer<List> mongoChecker(final String... expected) {\n    return actual -> {\n      if (expected == null) {\n        Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue());\n        return;\n      }\n\n      if (expected.length == 0) {\n        CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected,\n            actual.toArray(new Object[0]));\n        return;\n      }\n\n      final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected));\n      final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0))\n          .stream()\n          .map(Objects::toString)\n          .collect(Collectors.joining(\"\\n\")));\n\n      // compare Bson (not string) representation\n      if (!expectedBson.equals(actualBson)) {\n        final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build();\n        // used to pretty print Assertion error\n        Assert.assertEquals(\"expected and actual Mongo queries do not match\",\n            expectedBson.toJson(settings),\n            actualBson.toJson(settings));\n        Assert.fail(\"Should have failed previously because (expected != actual) is already known\");\n      }\n    };\n  }\n",
    "label": 1,
    "rec": "@param expected Expected query (as array)"
  },
  {
    "id": 22,
    "type": "Param",
    "comment": "@param body client model (required)",
    "code": "  public ApiResponse<Client> testClassnameWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 1,
    "rec": "@param client client model (required)"
  },
  {
    "id": 23,
    "type": "Param",
    "comment": "@param s The short name of the GrammaticalRelation",
    "code": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values, Lock readValuesLock) {\n    readValuesLock.lock();\n    try {\n      for (GrammaticalRelation reln : values) {\n        if (reln.toString().equals(s)) return reln;\n      }\n    } finally {\n      readValuesLock.unlock();\n    }\n\n    return null;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 24,
    "type": "Param",
    "comment": "@param body order placed for purchasing the pet",
    "code": "    public Order placeOrder(Order order, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(order, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "label": 1,
    "rec": "@param order order placed for purchasing the pet"
  },
  {
    "id": 25,
    "type": "Param",
    "comment": "@param property Property to get example string for",
    "code": "    protected String getExample(Schema schema) {\n        if (schema.getExample() != null) {\n            return schema.getExample().toString();\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"2000-01-23\";\n        } else if (ModelUtils.isBooleanSchema(schema)) {\n            return \"true\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            if (ModelUtils.isFloatSchema(schema)) { // float\n                return \"1.3579\";\n            } else { // double\n                return \"3.149\";\n            }\n        } else if (ModelUtils.isPasswordSchema(schema)) {\n            return \"********\";\n        } else if (ModelUtils.isUUIDSchema(schema)) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n            // do these last in case the specific types above are derived from these classes\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"aeiou\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            if (ModelUtils.isLongSchema(schema)) { // long\n                return \"123456789\";\n            } else { //integer\n                return \"123\";\n            }\n        } else {\n            LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema);\n            return \"UNDEFINED_EXAMPLE_VALUE\";\n        }\n    }\n",
    "label": 1,
    "rec": "@param schema Schema to get example string for"
  },
  {
    "id": 26,
    "type": "Param",
    "comment": "@param base the table part of the expansion",
    "code": "  public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 27,
    "type": "Param",
    "comment": "@param orderId ID of pet that needs to be fetched",
    "code": "  public Order  getOrderById (Long orderId) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Order) ApiInvoker.deserialize(response, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 28,
    "type": "Param",
    "comment": "@param authNames The authentications to apply",
    "code": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 29,
    "type": "Param",
    "comment": "@param channel",
    "code": "\t\tprivate byte[] read(InputStream in, int length) throws IOException {\n\t\t\tbyte[] buffer = new byte[length];\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += in.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n",
    "label": 1,
    "rec": "@param in"
  },
  {
    "id": 30,
    "type": "Param",
    "comment": "@param aliasedLockOptions a map of lock options indexed by aliased table names.",
    "code": "\tpublic String applyLocksToSql(String sql, LockOptions aliasedLockOptions, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString();\n\t}\n",
    "label": 1,
    "rec": "@param aliasedLockOptions lock options indexed by aliased table names."
  },
  {
    "id": 31,
    "type": "Param",
    "comment": "@param te is the typeEntry from the Parameters object, which represents the parameter",
    "code": "    public static QName getXSIType(Parameter param) {\n        if (param.getMIMEType() != null) {\n            return getMIMETypeQName(param.getMIMEType());\n        }\n\n        QName xmlType = null;\n        TypeEntry te = param.getType();\n\n        // If the TypeEntry describes an Element, get\n        // the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        // If the TypeEntry is a CollectionType, use\n        // the TypeEntry representing the component Type\n        // So for example a parameter that takes a \n        // collection type for\n        // <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"/>\n        // will be \n        // new ParameterDesc(<QName of A>, IN,\n        //                   <QName of xsd:string>,\n        //                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    }\n\n",
    "label": 1,
    "rec": "@param param is a parameter"
  },
  {
    "id": 32,
    "type": "Param",
    "comment": "@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3",
    "code": "\tpublic static Polygon getCanvasTileAreaPoly(Client client, LocalPoint localLocation, int size)\n\t{\n\t\tint plane = client.getPlane();\n\t\tint halfTile = LOCAL_TILE_SIZE / 2;\n\n\t\t// If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5\n\t\tint aoeSize = size / 2;\n\n\t\t// Shift over one half tile as localLocation is the center point of the tile, and then shift the area size\n\t\tPoint topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile,\n\t\t\tlocalLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile);\n\t\t// expand by size\n\t\tPoint bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1,\n\t\t\ttopLeft.getY() + size * LOCAL_TILE_SIZE - 1);\n\t\t// Take the x of top left and the y of bottom right to create bottom left\n\t\tPoint bottomLeft = new Point(topLeft.getX(), bottomRight.getY());\n\t\t// Similarly for top right\n\t\tPoint topRight = new Point(bottomRight.getX(), topLeft.getY());\n\n\t\tPoint p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane);\n\t\tPoint p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane);\n\t\tPoint p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane);\n\t\tPoint p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane);\n\n\t\tif (p1 == null || p2 == null || p3 == null || p4 == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tPolygon poly = new Polygon();\n\t\tpoly.addPoint(p1.getX(), p1.getY());\n\t\tpoly.addPoint(p2.getX(), p2.getY());\n\t\tpoly.addPoint(p3.getX(), p3.getY());\n\t\tpoly.addPoint(p4.getX(), p4.getY());\n\n\t\treturn poly;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 33,
    "type": "Param",
    "comment": "@param outputFile - The file to which we'll output the HTML results",
    "code": "    public String runHTMLSuite(String browser, String browserURL, File suiteFile, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException {\n        if (browser == null) throw new IllegalArgumentException(\"browser may not be null\");\n        if (!suiteFile.exists()) {\n    \t\tthrow new IOException(\"Can't find HTML Suite file:\" + suiteFile.getAbsolutePath());\n    \t}\n    \tif (!suiteFile.canRead()) {\n    \t\tthrow new IOException(\"Can't read HTML Suite file: \" + suiteFile.getAbsolutePath());\n    \t}\n    \tremoteControl.addNewStaticContent(suiteFile.getParentFile());\n        \n        // DGF this is a hack, but I can't find a better place to put it\n        String suiteURL;\n        if (browser.startsWith(\"*chrome\") || browser.startsWith(\"*firefox\") || browser.startsWith(\"*iehta\")  || browser.startsWith(\"*iexplore\") ) {\n            suiteURL = \"http://localhost:\" + remoteControl.getConfiguration().getPortDriversShouldContact() + \"/selenium-server/tests/\" + suiteFile.getName();\n        } else {\n          suiteURL = Urls.toProtocolHostAndPort(browserURL) + \"/selenium-server/tests/\" + suiteFile.getName();\n        }\n    \treturn runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 34,
    "type": "Param",
    "comment": "@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix",
    "code": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n\n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n\n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 35,
    "type": "Param",
    "comment": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "code": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchText(regex, matches, scroll);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 36,
    "type": "Param",
    "comment": "@param user (User) Updated user object (required)",
    "code": "        public UpdateUserOper body(User body) {\n            reqSpec.setBody(body);\n            return this;\n        }\n",
    "label": 1,
    "rec": "@param body (User) Updated user object (required)"
  },
  {
    "id": 37,
    "type": "Param",
    "comment": "@param length the new length",
    "code": "    public Duration withMillis(long duration) {\n        if (duration == getMillis()) {\n            return this;\n        }\n        return new Duration(duration);\n    }\n",
    "label": 1,
    "rec": "@param duration the new length of the duration"
  },
  {
    "id": 38,
    "type": "Param",
    "comment": "@param body Input boolean as post body (optional)",
    "code": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 1,
    "rec": "@param booleanPostBody Input boolean as post body (optional)"
  },
  {
    "id": 39,
    "type": "Param",
    "comment": "@param dataBufferRef Next set of bytes received by the caller",
    "code": "  public boolean parseMoreData(final EncodedImage encodedImage) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final int dataBufferSize = encodedImage.getSize();\n\n    // Is there any new data to parse?\n    // mBytesParsed might be greater than size of dataBuffer - that happens when\n    // we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        encodedImage.getInputStream(),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  }\n",
    "label": 1,
    "rec": "@param encodedImage Next set of bytes received by the caller"
  },
  {
    "id": 40,
    "type": "Param",
    "comment": "@param includeExtras If true, the list of typed dependencies returned may include \"extras\", like controlling subjects",
    "code": "  public List<TypedDependency> typedDependenciesCollapsed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(false);\n    // Adds stuff to the basic dependencies.\n    // We don't want to simply call typedDependencies with\n    // \"includeExtras\" because the collapseDependencies method may add\n    // the extras in a way that makes more logical sense.  For\n    // example, the English dependencies, when CC processed, have more\n    // nsubjs than they originally do.  If we wait until that occurs\n    // to add xsubj for xcomp dependencies, we get better coverage.\n    if (includeExtras) {\n      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter());\n    }\n    collapseDependencies(tdl, false, includeExtras);\n    return tdl;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 41,
    "type": "Param",
    "comment": "@param orderId ID of pet that needs to be fetched (required)",
    "code": "  public ApiResponse<Order> getOrderByIdWithHttpInfo(String orderId) throws ApiException {\n    Call call = getOrderByIdCall(orderId, null, null);\n    Type localVarReturnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, localVarReturnType);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 42,
    "type": "Param",
    "comment": "@param field field should operate in UTC or be time zone agnostic",
    "code": "    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        DateTimeField field = fieldType.getField(iChronoUTC);\n        return append0(new TextField(iChrono, field, iLocale, true));\n    }\n",
    "label": 1,
    "rec": "@param fieldType type of field to append"
  },
  {
    "id": 43,
    "type": "Param",
    "comment": "@param body List of user object",
    "code": "  public void createUsersWithArrayInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithArrayInput\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithArrayInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithArray\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "label": 1,
    "rec": "@param user List of user object"
  },
  {
    "id": 44,
    "type": "Param",
    "comment": "@param v the long to examine.",
    "code": "    public static int numberOfLeadingZeros(long lng) {\n        lng |= lng >> 1;\n        lng |= lng >> 2;\n        lng |= lng >> 4;\n        lng |= lng >> 8;\n        lng |= lng >> 16;\n        lng |= lng >> 32;\n        return bitCount(~lng);\n    }\n\n",
    "label": 1,
    "rec": "@param lng the long to examine."
  },
  {
    "id": 45,
    "type": "Param",
    "comment": "@param queryParams The query parameters",
    "code": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 46,
    "type": "Param",
    "comment": "@param cap",
    "code": "\tpublic static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url,Registry registry) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.addDesiredCapabilitiy(cap);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req,registry);\n\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 47,
    "type": "Param",
    "comment": "@param clause clause",
    "code": "    public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?>... clauses) {\n        SQLInsertClause insert = insert(entity);\n        StringBuilder flag = new StringBuilder(\" on duplicate key update \");\n        for (int i = 0; i < clauses.length; i++) {\n            flag.append(i > 0 ? \", \" : \"\").append(\"{\" + i + \"}\");\n        }\n        insert.addFlag(Position.END, ExpressionUtils.template(String.class, flag.toString(), clauses));\n        return insert;\n    }\n",
    "label": 1,
    "rec": "@param clauses clauses"
  },
  {
    "id": 48,
    "type": "Param",
    "comment": "@param p Swagger Property object",
    "code": "    public String getTypeDeclaration(Schema p) {\n        if (ModelUtils.isArraySchema(p)) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (ModelUtils.isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            // TODO not sure if the following map/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    }\n",
    "label": 1,
    "rec": "@param p OpenAPI Schema object"
  },
  {
    "id": 49,
    "type": "Param",
    "comment": "@param direction the direction to be scrolled",
    "code": "\tpublic boolean scrollList(int listIndex, Direction direction, ArrayList<ListView> listViews) {\n\t\tint[] xy = new int[2];\n\t\tfinal ListView listView = getView(ListView.class, listViews, listIndex);\n\t\t\n\t\tlistView.getLocationOnScreen(xy);\n\t\n\t\twhile (xy[1] + 20 > activityUtils.getCurrentActivity(false)\n\t\t\t\t.getWindowManager().getDefaultDisplay().getHeight()) {\n\t\t\tscrollScrollView(direction, null);\n\t\t\tlistView.getLocationOnScreen(xy);\n\t\t}\n\t\tif (direction == Direction.DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount() - 1) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition()+1);\n\t\t\t\n\t\t} else if (direction == Direction.UP) {\n\t\t\t\n\t\t\tif (listView.getFirstVisiblePosition() < 2) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tfinal int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition());\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\t\t\t\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 50,
    "type": "Param",
    "comment": "@param minimumSimilarity",
    "code": "    public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, maxEdits));\n    }\n",
    "label": 1,
    "rec": "@param maxEdits"
  },
  {
    "id": 51,
    "type": "Param",
    "comment": "@param scroll whether scrolling should be performed",
    "code": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 52,
    "type": "Param",
    "comment": "@param right",
    "code": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, right);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 53,
    "type": "Param",
    "comment": "@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.",
    "code": "        public int read(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 54,
    "type": "Param",
    "comment": "@param client",
    "code": "\tpublic static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, LocalPoint localLocation, SpritePixels sprite, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - sprite.getWidth() / 2;\n\t\tint yOffset = p.getY() - sprite.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 55,
    "type": "Param",
    "comment": "@param base the current base directory, may be null.",
    "code": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "@param file1 One of the files, for which the common base directory is being sought, may be null."
  },
  {
    "id": 56,
    "type": "Param",
    "comment": "@param instant the instant to compare to",
    "code": "    public int compareTo(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = partial.get(getFieldType());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n",
    "label": 1,
    "rec": "@param partial the partial to compare to"
  },
  {
    "id": 57,
    "type": "Param",
    "comment": "@param panelToolbar2 the toolbar",
    "code": "\tprotected int addToolBarElements(JToolBar toolBar, Location location, int gridX) {\n\t\treturn gridX;\n\t}\n",
    "label": 1,
    "rec": "@param toolBar the tool bar"
  },
  {
    "id": 58,
    "type": "Param",
    "comment": "@param template",
    "code": "    public TemplateExpressionImpl(Class<? extends T> type, Template template, Object... args){\n        this(type, template, Arrays.<Object>asList(args));\n    }    \n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 59,
    "type": "Param",
    "comment": "@param key mapper key",
    "code": "  public List<String> get(Path key) {\n    Integer index = keyToIndexMapper.get(key);\n    if (index == null) {\n      return Collections.emptyList();\n    }\n    return partitionValues.get(index);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 60,
    "type": "Param",
    "comment": "@param file the file for which the new base directory should be returned.",
    "code": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "@param file2 The other file for which the common base directory should be returned."
  },
  {
    "id": 61,
    "type": "Param",
    "comment": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "code": "\tpublic boolean searchText(String regex, int matches) {\n\t\tboolean found = searcher.searchText(regex, matches, true);\n\t\treturn found;\n\n\t}\n",
    "label": 1,
    "rec": "@param regex the text to search for. The parameter will be interpreted as a regular expression."
  },
  {
    "id": 62,
    "type": "Param",
    "comment": "@param clientId",
    "code": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 63,
    "type": "Param",
    "comment": "@param allocator The target allocator to create an association with.",
    "code": "  public DrillBuf retain(BufferAllocator target) {\n\n    if (isEmpty) {\n      return this;\n    }\n\n    if (BaseAllocator.DEBUG) {\n      historicalLog.recordEvent(\"retain(%s)\", target.getName());\n    }\n    final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target);\n    return otherLedger.newDrillBuf(offset, length, null);\n  }\n",
    "label": 1,
    "rec": "@param target The target allocator to create an association with."
  },
  {
    "id": 64,
    "type": "Param",
    "comment": "@param visible  true if only texts visible on the screen should be searched",
    "code": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible);\n\t}\n",
    "label": 1,
    "rec": "@param onlyVisible  true if only texts visible on the screen should be searched"
  },
  {
    "id": 65,
    "type": "Param",
    "comment": "@param client the game client",
    "code": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 66,
    "type": "Param",
    "comment": "@param multiQuery the array of prepared queries",
    "code": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 67,
    "type": "Param",
    "comment": "@param baseMillis source of missing fields",
    "code": "    public long resolve(long baseMillis, DateTimeZone zone) {\n        Chronology chrono = iChronology.withZone(zone);\n        long millis = baseMillis;\n        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));\n        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));\n        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));\n        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));\n        return millis;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 68,
    "type": "Param",
    "comment": "@param instant the partial instant",
    "code": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 69,
    "type": "Param",
    "comment": "@param client",
    "code": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 70,
    "type": "Param",
    "comment": "@param config An instance of  BroadcasterConfig",
    "code": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        config = c;\n        return factory;\n    }\n",
    "label": 1,
    "rec": "@param c An instance of  AtmosphereServlet.AtmosphereConfig"
  },
  {
    "id": 71,
    "type": "Param",
    "comment": "@param proto The serialized representation of the graph. This relies heavily on indexing into the original document.",
    "code": "  private static SemanticGraph fromProto(CoreNLPProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    // first construct the actual nodes; keep them indexed by their index\n    // This block is optimized as one of the places which take noticeable time\n    // in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    // add all edges to the actual graph\n    for(CoreNLPProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        // this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI - min]);\n      }\n      graph.setRoots(roots);\n    } else {\n      // Roots were not saved away\n      // compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 72,
    "type": "Param",
    "comment": "@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"",
    "code": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 73,
    "type": "Param",
    "comment": "@param lng the long to examine.",
    "code": "    public static int numberOfLeadingZeros(long v) {\n        // After Hacker's Delight, Figure 5-6\n        if (v < 0) {\n            return 0;\n        }\n        if (v == 0) {\n            return 64;\n        }\n        // On a 64-bit VM, the two previous tests should probably be replaced by\n        // if (v <= 0) return ((int) (~v >> 57)) & 64;\n\n        int n = 1;\n        int i = (int) (v >>> 32);\n        if (i == 0) {\n            n +=  32;\n            i = (int) v;\n        }\n        if (i >> 16 == 0) {\n            n +=  16;\n            i <<= 16;\n        }\n        if (i >> 24 == 0) {\n            n +=  8;\n            i <<= 8;\n        }\n        if (i >> 28 == 0) {\n            n +=  4;\n            i <<= 4;\n        }\n        if (i >> 30 == 0) {\n            n +=  2;\n            i <<= 2;\n        }\n        return n - (i >>> 31);\n    }\n\n",
    "label": 1,
    "rec": "@param v the long to examine."
  },
  {
    "id": 74,
    "type": "Param",
    "comment": "@param dialect The dialect in effect",
    "code": "\tprotected String determineSegmentColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() );\n\t}\n",
    "label": 1,
    "rec": "@param jdbcEnvironment The JDBC environment"
  },
  {
    "id": 75,
    "type": "Param",
    "comment": "@param ldapContext the dir context",
    "code": "    public static LdapContext createPathContext(\n        LdapContext authorityContext, \n        String[] pathTokens) \n    throws NamingException\n    {\n        for (int i = 1; i < (pathTokens.length); i++)\n        {\n            String subContext = CN + \"=\" + pathTokens[i];\n            authorityContext = (LdapContext) createSubContext( \n            \t\tauthorityContext, \n            \t\tsubContext, null );\n        }\n        return authorityContext;\n    }\n\n",
    "label": 1,
    "rec": "@param authorityContext the ldap context"
  },
  {
    "id": 76,
    "type": "Param",
    "comment": "@param is The input stream to read from. This should contain a single protocol buffer and nothing else.",
    "code": "  public Annotation readUndelimited(File in) throws IOException {\n    FileInputStream delimited = new FileInputStream(in);\n    FileInputStream undelimited = new FileInputStream(in);\n    CoreNLPProtos.Document doc;\n    try {\n      doc = CoreNLPProtos.Document.parseFrom(delimited);\n    } catch (Exception e) {\n      doc = CoreNLPProtos.Document.parseDelimitedFrom(undelimited);\n    } finally {\n      delimited.close();\n      undelimited.close();\n    }\n    return fromProto(doc);\n  }\n",
    "label": 1,
    "rec": "@param in The file to read."
  },
  {
    "id": 77,
    "type": "Param",
    "comment": "@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one.",
    "code": "    private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            // If the application is unknown do not register/renew/cancel but\n            // refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n                case Renew:\n                    tracer = RENEW_TIMER.start();\n                    urlPath = \"apps/\" + appPathIdentifier;\n                    response = r\n                            .path(urlPath)\n                            .queryParam(\"status\",\n                                    instanceInfo.getStatus().toString())\n                            .queryParam(\"lastDirtyTimestamp\",\n                                    instanceInfo.getLastDirtyTimestamp().toString())\n                            .put(ClientResponse.class);\n                    break;\n                case Refresh:\n                    tracer = REFRESH_TIMER.start();\n                    final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                    urlPath = vipAddress == null ? \"apps/\" : \"vips/\" + vipAddress;\n                    remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                    if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                        urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                    }\n                    response = getUrl(serviceUrl + urlPath);\n                    break;\n                case Refresh_Delta:\n                    tracer = REFRESH_DELTA_TIMER.start();\n                    urlPath = \"apps/delta\";\n                    remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                    if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                        urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                    }\n                    response = getUrl(serviceUrl + urlPath);\n                    break;\n                case Register:\n                    tracer = REGISTER_TIMER.start();\n                    urlPath = \"apps/\" + instanceInfo.getAppName();\n                    response = r.path(urlPath)\n                            .type(MediaType.APPLICATION_JSON_TYPE)\n                            .post(ClientResponse.class, instanceInfo);\n                    break;\n                case Cancel:\n                    tracer = CANCEL_TIMER.start();\n                    urlPath = \"apps/\" + appPathIdentifier;\n                    response = r.path(urlPath).delete(ClientResponse.class);\n                    // Return without during de-registration if it is not registered\n                    // already and if we get a 404\n                    if ((!isRegisteredWithDiscovery)\n                            && (response.getStatus() == Status.NOT_FOUND\n                            .getStatusCode())) {\n                        return response;\n                    }\n                    break;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\",\n                        new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});\n            }\n            if (isOk(action, response.getStatus())) {\n                return response;\n            } else {\n                logger.warn(\"Action: \" + action + \"  => returned status of \"\n                        + response.getStatus() + \" from \" + serviceUrl\n                        + urlPath);\n                throw new RuntimeException(\"Bad status: \"\n                        + response.getStatus());\n            }\n        } catch (Throwable t) {\n            closeResponse(response);\n            logger.warn(\"Can't get a response from \" + serviceUrl + urlPath, t);\n            throw t;\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param action the action to be performed on eureka server."
  },
  {
    "id": 78,
    "type": "Param",
    "comment": "@param tofind array you want to find in tokens",
    "code": "  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Predicate<Pair> matchingFunction){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(matchingFunction.test(new Pair(tofind[j], tokens[i]))){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 79,
    "type": "Param",
    "comment": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "code": "\tpublic boolean searchText(String regex) {\n\t\tboolean found = searcher.searchText(regex, 0, true);\n\t\treturn found;\n\t}\n",
    "label": 1,
    "rec": "@param regex the text to search for. The parameter will be interpreted as a regular expression."
  },
  {
    "id": 80,
    "type": "Param",
    "comment": "@param verCfg Audit configuration.",
    "code": "\tprotected EntityInfo getEntityInfo(EnversService enversService, String entityName) {\n\t\tEntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n",
    "label": 1,
    "rec": "@param enversService The EnversService"
  },
  {
    "id": 81,
    "type": "Param",
    "comment": "@param verbose whether or not to output verbose information.",
    "code": "  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 82,
    "type": "Param",
    "comment": "@param body client model (required)",
    "code": "    public Client testClientModel(Client client) throws ApiException {\n        ApiResponse<Client> resp = testClientModelWithHttpInfo(client);\n        return resp.getData();\n    }\n",
    "label": 1,
    "rec": "@param client client model (required)"
  },
  {
    "id": 83,
    "type": "Param",
    "comment": "@param reader scroll reader",
    "code": "    ScrollQuery scan(String query, BytesArray body, ScrollReader reader) throws IOException {\n        String[] scrollInfo = client.scan(query, body);\n        String scrollId = scrollInfo[0];\n        long totalSize = Long.parseLong(scrollInfo[1]);\n        return new ScrollQuery(this, scrollId, totalSize, reader);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 84,
    "type": "Param",
    "comment": "@param record the state of the record as read; may not be null",
    "code": "    public Struct read(Object record, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 85,
    "type": "Param",
    "comment": "@param path The path to the metadata file, located in the directory that contains the parquet files",
    "code": "  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext, ParquetFormatConfig formatConfig) throws IOException {\n    Metadata metadata = new Metadata(fs, formatConfig);\n    metadata.readBlockMeta(path, false, metaContext);\n    return metadata.parquetTableMetadata;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 86,
    "type": "Param",
    "comment": "@param p Swagger property object",
    "code": "    public String toInstantiationType(Schema schema) {\n        if (ModelUtils.isMapSchema(schema)) {\n            Schema additionalProperties = (Schema) schema.getAdditionalProperties();\n            String type = additionalProperties.getType();\n            if (null == type) {\n                LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties + \"\\n\" //\n                        + \"\\tIn Property: \" + schema);\n            }\n            String inner = getSchemaType(additionalProperties);\n            return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";\n        } else if (ModelUtils.isArraySchema(schema)) {\n            ArraySchema arraySchema = (ArraySchema) schema;\n            String inner = getSchemaType(arraySchema.getItems());\n            return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";\n        } else {\n            return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param schema property schema"
  },
  {
    "id": 87,
    "type": "Param",
    "comment": "@param docdate The document date",
    "code": "  public static String normalizeDateString(String s, Date ctxdate) {\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n",
    "label": 1,
    "rec": "@param ctxdate Context date (usually doc_date)"
  },
  {
    "id": 88,
    "type": "Param",
    "comment": "@param context ApplicationContext",
    "code": "\tpublic static RequestQueue newRequestQueue(int threadPoolSize) {\n\t\tRequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(getContext()), threadPoolSize);\n\t\trequestQueue.start();\n\t\treturn requestQueue;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 89,
    "type": "Param",
    "comment": "@param body Input composite as post body",
    "code": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "label": 1,
    "rec": "@param outerComposite Input composite as post body"
  },
  {
    "id": 90,
    "type": "Param",
    "comment": "@param additionalMetadata Additional data to pass to server (optional, default to null)",
    "code": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 91,
    "type": "Param",
    "comment": "@param removeByStatus must remove by status  com.liulishuo.filedownloader.model.FileDownloadStatus#warn  com.liulishuo.filedownloader.model.FileDownloadStatus#paused  com.liulishuo.filedownloader.model.FileDownloadStatus#completed  com.liulishuo.filedownloader.model.FileDownloadStatus#error",
    "code": "    public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            // \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 92,
    "type": "Param",
    "comment": "@param source the information about the source that was read; may be null",
    "code": "    public Struct read(Object record, Struct source, Instant timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli());\n        }\n        return struct;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 93,
    "type": "Param",
    "comment": "@param prefix custom prefix",
    "code": "    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 94,
    "type": "Param",
    "comment": "@param message the message to broadcast.",
    "code": "    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            // Avoid re-broadcasting\n            if (!receivedMessages.remove(message)) {\n                try {\n                    jchannel.send(new Message(null, null, message));\n                } catch (ChannelException e) {\n                    logger.warn(\"failed to send message\", e);\n                }\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n",
    "label": 1,
    "rec": "@param o the message to broadcast."
  },
  {
    "id": 95,
    "type": "Param",
    "comment": "@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available",
    "code": "    protected SourceInfo update(Long lsn, Long useconds, Long txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 96,
    "type": "Param",
    "comment": "@param hosts list of ES HTTP Hosts to connect to",
    "code": "  private static RestClient connect(List<HttpHost> hosts, String pathPrefix) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[hosts.size()]));\n    if (pathPrefix != null && !pathPrefix.isEmpty()) {\n      builder.setPathPrefix(pathPrefix);\n    }\n    return builder.build();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 97,
    "type": "Param",
    "comment": "@param body client model (required)",
    "code": "  public Client testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "label": 1,
    "rec": "@param client client model (required)"
  },
  {
    "id": 98,
    "type": "Param",
    "comment": "@param child an on-tree cuboid",
    "code": "    public long findBestMatchCuboid(long cuboid) {\n        return findBestMatchCuboid1(cuboid);\n    }\n",
    "label": 1,
    "rec": "@param cuboid an on-tree cuboid"
  },
  {
    "id": 99,
    "type": "Param",
    "comment": "@param name the alias of the from item",
    "code": "    RexNode lookupExp(SqlQualified qualified) {\n      if (nameToNodeMap != null && qualified.prefixLength == 1) {\n        RexNode node = nameToNodeMap.get(qualified.identifier.names.get(0));\n        if (node == null) {\n          throw Util.newInternal(\"Unknown identifier '\" + qualified.identifier\n              + \"' encountered while expanding expression\");\n        }\n        return node;\n      }\n      int[] offsets = {-1};\n      final SqlValidatorScope[] ancestorScopes = {null};\n      SqlValidatorNamespace foundNs =\n          scope.resolve(qualified.prefix(), ancestorScopes, offsets);\n      if (foundNs == null) {\n        return null;\n      }\n\n      // Found in current query's from list.  Find which from item.\n      // We assume that the order of the from clause items has been\n      // preserved.\n      SqlValidatorScope ancestorScope = ancestorScopes[0];\n      boolean isParent = ancestorScope != scope;\n      if ((inputs != null) && !isParent) {\n        int offset = offsets[0];\n        final LookupContext rels =\n            new LookupContext(this, inputs, systemFieldList.size());\n        return lookup(offset, rels);\n      } else {\n        // We're referencing a relational expression which has not been\n        // converted yet. This occurs when from items are correlated,\n        // e.g. \"select from emp as emp join emp.getDepts() as dept\".\n        // Create a temporary expression.\n        assert isParent;\n        DeferredLookup lookup =\n            new DeferredLookup(this, qualified.identifier.names.get(0));\n        String correlName = createCorrel();\n        mapCorrelToDeferred.put(correlName, lookup);\n        final RelDataType rowType = foundNs.getRowType();\n        return rexBuilder.makeCorrel(rowType, correlName);\n      }\n    }\n",
    "label": 1,
    "rec": "@param qualified the alias of the from item"
  },
  {
    "id": 100,
    "type": "Return",
    "comment": "@return Client",
    "code": "    public Client testClassname(Client body) throws ApiException {\n        ApiResponse<Client> localVarResp = testClassnameWithHttpInfo(body);\n        return localVarResp.getData();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 101,
    "type": "Return",
    "comment": "@return true if the listener is performing the operation on the specified entity.",
    "code": "\tpublic boolean isOperatedOn(Object entity) {\n\t\tif ( entity == null ) {\n\t\t\tthrow new NullPointerException( \"null entities are not supported by \" + getClass().getName() );\n\t\t}\n\t\treturn entityToOperatedOnFlagMap.get( entity );\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 102,
    "type": "Return",
    "comment": "@return The built metadata.",
    "code": "\tpublic MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) {\n\t\tMetadataBuilderImpl defaultBuilder = new MetadataBuilderImpl( this, serviceRegistry );\n\t\treturn getCustomBuilderOrDefault( defaultBuilder );\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 103,
    "type": "Return",
    "comment": "@return true when the title matches, false otherwise",
    "code": "  public static ExpectedCondition<Boolean> titleContains(final String title) {\n    return new ExpectedCondition<Boolean>() {\n      private String currentTitle = \"\";\n\n      public Boolean apply(WebDriver driver) {\n        currentTitle = driver.getTitle();\n        return currentTitle != null && currentTitle.contains(title);\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"title to contain \\\"%s\\\". Current title: \\\"%s\\\"\", title, currentTitle);\n      }\n    };\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 104,
    "type": "Return",
    "comment": "@return the debugger controller object",
    "code": "    public Debugger getDebugger() {\n        return debugger;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 105,
    "type": "Return",
    "comment": "@return A short/Short value.",
    "code": "\tpublic Short getShort(AttributeMetadata attributeMetadata) {\n\n\t\treturn (short)getInteger(Short.MAX_VALUE);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 106,
    "type": "Return",
    "comment": "@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STARTING}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_STOPPING}, {@link IServer#STATE_UNKNOWN}",
    "code": "public int track(IProgressMonitor monitor) throws CoreException, OperationCanceledException {\n    long currentTime = System.currentTimeMillis();\n    long totalTime = currentTime + timeout;\n    CloudFoundryServerBehaviour behaviour = cloudServer.getBehaviour();\n    String appName = appModule.getDeployedApplicationName();\n    printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule);\n    int state = IServer.STATE_UNKNOWN;\n    while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) {\n        if (monitor != null && monitor.isCanceled()) {\n            String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName);\n            printlnToConsole(error, appModule);\n            throw new OperationCanceledException(error);\n        }\n        CloudApplication cloudApp = behaviour.getCloudApplication(appName, monitor);\n        ApplicationStats applicationStats = behaviour.getApplicationStats(appName, monitor);\n        if (cloudApp == null) {\n            String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName);\n            printlnToConsole(error, appModule);\n            throw CloudErrorUtil.toCoreException(error);\n        } else {\n            state = CloudFoundryApplicationModule.getCloudState(cloudApp, applicationStats);\n            try {\n                Thread.sleep(WAIT_TIME);\n            } catch (InterruptedException e) {\n            }\n            currentTime = System.currentTimeMillis();\n        }\n    }\n    String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName);\n    printlnToConsole(runningStateMessage, appModule);\n    return state;\n}",
    "label": 1,
    "rec": "@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_UNKNOWN}"
  },
  {
    "id": 107,
    "type": "Return",
    "comment": "@return the source SELECT for the data to be updated",
    "code": "  public SqlSelect getSourceSelect() {\n    return sourceSelect;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 108,
    "type": "Return",
    "comment": "@return The ruleSet",
    "code": "public Package getRuleSet() {\n    return this.pkg;\n}",
    "label": 1,
    "rec": "@return The pkg"
  },
  {
    "id": 109,
    "type": "Return",
    "comment": "@return javax.swing.JTextArea",
    "code": "    private ZapTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new ZapTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n",
    "label": 1,
    "rec": "@return javax.swing.ZapTextArea"
  },
  {
    "id": 110,
    "type": "Return",
    "comment": "@return red value in given position",
    "code": "public short getRed() {\n    return data[getFirst1DIndex()];\n}",
    "label": 1,
    "rec": "@return red value in the first position"
  },
  {
    "id": 111,
    "type": "Return",
    "comment": "@return read operation {@link RdfBranch}",
    "code": "private SailBranch branch(boolean includeinferred) throws SailException {\n    boolean active = isActive();\n    IsolationLevel level = getIsolationLevel();\n    boolean isolated = !IsolationLevels.NONE.isCompatibleWith(level);\n    if (includeinferred && active && isolated) {\n        return new DelegatingSailBranch(includeInferredBranch, false);\n    } else if (active && isolated) {\n        return new DelegatingSailBranch(explicitOnlyBranch, false);\n    } else if (includeinferred && active) {\n        return new UnionSailBranch(new SailNotBranchedSource(store.getInferredSailSource(level)), new SailNotBranchedSource(store.getExplicitSailSource(level)));\n    } else if (active) {\n        return new SailNotBranchedSource(store.getExplicitSailSource(level));\n    } else if (includeinferred) {\n        return new UnionSailBranch(store.getInferredSailSource(level).fork(), store.getExplicitSailSource(level).fork());\n    } else {\n        return store.getExplicitSailSource(level).fork();\n    }\n}",
    "label": 1,
    "rec": "@return read operation {@link SailBranch}"
  },
  {
    "id": 112,
    "type": "Return",
    "comment": "@return the number of buttons in the current activity",
    "code": "\tpublic int getCurrenButtonsCount() {\n\t\tint number = soloView.getCurrenButtonsCount();\n\t\treturn number;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 113,
    "type": "Return",
    "comment": "@return item in given position",
    "code": "@SuppressWarnings(STR)\npublic double getReal() {\n    return (double) getFirstValue();\n}",
    "label": 1,
    "rec": "@return item in first position"
  },
  {
    "id": 114,
    "type": "Return",
    "comment": "@return JSON array of the aggreagtor values",
    "code": "private byte[] marshalAggregatorValues(long superstep) {\n    if (superstep == INPUT_SUPERSTEP) {\n        return new byte[NUM];\n    }\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    DataOutputStream output = new DataOutputStream(outputStream);\n    for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) {\n        if (entry.getValue().isChanged()) {\n            try {\n                output.writeUTF(entry.getKey());\n                entry.getValue().getCurrentAggregatedValue().write(output);\n            } catch (IOException e) {\n                throw new IllegalStateException(STR + STR + entry.getKey(), e);\n            }\n        }\n    }\n    if (LOG.isInfoEnabled()) {\n        LOG.info(STR);\n    }\n    return outputStream.toByteArray();\n}",
    "label": 1,
    "rec": "@return Byte array of the aggreagtor values"
  },
  {
    "id": 115,
    "type": "Return",
    "comment": "@return True if the selector should be shown",
    "code": "    boolean shouldShowSelector() {\n        return ((hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState()) &&  ( mBeginClick ) ;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 116,
    "type": "Return",
    "comment": "@return the {@link org.atmosphere.cpr.MetaBroadcaster}",
    "code": "public static DefaultMetaBroadcaster metaBroadcaster() {\n    return metaBroadcaster;\n}",
    "label": 1,
    "rec": "@return the {@link DefaultMetaBroadcaster}"
  },
  {
    "id": 117,
    "type": "Return",
    "comment": "@return a vector holding the value as string.",
    "code": "    public Vector<String> getHeaders(String name) {\n    \tVector<String> v = mHeaderFields.get(name.toUpperCase());\n    \treturn v;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 118,
    "type": "Return",
    "comment": "@return If reached, return true; else, return false.",
    "code": "public static boolean exceedsMaxCount() {\n    final long maxTestCount = HostConfig.getMaxTestCount();\n    return (maxTestCount > NUM) && (mTestCount >= maxTestCount);\n}",
    "label": 1,
    "rec": "@return true, if the max count is enabled and exceeded."
  },
  {
    "id": 119,
    "type": "Return",
    "comment": "@return -1 if the value is not valid",
    "code": "public static ImportMode getModeValue(String mode) {\n    if (mode == null)\n        return null;\n    mode = mode.trim().toLowerCase();\n    if (mode.indexOf(STR) == -NUM) {\n        if (STR.equals(mode)) {\n            return ImportMode.insert;\n        } else if (STR.equals(mode)) {\n            return ImportMode.update;\n        } else {\n            return null;\n        }\n    } else {\n        List l = StringUtil.stringToList(mode, STR);\n        String first = (String) l.get(NUM);\n        String second = (String) l.get(NUM);\n        if (STR.equals(first) && STR.equals(second)) {\n            return ImportMode.insertUpdate;\n        } else if (STR.equals(first) && STR.equals(second)) {\n            return ImportMode.updateInsert;\n        } else {\n            return null;\n        }\n    }\n}",
    "label": 1,
    "rec": "@return null if the value is not valid"
  },
  {
    "id": 120,
    "type": "Return",
    "comment": "@return Built {@link Ct.TimestampedEntry}.",
    "code": "public static TimestampedEntry parseTimestampedEntry(InputStream in) {\n    TimestampedEntry timestampedEntry = new TimestampedEntry();\n    timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType);\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n        int length = (int) readNumber(in, NUM);\n        ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n        signedEntryBuilder.setX509(x509);\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n        Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n        byte[] arr = readFixedLength(in, NUM);\n        preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n        arr = readFixedLength(in, NUM);\n        int length = (int) readNumber(in, NUM);\n        preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n        preCertBuilder.build();\n        signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n        throw new SerializationException(String.format(STR, entryType));\n    }\n    timestampedEntry.signedEntry = signedEntryBuilder.build();\n    return timestampedEntry;\n}",
    "label": 1,
    "rec": "@return Built {@link TimestampedEntry}."
  },
  {
    "id": 121,
    "type": "Return",
    "comment": "@return a  BigDecimal value which contains the number of nanoseconds, never  null",
    "code": "    public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n",
    "label": 1,
    "rec": "@return Approximate representation of the given interval as a number of nanoseconds"
  },
  {
    "id": 122,
    "type": "Return",
    "comment": "@return the converted value, or null if the conversion could not be made and the column allows nulls",
    "code": "    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        return convertValue(column, fieldDefn, data, SHORT_FALSE, (r) -> {\n            if (data instanceof Short) {\n                r.deliver(data);\n            }\n            else if (data instanceof Number) {\n                Number value = (Number) data;\n                r.deliver(new Short(value.shortValue()));\n            }\n            else if (data instanceof Boolean) {\n                r.deliver(NumberConversions.getShort((Boolean)data));\n            }\n            else if (data instanceof String) {\n                r.deliver(Short.parseShort((String)data));\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 123,
    "type": "Return",
    "comment": "@return ResponseEntity&lt;BigDecimal&gt;",
    "code": "    public ResponseEntity<BigDecimal> fakeOuterNumberSerializeWithHttpInfo(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = apiClient.expandPath(\"/fake/outer/number\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 124,
    "type": "Return",
    "comment": "@return The {@link android.telecomm.Connection.VideoProvider}.",
    "code": "public android.telecom.Connection.VideoProvider getVideoProvider() {\n    return mVideoProvider;\n}",
    "label": 1,
    "rec": "@return The {@link android.telecom.Connection.VideoProvider}."
  },
  {
    "id": 125,
    "type": "Return",
    "comment": "@return suggestion map",
    "code": "    public EnvelopeResponse getValidEncodings() {\n\n        Set<String> allDatatypes = Sets.newHashSet();\n        allDatatypes.addAll(DataType.DATETIME_FAMILY);\n        allDatatypes.addAll(DataType.INTEGER_FAMILY);\n        allDatatypes.addAll(DataType.NUMBER_FAMILY);\n        allDatatypes.addAll(DataType.STRING_FAMILY);\n\n        Map<String, List<String>> datatypeValidEncodings = Maps.newHashMap();\n        for (String dataTypeStr : allDatatypes) {\n            datatypeValidEncodings.put(dataTypeStr, encodingService.getValidEncodings(DataType.getType(dataTypeStr)));\n        }\n\n        return new EnvelopeResponse(ResponseCode.CODE_SUCCESS, datatypeValidEncodings, \"\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 126,
    "type": "Return",
    "comment": "@return a VirErrorLevel",
    "code": "public ErrorLevel getLevel() {\n    return level;\n}",
    "label": 1,
    "rec": "@return a ErrorLevel"
  },
  {
    "id": 127,
    "type": "Return",
    "comment": "@return project files in that directory, sorted alphabetically.",
    "code": "private File[] getProjectFiles(File directory) {\n    return directory.listFiles(new FileFilter() {\n\n        public boolean accept(File file) {\n            return (file.isFile() && file.getName().endsWith(STR));\n        }\n    });\n}",
    "label": 1,
    "rec": "@return project files in that directory."
  },
  {
    "id": 128,
    "type": "Return",
    "comment": "@return the extended FluentPipeline",
    "code": "public GremlinPipeline<S, Edge> E() {\n    return this.add(new EdgesPipe());\n}",
    "label": 1,
    "rec": "@return the extended Pipeline"
  },
  {
    "id": 129,
    "type": "Return",
    "comment": "@return True if a vacant cell was found",
    "code": "    public boolean getVacantCell(int[] vacant, int spanX, int spanY) {\n        final boolean portrait = mPortrait;\n        final int xCount = portrait ? mShortAxisCells : mLongAxisCells;\n        final int yCount = portrait ? mLongAxisCells : mShortAxisCells;\n        final boolean[][] occupied = mOccupied;\n\n        findOccupiedCells(xCount, yCount, occupied, null);\n\n        return findVacantCell(vacant, spanX, spanY, xCount, yCount, occupied);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 130,
    "type": "Return",
    "comment": "@return measuredWidth",
    "code": "    private int measureWidth(int widthMeasureSpec) {\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int measuredWidth = widthSize;\n\n        if (mThumbWidth == 0 && mIsThumbUseDrawable) {\n            mThumbWidth = mThumbDrawable.getIntrinsicWidth();\n        }\n\n        int moveRange;\n        int textWidth = ceil(mTextWidth);\n        // how much the background should extend to fit text.\n        int textExtraSpace;\n        int contentSize;\n\n        if (mThumbRangeRatio == 0) {\n            mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n        }\n\n        if (widthMode == MeasureSpec.EXACTLY) {\n            contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n\n            if (mThumbWidth != 0) {\n                moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0));\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                }\n                if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) {\n                    mThumbWidth = 0;\n                }\n            }\n\n            if (mThumbWidth == 0) {\n                contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n                moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0));\n                if (moveRange < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                mThumbWidth = ceil(moveRange / mThumbRangeRatio);\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right);\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                if (textExtraSpace > 0) {\n                    // since backWidth is determined by view width, so we can only reduce thumbSize.\n                    mThumbWidth = mThumbWidth - textExtraSpace;\n                }\n                if (mThumbWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n            }\n        } else {\n            /*\n            If parent view want SwitchButton to determine it's size itself, we calculate the minimal\n            size of it's content. Further more, we ignore the limitation of widthSize since we want\n            to display SwitchButton in its actual size rather than compress the shape.\n             */\n            if (mThumbWidth == 0) {\n                /*\n                If thumbWidth is not set, use the default one.\n                 */\n                mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP);\n            }\n            if (mThumbRangeRatio == 0) {\n                mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n            }\n\n            moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n            textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset));\n            mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace));\n            if (mBackWidth < 0) {\n                mThumbWidth = 0;\n                mBackWidth = 0;\n                return measuredWidth;\n            }\n            contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace));\n\n            measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight());\n        }\n        return measuredWidth;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 131,
    "type": "Return",
    "comment": "@return int",
    "code": "  public int getUniformLocation(String name) {\n    init();\n    return pgl.glGetUniformLocation(programObject, name);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 132,
    "type": "Return",
    "comment": "@return the matching option, or null if no match is found and the non-null default is invalid",
    "code": "        public static EventProcessingFailureHandlingMode parse(String value) {\n            if (value == null) {\n                return null;\n            }\n\n            value = value.trim();\n\n            for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n\n            return null;\n        }\n",
    "label": 1,
    "rec": "@return the matching option, or null if no match is found"
  },
  {
    "id": 133,
    "type": "Return",
    "comment": "@return true to continue forwarding motion events, false to cancel",
    "code": "    private boolean onTouchForwarded(MotionEvent srcEvent) {\n        final View src = mSrcIcon;\n\n        final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer();\n        if (dst == null) {\n            return false;\n        }\n        if (!dst.isLaidOut()) {\n            return true;\n        }\n\n        // Convert event to destination-local coordinates.\n        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);\n        Utilities.translateEventCoordinates(src, dst, dstEvent);\n\n        // Convert touch down event to destination-local coordinates.\n        if (!mHasMappedTouchDownToContainerCoord) {\n            mDragLayer.mapCoordInSelfToDescendent(dst, mTouchDown);\n            mHasMappedTouchDownToContainerCoord = true;\n        }\n\n        // Forward converted event to destination view, then recycle it.\n        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown);\n        dstEvent.recycle();\n\n        // Always cancel forwarding when the touch stream ends.\n        final int action = srcEvent.getActionMasked();\n        final boolean keepForwarding = action != MotionEvent.ACTION_UP\n                && action != MotionEvent.ACTION_CANCEL;\n\n        return handled && keepForwarding;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 134,
    "type": "Return",
    "comment": "@return true if a message was removed, false otherwise.",
    "code": "public int removeActiveMessage() {\n    return removeMessage(currentPage);\n}",
    "label": 1,
    "rec": "@return One of STATUS_MESSAGES_REMAINING, STATUS_NO_MESSAGES_REMAINING or STATUS_REMOVING_MESSAGE"
  },
  {
    "id": 135,
    "type": "Return",
    "comment": "@return the broker Response for the given Command.",
    "code": "    public Response syncSendPacket(Command command) throws JMSException {\n        return syncSendPacket(command, 0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 136,
    "type": "Return",
    "comment": "@return LoginDetails instance corresponding to the given LoginDetails class. Null if no such id found.",
    "code": "@JsonIgnore\n@SuppressWarnings(STR)\n@Nullable\npublic <T extends Credentials> Credentials getLoginDetails(Class<T> loginDetailsClass) {\n    return Maps.uniqueIndex(this.credentials, new Function<Credentials, Class<Credentials>>() {\n\n        @Override\n        public Class<Credentials> apply(@Nullable Credentials credentials) {\n            if (credentials != null) {\n                return (Class<Credentials>) credentials.getClass();\n            }\n            return null;\n        }\n    }).get(loginDetailsClass);\n}",
    "label": 1,
    "rec": "@return Credentials instance corresponding to the given Credentials class. Null if no such id found."
  },
  {
    "id": 137,
    "type": "Return",
    "comment": "@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless)",
    "code": "    public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end);\n\n        if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) {\n            return INVALID_POSITION;\n        }\n\n        int excessChars = 0;\n        int pos = 0;\n        while ((pos = header.indexOf(\"\\r\\n\", pos)) != -1) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        if (start + excessChars < header.length()) {\n            int[] position = getViewToHeaderPositionImpl(view, start, end);\n            if (position[1] > header.length()) {\n                position[1] = header.length();\n            }\n            return position;\n        }\n\n        int finalStartPos = start + excessChars - header.length();\n        int finalEndPos = end + excessChars - header.length();\n        return new int[] { finalStartPos, finalEndPos, 0 };\n    }\n",
    "label": 1,
    "rec": "@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless), or  #INVALID_POSITION if the  start or  end is greater than the length of the  view"
  },
  {
    "id": 138,
    "type": "Return",
    "comment": "@return A float value to represent px equivalent to dp depending on device density",
    "code": "    public static float convertDpToPixel(float dp, Context context) {\n        float scale = context.getResources().getDisplayMetrics().density;\n        return dp * scale + 0.5f;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 139,
    "type": "Return",
    "comment": "@return true when 10% or less room is left for dispatching messages",
    "code": "    public boolean isHighWaterMark() {\n        return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 140,
    "type": "Return",
    "comment": "@return double The yaw Euler angle.",
    "code": "public double getRotY() {\n    return Math.toDegrees(mOrientation.getRotationY());\n}",
    "label": 1,
    "rec": "@return double The yaw Euler angle in degrees."
  },
  {
    "id": 141,
    "type": "Return",
    "comment": "@return true if equal",
    "code": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof GJChronology) {\n            GJChronology chrono = (GJChronology) obj;\n            return iCutoverMillis == chrono.iCutoverMillis &&\n                    getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &&\n                    getZone().equals(chrono.getZone());\n        }\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 142,
    "type": "Return",
    "comment": "@return the next power of two that is larger than the specified int value.",
    "code": "public static int nextPowerOfTwo(final int value) {\n    return NUM << (NUM - Integer.numberOfLeadingZeros(value - NUM));\n}",
    "label": 1,
    "rec": "@return The next power of 2 or the value itself if it is a power of 2"
  },
  {
    "id": 143,
    "type": "Return",
    "comment": "@return Location.",
    "code": "    public String getLocation() {\n        return getFirstValue(HEAD_KEY_LOCATION);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 144,
    "type": "Return",
    "comment": "@return the response, or an Exception if something bad happened",
    "code": "private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) {\n    final String response = readResponseFromClientResponse(clientResponse);\n    if (clientResponse.getStatus() == NUM) {\n        return null;\n    } else if (clientResponse.getStatus() >= NUM) {\n        throw new HandshakeAPIException(response);\n    }\n    try {\n        return parseJson(response, responseType);\n    } catch (final IOException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "label": 1,
    "rec": "@return the response, null if not found, or an Exception if something bad happened"
  },
  {
    "id": 145,
    "type": "Return",
    "comment": "@return the probability of the tag of being at the beginning of the table",
    "code": "  public double conditionalLogProbGivenNext(int[] given, int of) {\n    if (given.length != windowSize - 1) {\n      throw new IllegalArgumentException(\"conditionalLogProbGivenNext requires given one less than clique size (\" +\n          windowSize + \") but was \" + Arrays.toString(given));\n    }\n    int[] label = indicesEnd(given);\n    double[] masses = new double[label.length];\n    for (int i = 0; i < masses.length; i++) {\n      masses[i] = table[label[i]];\n    }\n    return table[indexOf(of, given)] - ArrayMath.logSum(masses);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 146,
    "type": "Return",
    "comment": "@return a TregexMatcher",
    "code": "  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {\n    return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 147,
    "type": "Return",
    "comment": "@return a formatter for xxxx-'W'ww-e",
    "code": "    public static DateTimeFormatter weekDate() {\n        return Constants.wwd;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 148,
    "type": "Return",
    "comment": "@return a new parameters object with the new state",
    "code": "    public InstrumentationDeferredFieldParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationDeferredFieldParameters(\n                this.getExecutionContext(), this.executionStrategyParameters, this.getField(), this.getExecutionStepInfo(), instrumentationState);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 149,
    "type": "Return",
    "comment": "@return The generated proxy.",
    "code": "\tpublic static Blob generateProxy(InputStream stream, long length) {\n\t\treturn new BlobProxy( stream, length );\n\t}\n",
    "label": 1,
    "rec": "@return The BlobProxy instance to represent this data."
  },
  {
    "id": 150,
    "type": "Return",
    "comment": "@return true if the input can be combined into a parent MultiJoinRel",
    "code": "  private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoin\n        && !((MultiJoin) input).isFullOuterJoin()\n        && !((MultiJoin) input).containsOuter()\n        && !nullGenerating;\n  }\n",
    "label": 1,
    "rec": "@return true if the input can be combined into a parent MultiJoin"
  },
  {
    "id": 151,
    "type": "Return",
    "comment": "@return ordinal number",
    "code": "    public NumberExpression<Integer> ordinal() {\n        if (ordinal == null) {\n            ordinal = Expressions.numberOperation(Integer.class, Ops.ORDINAL, mixin);\n        }\n        return ordinal;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 152,
    "type": "Return",
    "comment": "@return Whether start tasks successfully.",
    "code": "    public boolean start(final FileDownloadListener listener, final boolean isSerial) {\n\n        if (listener == null) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because the listener \" +\n                    \"provided is null: [null, %B]\", isSerial);\n            return false;\n        }\n\n\n        return isSerial ? startSerialTasks(listener) : startParallelTasks(listener);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 153,
    "type": "Return",
    "comment": "@return new {@link HSSFWorkbook} generated by inserting beans into corresponding excel template",
    "code": "public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException {\n    org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null;\n    try {\n        hssfWorkbook = WorkbookFactory.create(is);\n        transformWorkbook(hssfWorkbook, beanParams);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return hssfWorkbook;\n}",
    "label": 1,
    "rec": "@return new {@link org.apache.poi.ss.usermodel.Workbook} generated by inserting beans into corresponding excel template"
  },
  {
    "id": 154,
    "type": "Return",
    "comment": "@return The appropriate IdentifierProperty definition.",
    "code": "\tpublic static IdentifierProperty buildIdentifierProperty(EntityBinding mappedEntity, IdentifierGenerator generator) {\n\n\t\tfinal SimpleAttributeBinding property = mappedEntity.getEntityIdentifier().getValueBinding();\n\n\t\t// TODO: the following will cause an NPE with \"virtual\" IDs; how should they be set?\n\t\tfinal String mappedUnsavedValue = property.getUnsavedValue();\n\t\tfinal Type type = property.getHibernateTypeDescriptor().getExplicitType();\n\n\t\tIdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(\n\t\t\t\tmappedUnsavedValue,\n\t\t\t\tgetGetter( property ),\n\t\t\t\ttype,\n\t\t\t\tgetConstructor( mappedEntity )\n\t\t\t);\n\n\t\tif ( property == null ) {\n\t\t\t// this is a virtual id property...\n\t\t\treturn new IdentifierProperty(\n\t\t\t        type,\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isEmbedded(),\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isIdentifierMapper(),\n\t\t\t\t\tunsavedValue,\n\t\t\t\t\tgenerator\n\t\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new IdentifierProperty(\n\t\t\t\t\tproperty.getAttribute().getName(),\n\t\t\t\t\tproperty.getNodeName(),\n\t\t\t\t\ttype,\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isEmbedded(),\n\t\t\t\t\tunsavedValue,\n\t\t\t\t\tgenerator\n\t\t\t\t);\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 155,
    "type": "Return",
    "comment": "@return The x location of the center of this circle",
    "code": "public float getX() {\n    if (left == null) {\n        calculateLeft();\n    }\n    return left.floatValue();\n}",
    "label": 1,
    "rec": "@return The x location of the left side of this shape."
  },
  {
    "id": 156,
    "type": "Return",
    "comment": "@return The stored value or null if it doesn't exist in specified form.",
    "code": "public boolean getExtraBoolean(String key) throws JSONException {\n    return mExtraData.getBoolean(key);\n}",
    "label": 1,
    "rec": "@return The stored value."
  },
  {
    "id": 157,
    "type": "Return",
    "comment": "@return the list of KDCs",
    "code": "public String getKDCList(String realm) throws KrbException {\n    if (realm == null) {\n        realm = getDefaultRealm();\n    }\n    Exception cause = null;\n    String kdcs = getDefault(STR, realm);\n    if (kdcs == null) {\n        kdcs = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<String>() {\n\n            @Override\n            public String run() {\n                String osname = System.getProperty(STR);\n                if (osname.startsWith(STR)) {\n                    String logonServer = System.getenv(STR);\n                    if (logonServer != null && logonServer.startsWith(STR)) {\n                        logonServer = logonServer.substring(NUM);\n                    }\n                    return logonServer;\n                }\n                return null;\n            }\n        });\n    }\n    if (kdcs == null) {\n        KrbException ke = new KrbException(STR);\n        if (cause != null) {\n            ke.initCause(cause);\n        }\n        throw ke;\n    }\n    return kdcs;\n}",
    "label": 1,
    "rec": "@return the list of KDCs separated by a space, always non null"
  },
  {
    "id": 158,
    "type": "Return",
    "comment": "@return caption for that handle",
    "code": "public String getCaption(String handle) {\n    TerminalMetadata data = getMetadataForHandle(handle);\n    if (data == null) {\n        return null;\n    }\n    return data.caption_;\n}",
    "label": 1,
    "rec": "@return caption for that handle or null if no such handle"
  },
  {
    "id": 159,
    "type": "Return",
    "comment": "@return the next token",
    "code": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 77: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 78: break;\n          case 3: \n            { return getNext();\n            }\n          case 79: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 80: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 81: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 82: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 84: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 85: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 87: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 88: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 89: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 90: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 91: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 92: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 93: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 101: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 102: break;\n          case 27: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 103: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 104: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 105: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 106: break;\n          case 31: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 107: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 108: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 109: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 35: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 111: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 113: break;\n          case 38: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 114: break;\n          case 39: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 115: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 117: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 43: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 120: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 121: break;\n          case 46: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 122: break;\n          case 47: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 123: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 124: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 125: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 127: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 128: break;\n          case 53: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 54: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 130: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 131: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 133: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 60: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 136: break;\n          case 61: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 137: break;\n          case 62: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 138: break;\n          case 63: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 139: break;\n          case 64: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 140: break;\n          case 65: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 141: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 142: break;\n          case 67: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 143: break;\n          case 68: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 144: break;\n          case 69: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 70: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 146: break;\n          case 71: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 147: break;\n          case 72: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 148: break;\n          case 73: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 149: break;\n          case 74: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 75: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 151: break;\n          case 76: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 152: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 160,
    "type": "Return",
    "comment": "@return a string representation of this map",
    "code": "@Override\npublic final String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    Iterator<E> it = iterator();\n    if (it.hasNext()) {\n        for (; ; ) {\n            Object e = it.next();\n            sb.append(e == this ? STR : e);\n            if (!it.hasNext()) {\n                break;\n            }\n            sb.append(STR).append(STR);\n        }\n    }\n    return sb.append(STR).toString();\n}",
    "label": 1,
    "rec": "@return a string representation of this collection"
  },
  {
    "id": 161,
    "type": "Return",
    "comment": "@return javax.swing.JTextArea",
    "code": "\tprivate ZapTextArea getTxtDescription() {\n\t\tif (txtDescription == null) {\n\t\t\ttxtDescription = new ZapTextArea();\n\t\t\ttxtDescription.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));\n\t\t\ttxtDescription.setLineWrap(true);\n\t\t\ttxtDescription.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11));\n\t\t}\n\t\treturn txtDescription;\n\t}\n",
    "label": 1,
    "rec": "@return javax.swing.ZapTextArea"
  },
  {
    "id": 162,
    "type": "Return",
    "comment": "@return - response",
    "code": "    private boolean reconcileAndLogDifference(Applications delta, String reconcileHashCode) throws Throwable {\n        logger.warn(\"The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry\",\n                reconcileHashCode, delta.getAppsHashCode());\n\n        long currentGeneration = fetchRegistryGeneration.get();\n\n        Applications serverApps = this.fetchRemoteRegistry(false);\n        if (serverApps == null) {\n            logger.error(\"The application is null for some reason. Not storing this information\");\n            return false;\n        }\n\n        if (fetchRegistryGeneration.compareAndSet(currentGeneration, currentGeneration + 1)) {\n            applications.set(serverApps);\n            applicationsDelta.set(serverApps);\n            logger.warn(\"The Reconcile hashcodes after complete sync up, client : {}, server : {}.\",\n                    getApplications().getReconcileHashCode(),\n                    delta.getAppsHashCode());\n            return true;\n        }else {\n            logger.warn(\"Not setting the applications map as another thread has advanced the update generation\");\n            return true;  // still return true\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 163,
    "type": "Return",
    "comment": "@return the next token",
    "code": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 37: break;\n          case 2: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 38: break;\n          case 3: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 39: break;\n          case 4: \n            { return getNext();\n            }\n          case 40: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 41: break;\n          case 6: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 42: break;\n          case 7: \n            { if (ptb3Dashes) {\n                return getNext(ptbmdash, yytext()); }\n              else {\n                return getNext();\n              }\n            }\n          case 43: break;\n          case 8: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 44: break;\n          case 9: \n            { return handleEllipsis(yytext());\n            }\n          case 45: break;\n          case 10: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(handleDash(origTxt), origTxt);\n\t\t  }\n            }\n          case 46: break;\n          case 11: \n            { return normalizeFractions(yytext());\n            }\n          case 47: break;\n          case 12: \n            { final String origTxt = yytext();\n                          return getNext(handleQuotes(origTxt), origTxt);\n            }\n          case 48: break;\n          case 13: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 49: break;\n          case 14: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 50: break;\n          case 15: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 51: break;\n          case 16: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 52: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 53: break;\n          case 18: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 54: break;\n          case 19: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 55: break;\n          case 20: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 56: break;\n          case 21: \n            { final String origTxt = yytext();\n                          return getNext(origTxt, origTxt, CONTR_ANNOTATION);\n            }\n          case 57: break;\n          case 22: \n            { final String origTxt = yytext();\n                          return getNext(origTxt, origTxt, VB_PRON_ANNOTATION);\n            }\n          case 58: break;\n          case 23: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 1;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 2;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 59: break;\n          case 24: \n            { if (!noSGML) {\n             \t return getNext();\n\t\t\t\t\t    }\n            }\n          case 60: break;\n          case 25: \n            { final String origTxt = yytext();\n                          return getNext (handleQuotes(origTxt), origTxt);\n            }\n          case 61: break;\n          case 26: \n            { final String origTxt = yytext();\n                          return getNext(handleQuotes(handleDash(origTxt)), origTxt, COMPOUND_ANNOTATION);\n            }\n          case 62: break;\n          case 27: \n            { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n            }\n          case 63: break;\n          case 28: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 64: break;\n          case 29: \n            { final String origTxt = yytext();\n                          return getNext(handleQuotes(handleDash(origTxt)), origTxt);\n            }\n          case 65: break;\n          case 30: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 66: break;\n          case 31: \n            { return getNormalizedAmpNext();\n            }\n          case 67: break;\n          case 32: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 68: break;\n          case 33: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n            }\n          case 69: break;\n          case 34: \n            { yypushback(3) ; return getNext();\n            }\n          case 70: break;\n          case 35: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 71: break;\n          case 36: \n            { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n                              txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                              txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n            }\n          case 72: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 164,
    "type": "Return",
    "comment": "@return DateTimeField or UnsupportedDateTimeField if unsupported",
    "code": "    public DateTimeField yearOfCentury() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 165,
    "type": "Return",
    "comment": "@return Webcam view size (picture size) in pixels.",
    "code": "\tpublic Dimension getViewSize() {\n\t\treturn device.getSize();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 166,
    "type": "Return",
    "comment": "@return the converted value, or null if the conversion could not be made",
    "code": "    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return new java.util.Date(0L); // return epoch\n        }\n        try {\n            return new java.util.Date(Timestamp.toEpochMillis(data));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n",
    "label": 1,
    "rec": "@return the converted value, or null if the conversion could not be made and the column allows nulls"
  },
  {
    "id": 167,
    "type": "Return",
    "comment": "@return A local ongoing notification which pending intent is bound to the main activity.",
    "code": "    private Notification makeNotification() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context     = getApplicationContext();\n        String pkgName      = context.getPackageName();\n        Intent intent       = context.getPackageManager()\n                .getLaunchIntentForPackage(pkgName);\n\n        Notification.Builder notification = new Notification.Builder(context)\n                .setContentTitle(settings.optString(\"title\", \"\"))\n                .setContentText(settings.optString(\"text\", \"\"))\n                .setOngoing(true)\n                .setSmallIcon(getIconResId());\n\n        if (intent != null && settings.optBoolean(\"resume\")) {\n            PendingIntent contentIntent = PendingIntent.getActivity(\n                    context, NOTIFICATION_ID, intent,\n                    PendingIntent.FLAG_UPDATE_CURRENT);\n\n            notification.setContentIntent(contentIntent);\n        }\n\n        return notification.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 168,
    "type": "Return",
    "comment": "@return {@link ScaleAnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.ScaleAnimationBuilder#start()} to start the anim.",
    "code": "public AnimationBuilder animateScale(float scale) {\n    if (!isImageReady()) {\n        return null;\n    }\n    return new AnimationBuilder(scale);\n}",
    "label": 1,
    "rec": "@return {@link AnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim."
  },
  {
    "id": 169,
    "type": "Return",
    "comment": "@return data stored for the specified parent",
    "code": "  public PMetadata getCache(PGraphics renderer) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(renderer);\n  }\n",
    "label": 1,
    "rec": "@return metadata stored for the specified renderer"
  },
  {
    "id": 170,
    "type": "Return",
    "comment": "@return this DateTimeFormatterBuilder",
    "code": "    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 171,
    "type": "Return",
    "comment": "@return a  List of the  GridViews contained in the current  Activity",
    "code": "\tpublic ArrayList<GridView> getCurrentGridViews() {\n\t\treturn getCurrentViews(GridView.class);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 172,
    "type": "Return",
    "comment": "@return the starting message",
    "code": "    protected static String getStartingMessage() {\n        DateFormat dateFormat = SimpleDateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);\n        StringBuilder strBuilder = new StringBuilder(200);\n        strBuilder.append(Constant.PROGRAM_NAME).append(' ').append(Constant.PROGRAM_VERSION);\n        strBuilder.append(\" started \");\n        strBuilder.append(dateFormat.format(new Date()));\n        return strBuilder.toString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 173,
    "type": "Return",
    "comment": "@return An annotator as specified by the given name and properties.",
    "code": "  private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) {\n    return () -> {\n      Annotator rtn = customAnnotators.get(factory.signature());\n      if (rtn == null) {\n        // Create the annotator\n        rtn = factory.create();\n        // Register the annotator\n        customAnnotators.put(factory.signature(), factory.create());\n        // Clean up memory if needed\n        while (customAnnotators.size() > 10) {\n          customAnnotators.keySet().iterator().remove();\n        }\n      }\n      return rtn;\n    };\n  }\n",
    "label": 1,
    "rec": "@return An annotator created by that factory."
  },
  {
    "id": 174,
    "type": "Return",
    "comment": "@return A configuration configured via the stream",
    "code": "\tprotected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n\t\ttry {\n\t\t\tList errors = new ArrayList();\n\t\t\tDocument document = xmlHelper.createSAXReader( resourceName, errors, entityResolver )\n\t\t\t\t\t.read( new InputSource( stream ) );\n\t\t\tif ( errors.size() != 0 ) {\n\t\t\t\tthrow new MappingException( \"invalid configuration\", (Throwable) errors.get( 0 ) );\n\t\t\t}\n\t\t\tdoConfigure( document );\n\t\t}\n\t\tcatch (DocumentException e) {\n\t\t\tthrow new HibernateException( \"Could not parse configuration: \" + resourceName, e );\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe );\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n",
    "label": 1,
    "rec": "@return this for method chaining"
  },
  {
    "id": 175,
    "type": "Return",
    "comment": "@return the validated collection (never {@code null} for method chaining)",
    "code": "public static <T extends CharSequence> T validIndex(final T chars, final int index) {\n    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));\n}",
    "label": 1,
    "rec": "@return the validated character sequence (never {@code null} for method chaining)"
  },
  {
    "id": 176,
    "type": "Return",
    "comment": "@return the configuration builder",
    "code": "    public static Builder create() {\n        return new Builder() {\n            private Properties props = new Properties();\n\n            @Override\n            public Builder with(String key, String value) {\n                props.setProperty(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder withDefault(String key, String value) {\n                if (!props.containsKey(key)) {\n                    props.setProperty(key, value);\n                }\n                return this;\n            }\n\n            @Override\n            public Builder apply(Consumer<Builder> function) {\n                function.accept(this);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(Configuration.from(props));\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 177,
    "type": "Return",
    "comment": "@return this builder",
    "code": "  public T setMinDecodeIntervalMs(int intervalMs) {\n    mMinDecodeIntervalMs = intervalMs;\n    return getThis();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 178,
    "type": "Return",
    "comment": "@return Returns the charset.",
    "code": "public String getCharset() {\n    if (charset != null) {\n        return charset.name();\n    }\n    return DEFAULT_CHARSET;\n}",
    "label": 1,
    "rec": "@return the name of the charset, never {@code null}"
  },
  {
    "id": 179,
    "type": "Return",
    "comment": "@return the adapter to test",
    "code": "private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) {\n    picoContainer.addComponent(RecordingLifecycle.One.class);\n    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));\n    return picoContainer.addAdapter(poolingComponentAdapter).lastCA();\n}",
    "label": 1,
    "rec": "@return the addAdapter to test"
  },
  {
    "id": 180,
    "type": "Return",
    "comment": "@return true if the gzip compression should be used if the client accespts it. Default this option is tuned off.",
    "code": "    protected boolean useGzipWhenAccepted(Response r) {\n        return r.getMimeType() != null && r.getMimeType().toLowerCase().contains(\"text/\");\n    }\n",
    "label": 1,
    "rec": "@return true if the gzip compression should be used if the client accespts it. Default this option is on for text content and off for everything else."
  },
  {
    "id": 181,
    "type": "Return",
    "comment": "@return threshold, default 20",
    "code": "  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n",
    "label": 1,
    "rec": "@return threshold, default  #IN_SUBQUERY_THRESHOLD"
  },
  {
    "id": 182,
    "type": "Return",
    "comment": "@return an array of integers mapping to the update count per SQL command.",
    "code": "  protected long[] executeBatchInternal() throws SQLException {\n    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {\n      try {\n        return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts;\n      } catch (NoSuchStatementException e) {\n        resetStatement();\n      }\n    }\n\n    throw new RuntimeException(\"Failed to successfully execute batch update after \"\n        +  connection.maxRetriesPerExecute + \" attempts\");\n  }\n",
    "label": 1,
    "rec": "@return an array of long mapping to the update count per SQL command."
  },
  {
    "id": 183,
    "type": "Return",
    "comment": "@return the size of tiles in pixels",
    "code": "@Deprecated\npublic int getTileSize() {\n    return Math.max(tileHeight, tileWidth);\n}",
    "label": 1,
    "rec": "@return tile height or width, whichever is larger"
  },
  {
    "id": 184,
    "type": "Return",
    "comment": "@return The matching enum value. An empty value will return  #NONE.",
    "code": "\tpublic static SchemaGenAction interpret(Object value) {\n\t\tif ( value == null ) {\n\t\t\treturn NONE;\n\t\t}\n\n\t\tif ( SchemaGenAction.class.isInstance( value ) ) {\n\t\t\treturn (SchemaGenAction) value;\n\t\t}\n\n\t\tfinal String name = value.toString();\n\t\tif ( StringHelper.isEmpty( name ) || NONE.externalName.equals( name ) ) {\n\t\t\t// default is NONE\n\t\t\treturn NONE;\n\t\t}\n\n\t\tif ( CREATE.externalName.equals( name ) ) {\n\t\t\treturn CREATE;\n\t\t}\n\t\telse if ( DROP.externalName.equals( name ) ) {\n\t\t\treturn DROP;\n\t\t}\n\t\telse if ( BOTH.externalName.equals( name ) ) {\n\t\t\treturn BOTH;\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\n\t\t\t\t\t\t\"Unrecognized '%s' or '%s' value : %s\",\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_DATABASE_ACTION,\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION,\n\t\t\t\t\t\tvalue\n\t\t\t\t)\n\t\t);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 185,
    "type": "Return",
    "comment": "@return the extended FluentPipeline",
    "code": "public GremlinPipeline<S, Vertex> bothV() {\n    return this.add(new BothVerticesPipe());\n}",
    "label": 1,
    "rec": "@return the extended Pipeline"
  },
  {
    "id": 186,
    "type": "Return",
    "comment": "@return a SecurityContext representing the authenticated account.",
    "code": "public Subject login(AuthenticationToken token) throws AuthenticationException {\n    Account account;\n    try {\n        account = authenticate(token);\n        rememberMeSuccessfulLogin(token, account);\n    } catch (AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n        throw ae;\n    }\n    Subject secCtx = createSubject(token, account);\n    assertCreation(secCtx);\n    bind(secCtx);\n    return secCtx;\n}",
    "label": 1,
    "rec": "@return a Subject representing the authenticated account."
  },
  {
    "id": 187,
    "type": "Return",
    "comment": "@return the  Button that shows the given text",
    "code": "\tpublic Button getButton(String text, boolean onlyVisible)\n\t{\n\t\treturn getter.getView(Button.class, text, onlyVisible);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 188,
    "type": "Return",
    "comment": "@return The type of the named parameter.",
    "code": "    public Type getParameterType(String parameterName) {\n\t    return parameterTypes.get(parameterName);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 189,
    "type": "Return",
    "comment": "@return this DateTimeFormatterBuilder",
    "code": "    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 190,
    "type": "Return",
    "comment": "@return List of all selected objects.",
    "code": "public Collection<OsmPrimitive> getSelected() {\n    return Collections.unmodifiableSet(selectedPrimitives);\n}",
    "label": 1,
    "rec": "@return unmodifiable collection of primitives"
  },
  {
    "id": 191,
    "type": "Return",
    "comment": "@return the converted list.",
    "code": "    public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) {\n        return new AuditEvent(Date.from(persistentAuditEvent.getAuditEventDate()), persistentAuditEvent.getPrincipal(),\n            persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 192,
    "type": "Return",
    "comment": "@return Class - The AST node class to instantiate.",
    "code": "\tpublic Class getASTNodeType(int tokenType) {\n\t\tswitch ( tokenType ) {\n\t\t\tcase SELECT:\n\t\t\tcase QUERY:\n\t\t\t\treturn QueryNode.class;\n\t\t\tcase UPDATE:\n\t\t\t\treturn UpdateStatement.class;\n\t\t\tcase DELETE:\n\t\t\t\treturn DeleteStatement.class;\n\t\t\tcase INSERT:\n\t\t\t\treturn InsertStatement.class;\n\t\t\tcase INTO:\n\t\t\t\treturn IntoClause.class;\n\t\t\tcase FROM:\n\t\t\t\treturn FromClause.class;\n\t\t\tcase FROM_FRAGMENT:\n\t\t\t\treturn FromElement.class;\n\t\t\tcase IMPLIED_FROM:\n\t\t\t\treturn ImpliedFromElement.class;\n\t\t\tcase DOT:\n\t\t\t\treturn DotNode.class;\n\t\t\tcase INDEX_OP:\n\t\t\t\treturn IndexNode.class;\n\t\t\t\t// Alias references and identifiers use the same node class.\n\t\t\tcase ALIAS_REF:\n\t\t\tcase IDENT:\n\t\t\t\treturn IdentNode.class;\n\t\t\tcase SQL_TOKEN:\n\t\t\t\treturn SqlFragment.class;\n\t\t\tcase METHOD_CALL:\n\t\t\t\treturn MethodNode.class;\n\t\t\tcase ELEMENTS:\n\t\t\tcase INDICES:\n\t\t\t\treturn CollectionFunction.class;\n\t\t\tcase SELECT_CLAUSE:\n\t\t\t\treturn SelectClause.class;\n\t\t\tcase SELECT_EXPR:\n\t\t\t\treturn SelectExpressionImpl.class;\n\t\t\tcase AGGREGATE:\n\t\t\t\treturn AggregateNode.class;\n\t\t\tcase COUNT:\n\t\t\t\treturn CountNode.class;\n\t\t\tcase CONSTRUCTOR:\n\t\t\t\treturn ConstructorNode.class;\n\t\t\tcase NUM_INT:\n\t\t\tcase NUM_FLOAT:\n\t\t\tcase NUM_LONG:\n\t\t\tcase NUM_DOUBLE:\n\t\t\tcase QUOTED_STRING:\n\t\t\t\treturn LiteralNode.class;\n\t\t\tcase TRUE:\n\t\t\tcase FALSE:\n\t\t\t\treturn BooleanLiteralNode.class;\n\t\t\tcase JAVA_CONSTANT:\n\t\t\t\treturn JavaConstantNode.class;\n\t\t\tcase ORDER:\n\t\t\t\treturn OrderByClause.class;\n\t\t\tcase PLUS:\n\t\t\tcase MINUS:\n\t\t\tcase STAR:\n\t\t\tcase DIV:\n\t\t\t\treturn BinaryArithmeticOperatorNode.class;\n\t\t\tcase UNARY_MINUS:\n\t\t\tcase UNARY_PLUS:\n\t\t\t\treturn UnaryArithmeticNode.class;\n\t\t\tcase CASE2:\n\t\t\t\treturn Case2Node.class;\n\t\t\tcase CASE:\n\t\t\t\treturn CaseNode.class;\n\t\t\tcase PARAM:\n\t\t\tcase NAMED_PARAM:\n\t\t\t\treturn ParameterNode.class;\n\t\t\tcase EQ:\n\t\t\tcase NE:\n\t\t\tcase LT:\n\t\t\tcase GT:\n\t\t\tcase LE:\n\t\t\tcase GE:\n\t\t\tcase LIKE:\n\t\t\tcase NOT_LIKE:\n\t\t\t\treturn BinaryLogicOperatorNode.class;\n\t\t\tcase IN:\n\t\t\tcase NOT_IN:\n\t\t\t\treturn InLogicOperatorNode.class;\n\t\t\tcase BETWEEN:\n\t\t\tcase NOT_BETWEEN:\n\t\t\t\treturn BetweenOperatorNode.class;\n\t\t\tcase IS_NULL:\n\t\t\t\treturn IsNullLogicOperatorNode.class;\n\t\t\tcase IS_NOT_NULL:\n\t\t\t\treturn IsNotNullLogicOperatorNode.class;\n\t\t\tcase EXISTS:\n\t\t\t\treturn UnaryLogicOperatorNode.class;\n\t\t\tcase KEY: {\n\t\t\t\treturn MapKeyNode.class;\n\t\t\t}\n\t\t\tcase VALUE: {\n\t\t\t\treturn MapValueNode.class;\n\t\t\t}\n\t\t\tcase ENTRY: {\n\t\t\t\treturn MapEntryNode.class;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn SqlNode.class;\n\t\t} // switch\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 193,
    "type": "Return",
    "comment": "@return a {@link Criterion} that evaluates the raw selection and selection args",
    "code": "public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) {\n    if (TextUtils.isEmpty(selection)) {\n        return null;\n    }\n    return new Criterion(null) {\n\n        @Override\n        protected void populate(SqlBuilder builder, boolean forSqlValidation) {\n            builder.sql.append(selection);\n            if (selectionArgs != null && selectionArgs.length > NUM) {\n                if (builder.args == null) {\n                    throw new UnsupportedOperationException(STR + STR);\n                }\n                Collections.addAll(builder.args, selectionArgs);\n            }\n        }\n    };\n}",
    "label": 1,
    "rec": "@return a {@link Criterion} that evaluates the raw selection and selection args. If the selection string is empty, this will return null."
  },
  {
    "id": 194,
    "type": "Return",
    "comment": "@return Whether this is less than w or not in the ordering",
    "code": "  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    // Override the default comparator if pseudo-positions are set.\n    // This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    // Otherwise, compare using the normal doc/sentence/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = Integer.compare(sentIndex(), w.sentIndex());\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = Integer.compare(index(), w.index());\n    if (indexComp != 0) return indexComp;\n\n    return Integer.compare(copyCount(), w.copyCount());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 195,
    "type": "Return",
    "comment": "@return an  ExecutionResult",
    "code": "    protected FieldValueInfo completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) {\n\n        Collection<Object> values = FpKit.toCollection(iterableValues);\n        ExecutionTypeInfo typeInfo = parameters.getTypeInfo();\n        GraphQLList fieldType = typeInfo.castType(GraphQLList.class);\n        GraphQLFieldDefinition fieldDef = parameters.getTypeInfo().getFieldDefinition();\n\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo(parameters, fieldDef), values);\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n\n        InstrumentationContext<ExecutionResult> completeListCtx = instrumentation.beginFieldListComplete(\n                instrumentationParams\n        );\n\n        List<FieldValueInfo> fieldValueInfos = new ArrayList<>();\n        int index = 0;\n        for (Object item : values) {\n            ExecutionPath indexedPath = parameters.getPath().segment(index);\n\n            ExecutionTypeInfo wrappedTypeInfo = ExecutionTypeInfo.newTypeInfo()\n                    .parentInfo(typeInfo)\n                    .type(fieldType.getWrappedType())\n                    .path(indexedPath)\n                    .fieldDefinition(fieldDef)\n                    .build();\n\n            NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, wrappedTypeInfo);\n\n            int finalIndex = index;\n            ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                    builder.typeInfo(wrappedTypeInfo)\n                            .nonNullFieldValidator(nonNullableFieldValidator)\n                            .listSize(values.size())\n                            .currentListIndex(finalIndex)\n                            .path(indexedPath)\n                            .source(item)\n            );\n            fieldValueInfos.add(completeValue(executionContext, newParameters));\n            index++;\n        }\n\n        CompletableFuture<List<ExecutionResult>> resultsFuture = Async.each(fieldValueInfos, (item, i) -> item.getFieldValue());\n\n        CompletableFuture<ExecutionResult> overallResult = new CompletableFuture<>();\n        completeListCtx.onDispatched(overallResult);\n\n        resultsFuture.whenComplete((results, exception) -> {\n            if (exception != null) {\n                ExecutionResult executionResult = handleNonNullException(executionContext, overallResult, exception);\n                completeListCtx.onCompleted(executionResult, exception);\n                return;\n            }\n            List<Object> completedResults = new ArrayList<>();\n            for (ExecutionResult completedValue : results) {\n                completedResults.add(completedValue.getData());\n            }\n            ExecutionResultImpl executionResult = new ExecutionResultImpl(completedResults, null);\n            overallResult.complete(executionResult);\n        });\n        overallResult.whenComplete(completeListCtx::onCompleted);\n\n        return FieldValueInfo.newFieldValueInfo(LIST)\n                .fieldValue(overallResult)\n                .fieldValueInfos(fieldValueInfos)\n                .build();\n    }\n",
    "label": 1,
    "rec": "@return a  FieldValueInfo"
  },
  {
    "id": 196,
    "type": "Return",
    "comment": "@return status",
    "code": "  public String getStatus() {\n    if (status == null) {\n      return null;\n    }\n    return status.value();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 197,
    "type": "Return",
    "comment": "@return the current time in ms",
    "code": "private long now() {\n    return SystemClock.uptimeMillis();\n}",
    "label": 1,
    "rec": "@return the current uptime in ms"
  },
  {
    "id": 198,
    "type": "Return",
    "comment": "@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.",
    "code": "    public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) {\n        if (hasControlRemoteAppTransitionPermission()) {\n            TaskView taskView = findTaskViewToLaunch(launcher, v);\n            try {\n                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {\n                    @Override\n                    public void onAnimationStart(RemoteAnimationTargetCompat[] targets,\n                                                 Runnable finishedCallback) {\n                        // Post at front of queue ignoring sync barriers to make sure it gets\n                        // processed before the next frame.\n                        postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {\n                            final boolean removeTrackingView;\n                            LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(\n                                    taskView == null ? v : taskView, targets);\n                            if (animator != null) {\n                                // We are animating the task view directly, do not remove it after\n                                removeTrackingView = false;\n                            } else {\n                                animator = composeAppLaunchAnimator(v, targets);\n                                // A new floating view is created for the animation, remove it after\n                                removeTrackingView = true;\n                            }\n\n                            setCurrentAnimator(animator);\n                            mAnimator = animator.getAnimatorSet();\n                            mAnimator.addListener(new AnimatorListenerAdapter() {\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    // Reset launcher to normal state\n                                    v.setVisibility(View.VISIBLE);\n                                    if (removeTrackingView) {\n                                        ((ViewGroup) mDragLayer.getParent()).removeView(\n                                                mFloatingView);\n                                    }\n\n                                    mDragLayer.setAlpha(1f);\n                                    mDragLayer.setTranslationY(0f);\n\n                                    View appsView = mLauncher.getAppsView();\n                                    appsView.setAlpha(1f);\n                                    appsView.setTranslationY(0f);\n\n                                    finishedCallback.run();\n                                }\n                            });\n                            mAnimator.start();\n                            // Because t=0 has the app icon in its original spot, we can skip the\n                            // first frame and have the same movement one frame earlier.\n                            mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);\n                        });\n                    }\n                };\n\n                int duration = taskView != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION;\n                int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION;\n                return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(\n                        runner, duration, statusBarTransitionDelay));\n            } catch (NoClassDefFoundError e) {\n                // Gracefully fall back to default launch options if the user's platform doesn't\n                // have the latest changes.\n            }\n        }\n        return getDefaultActivityLaunchOptions(launcher, v);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 199,
    "type": "Return",
    "comment": "@return A String array corresponding to the encoded array",
    "code": "  public static String[] decodeArray(String encoded){\n    if (encoded.isEmpty()) return EMPTY_STRING_ARRAY;\n    char[] chars = encoded.trim().toCharArray();\n\n    //--Parse the String\n    // (state)\n    char quoteCloseChar = (char) 0;\n    List<StringBuilder> terms = new LinkedList<>();\n    StringBuilder current = new StringBuilder();\n    //(start/stop overhead)\n    int start = 0; int end = chars.length;\n    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); }\n    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    // (finite state automaton)\n    for (int i=start; i<end; i++) {\n      if (chars[i] == '\\r') {\n        // Ignore funny windows carriage return\n        continue;\n      } else if(chars[i] == '\\\\'){\n        //(case: escaped character)\n        if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded array is escape character: \" + encoded);\n        current.append(chars[i+1]);\n        i += 1;\n      } else if (quoteCloseChar != 0) {\n        //(case: in quotes)\n        if(chars[i] == quoteCloseChar){\n          quoteCloseChar = (char) 0;\n        }else{\n          current.append(chars[i]);\n        }\n      } else {\n        //(case: normal)\n        if(chars[i] == '\"'){\n          quoteCloseChar = '\"';\n        } else if(chars[i] == '\\''){\n          quoteCloseChar = '\\'';\n        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n'){\n          //break\n          if (current.length() > 0) {\n            terms.add(current);\n          }\n          current = new StringBuilder();\n        }else{\n          current.append(chars[i]);\n        }\n      }\n    }\n\n    //--Return\n    if(current.length() > 0) terms.add(current);\n    String[] rtn = new String[terms.size()];\n    int i=0;\n    for(StringBuilder b : terms){\n      rtn[i] = b.toString().trim();\n      i += 1;\n    }\n    return rtn;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 200,
    "type": "Summary",
    "comment": "Provides a list containing four set, each containing projects to be displayed on the project view for projects using the parameterized trigger plugin under 'Subprojects'. ",
    "code": "    public SubProjectData getProjectInfo(AbstractProject context) {\n\n        SubProjectData subProjectData = new SubProjectData();\n\n        iterateBuilds(context, projects, subProjectData);\n\n        // We don't want to show a project twice\n        subProjectData.getTriggered().removeAll(subProjectData.getDynamic());\n        subProjectData.getTriggered().removeAll(subProjectData.getFixed());\n\n        return subProjectData;\n    }\n\n",
    "label": 1,
    "rec": "Provides a SubProjectData object containing four set, each containing projects to be displayed on the project view under 'Subprojects' section. "
  },
  {
    "id": 201,
    "type": "Summary",
    "comment": "Create a new  Builder configuration builder that starts with a copy of the supplied configuration.",
    "code": "    public static Builder copy(Configuration config) {\n        return new Builder() {\n            private Configuration.Builder builder = Configuration.copy(config);\n\n            @Override\n            public Builder with(String key, String value) {\n                builder.with(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder withDefault(String key, String value) {\n                builder.withDefault(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder apply(Consumer<Builder> function) {\n                function.accept(this);\n                return this;\n            }\n            \n            @Override\n            public Builder changeString(Field field, Function<String, String> function) {\n                changeString(field,function);\n                return this;\n            }\n            \n            @Override\n            public Builder changeString(String key, Function<String, String> function) {\n                changeString(key,function);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(builder.build());\n            }\n\n            @Override\n            public String toString() {\n                return builder.toString();\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 202,
    "type": "Summary",
    "comment": "A variation of findDeclaration() but accepts an alternate parent ASTNode",
    "code": "  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\n          if (stp == null) {\n            return null;\n          }\n\n//          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n//          log(\"QN decl class: \"\n//              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    } // TODO: in findDec, we also have a case where parent of type TD is handled.\n      // Figure out if needed here as well.\n//    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n//      log(\"findDeclaration2 -> \"\n//          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 203,
    "type": "Summary",
    "comment": "Returns true if, the lockClient is keeping the lock for the lockPath",
    "code": "\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n\n",
    "label": 1,
    "rec": "Returns true if, the job server is keeping the lock for the lockPath"
  },
  {
    "id": 204,
    "type": "Summary",
    "comment": "Returns the difference between this field property instant and the one passed in, in the units of this field.",
    "code": "    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 205,
    "type": "Summary",
    "comment": "Checks if a flag is set.",
    "code": "    public boolean isFlagSet(int flagsToCheck) {\n        return (flags & flagsToCheck) != 0;\n    }\n\n",
    "label": 1,
    "rec": "Returns  true if any of the flags supplied in the argument are set."
  },
  {
    "id": 206,
    "type": "Summary",
    "comment": "Constructs a new PTBTokenizer that makes CoreLabel tokens.",
    "code": "  public static PTBTokenizer<CoreLabel> newPTBTokenizer(Reader r, boolean tokenizeNLs, boolean invertible) {\n    return new PTBTokenizer<>(r, tokenizeNLs, invertible, false, new CoreLabelTokenFactory());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 207,
    "type": "Summary",
    "comment": "This method initializes jTextArea",
    "code": "    private ZapTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new ZapTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n",
    "label": 1,
    "rec": "This method initializes ZapTextArea"
  },
  {
    "id": 208,
    "type": "Summary",
    "comment": "Gets the matching http session for a particular message containing a list of cookies.",
    "code": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\t\tCollection<HttpSession> sessionsCopy;\n\t\tsynchronized (sessions) {\n\t\t\tsessionsCopy = new ArrayList<>(sessions);\n\t\t}\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessionsCopy, cookies, siteTokens);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 209,
    "type": "Summary",
    "comment": "Returns the common base directory between a current base directory and a given file.",
    "code": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "Returns the common base directory between the passed file1 and file2."
  },
  {
    "id": 210,
    "type": "Summary",
    "comment": "creates an XmlItem this route creates an XmlItem",
    "code": "    public ApiResponse<Void> createXmlItemWithHttpInfo(XmlItem xmlItem) throws ApiException {\n        okhttp3.Call localVarCall = createXmlItemValidateBeforeCall(xmlItem, null, null);\n        return localVarApiClient.execute(localVarCall);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 211,
    "type": "Summary",
    "comment": "Return the list of Cassandra instances ordered by position on ring, indicated by token.",
    "code": "  @GET\n  public Set<CassandraInstance> findAll() {\n    return service.findAll();\n  }\n\n",
    "label": 1,
    "rec": "Return the set of Cassandra instances."
  },
  {
    "id": 212,
    "type": "Summary",
    "comment": "Gets the quality or status of the given passive  scanner.",
    "code": "\tpublic static String getPluginQuality(PluginPassiveScanner scanner) {\n//        String scannerPackage = scanner.getClass().getCanonicalName();\n        String scannerName = scanner.getName();\n        \n        return (getSpecificQuality(scannerName, scanner));\n        \n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 213,
    "type": "Summary",
    "comment": "Removes the content source from this channel, if it exists.",
    "code": "    public RepoContentSource removeContentSource(ContentSource contentSource) {\n        if ((this.repoContentSources == null) || (contentSource == null)) {\n            return null;\n        }\n\n        RepoContentSource doomed = null;\n\n        for (RepoContentSource ccs : this.repoContentSources) {\n            if (contentSource.equals(ccs.getRepoContentSourcePK().getContentSource())) {\n                doomed = ccs;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.repoContentSources.remove(doomed);\n        }\n\n        return doomed;\n    }\n\n",
    "label": 1,
    "rec": "Removes the content source from this repo, if it exists."
  },
  {
    "id": 214,
    "type": "Summary",
    "comment": "Disable tiling of the image.",
    "code": "    public ImageSource tilingDisabled() {\n        return setTiling(false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 215,
    "type": "Summary",
    "comment": "First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity.",
    "code": "    public Subject login(AuthenticationToken token) throws AuthenticationException {\r\n        Account account;\r\n        try {\r\n            account = authenticate(token);\r\n            rememberMeSuccessfulLogin(token, account);\r\n        } catch (AuthenticationException ae) {\r\n            rememberMeFailedLogin(token, ae);\r\n            throw ae; //propagate\r\n        }\r\n        Subject secCtx = createSubject(token, account);\r\n        assertCreation(secCtx);\r\n        bind(secCtx);\r\n        return secCtx;\r\n    }\r\n\n",
    "label": 1,
    "rec": "First authenticates the AuthenticationToken argument, and if successful, constructs a Subject instance representing the authenticated account's identity."
  },
  {
    "id": 216,
    "type": "Summary",
    "comment": "Does this time interval overlap the specified time interval.",
    "code": "    public boolean overlaps(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart < otherEnd && otherStart < thisEnd);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 217,
    "type": "Summary",
    "comment": "Creates a QueueReceiver object to receive messages from the specified queue using a message selector.",
    "code": "    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 218,
    "type": "Summary",
    "comment": "Looks up a specific revision based on some SCM-specific set of permissible syntaxes.",
    "code": "    @CheckForNull\n    public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(thingName, defaultListener(listener));\n    }\n\n",
    "label": 1,
    "rec": "Looks up a specific thingName based on some SCM-specific set of permissible syntaxes."
  },
  {
    "id": 219,
    "type": "Summary",
    "comment": "Invoke the proprietary  CometSupport",
    "code": "    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        Action a = null;\n        try {\n            if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                req.headers(headers)\n                   .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n                if (body != null) {\n                   req.body(body);\n                }\n\n                a = asyncSupport.service(req, res);\n            } else {\n                return asyncSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", asyncSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                asyncSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (req != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                req.destroy();\n                res.destroy();\n            }\n        }\n        return null;\n    }\n",
    "label": 1,
    "rec": "Invoke the proprietary  AsyncSupport"
  },
  {
    "id": 220,
    "type": "Summary",
    "comment": "Obtain a new  Builder instance that can be used to construct runnable  EmbeddedConnector instances.",
    "code": "    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedConnector build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedConnector(config, classLoader, clock, consumer);\n            }\n\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 221,
    "type": "Summary",
    "comment": "Returns a DurationField representing seconds.",
    "code": "    public DurationField seconds() {\n        return UnsupportedDurationField.getInstance(\"seconds\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 222,
    "type": "Summary",
    "comment": "We should return a full clone of TvShow objects inside catalog because all this data is in memory and anyone can change it if we don't return only copies, but this is just a sample!",
    "code": "  public Collection<TvShow> getTvShows() {\n    return (Set<TvShow>) ((LinkedHashSet<TvShow>) tvShows).clone();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 223,
    "type": "Summary",
    "comment": "Maps offset from java code to pde code.",
    "code": "  protected int[] JavaToPdeOffsets(int line, int offset) {\n\n    return new int[] { 0, 0 }; // TODO\n\n    /*\n    int codeIndex = 0;\n\n    int x = line - mainClassOffset;\n    if (x < 0) {\n      // log(\"Negative line number \"\n      // + problem.getSourceLineNumber() + \" , offset \"\n      // + mainClassOffset);\n      x = line - 2; // Another -1 for 0 index\n      if (x < programImports.size() && x >= 0) {\n        ImportStatement is = programImports.get(x);\n        // log(is.importName + \", \" + is.tab + \", \"\n        // + is.lineNumber);\n        return new int[] { 0, 0 }; // TODO\n      } else {\n\n        // Some seriously ugly stray error, just can't find the source\n        // line! Simply return first line for first tab.\n        return  new int[] { 0, 1 };\n      }\n\n    }\n\n    try {\n      for (SketchCode sc : editor.getSketch().getCode()) {\n        if (sc.isExtension(\"pde\")) {\n          int len;\n          if (editor.getSketch().getCurrentCode().equals(sc)) {\n            len = Util.countLines(sc.getDocumentText()) + 1;\n          } else {\n            len = Util.countLines(sc.getProgram()) + 1;\n          }\n\n          // log(\"x,len, CI: \" + x + \",\" + len + \",\"\n          // + codeIndex);\n\n          if (x >= len) {\n\n            // We're in the last tab and the line count is greater\n            // than the no.\n            // of lines in the tab,\n            if (codeIndex >= editor.getSketch().getCodeCount() - 1) {\n              // log(\"Exceeds lc \" + x + \",\" + len\n              // + problem.toString());\n              // x = len\n              x = editor.getSketch().getCode(codeIndex)\n                  .getLineCount();\n              // TODO: Obtain line having last non-white space\n              // character in the code.\n              break;\n            } else {\n              x -= len;\n              codeIndex++;\n            }\n          } else {\n\n            if (codeIndex >= editor.getSketch().getCodeCount()) {\n              codeIndex = editor.getSketch().getCodeCount() - 1;\n            }\n            break;\n          }\n\n        }\n      }\n    } catch (Exception e) {\n      System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\");\n      e.printStackTrace();\n    }\n    return new int[] { codeIndex, x };\n    */\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 224,
    "type": "Summary",
    "comment": "Return the  org.atmosphere.cpr.MetaBroadcaster",
    "code": "    public static DefaultMetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    }\n\n",
    "label": 1,
    "rec": "Return the  DefaultMetaBroadcaster"
  },
  {
    "id": 225,
    "type": "Summary",
    "comment": "Returns a one dimensional array from an sql query.",
    "code": "    public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result)\n    {   // Check status\n        if (checkOpen()==false)\n            return -1;\n        // Start query\n        ResultSet rs = null;\n        try\n        {   // Log performance\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return -1;\n            }\n            // Check Result\n            int count=0;\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n                count++;\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return count;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return -1;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return -1;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    }\n\n",
    "label": 1,
    "rec": "Adds the first column of a query result to a collection."
  },
  {
    "id": 226,
    "type": "Summary",
    "comment": "Removes a converter from the set of converters, by index.",
    "code": "    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n",
    "label": 1,
    "rec": "Removes a converter from the set of converters."
  },
  {
    "id": 227,
    "type": "Summary",
    "comment": "Gets the writer schema of the AvroKey datum that is being serialized/deserialized.",
    "code": "  public static Schema getKeyWriterSchema(Configuration conf) {\n    String json = conf.get(CONF_KEY_WRITER_SCHEMA);\n    return null == json ? null : new Schema.Parser().parse(json);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 228,
    "type": "Summary",
    "comment": "Output the proper model name (capitalized).",
    "code": "    public String toModelName(final String name) {\n        String result = camelize(sanitizeName(name));\n\n        if (!StringUtils.isEmpty(modelNamePrefix)) {\n            result = modelNamePrefix + \"_\" + result;\n        }\n\n        // model name cannot use reserved keyword, e.g. return\n        if (isReservedWord(name)) {\n            String modelName = \"Model_\" + result;\n            LOGGER.warn(name + \" (reserved word) cannot be used as model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        // model name starts with number\n        if (result.matches(\"^\\\\d.*\")) {\n            String modelName = \"Model_\" + result; // e.g. 200Response => Model_200Response (after camelize)\n            LOGGER.warn(name + \" (model name starts with number) cannot be used as model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        if (languageSpecificPrimitives.contains(result)) {\n            String modelName = \"Model_\" + result;\n            LOGGER.warn(name + \" (model name matches existing language type) cannot be used as a model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        if (!StringUtils.isEmpty(modelNameSuffix)) {\n            result = result + \"_\" + modelNameSuffix;\n        }\n\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 229,
    "type": "Summary",
    "comment": "Return a scanner for creating Processing partitions.",
    "code": "\t public ProcessingPartitionScanner getProcessingPartitionScanner() {\n\t\treturn (fPartitionScanner == null) ? new ProcessingPartitionScanner() : fPartitionScanner;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 230,
    "type": "Summary",
    "comment": "Get the x location of the center of this circle",
    "code": "    public float getX() {\r\n        if(left == null) {\r\n            calculateLeft();\r\n        }\r\n\r\n        return left.floatValue();\r\n    }\r\n\n",
    "label": 1,
    "rec": "Get the x location of the left side of this shape."
  },
  {
    "id": 231,
    "type": "Summary",
    "comment": "Return  InputSplitWrappers for given  HiveReadEntry.",
    "code": "  public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<LogicalInputSplit> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  }\n",
    "label": 1,
    "rec": "Return  LogicalInputSplits for given  HiveReadEntry."
  },
  {
    "id": 232,
    "type": "Summary",
    "comment": "Build all the code for this sketch.",
    "code": "  public String preprocess(String buildPath) throws RunnerException {\n    try {\n      return preprocess(buildPath, new PdePreprocessor(buildPath, name));\n    } catch (IOException e) {\n      throw new RunnerException(\"Error while preprocessing\", true);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 233,
    "type": "Summary",
    "comment": "Extract a component property value.",
    "code": "\tprotected Object getComponentValue(ComponentType type, Object component, String propertyPath) {\n\t\tfinal int loc = propertyPath.indexOf( '.' );\n\t\tfinal String basePropertyName = loc > 0\n\t\t\t\t? propertyPath.substring( 0, loc )\n\t\t\t\t: propertyPath;\n\t\tfinal int index = findSubPropertyIndex( type, basePropertyName );\n\t\tfinal Object baseValue = type.getPropertyValue( component, index, getEntityMode() );\n\t\tif ( loc > 0 ) {\n\t\t\tif ( baseValue == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn getComponentValue(\n\t\t\t\t\t(ComponentType) type.getSubtypes()[index],\n\t\t\t\t\tbaseValue,\n\t\t\t\t\tpropertyPath.substring(loc+1)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn baseValue;\n\t\t}\n\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 234,
    "type": "Summary",
    "comment": "Get the millis duration field for this chronology.",
    "code": "    public DurationField millis() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 235,
    "type": "Summary",
    "comment": "Convenient replacement of  #startProfilingCPU(long) with  ProfilingModes#CPU_TRACING for the mode.",
    "code": "  public static YourKitContext startProfile(boolean enableStackTelemetry,\n                                            boolean enableCPUProfilling,\n                                            boolean enableAllocationRecording) {\n    Controller controller;\n    try {\n      controller = new Controller();\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to set up YourKit controller\", e);\n      return null;\n    }\n\n    try {\n      if (enableStackTelemetry) {\n        controller.enableStackTelemetry();\n        LOG.info(\"Enabled Yourkit stack telemetry\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to enable YourKit stack telemetry\", e);\n    }\n\n    try {\n      if (enableCPUProfilling) {\n        controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,\n          Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC);\n        LOG.info(\"Started YourKit CPU profiling\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to start YourKit CPU profiling\", e);\n    }\n\n    try {\n      if (enableAllocationRecording) {\n        controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL,\n            false, -1, true, false);\n        LOG.info(\"Started YourKit allocation recording\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to start YourKit allocation recording\", e);\n    }\n\n    return new YourKitContext(controller);\n  }\n\n",
    "label": 1,
    "rec": "Create a YourKit controller and do some or all of  Controller#enableExceptionTelemetry()  Controller#startCPUProfiling(long, String, String)  Controller#startAllocationRecording(boolean, int, boolean, int, boolean, boolean) based on boolean config options passed as method parameters"
  },
  {
    "id": 236,
    "type": "Summary",
    "comment": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "code": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 63: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 65: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 67: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 68: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 69: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 3: \n          { return getNext();\n          }\n        case 72: break;\n        case 24: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 73: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 76: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 79: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 80: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 81: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 82: break;\n        case 50: \n          { yypushback(3) ; return getNext();\n          }\n        case 83: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 88: break;\n        case 34: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 90: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 91: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 92: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 93: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 94: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 95: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 96: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 97: break;\n        case 48: \n          { if (keepAssimilations) {\n                            yypushback(2) ; return getNext(); \n                          } else {\n                            return getNext();\n                          }\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 237,
    "type": "Summary",
    "comment": "Tags the Words in each Sentence in the given List with their grammatical part-of-speech.",
    "code": "  public List<List<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) {\n    List<List<TaggedWord>> taggedSentences = Generics.newArrayList();\n\n    TestSentence testSentence = new TestSentence(this);\n    for (List<? extends HasWord> sentence : sentences) {\n      taggedSentences.add(testSentence.tagSentence(sentence, false));\n    }\n    return taggedSentences;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 238,
    "type": "Summary",
    "comment": "Searches for a text string in the edit texts located in the current activity.",
    "code": "\tpublic boolean searchEditText(String search) {\n\t\tboolean found = soloSearch.searchEditText(search);\n\t\treturn found;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 239,
    "type": "Summary",
    "comment": "Gets an array of the fields that this partial supports.",
    "code": "    public DateTimeField[] getFields() {\n        DateTimeField[] result = new DateTimeField[getFieldSize()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getField(i);\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 240,
    "type": "Summary",
    "comment": "Get the  edu.stanford.nlp.international.Language object corresponding to the given language string.",
    "code": "  private Languages.Language getLanguage(String languageStr) {\n    for (Languages.Language l : Languages.Language.values()) {\n      if (l.name().equalsIgnoreCase(languageStr))\n        return l;\n    }\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Get the  edu.stanford.nlp.international.Languages.Language object corresponding to the given language string."
  },
  {
    "id": 241,
    "type": "Summary",
    "comment": "Apply this  HintStrategyTable to the given relational expression for the  hints.",
    "code": "  public List<RelHint> apply(List<RelHint> hints, RelNode rel) {\n    return hints.stream()\n        .filter(relHint -> canApply(relHint, rel))\n        .collect(Collectors.toList());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 242,
    "type": "Summary",
    "comment": "Moves the mouse to the middle of the element.",
    "code": "  public Actions moveToElement(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new MoveMouseAction(jsonMouse, (Locatable) target));\n    }\n\n    return moveInTicks(target, 0, 0);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 243,
    "type": "Summary",
    "comment": "Gets a PendingIntent to send with the request to add or remove Geofences.",
    "code": "    private PendingIntent getGeofencePendingIntent() {\n        // Reuse the PendingIntent if we already have it.\n        if (mGeofencePendingIntent != null) {\n            return mGeofencePendingIntent;\n        }\n        Intent intent = new Intent(this, GeofenceBroadcastReceiver.class);\n        // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling\n        // addGeofences() and removeGeofences().\n        mGeofencePendingIntent = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n        return mGeofencePendingIntent;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 244,
    "type": "Summary",
    "comment": "Gets the EmfRefactoring supported by the controller.",
    "code": "\t@Override\n\tpublic Refactoring getParent() {\n\t\treturn this.parent;\n\t}\n\n",
    "label": 1,
    "rec": "Gets the Refactoring supported by the controller."
  },
  {
    "id": 245,
    "type": "Summary",
    "comment": "Parses a serialized Graph from an InputStream.",
    "code": "    public ImmutableGraph parse(InputStream serializedGraph,\n            String formatIdentifier) throws UnsupportedFormatException {\n        return parse(serializedGraph, formatIdentifier, null);\n    }\n\n",
    "label": 1,
    "rec": "Parses a serialized ImmutableGraph from an InputStream."
  },
  {
    "id": 246,
    "type": "Summary",
    "comment": "Retrieves the resource ID of the app icon.",
    "code": "    private int getIconResId() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context = getApplicationContext();\n        Resources res   = context.getResources();\n        String pkgName  = context.getPackageName();\n        String icon     = settings.optString(\"icon\", \"icon\");\n\n        int resId = res.getIdentifier(icon, \"drawable\", pkgName);\n\n        if (resId == 0) {\n            resId = res.getIdentifier(\"icon\", \"drawable\", pkgName);\n        }\n\n        return resId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 247,
    "type": "Summary",
    "comment": "Returns true if the texture has been initialized.",
    "code": "  public boolean available()  {\n    return 0 < glTextureID;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 248,
    "type": "Summary",
    "comment": "Get the current number of bucket hosts and update the redundancy statistics for the region",
    "code": "  private int updateRedundancy() {\n    int desiredRedundancy = this.pRegion.getRedundantCopies();\n    int numBucketHosts = getNumInitializedBuckets();\n    if (isClosed()) {\n      return numBucketHosts;\n    }\n    int actualRedundancy = numBucketHosts - 1;\n    this.redundancy = actualRedundancy;\n    if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) {\n      incLowRedundancyBucketCount(1);\n      this.redundancySatisfied = false;\n    } else if (!this.redundancySatisfied && numBucketHosts > 0\n        && actualRedundancy >= desiredRedundancy) {\n      incLowRedundancyBucketCount(-1);\n      this.redundancySatisfied = true;\n      this.redundancyEverSatisfied = true;\n    }\n    return numBucketHosts;\n  }\n\n",
    "label": 1,
    "rec": "Determine if there has been a change in redundancy and alter the lowRedundancyBucketCount stat as needed."
  },
  {
    "id": 249,
    "type": "Summary",
    "comment": "Logs user into the system",
    "code": "    public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException {\n        okhttp3.Call localVarCall = loginUserValidateBeforeCall(username, password, null, null);\n        Type localVarReturnType = new TypeToken<String>(){}.getType();\n        return localVarApiClient.execute(localVarCall, localVarReturnType);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 250,
    "type": "Summary",
    "comment": "Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.",
    "code": "   public AnsiClazzes processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'\n         blockClazzes_.clear();\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  // unknown extended color format; hard to recover so\n                  // just reset back to defaults and return\n                  clazzes_.clear();\n                  blockClazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               // We don't support colors specified via RGB, but parse the\n               // sequence then ignore it in case there are supported \n               // sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false /*background*/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true /*background*/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n            blockClazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            // NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            // NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == FONT_NINE)\n         {\n            blockClazzes_.add(FONT_NINE_STYLE);\n         }\n         else if (codeVal == DEFAULT_FONT || \n               (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT))\n         {\n            blockClazzes_.remove(FONT_NINE_STYLE);\n         }\n         else\n         {\n            // ignore all others\n         }\n      }\n      return getStyles();\n   }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 251,
    "type": "Summary",
    "comment": "Test whether two geometries, not of type GeometryCollection are equal.",
    "code": "\tprotected boolean testSimpleGeometryEquality(Geometry geom1, Geometry geom2) {\n\t\t//return geom1.equals(geom2);\n\t\treturn testTypeAndVertexEquality( geom1, geom2 ) && equalSRID( geom1, geom2 );\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 252,
    "type": "Summary",
    "comment": "Retrieves the parsed Test Suite.",
    "code": "\tpublic List<TestSuite> getSuite()\n\t{\n\t\treturn this.testSuites;\n\t}\n\n",
    "label": 1,
    "rec": "Retrieves a linked list with parsed Test Suites."
  },
  {
    "id": 253,
    "type": "Summary",
    "comment": "Checks if this persistent resource's underlying entity is sharable.",
    "code": "    private boolean isShareable() {\n        return getRequestScope().getDictionary().isShareable(obj.getClass());\n    }\n\n",
    "label": 1,
    "rec": "Checks if this persistent resource's underlying entity is shareable."
  },
  {
    "id": 254,
    "type": "Summary",
    "comment": "Createa an Add if it matches, or missing if not.",
    "code": "        public static Optional<Add> create(String statement) {\n            Matcher argumentMatcher = ARGUMENT_TOKENIZER.matcher(statement.trim());\n\n            if (!argumentMatcher.find()) {\n                return Optional.absent();\n            }\n\n            String commandName = argumentMatcher.group();\n            if (!(StringUtils.equals(commandName, \"ADD\") || StringUtils.equals(commandName, \"COPY\"))) {\n                return Optional.absent();\n            }\n\n            String lastToken = null;\n            Collection<String> sources = new ArrayList<>();\n\n            while (argumentMatcher.find()) {\n                if (lastToken != null) {\n                    sources.add(lastToken);\n                }\n                lastToken = argumentMatcher.group().replaceAll(\"(^\\\")|(\\\"$)\", \"\");\n            }\n\n            if (sources.isEmpty()) {\n                throw new DockerClientException(\"Wrong ADD or COPY format\");\n            }\n\n            return Optional.of(new Add(sources, lastToken));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 255,
    "type": "Summary",
    "comment": "Return a list of all selected objects.",
    "code": "    public Collection<OsmPrimitive> getSelected() {\n        return Collections.unmodifiableSet(selectedPrimitives);\n    }\n\n",
    "label": 1,
    "rec": "Replies an unmodifiable collection of primitives currently selected in this dataset"
  },
  {
    "id": 256,
    "type": "Summary",
    "comment": "Construct the text for the main label of a graphic.",
    "code": "    public String[] createText(MilStd2525TacticalGraphic graphic)\n    {\n        String[] result;\n\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n        {\n            result = new String[] { graphic.getText() };\n        }\n        else\n        {\n            boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId);\n            String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel);\n\n            if (useSeparateTimeLabel)\n            {\n                String timeText = this.createTimeRangeText(graphic);\n                result = new String[] { mainText, timeText };\n            }\n            else\n            {\n                result = new String[] { mainText };\n            }\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "Construct the text for labels in a Fire Support area graphic."
  },
  {
    "id": 257,
    "type": "Summary",
    "comment": "Create the intersection of the given arguments",
    "code": "    public static Predicate and(Predicate left, Predicate right){\n        return PredicateOperation.create(Ops.AND, left, right);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 258,
    "type": "Summary",
    "comment": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "code": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { return tokenFactory.makeToken(yytext(), yychar, yylength());\n            }\n          case 4: break;\n          case 2: \n            { return tokenFactory.makeToken(NEWLINE, yychar, yylength());\n            }\n          case 5: break;\n          case 3: \n            { \n            }\n          case 6: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 259,
    "type": "Summary",
    "comment": "Creates a  TokenStream that aggregates the outputs of a given set of  TokenStreams.",
    "code": "  public static final TwitterTokenStream of(TwitterTokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n  }\n\n",
    "label": 1,
    "rec": "Creates a  TwitterTokenStream that aggregates the outputs of a given set of  TokenStreams."
  },
  {
    "id": 260,
    "type": "Summary",
    "comment": "It returns the getter for the given field.",
    "code": "\tpublic static Method getGetterFor(Field field) {\n\t\tString name = field.getName().substring(0, 1).toUpperCase()\n\t\t\t\t+ field.getName().substring(1);\n\n\t\tString methodName;\n\t\tif (boolean.class.isAssignableFrom(field.getType()) ||\n\t\t\tBoolean.class.isAssignableFrom(field.getType())) {\n\t\t\tmethodName = \"is\" + name;\n\t\t} else {\n\t\t\tmethodName = \"get\" + name;\n\t\t}\n\n\t\ttry {\n\t\t\treturn field.getDeclaringClass().getMethod(methodName);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tif (methodName.startsWith(\"is\")) {\n\t\t\t\tmethodName = \"get\" + name;\n\t\t\t\ttry {\n\t\t\t\t\treturn field.getDeclaringClass().getMethod(methodName);\n\t\t\t\t} catch (NoSuchMethodException e2) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tLOG.info(\"No getter {}() for field {}[{}]\", methodName,\n\t\t\t\t\tfield.getDeclaringClass().getName(), field.getName());\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 261,
    "type": "Summary",
    "comment": "To test \\&quot;client\\&quot; model",
    "code": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> pathParams = new HashMap<String, Object>();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(\"/fake\", HttpMethod.PATCH, pathParams, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 262,
    "type": "Summary",
    "comment": "Enhance the interfaces implemented by this instance of WebDriver iff that instance is a  org.openqa.selenium.remote.RemoteWebDriver.",
    "code": "  public WebDriver augment(WebDriver driver) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      // Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));\n      enhancer.setCallback(handler);\n      enhancer.setSuperclass(driver.getClass());\n\n      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();\n      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());\n      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());\n      return remote;\n    }\n\n    return driver;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 263,
    "type": "Summary",
    "comment": "Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "code": "\tstatic public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) {\n\t\tIStructuredTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (IStructuredTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new StructuredTextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n\n",
    "label": 1,
    "rec": "Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment."
  },
  {
    "id": 264,
    "type": "Summary",
    "comment": "Get the y location of the center of this circle",
    "code": "    public float getY() {\r\n        if(top == null) {\r\n            calculateTop();\r\n        }\r\n\r\n        return top.floatValue();\r\n    }\r\n\n",
    "label": 1,
    "rec": "Get the y position of the top of this shape."
  },
  {
    "id": 265,
    "type": "Summary",
    "comment": "Read the announcement generated file.",
    "code": "    protected String readAnnouncement( File file )\n        throws MojoExecutionException\n    {\n        InputStreamReader reader = null;\n        FileInputStream inputStream = null;\n        try\n        {\n            inputStream = new FileInputStream( file );\n\n            if ( StringUtils.isEmpty( templateEncoding ) )\n            {\n                templateEncoding = ReaderFactory.FILE_ENCODING;\n                getLog().warn( \"File encoding has not been set, using platform encoding '\" + templateEncoding\n                                   + \"', i.e. build is platform dependent!\" );\n            }\n\n            reader = new InputStreamReader( inputStream, templateEncoding );\n            return IOUtil.toString( reader );\n        }\n        catch ( FileNotFoundException fnfe )\n        {\n            throw new MojoExecutionException( \"File not found. \" + file );\n        }\n        catch ( UnsupportedEncodingException uee )\n        {\n            throw new MojoExecutionException( \"Unsupported encoding: '\" + templateEncoding + \"'\" );\n        }\n        catch ( IOException ioe )\n        {\n            throw new MojoExecutionException( \"Failed to read the announcement file.\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( inputStream );\n            IOUtil.close( reader );\n        }\n    }\n\n",
    "label": 1,
    "rec": "Read the content of the generated announcement file."
  },
  {
    "id": 266,
    "type": "Summary",
    "comment": "Gets the list size threshold under which  #convertInToOr is used.",
    "code": "  protected int getInSubqueryThreshold() {\n    return config.getInSubqueryThreshold();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 267,
    "type": "Summary",
    "comment": "Create  GitHubRepositoryName from URL",
    "code": "    public static GitlabRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Create  GitlabRepositoryName from URL"
  },
  {
    "id": 268,
    "type": "Summary",
    "comment": "Creates a new UserFolder, inflated from R.layout.user_folder.",
    "code": "    static Folder fromXml(Context context) {\n        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 269,
    "type": "Summary",
    "comment": "Searches for a button with the given search string and returns true if the searched button is found a given number of times",
    "code": "\tprivate boolean searchForButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(regex, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n",
    "label": 1,
    "rec": "Searches for a button with the given regex string and returns true if the searched button is found a given number of times"
  },
  {
    "id": 270,
    "type": "Summary",
    "comment": "Returns an instance of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.",
    "code": "    @Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    @Paged\n    public PagingDelegate<CalendarList> getCalendarList(\n    \t\tfinal @Optional @Default(\"false\") boolean showHidden,\n    \t\tfinal PagingConfiguration pagingConfiguration) throws IOException {\n    \t\n    \treturn new TokenBasedPagingDelegate<CalendarList>() {\n    \t\t\n    \t\t@Override\n    \t\tpublic List<CalendarList> doGetPage() throws IOException {\n\t\t\t\tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list();\n\t\t\t\tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize())\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.setShowHidden(showHidden)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\n\t\t\t\tsetPageToken(list.getNextPageToken());\n\t\t\t\treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    \t\t}\n\t\t};\n    }\n\n",
    "label": 1,
    "rec": "Returns a paginated iterator with instances of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token."
  },
  {
    "id": 271,
    "type": "Summary",
    "comment": "Waits for a text to be shown.",
    "code": "\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {\n\t\tTextView textView = waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll);\n\t\treturn textView != null;\n\t\t\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 272,
    "type": "Summary",
    "comment": "Cancel/discard a job",
    "code": "    public JobInstance cancel(@PathVariable String jobId) {\n\n        try {\n            final JobInstance jobInstance = jobService.getJobInstance(jobId);\n            jobService.cancelJob(jobInstance);\n            return jobService.getJobInstance(jobId);\n        } catch (Exception e) {\n            logger.error(e.getLocalizedMessage(), e);\n            throw new InternalErrorException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 273,
    "type": "Summary",
    "comment": "Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.",
    "code": "    public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        if (rawValue.isNull()) {\n            // nulls are null\n            return null;\n        }\n\n        if (type.isArrayType()) {\n            try {\n                final String dataString = rawValue.asString();\n                PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString);\n                Object deserializedArray = arrayData.getArray();\n                return Arrays.asList((Object[])deserializedArray);\n            }\n            catch (SQLException e) {\n                LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", fullType, columnName, e);\n            }\n            return null;\n        }\n\n        switch (type.getName()) {\n            // include all types from https://www.postgresql.org/docs/current/static/datatype.html#DATATYPE-TABLE\n            // plus aliases from the shorter names produced by older wal2json\n            case \"boolean\":\n            case \"bool\":\n                return rawValue.asBoolean();\n\n            case \"integer\":\n            case \"int\":\n            case \"int4\":\n            case \"smallint\":\n            case \"int2\":\n            case \"smallserial\":\n            case \"serial\":\n            case \"serial2\":\n            case \"serial4\":\n            case \"oid\":\n                return rawValue.asInteger();\n\n            case \"bigint\":\n            case \"bigserial\":\n            case \"int8\":\n                return rawValue.asLong();\n\n            case \"real\":\n            case \"float4\":\n                return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString());\n\n            case \"double precision\":\n            case \"float8\":\n                return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString());\n\n            case \"numeric\":\n            case \"decimal\":\n                if (rawValue.isInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger()));\n                }\n                else if (rawValue.isLong()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asLong()));\n                }\n                else if (rawValue.isBigInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger()));\n                }\n                return SpecialValueDecimal.valueOf(rawValue.asString());\n\n            case \"character\":\n            case \"char\":\n            case \"character varying\":\n            case \"varchar\":\n            case \"bpchar\":\n            case \"text\":\n                return rawValue.asString();\n\n            case \"date\":\n                return DateTimeFormat.get().date(rawValue.asString());\n\n            case \"timestamp with time zone\":\n            case \"timestamptz\":\n                return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString());\n\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n                final LocalDateTime serverLocal = Conversions.fromNanosToLocalDateTimeUTC(DateTimeFormat.get().timestamp(rawValue.asString()));\n                final Instant utc = serverLocal.atOffset(serverTimezone).toInstant();\n                return Conversions.toEpochNanos(utc);\n\n            case \"time\":\n            case \"time without time zone\":\n                return DateTimeFormat.get().time(rawValue.asString());\n\n            case \"time with time zone\":\n            case \"timetz\":\n                return DateTimeFormat.get().timeWithTimeZone(rawValue.asString());\n\n            case \"bytea\":\n                return Strings.hexStringToByteArray(rawValue.asString());\n\n            // these are all PG-specific types and we use the JDBC representations\n            // note that, with the exception of point, no converters for these types are implemented yet,\n            // i.e. those values won't actually be propagated to the outbound message until that's the case\n            case \"box\":\n                try {\n                    return new PGbox(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"circle\":\n                try {\n                    return new PGcircle(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"interval\":\n                try {\n                    return new PGInterval(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"line\":\n                try {\n                    return new PGline(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"lseg\":\n                try {\n                    return new PGlseg(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"money\":\n                try {\n                    return new PGmoney(rawValue.asString()).val;\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"path\":\n                try {\n                    return new PGpath(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"point\":\n                try {\n                    return new PGpoint(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"polygon\":\n                try {\n                    return new PGpolygon(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n\n            // PostGIS types are HexEWKB strings\n            // ValueConverter turns them into the correct types\n            case \"geometry\":\n            case \"geography\":\n                return rawValue.asString();\n\n            case \"bit\":\n            case \"bit varying\":\n            case \"varbit\":\n            case \"json\":\n            case \"jsonb\":\n            case \"xml\":\n            case \"uuid\":\n            case \"tstzrange\":\n                return rawValue.asString();\n            // catch-all for other known/builtin PG types\n            // TODO: improve with more specific/useful classes here?\n            case \"cidr\":\n            case \"inet\":\n            case \"macaddr\":\n            case \"macaddr8\":\n            case \"pg_lsn\":\n            case \"tsquery\":\n            case \"tsvector\":\n            case \"txid_snapshot\":\n            // catch-all for unknown (extension module/custom) types\n            default:\n                break;\n        }\n\n        if (includeUnknownDatatypes) {\n            // this includes things like PostGIS geometries or other custom types.\n            // leave up to the downstream message recipient to deal with.\n            LOGGER.debug(\"processing column '{}' with unknown data type '{}' as byte array\", columnName,\n                    fullType);\n            return rawValue.asString();\n        }\n        LOGGER.debug(\"Unknown column type {} for column {} \u00e2\u0080\u0093\u00c2\u00a0ignoring\", fullType, columnName);\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 274,
    "type": "Summary",
    "comment": "Parses the output of ping and populates a instance of  PingInfo",
    "code": "\tprotected PingResult parse(int exitValue, List<String> outLines,List<String> errLines) {\n\t\tPingResult info = new PingResult();\n\t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n\t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n\t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n\t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n\n\t\tinfo.setHost(getHost());\n\n\t\t// Parse the output based on exit value of ping\n\t\tswitch (exitValue) {\n\n\t\t// Clean exit\n\t\tcase 0:\n\t\t\t// Extract the RTT times\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = roundTripTimePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1)));\n\t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2)));\n\t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3)));\n\t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Extract the transmit and received counts\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If no ICMP packages are returned then consider the test failed\n\t\t\tif (info.getReceived() == 0) {\n\t\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo.setStatus(ServiceStatus.SUCCESS);\n\t\t\t}\n\t\t\tbreak;\n\t\t// Error case: 1) Unable to resolve host ; 2) Host unreachable\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 68:\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (String line: errLines) {\n\t\t\t\tMatcher matcher = unknownHostPat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setMessage(matcher.group(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert false: \"Unknown exit code\";\n\t\t}\n\n\t\treturn info;\n\t}\n\n",
    "label": 1,
    "rec": "Parses the output of ping and populates a instance of  PingResult"
  },
  {
    "id": 275,
    "type": "Summary",
    "comment": "Removes the package version from this channel, if it exists.",
    "code": "    public RepoPackageVersion removePackageVersion(PackageVersion packageVersion) {\n        if ((this.repoPackageVersions == null) || (packageVersion == null)) {\n            return null;\n        }\n\n        RepoPackageVersion doomed = null;\n\n        for (RepoPackageVersion cpv : this.repoPackageVersions) {\n            if (packageVersion.equals(cpv.getRepoPackageVersionPK().getPackageVersion())) {\n                doomed = cpv;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.repoPackageVersions.remove(doomed);\n        }\n\n        return doomed;\n    }\n\n",
    "label": 1,
    "rec": "Removes the package version from this repo, if it exists."
  },
  {
    "id": 276,
    "type": "Summary",
    "comment": "Compares this object with the specified object for equality based on start and end millis.",
    "code": "    public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return (getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis() &&\n                getChronology() == other.getChronology());\n    }\n",
    "label": 1,
    "rec": "Compares this object with the specified object for equality based on start and end millis plus the chronology."
  },
  {
    "id": 277,
    "type": "Summary",
    "comment": "Returns the stored portlet preferences array.",
    "code": "\tpublic Map<String,InternalPortletPreference> getStoredPreferences(\n\t\t\tPortletWindow portletWindow,\n\t\t\tPortletRequest request)\n\tthrows PortletContainerException {\n        String key = getFormattedKey(portletWindow, request);\n        Map<String,InternalPortletPreference> preferences = storage.get(key);\n        if (preferences == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No portlet preferences found for: \" + key);\n            }\n            return Collections.emptyMap();\n        } else {\n        \tif (LOG.isDebugEnabled()) {\n        \t\tLOG.debug(\"Got \" + preferences.size() + \" stored preferences.\");\n        \t}\n        \treturn clonePreferences(preferences);\n        }\n    }\n\n",
    "label": 1,
    "rec": "Returns the stored portlet preferences map."
  },
  {
    "id": 278,
    "type": "Summary",
    "comment": "Get the relative index of an element to its parent (starting from 0).",
    "code": "  public Number getElementIndex(String locator) {\n    WebElement element = elementFinder.findElement(driver, locator);\n    String script = \n      \"var _isCommentOrEmptyTextNode = function(node) {\\n\" + \n      \"    return node.nodeType == 8 || ((node.nodeType == 3) && !(/[^\\\\t\\\\n\\\\r ]/.test(node.data)));\\n\" + \n      \"}\\n\" +\n      \"    var element = arguments[0];\\n\" +\n      \"    var previousSibling;\\n\" + \n      \"    var index = 0;\\n\" + \n      \"    while ((previousSibling = element.previousSibling) != null) {\\n\" + \n      \"        if (!_isCommentOrEmptyTextNode(previousSibling)) {\\n\" + \n      \"            index++;\\n\" + \n      \"        }\\n\" + \n      \"        element = previousSibling;\\n\" + \n      \"    }\\n\" + \n      \"    return index;\";\n    return (Long) javascriptLibrary.executeScript(driver, script, element);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 279,
    "type": "Summary",
    "comment": "Returns the common base directory between a current base directory and a given file.",
    "code": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "Returns the common base directory between the passed file1 and file2."
  },
  {
    "id": 280,
    "type": "Summary",
    "comment": "Returns the  ConnectionJDBC object referenced by the  #statement instance variable.",
    "code": "    private JtdsConnection getConnection() throws SQLException {\n        return (JtdsConnection) statement.getConnection();\n    }\n\n",
    "label": 1,
    "rec": "Returns the  JtdsConnection object referenced by the  #statement instance variable."
  },
  {
    "id": 281,
    "type": "Summary",
    "comment": "This method initializes txtProxyPort",
    "code": "\tprivate ZapTextField getTxtProxyPort() {\n\t\tif (txtProxyPort == null) {\n\t\t\ttxtProxyPort = new ZapTextField();\n\t\t}\n\t\treturn txtProxyPort;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 282,
    "type": "Summary",
    "comment": "Searches an array of methods for a match against the given operation",
    "code": "    public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException {\n        String name = operation.getName();\n        Class<?>[] paramTypes = getPhysicalTypes(operation);\n        return implClass.getMethod(name, paramTypes);\n    }\n\n",
    "label": 1,
    "rec": "Return the method on the implementation class that matches the operation."
  },
  {
    "id": 283,
    "type": "Summary",
    "comment": "Marshall JSON metadata into a new Widget instance",
    "code": "\tpublic static W3CWidget getWidget(String metadata, String shindig) throws Exception{\n\t\tJSONObject gadget = null;\n\t\tJSONObject response = new JSONObject(metadata);\n\t\tJSONArray gadgets = response.getJSONArray(\"gadgets\");\n\t\tif (gadgets.length()==0) return null;\n\t\tgadget = gadgets.getJSONObject(0);\n\t\treturn new GadgetAdapter(gadget, shindig);\n\t}\n\n",
    "label": 1,
    "rec": "Marshall JSON metadata into a new W3CWidget instance"
  },
  {
    "id": 284,
    "type": "Summary",
    "comment": "Tells whether or not the given  name matches the given  engineName and  engineLanguage.",
    "code": "\tpublic static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In the configs we just use the engine name, in the UI we use the language name as well\n\t\tif (name.indexOf(LANG_ENGINE_SEP) > 0) {\n\t\t\tif (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn name.equals(engineName);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 285,
    "type": "Summary",
    "comment": "Returns the Thread Context ClassLoader (TCCL).",
    "code": "\tpublic static ClassLoader defaultClassLoader() {\n\t\treturn Thread.currentThread().getContextClassLoader();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 286,
    "type": "Summary",
    "comment": "Gets the title of the current page.",
    "code": "  public String getTitle() {\n    return (String) seleneseMethods.get(\"getTitle\").apply(driver);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 287,
    "type": "Summary",
    "comment": "Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.",
    "code": "\tpublic synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tVisualItem item = (VisualItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} //\n\n",
    "label": 1,
    "rec": "Requests a VisualItem of the specified item class corresponding to a given Entity, optionally creating the VisualItem if it doesn't already exist."
  },
  {
    "id": 288,
    "type": "Summary",
    "comment": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  ActiveDirectoryInfo instance containing the results.",
    "code": "    protected LdapDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getLdapDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n\n",
    "label": 1,
    "rec": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  LdapDirectoryInfo instance containing the results."
  },
  {
    "id": 289,
    "type": "Summary",
    "comment": "Return a DERObject containing the encoded certificate.",
    "code": "    private ASN1Object toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n\n",
    "label": 1,
    "rec": "Return a ASN1Object containing the encoded certificate."
  },
  {
    "id": 290,
    "type": "Summary",
    "comment": "Extract the nominal patterns from this sentence.",
    "code": "  public List<RelationTriple> extract(SemanticGraph parse, List<CoreLabel> tokens) {\n    List<RelationTriple> extractions = new ArrayList<>();\n    Set<Triple<Span,String,Span>> alreadyExtracted = new HashSet<>();\n\n    // Run Token Patterns\n    for (TokenSequencePattern tokenPattern : NOUN_TOKEN_PATTERNS) {\n      TokenSequenceMatcher tokenMatcher = tokenPattern.matcher(tokens);\n      while (tokenMatcher.find()) {\n        // Create subject\n        List<? extends CoreMap> subject = tokenMatcher.groupNodes(\"$subject\");\n        Span subjectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) subject.get(0)).index() - 1, ((CoreLabel) subject.get(subject.size() - 1)).index()));\n        List<CoreLabel> subjectTokens = new ArrayList<>();\n        for (int i : subjectSpan) {\n          subjectTokens.add(tokens.get(i));\n        }\n        // Create object\n        List<? extends CoreMap> object = tokenMatcher.groupNodes(\"$object\");\n        Span objectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) object.get(0)).index() - 1, ((CoreLabel) object.get(object.size() - 1)).index()));\n        if (Span.overlaps(subjectSpan, objectSpan)) {\n          continue;\n        }\n        List<CoreLabel> objectTokens = new ArrayList<>();\n        for (int i : objectSpan) {\n          objectTokens.add(tokens.get(i));\n        }\n        // Create relation\n        if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n          List<CoreLabel> relationTokens = new ArrayList<>();\n          // (add the 'be')\n          relationTokens.add(new CoreLabel() {{\n            setWord(\"is\");\n            setLemma(\"be\");\n            setTag(\"VBZ\");\n            setNER(\"O\");\n            setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n            setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n            setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n            setIndex(-1);\n          }});\n          // (add a complement to the 'be')\n          List<? extends CoreMap> beofComp = tokenMatcher.groupNodes(\"$beof_comp\");\n          if (beofComp != null) {\n            // (add the complement\n            for (CoreMap token : beofComp) {\n              if (token instanceof CoreLabel) {\n                relationTokens.add((CoreLabel) token);\n              } else {\n                relationTokens.add(new CoreLabel(token));\n              }\n            }\n            // (add the 'of')\n            relationTokens.add(new CoreLabel() {{\n              setWord(\"of\");\n              setLemma(\"of\");\n              setTag(\"IN\");\n              setNER(\"O\");\n              setBeginPosition(objectTokens.get(0).beginPosition());\n              setEndPosition(objectTokens.get(0).beginPosition());\n              setSentIndex(objectTokens.get(0).sentIndex());\n              setIndex(-1);\n            }});\n          }\n          // Add extraction\n          String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n          if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n            extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens));\n            alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n          }\n        }\n      }\n\n      // Run Semgrex Matches\n      for (SemgrexPattern semgrex : NOUN_DEPENDENCY_PATTERNS) {\n        SemgrexMatcher matcher = semgrex.matcher(parse);\n        while (matcher.find()) {\n          // Create subject\n          IndexedWord subject = matcher.getNode(\"subject\");\n          Span subjectSpan = Util.extractNER(tokens, Span.fromValues(subject.index() - 1, subject.index()));\n          List<CoreLabel> subjectTokens = new ArrayList<>();\n          for (int i : subjectSpan) {\n            subjectTokens.add(tokens.get(i));\n          }\n          // Create object\n          IndexedWord object = matcher.getNode(\"object\");\n          Span objectSpan = Util.extractNER(tokens, Span.fromValues(object.index() - 1, object.index()));\n          List<CoreLabel> objectTokens = new ArrayList<>();\n          for (int i : objectSpan) {\n            objectTokens.add(tokens.get(i));\n          }\n          // Check that the pair is valid\n          if (Span.overlaps(subjectSpan, objectSpan)) {\n            continue;  // We extracted an identity\n          }\n          if (subjectSpan.end() == objectSpan.start() - 1 &&\n              (tokens.get(subjectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(subjectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n          if (objectSpan.end() == subjectSpan.start() - 1 &&\n              (tokens.get(objectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(objectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n          // Get the relation\n          if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n            LinkedList<CoreLabel> relationTokens = new LinkedList<>();\n            IndexedWord relNode = matcher.getNode(\"relation\");\n            if (relNode != null) {\n              // (add the relation)\n              relationTokens.add(relNode.backingLabel());\n              // (check for aux information)\n              String relaux = matcher.getRelnString(\"relaux\");\n              if (relaux != null && relaux.startsWith(\"nmod:\") && !\"nmod:poss\".equals(relaux)) {\n                relationTokens.add(new CoreLabel() {{\n                  setWord(relaux.substring(\"nmod:\".length()));\n                  setLemma(relaux.substring(\"nmod:\".length()));\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              } else if (relaux != null && \"nmod:poss\".equals(relaux)) {\n                relationTokens.addFirst(new CoreLabel() {{\n                  setWord(\"'s\");\n                  setLemma(\"'s\");\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n                relationTokens.addLast(new CoreLabel() {{\n                  setWord(\"is\");\n                  setLemma(\"be\");\n                  setTag(\"VBZ\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              }\n            } else {\n              // (add the 'be')\n              relationTokens.add(new CoreLabel() {{\n                setWord(\"is\");\n                setLemma(\"be\");\n                setTag(\"VBZ\");\n                setNER(\"O\");\n                setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                setIndex(-1);\n              }});\n              // (add an optional prep)\n              String rel = matcher.getRelnString(\"relation\");\n              String prep = null;\n              if (rel != null && rel.startsWith(\"nmod:\") && !\"nmod:poss\".equals(rel)) {\n                prep = rel.substring(\"nmod:\".length());\n              } else if (rel != null && (rel.startsWith(\"acl:\") || rel.startsWith(\"advcl:\")) ) {\n                prep = rel.substring(rel.indexOf(\":\"));\n              } else if (rel != null && rel.equals(\"nmod:poss\")) {\n                relationTokens.clear();\n                prep = \"'s\";\n              }\n              if (prep != null) {\n                final String p = prep;\n                relationTokens.add(new CoreLabel() {{\n                  setWord(p);\n                  setLemma(p);\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              }\n            }\n            // Add extraction\n            String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n            if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n              extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens));\n              alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n            }\n          }\n        }\n      }\n    }\n\n    // Filter downward polarity extractions\n    Iterator<RelationTriple> iter = extractions.iterator();\n    while (iter.hasNext()) {\n      RelationTriple term = iter.next();\n      boolean shouldRemove = false;\n      for (CoreLabel token : term) {\n        if (token.get(NaturalLogicAnnotations.PolarityAnnotation.class) != null &&\n            token.get(NaturalLogicAnnotations.PolarityAnnotation.class).isDownwards() ) {\n          shouldRemove = true;\n        }\n      }\n      if (shouldRemove) { iter.remove(); }  // Don't extract things in downward polarity contexts.\n    }\n\n    // Return\n    return extractions;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 291,
    "type": "Summary",
    "comment": "Create a new request queue, using NoHttp default request executor  HttpRestConnection and default response parser  HttpRestParser.",
    "code": "    public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {\n        return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n",
    "label": 1,
    "rec": "Create a new request queue, using NoHttp default request executor  RestProtocol and default response parser  RestParser."
  },
  {
    "id": 292,
    "type": "Summary",
    "comment": "Get the actual schema from aliases.",
    "code": "    public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) {\n        Map<String, Schema> allSchemas = getSchemas(openAPI);\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; // generate a model extending array\n                } else {\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property\n                    return schema; // treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; // generate a model extending map\n                    } else {\n                        // treat it as a typical map\n                        return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { // model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property\n                    return schema;\n                } else { // free form object (type: object)\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 293,
    "type": "Summary",
    "comment": "Applies  predicate to each item",
    "code": "    public <V extends Visitor<? super X>> V visit(V visitor)\n    {\n        for (X x : this) {\n            visitor.visit(x);\n        }\n\n        return visitor;\n    }\n\n",
    "label": 1,
    "rec": "Applies  visitor to each item"
  },
  {
    "id": 294,
    "type": "Summary",
    "comment": "Returns the  ConnectionService.VideoCallProvider for the connection.",
    "code": "    public VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    }\n\n",
    "label": 1,
    "rec": "Returns the  VideoCallProvider for the connection."
  },
  {
    "id": 295,
    "type": "Summary",
    "comment": "Returns the message id header value of a SIP request",
    "code": "\tpublic static String getMessageId(SipRequest request) {\r\n\t\tString result = null;\r\n\t\ttry {\r\n\t\t\t// Read ID from multipart content\r\n\t\t    String content = request.getContent();\r\n\t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\t\tif (index != -1) {\r\n\t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r\n\t\t\t\tString part = content.substring(index);\r\n\t\t\t\tString msgId = part.substring(0, part.indexOf(CRLF));\r\n\t\t\t\tresult = msgId.trim();\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Returns the message ID from a SIP request"
  },
  {
    "id": 296,
    "type": "Summary",
    "comment": "Return a  FilteredEnvironment for the calling user.",
    "code": "    public static FxEnvironment getFilteredEnvironment() {\n        return new FxFilteredEnvironment(getEnvironment());\n    }\n\n",
    "label": 1,
    "rec": "Return a  com.flexive.shared.structure.FxFilteredEnvironment for the calling user."
  },
  {
    "id": 297,
    "type": "Summary",
    "comment": "Index of terminal to show after closing indicated terminal index",
    "code": "   private String terminalToShowWhenClosing(String handle)\n   {\n      int terminalClosing = terminals_.indexOfTerminal(handle);\n      if (terminalClosing > 0)\n         return terminals_.terminalHandleAtIndex(terminalClosing - 1);\n      else if (terminalClosing + 1 < terminals_.terminalCount())\n         return terminals_.terminalHandleAtIndex(terminalClosing + 1);\n      else\n         return null;\n   }\n",
    "label": 1,
    "rec": "Handle of terminal to show after closing indicated terminal."
  },
  {
    "id": 298,
    "type": "Summary",
    "comment": "Gets a Map of distances for a specific run and year.",
    "code": "\tpublic Collection getDistancesMap(Group run, String year) {\n\t\tIWContext iwc = IWContext.getInstance();\n\t\tMap disMap = new LinkedHashMap();\n\t\tCollection distances = null;\n\t\tCollection type = new ArrayList();\n\t\ttype.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n\t\tIterator yearsIter = getYears(run).iterator();\n\t\twhile (yearsIter.hasNext()) {\n\t\t\tGroup y = (Group) yearsIter.next();\n\t\t\tif (y.getName().equals(year)) {\n\t\t\t\ttry {\n\t\t\t\t\tdistances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tdistances = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distances;\n\t}\n\n",
    "label": 1,
    "rec": "Gets a Collection of distances for a specific run and year."
  },
  {
    "id": 299,
    "type": "Summary",
    "comment": "Checks whether this ChatSection's argument can be parsed as a boolean",
    "code": "    public boolean isBoolean() {\n        return raw.equals(\"true\") || raw.equals(\"false\");\n    }\n\n",
    "label": 1,
    "rec": "Checks whether this ChatSection's value can be parsed as a boolean"
  }
]