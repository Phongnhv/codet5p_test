[
  {
    "id": 0,
    "type": "Param",
    "comment": "@param userName the name of the user",
    "code": "\tpublic User getUser(String userId) {\n\t\t\n\t\tif (getUsers().containsKey(userId.toLowerCase())) {\n\t\t\treturn getUsers().get(userId.toLowerCase());\n\t\t}\n\t\t\n\t\t// Legacy name matching\n\t\tif (userId.length() < 36) {\n\n\t\t\t// Search for a LastName match\n\t\t\tfor (User user : getUserList()) {\n\t\t\t\t\n\t\t\t\tif (user.getLastName().equalsIgnoreCase(userId))\n\t\t\t\t\treturn user;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// No user account found so create a new one.\n\t\tUser newUser = createUser(userId);\n\t\t\n\t\treturn newUser;\n\t}\n",
    "label": 1,
    "rec": "@param userId the UUID String or name of the user"
  },
  {
    "id": 1,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    @Override protected void clearIndex(CacheObject val) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2,
    "type": "Param",
    "comment": "@param createDate",
    "code": "    public int delete(Date now) {\n        if (null != now) {\n            QueryHandler queryHandler = getQueryHandler(\"delete from SysEmailToken bean\");\n            queryHandler.condition(\"bean.expiryDate is not null\");\n            queryHandler.condition(\"bean.expiryDate <= :expiryDate\").setParameter(\"expiryDate\", now);\n            return delete(queryHandler);\n        }\n        return 0;\n    }\n",
    "label": 1,
    "rec": "@param now"
  },
  {
    "id": 3,
    "type": "Param",
    "comment": "@param key Key to add.",
    "code": "    private boolean addLocalKey(KeyCacheObject key, long topVer, Collection<KeyCacheObject> distributedKeys)\n        throws IgniteCheckedException {\n        GridDistributedCacheEntry entry = cctx.colocated().entryExx(key, topVer, false);\n\n        assert !entry.detached();\n\n        if (!cctx.isAll(entry, filter)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Entry being locked did not pass filter (will not lock): \" + entry);\n\n            onComplete(false, false);\n\n            return false;\n        }\n\n        GridCacheMvccCandidate cand = addEntry(entry);\n\n        if (cand != null && !cand.reentry())\n            distributedKeys.add(key);\n\n        return inTx() && cand == null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 4,
    "type": "Param",
    "comment": "@param metaStore Store.",
    "code": "    protected ReuseList createReuseList(int cacheId, PageMemory pageMem, long[] rootIds, boolean initNew)\n        throws IgniteCheckedException {\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param initNew Init new flag."
  },
  {
    "id": 5,
    "type": "Param",
    "comment": "@param apiGroupName the API Group name like apps.openshift.io or build.openshift.io",
    "code": "  public static ConfigAndApiGroupsInfo withApiGroup(OpenShiftClient openShiftClient, String apiGroupName, String apiVersion, OpenShiftConfig config) {\n    String oapiVersion = config.getOapiVersion();\n    if (config.isOpenShiftAPIGroups(openShiftClient)) {\n      String apiGroupUrl = URLUtils.join(config.getMasterUrl(), \"apis\", apiGroupName, oapiVersion);\n      String apiGroupVersion = URLUtils.join(apiGroupName, oapiVersion);\n      return new ConfigAndApiGroupsInfo(new OpenShiftConfig(config, apiGroupUrl), apiGroupName, apiGroupVersion);\n    } else {\n      if (apiVersion == null) {\n        apiVersion = oapiVersion;\n      }\n      return new ConfigAndApiGroupsInfo(config, apiGroupName, apiVersion);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 6,
    "type": "Param",
    "comment": "@param userName",
    "code": "\tpublic boolean isUserDeclared(String userId) {\n\n\t\treturn getUsers().containsKey(userId.toLowerCase());\n\t}\n",
    "label": 1,
    "rec": "@param userId"
  },
  {
    "id": 7,
    "type": "Param",
    "comment": "@param cnt Number of popular numbers to return.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer, final int cnt) {\n        TimerTask task = new TimerTask() {\n            private CacheQuery<List<?>> qry;\n\n            @Override public void run() {\n                // Get reference to cache.\n                GridCache<Integer, Long> cache = ignite.cache(CACHE_NAME);\n\n                if (qry == null)\n                    qry = cache.queries().\n                        createSqlFieldsQuery(\"select _key, _val from Long order by _val desc limit \" + cnt);\n\n                try {\n                    List<List<?>> results = new ArrayList<>(qry.execute().get());\n\n                    Collections.sort(results, new Comparator<List<?>>() {\n                        @Override public int compare(List<?> r1, List<?> r2) {\n                            long cnt1 = (Long)r1.get(1);\n                            long cnt2 = (Long)r2.get(1);\n\n                            return cnt1 < cnt2 ? 1 : cnt1 > cnt2 ? -1 : 0;\n                        }\n                    });\n\n                    for (int i = 0; i < cnt && i < results.size(); i++) {\n                        List<?> res = results.get(i);\n\n                        System.out.println(res.get(0) + \"=\" + res.get(1));\n                    }\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 8,
    "type": "Param",
    "comment": "@param schema Schema.",
    "code": "    public String space(String schemaName) {\n        assert schemaName != null;\n\n        Schema schema = schemas.get(schemaName);\n\n        // For the compatibility with conversion from \"\"\"\" to \"\" inside h2 lib\n        if (schema == null) {\n            assert schemaName.isEmpty() || schemaName.charAt(0) != ESC_CH;\n\n            schema = schemas.get(escapeName(schemaName, true));\n        }\n\n        return schema.spaceName;\n    }\n",
    "label": 1,
    "rec": "@param schemaName Schema name. Could not be null. Could be empty."
  },
  {
    "id": 9,
    "type": "Param",
    "comment": "@param ctx Cache context.",
    "code": "    public static Collection<ClusterNode> allNodes(GridCacheContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().cacheNodes(ctx.namex(), topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 10,
    "type": "Param",
    "comment": "@param kedge the  KEdge check for connected elements",
    "code": "    public static Iterator<ElkGraphElement> getConnectedElements(final ElkEdge edge, final boolean addPorts) {\n        final SelectionIterator sourceSideIt = new DefaultSelectionIterator(edge, addPorts, false);\n        final SelectionIterator targetSideIt = new DefaultSelectionIterator(edge, addPorts, true);\n\n        return getConnectedElements(edge, sourceSideIt, targetSideIt);\n    }\n\n",
    "label": 1,
    "rec": "@param kedge the edge to check for connected elements"
  },
  {
    "id": 11,
    "type": "Param",
    "comment": "@param pageMem Page memory.",
    "code": "    protected ReuseList createReuseList(int cacheId, PageMemory pageMem, long[] rootIds, boolean initNew)\n        throws IgniteCheckedException {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 12,
    "type": "Param",
    "comment": "@param wsResultVector The result vector to fetch an action from",
    "code": "    public static WSSecurityEngineResult fetchActionResult(List resultList, int action) {\n\n        for (int i = 0; i < resultList.size(); i++) {\n            //\n            // Check the result of every action whether it matches the given action\n            //\n            WSSecurityEngineResult result = \n                (WSSecurityEngineResult) resultList.get(i);\n            int resultAction = \n                ((java.lang.Integer)result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n            if (resultAction == action) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "@param resultList The result list to fetch an action from"
  },
  {
    "id": 13,
    "type": "Param",
    "comment": "@param ctx Shared cache context.",
    "code": "    public static Collection<ClusterNode> allNodes(GridCacheSharedContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().cacheNodes(topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 14,
    "type": "Param",
    "comment": "@param refresh",
    "code": "    public String check(Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        if (CommonUtils.notEmpty(ids)) {\n            SysSite site = getSite(request);\n            Long userId = ControllerUtils.getAdminFromSession(session).getId();\n            List<CmsContent> entityList = service.check(site.getId(), userId, ids);\n            Set<Integer> categoryIdSet = new HashSet<>();\n            for (CmsContent entity : entityList) {\n                if (null != entity && site.getId() == entity.getSiteId()) {\n                    if (CommonUtils.notEmpty(entity.getParentId())) {\n                        publish(new Long[] { entity.getParentId() }, _csrf, request, session, model);\n                    }\n                    publish(new Long[] { entity.getId() }, _csrf, request, session, model);\n                    categoryIdSet.add(entity.getCategoryId());\n                }\n            }\n            for (CmsCategory category : categoryService.getEntitys(categoryIdSet.toArray(new Integer[categoryIdSet.size()]))) {\n                templateComponent.createCategoryFile(site, category, null, null);\n            }\n            logOperateService.save(new LogOperate(site.getId(), userId, LogLoginService.CHANNEL_WEB_MANAGER, \"check.content\",\n                    RequestUtils.getIpAddress(request), CommonUtils.getDate(), StringUtils.join(ids, ',')));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 1,
    "rec": "@param _csrf"
  },
  {
    "id": 15,
    "type": "Param",
    "comment": "@param key",
    "code": "  public Long incrBy(final byte[] key, final long increment) {\n    checkIsInMultiOrPipeline();\n    client.incrBy(key, increment);\n    return client.getIntegerReply();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 16,
    "type": "Param",
    "comment": "@param id",
    "code": "    public boolean virify(String name, String domain, String oldName, ModelMap model) {\n        if (CommonUtils.notEmpty(name)) {\n            if (CommonUtils.notEmpty(oldName) && !name.equals(oldName)\n                    && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(name), model)\n                    || CommonUtils.empty(oldName) && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(name), model)) {\n                return false;\n            }\n        }\n        if (CommonUtils.notEmpty(domain) && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(domain), model)) {\n            return false;\n        }\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param oldName"
  },
  {
    "id": 17,
    "type": "Param",
    "comment": "@param pendingParts per tier pending partitions map.",
    "code": "        boolean assign(int part, int tier, ClusterNode node, boolean force, Map<Integer, Queue<Integer>> pendingParts) {\n            UUID nodeId = node.id();\n\n            if (!fullMap.get(nodeId).contains(part)) {\n                tierMaps[tier].get(nodeId).add(part);\n\n                fullMap.get(nodeId).add(part);\n\n                List<ClusterNode> assignment = assignments.get(part);\n\n                if (assignment.size() <= tier)\n                    assignment.add(node);\n                else {\n                    ClusterNode oldNode = assignment.set(tier, node);\n\n                    if (oldNode != null) {\n                        UUID oldNodeId = oldNode.id();\n\n                        tierMaps[tier].get(oldNodeId).remove(part);\n                        fullMap.get(oldNodeId).remove(part);\n                    }\n                }\n\n                return true;\n            }\n            else if (force) {\n                assert !tierMaps[tier].get(nodeId).contains(part);\n\n                // Check previous tiers first.\n                for (int t = 0; t < tier; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part))\n                        return false;\n                }\n\n                // Partition is on some lower tier, switch it.\n                for (int t = tier + 1; t < tierMaps.length; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part)) {\n                        ClusterNode oldNode = assignments.get(part).get(tier);\n\n                        // Move partition from level t to tier.\n                        assignments.get(part).set(tier, node);\n                        assignments.get(part).set(t, null);\n\n                        if (oldNode != null) {\n                            tierMaps[tier].get(oldNode.id()).remove(part);\n                            fullMap.get(oldNode.id()).remove(part);\n                        }\n\n                        tierMaps[tier].get(nodeId).add(part);\n                        tierMaps[t].get(nodeId).remove(part);\n\n                        Queue<Integer> pending = pendingParts.get(t);\n\n                        if (pending == null) {\n                            pending = new LinkedList<>();\n\n                            pendingParts.put(t, pending);\n                        }\n\n                        pending.add(part);\n\n                        return true;\n                    }\n                }\n\n                throw new IllegalStateException(\"Unable to assign partition to node while force is true.\");\n            }\n\n            // !force.\n            return false;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 18,
    "type": "Param",
    "comment": "@param cls Source type class.",
    "code": "    private static ClassProperty buildClassProperty(Class<?> keyCls, Class<?> valCls, String pathStr, Class<?> resType)\n        throws IgniteCheckedException {\n        ClassProperty res = buildClassProperty(true, keyCls, pathStr, resType);\n\n        if (res == null) // We check key before value consistently with PortableProperty.\n            res = buildClassProperty(false, valCls, pathStr, resType);\n\n        if (res == null)\n            throw new IgniteCheckedException(\"Failed to initialize property '\" + pathStr + \"' for \" +\n                \"key class '\" + keyCls + \"' and value class '\" + valCls + \"'. \" +\n                \"Make sure that one of these classes contains respective getter method or field.\");\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param valCls Value class."
  },
  {
    "id": 19,
    "type": "Param",
    "comment": "@param numRows number of training rows",
    "code": "  private static long computeTrainSamplesPerIteration(final long train_samples_per_iteration, final long numRows, final boolean replicate_training_data, final boolean single_node_mode) {\n    long tspi = train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi >= 1);\n    if (tspi == 0 || (!replicate_training_data && (tspi == -1 || tspi > numRows)) || (replicate_training_data && single_node_mode))\n      Log.info(\"Setting train_samples_per_iteration (\" + tspi + \") to one epoch: #rows (\" + (tspi=numRows) + \").\");\n    else if (tspi == -1 || tspi > H2O.CLOUD.size()*numRows)\n      Log.info(\"Setting train_samples_per_iteration (\" + tspi + \") to the largest possible number: #nodes x #rows (\" + (tspi=H2O.CLOUD.size()*numRows) + \").\");\n    assert(tspi != 0 && tspi != -1 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 20,
    "type": "Param",
    "comment": "@param luminanceBuckets an array of counts of luminance values",
    "code": "  public static int estimate(int[] histogram) {\n\n    int numBuckets = histogram.length;\n\n    // Find tallest peak in histogram\n    int firstPeak = 0;\n    int firstPeakSize = 0;\n    for (int i = 0; i < numBuckets; i++) {\n      if (histogram[i] > firstPeakSize) {\n        firstPeak = i;\n        firstPeakSize = histogram[i];\n      }\n    }\n\n    // Find second-tallest peak -- well, another peak that is tall and not\n    // so close to the first one\n    int secondPeak = 0;\n    int secondPeakScore = 0;\n    for (int i = 0; i < numBuckets; i++) {\n      int distanceToBiggest = i - firstPeak;\n      // Encourage more distant second peaks by multiplying by square of distance\n      int score = histogram[i] * distanceToBiggest * distanceToBiggest;\n      if (score > secondPeakScore) {\n        secondPeak = i;\n        secondPeakScore = score;\n      }\n    }\n\n    // Put firstPeak first\n    if (firstPeak > secondPeak) {\n      int temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    }\n\n    // Find a valley between them that is low and closer to the white peak\n    int bestValley = secondPeak;\n    int bestValleyScore = Integer.MAX_VALUE;\n    for (int i = secondPeak; i > firstPeak; i--) {\n      int distance = secondPeak - i + 3;\n      int score = distance * histogram[i];\n      if (score < bestValleyScore) {\n        bestValley = i;\n        bestValleyScore = score;\n      }\n    }\n\n    return bestValley;\n  }\n",
    "label": 1,
    "rec": "@param histogram an array of counts of luminance values"
  },
  {
    "id": 21,
    "type": "Param",
    "comment": "@param app",
    "code": "    public static ApplicationRepresentation exportApplication(ClientModel app) {\n        ApplicationRepresentation appRep = ModelToRepresentation.toRepresentation(app);\n\n        appRep.setSecret(app.getSecret());\n        return appRep;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 22,
    "type": "Param",
    "comment": "@param userId",
    "code": "    public List<CmsContent> check(short siteId, SysUser user, Serializable[] ids) {\n        List<CmsContent> entityList = new ArrayList<>();\n        for (CmsContent entity : getEntitys(ids)) {\n            if (null != entity && siteId == entity.getSiteId() && STATUS_PEND == entity.getStatus()\n                    && (user.isOwnsAllContent() || entity.getUserId() == user.getId())) {\n                entity.setStatus(STATUS_NORMAL);\n                entity.setCheckUserId(user.getId());\n                entity.setCheckDate(CommonUtils.getDate());\n                entityList.add(entity);\n            }\n        }\n        return entityList;\n    }\n",
    "label": 1,
    "rec": "@param user"
  },
  {
    "id": 23,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean update(KeyCacheObject key, int partId, CacheObject val, GridCacheVersion ver, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, partId, val, ver, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 24,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskInfo info, boolean locCombiner) throws GridException {\n        switch (info.type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input((Comparator<Object>)job.combineGroupComparator());\n                }\n\n            default:\n                return createInput(info);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 25,
    "type": "Param",
    "comment": "@param itemName",
    "code": "\tprivate ExecBindingProvider findFirstMatchingBindingProvider(String itemName, Command command) {\n\t\t\n\t\tExecBindingProvider firstMatchingProvider = null;\n\t\t\n\t\tfor (ExecBindingProvider provider : this.providers) {\n\t\t\t\n\t\t\tString commandLine = provider.getCommandLine(itemName, command);\n\t\t\t\n\t\t\tif (commandLine != null) {\n\t\t\t\tfirstMatchingProvider = provider;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// we didn't find an exact match. probably one configured a fallback\n\t\t// command?\n\t\tif (firstMatchingProvider == null) {\n\t\t\tfor (ExecBindingProvider provider : this.providers) {\n\t\t\t\t\n\t\t\t\tString commandLine = provider.getCommandLine(itemName, WILDCARD_COMMAND_KEY);\n\t\t\t\tif (commandLine != null) {\n\t\t\t\t\tfirstMatchingProvider = provider;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn firstMatchingProvider;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 26,
    "type": "Param",
    "comment": "@param score",
    "code": "  public Double zincrby(final byte[] key, final double increment, final byte[] member) {\n    checkIsInMultiOrPipeline();\n    client.zincrby(key, increment, member);\n    String newscore = client.getBulkReply();\n    return Double.valueOf(newscore);\n  }\n",
    "label": 1,
    "rec": "@param increment"
  },
  {
    "id": 27,
    "type": "Param",
    "comment": "@param parentId Parent ID.",
    "code": "    @Nullable private IgniteUuid softDeleteNonTx(@Nullable IgniteUuid parentId, @Nullable String name, IgniteUuid id)\n        throws GridException {\n        assert validTxState(true);\n\n        IgniteUuid resId;\n\n        if (parentId == null) {\n            // Handle special case when we deleting root directory.\n            assert ROOT_ID.equals(id);\n\n            GridGgfsFileInfo rootInfo = id2InfoPrj.get(ROOT_ID);\n\n            if (rootInfo == null)\n                return null; // Root was never created.\n\n            // Ensure trash directory existence.\n            if (id2InfoPrj.get(TRASH_ID) == null)\n                id2InfoPrj.put(TRASH_ID, new GridGgfsFileInfo(TRASH_ID));\n\n            Map<String, GridGgfsListingEntry> rootListing = rootInfo.listing();\n\n            if (!rootListing.isEmpty()) {\n                IgniteUuid[] lockIds = new IgniteUuid[rootInfo.listing().size()];\n\n                int i = 0;\n\n                for (GridGgfsListingEntry entry : rootInfo.listing().values())\n                    lockIds[i++] = entry.fileId();\n\n                // Lock children IDs in correct order.\n                lockIds(lockIds);\n\n                // Construct new info and move locked entries from root to it.\n                Map<String, GridGgfsListingEntry> transferListing = new HashMap<>();\n\n                transferListing.putAll(rootListing);\n\n                GridGgfsFileInfo newInfo = new GridGgfsFileInfo(transferListing);\n\n                id2InfoPrj.put(newInfo.id(), newInfo);\n\n                // Add new info to trash listing.\n                id2InfoPrj.transform(TRASH_ID, new UpdateListing(newInfo.id().toString(),\n                    new GridGgfsListingEntry(newInfo), false));\n\n                // Remove listing entries from root.\n                for (Map.Entry<String, GridGgfsListingEntry> entry : transferListing.entrySet())\n                    id2InfoPrj.transform(ROOT_ID, new UpdateListing(entry.getKey(), entry.getValue(), true));\n\n                resId = newInfo.id();\n            }\n            else\n                resId = null;\n        }\n        else {\n            // Ensure trash directory existence.\n            if (id2InfoPrj.get(TRASH_ID) == null)\n                id2InfoPrj.put(TRASH_ID, new GridGgfsFileInfo(TRASH_ID));\n\n            moveNonTx(id, name, parentId, id.toString(), TRASH_ID);\n\n            resId = id;\n        }\n\n        return resId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 28,
    "type": "Param",
    "comment": "@param target the target name to write.",
    "code": "\tpublic ManagedOutputStream getOutputStream(String managedFile) throws IOException {\n\t\tif (useReliableFiles) {\n\t\t\tReliableFileOutputStream out = new ReliableFileOutputStream(new File(getBase(), managedFile));\n\t\t\treturn new ManagedOutputStream(out, this, managedFile, null);\n\t\t}\n\t\tFile tmpFile = createTempFile(managedFile);\n\t\treturn new ManagedOutputStream(new FileOutputStream(tmpFile), this, managedFile, tmpFile);\n\t}\n\n",
    "label": 1,
    "rec": "@param managedFile the name of the managed file to write."
  },
  {
    "id": 29,
    "type": "Param",
    "comment": "@param n Node from which affinity is requested.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        CacheAffinityFunction f = (CacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        CacheAffinityKeyMapper m = (CacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(n, cacheName));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 30,
    "type": "Param",
    "comment": "@param resId",
    "code": "    public StyledText foreground(final CharSequence text, final int color) {\n        return append(text, new ForegroundColorSpan(color));\n    }\n",
    "label": 1,
    "rec": "@param color"
  },
  {
    "id": 31,
    "type": "Param",
    "comment": "@param p Partition.",
    "code": "        private boolean preloadEntry(GridNode pick, int p, GridCacheEntryInfo<K, V> entry, long topVer)\n            throws GridException, GridInterruptedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isGgfsDataCache() &&\n                        cctx.dht().ggfsDataSpaceUsed() > cctx.dht().ggfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload GGFS data cache (GGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (GridUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (GridInterruptedException e) {\n                throw e;\n            }\n            catch (GridException e) {\n                throw new GridException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 32,
    "type": "Param",
    "comment": "@param itemName",
    "code": "\tpublic Iterable<Rule> getRules(TriggerTypes triggerType, Item item, Command command) {\n\t\treturn internalGetRules(triggerType, item, command, null);\n\t}\n",
    "label": 1,
    "rec": "@param item"
  },
  {
    "id": 33,
    "type": "Param",
    "comment": "@param keys Keys to lock.",
    "code": "    private List<GridDhtCacheEntry> lockEntries(List<KeyCacheObject> keys, AffinityTopologyVersion topVer)\n        throws GridDhtInvalidPartitionException {\n        if (keys.size() == 1) {\n            KeyCacheObject key = keys.get(0);\n\n            while (true) {\n                try {\n                    GridDhtCacheEntry entry = entryExx(key, topVer);\n\n                    UNSAFE.monitorEnter(entry);\n\n                    if (entry.obsolete())\n                        UNSAFE.monitorExit(entry);\n                    else\n                        return Collections.singletonList(entry);\n                }\n                catch (GridDhtInvalidPartitionException e) {\n                    // Ignore invalid partition exception in CLOCK ordering mode.\n                    if (ctx.config().getAtomicWriteOrderMode() == CLOCK)\n                        return Collections.singletonList(null);\n                    else\n                        throw e;\n                }\n            }\n        }\n        else {\n            List<GridDhtCacheEntry> locked = new ArrayList<>(keys.size());\n\n            while (true) {\n                for (KeyCacheObject key : keys) {\n                    try {\n                        GridDhtCacheEntry entry = entryExx(key, topVer);\n\n                        locked.add(entry);\n                    }\n                    catch (GridDhtInvalidPartitionException e) {\n                        // Ignore invalid partition exception in CLOCK ordering mode.\n                        if (ctx.config().getAtomicWriteOrderMode() == CLOCK)\n                            locked.add(null);\n                        else\n                            throw e;\n                    }\n                }\n\n                boolean retry = false;\n\n                for (int i = 0; i < locked.size(); i++) {\n                    GridCacheMapEntry entry = locked.get(i);\n\n                    if (entry == null)\n                        continue;\n\n                    UNSAFE.monitorEnter(entry);\n\n                    if (entry.obsolete()) {\n                        // Unlock all locked.\n                        for (int j = 0; j <= i; j++) {\n                            if (locked.get(j) != null)\n                                UNSAFE.monitorExit(locked.get(j));\n                        }\n\n                        // Clear entries.\n                        locked.clear();\n\n                        // Retry.\n                        retry = true;\n\n                        break;\n                    }\n                }\n\n                if (!retry)\n                    return locked;\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 34,
    "type": "Param",
    "comment": "@param donorNodeId Donor node id",
    "code": "    private Node getNodeIfPresent(int proxyNodeId) {\n        try {\n            return metadata.getCluster().getNodeById(proxyNodeId);\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to get proxyNode \" + proxyNodeId\n                                         + \" from current cluster \" + metadata.getCluster()\n                                         + \" at node \" + metadata.getNodeId(), e);\n        }\n    }\n",
    "label": 1,
    "rec": "@param proxyNodeId proxy node id"
  },
  {
    "id": 35,
    "type": "Param",
    "comment": "@param timeout the socket timeout to wait for data",
    "code": "\tpublic static String executeUrl(String httpMethod, String url, int timeout, String proxyHost, Integer proxyPort, String proxyUser, String proxyPassword) {\n\t\t\n\t\tHttpClient client = new HttpClient();\n\n\t\t// only configure a proxy if a host is provided\n\t\tif (StringUtils.isNotBlank(proxyHost)) {\n\t\t\tclient.getHostConfiguration().setProxy(proxyHost, proxyPort);\n\t\t\tif (StringUtils.isNotBlank(proxyUser)) {\n\t\t\t\tclient.getState().setProxyCredentials(AuthScope.ANY,\n\t\t\t\t\tnew UsernamePasswordCredentials(proxyUser, proxyPassword));\n\t\t\t}\n\t\t}\n\t\t  \n\t\tHttpMethod method = HttpUtil.createHttpMethod(httpMethod, url);\n\n\t\tmethod.getParams().setSoTimeout(timeout);\n\t\tmethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,\n\t\t\t\tnew DefaultHttpMethodRetryHandler(3, false));\n\n\t\tCredentials credentials = extractCredentials(url);\n\t\tif (credentials != null) {\n\t\t\tclient.getParams().setAuthenticationPreemptive(true); \n\t\t\tclient.getState().setCredentials(AuthScope.ANY, credentials);\t\t\t\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\ttry {\n\t\t\t\tlogger.debug(\"About to execute '\" + method.getURI().toString() + \"'\");\n\t\t\t} catch (URIException e) {\n\t\t\t\tlogger.debug(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\n\t\t\tint statusCode = client.executeMethod(method);\n\n\t\t\tif (statusCode != HttpStatus.SC_OK) {\n\t\t\t\tlogger.warn(\"Method failed: \" + method.getStatusLine());\n\t\t\t}\n\n\t\t\tString responseBody = IOUtils.toString(method.getResponseBodyAsStream());\n\n\t\t\tif (!responseBody.isEmpty()) {\n\t\t\t\tlogger.debug(responseBody);\n\t\t\t}\n\t\t\t\n\t\t\treturn responseBody;\n\t\t}\n\t\tcatch (HttpException he) {\n\t\t\tlogger.error(\"Fatal protocol violation: \", he);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tlogger.error(\"Fatal transport error: {}\", e.toString());\n\t\t}\n\t\tfinally {\n\t\t\tmethod.releaseConnection();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 36,
    "type": "Param",
    "comment": "@param userName",
    "code": "\tpublic boolean removeUser(String userId) {\n\n\t\t//OVERLOADED CODE\n\t\tif (overloadedUsers.containsKey(userId.toLowerCase())) {\n\t\t\toverloadedUsers.remove(userId.toLowerCase());\n\t\t\treturn true;\n\t\t}\n\t\t//END CODE\n\t\tif (getUsers().containsKey(userId.toLowerCase())) {\n\t\t\tgetUsers().remove(userId.toLowerCase());\n\t\t\tsetUsersChanged(true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "label": 1,
    "rec": "@param userId"
  },
  {
    "id": 37,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    public static VisorCacheMetrics from(IgniteEx ignite, String cacheName) {\n        VisorCacheMetrics cm = new VisorCacheMetrics();\n\n        GridCacheProcessor cacheProcessor = ignite.context().cache();\n\n        IgniteCache<Object, Object> c = cacheProcessor.jcache(cacheName);\n\n        cm.name = cacheName;\n        cm.mode = cacheProcessor.cacheMode(cacheName);\n        cm.sys = cacheProcessor.systemCache(cacheName);\n\n        CacheMetrics m = c.metrics();\n\n        cm.size = m.getSize();\n        cm.keySize = m.getKeySize();\n\n        cm.reads = m.getCacheGets();\n        cm.writes = m.getCachePuts() + m.getCacheRemovals();\n        cm.hits = m.getCacheHits();\n        cm.misses = m.getCacheMisses();\n\n        cm.txCommits = m.getCacheTxCommits();\n        cm.txRollbacks = m.getCacheTxRollbacks();\n\n        cm.avgTxCommitTime = m.getAverageTxCommitTime();\n        cm.avgTxRollbackTime = m.getAverageTxRollbackTime();\n\n        cm.puts = m.getCachePuts();\n        cm.removals = m.getCacheRemovals();\n        cm.evictions = m.getCacheEvictions();\n\n        cm.avgReadTime = m.getAverageGetTime();\n        cm.avgPutTime = m.getAveragePutTime();\n        cm.avgRemovalTime = m.getAverageRemoveTime();\n\n        cm.readsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageGetTime());\n        cm.writesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAveragePutTime());\n        cm.hitsPerSec = -1;\n        cm.missesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageRemoveTime());\n        cm.commitsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxCommitTime());\n        cm.rollbacksPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxRollbackTime());\n\n        cm.qryMetrics = VisorCacheQueryMetrics.from(c.queryMetrics());\n\n        cm.dhtEvictQueueCurrSize = m.getDhtEvictQueueCurrentSize();\n        cm.txThreadMapSize = m.getTxThreadMapSize();\n        cm.txXidMapSize = m.getTxXidMapSize();\n        cm.txCommitQueueSize = m.getTxCommitQueueSize();\n        cm.txPrepareQueueSize = m.getTxPrepareQueueSize();\n        cm.txStartVerCountsSize = m.getTxStartVersionCountsSize();\n        cm.txCommittedVersionsSize = m.getTxCommittedVersionsSize();\n        cm.txRolledbackVersionsSize = m.getTxRolledbackVersionsSize();\n        cm.txDhtThreadMapSize = m.getTxDhtThreadMapSize();\n        cm.txDhtXidMapSize = m.getTxDhtXidMapSize();\n        cm.txDhtCommitQueueSize = m.getTxDhtCommitQueueSize();\n        cm.txDhtPrepareQueueSize = m.getTxDhtPrepareQueueSize();\n        cm.txDhtStartVerCountsSize = m.getTxDhtStartVersionCountsSize();\n        cm.txDhtCommittedVersionsSize = m.getTxDhtCommittedVersionsSize();\n        cm.txDhtRolledbackVersionsSize = m.getTxDhtRolledbackVersionsSize();\n\n        return cm;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 38,
    "type": "Param",
    "comment": "@param train_samples_per_iteration user-given train_samples_per_iteration size",
    "code": "  private static long computeTrainSamplesPerIteration(final DeepLearning mp, final long numRows, long model_size) {\n    long tspi = mp.train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi == -2 || tspi >= 1);\n    if (tspi == 0 || (!mp.replicate_training_data && tspi == -1) ) {\n      tspi = numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n    }\n    else if (tspi == -1) {\n      tspi = (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n    } else if (tspi == -2) {\n      // automatic tuning based on CPU speed, network speed and model size\n\n      // measure cpu speed\n      double total_gflops = 0;\n      for (H2ONode h2o : H2O.CLOUD._memary) {\n        HeartBeat hb = h2o._heartbeat;\n        total_gflops += hb._gflops;\n      }\n      if (mp.single_node_mode) total_gflops /= H2O.CLOUD.size();\n      if (total_gflops == 0) {\n        total_gflops = Linpack.run(H2O.SELF._heartbeat._cpus_allowed) * (mp.single_node_mode ? 1 : H2O.CLOUD.size());\n      }\n\n      int[] msg_sizes = new int[]{ (int)(model_size*4) == (model_size*4) ? (int)(model_size*4) : Integer.MAX_VALUE };\n      double[] microseconds_collective = new double[msg_sizes.length];\n      NetworkTest.NetworkTester nt = new NetworkTest.NetworkTester(msg_sizes,null,microseconds_collective,model_size>1e6 ? 1 : 5 /*repeats*/,false,true /*only collectives*/);\n      nt.compute2();\n\n      //length of the network traffic queue based on log-tree rollup (2 log(nodes))\n      int network_queue_length = mp.single_node_mode || H2O.CLOUD.size() == 1? 1 : 2*(int)Math.floor(Math.log(H2O.CLOUD.size())/Math.log(2));\n\n      // heuristics\n      double flops_overhead_per_row = 30;\n      if (mp.activation == Activation.Maxout || mp.activation == Activation.MaxoutWithDropout) {\n        flops_overhead_per_row *= 8;\n      } else if (mp.activation == Activation.Tanh || mp.activation == Activation.TanhWithDropout) {\n        flops_overhead_per_row *= 5;\n      }\n\n      // target fraction of comm vs cpu time: 5%\n      double fraction = mp.single_node_mode || H2O.CLOUD.size() == 1 ? 1e-3 : 0.05; //one single node mode, there's no model averaging effect, so less need to shorten the M/R iteration\n\n      // estimate the time for communication (network) and training (compute)\n      double time_comm_us = (H2O.CLOUD.size() == 1 ? 1e4 /* add 10ms for single-node */ : 0) + network_queue_length * microseconds_collective[0];\n      double time_per_row_us  = flops_overhead_per_row * model_size / (total_gflops * 1e9) / H2O.SELF._heartbeat._cpus_allowed * 1e6;\n\n      // compute the optimal number of training rows per iteration\n      // fraction := time_comm_us / (time_comm_us + tspi * time_per_row_us)  ==>  tspi = (time_comm_us/fraction - time_comm_us)/time_per_row_us\n      tspi = (long)((time_comm_us / fraction - time_comm_us)/ time_per_row_us);\n\n      tspi = Math.max(1, tspi); //at least 1 point\n      tspi = Math.min(tspi, (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows * 10); //not more than 10x of what train_samples_per_iteration=-1 would do\n\n      // If the number is close to a multiple of epochs, use that -> prettier scoring\n      if (tspi > numRows && Math.abs(tspi % numRows)/(double)numRows < 0.2)  tspi = tspi - tspi % numRows;\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows)); //limit to number of epochs desired\n\n      if (!mp.quiet_mode) {\n        Log.info(\"Auto-tuning parameter 'train_samples_per_iteration':\");\n        Log.info(\"Estimated compute power : \" + (int)total_gflops + \" GFlops\");\n        Log.info(\"Estimated time for comm : \" + PrettyPrint.usecs((long)time_comm_us));\n        Log.info(\"Estimated time per row  : \" + ((long)time_per_row_us > 0 ? PrettyPrint.usecs((long)time_per_row_us) : time_per_row_us + \" usecs\"));\n        Log.info(\"Estimated training speed: \" + (int)(1e6/time_per_row_us) + \" rows/sec\");\n        Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to auto-tuned value: \" + tspi);\n      }\n\n    } else {\n      // limit user-given value to number of epochs desired\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows));\n    }\n    assert(tspi != 0 && tspi != -1 && tspi != -2 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 1,
    "rec": "@param mp Model parameter (DeepLearning object)"
  },
  {
    "id": 39,
    "type": "Param",
    "comment": "@param apiGroupName the API Group name like apps.openshift.io or build.openshift.io",
    "code": "  public static OpenShiftConfig withApiGroup(OkHttpClient httpClient, String apiGroupName, OpenShiftConfig config) {\n    OpenShiftClient openShiftClient = new DefaultOpenShiftClient(httpClient, config);\n    return withApiGroup(openShiftClient, apiGroupName, config);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 40,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    public static boolean hasStreamer(Ignite ignite, String name) {\n        if (ignite.configuration().getStreamerConfiguration() != null) {\n            for (GridStreamerConfiguration cfg : ignite.configuration().getStreamerConfiguration()) {\n                if (name.equals(cfg.getName()))\n                    return true;\n            }\n        }\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 41,
    "type": "Param",
    "comment": "@param dhtNodeId DHT node ID.",
    "code": "    @Nullable private GridCacheMvccCandidate addEntry(long topVer, GridNearCacheEntry entry, UUID dhtNodeId)\n        throws GridCacheEntryRemovedException {\n        // Check if lock acquisition is timed out.\n        if (timedOut)\n            return null;\n\n        // Add local lock first, as it may throw GridCacheEntryRemovedException.\n        GridCacheMvccCandidate c = entry.addNearLocal(\n            dhtNodeId,\n            threadId,\n            lockVer,\n            timeout,\n            !inTx(),\n            inTx(),\n            implicitSingleTx()\n        );\n\n        if (inTx()) {\n            IgniteTxEntry txEntry = tx.entry(entry.txKey());\n\n            txEntry.cached(entry, null);\n        }\n\n        if (c != null)\n            c.topologyVersion(topVer);\n\n        synchronized (mux) {\n            entries.add(entry);\n        }\n\n        if (c == null && timeout < 0) {\n            if (log.isDebugEnabled())\n                log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n\n            onFailed(false);\n\n            return null;\n        }\n\n        // Double check if lock acquisition has already timed out.\n        if (timedOut) {\n            entry.removeLock(lockVer);\n\n            return null;\n        }\n\n        return c;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 42,
    "type": "Param",
    "comment": "@param cls Map class.",
    "code": "    private Map readMap0(@Nullable BinaryMapFactory factory) throws BinaryObjectException {\n        switch (checkFlag(MAP)) {\n            case NORMAL:\n                return (Map)PortableUtils.doReadMap(in, ctx, ldr, this, true, factory);\n\n            case HANDLE: {\n                int handlePos = PortableUtils.positionForHandle(in) - in.readInt();\n\n                Object obj = getHandle(handlePos);\n\n                if (obj == null) {\n                    int retPos = in.position();\n\n                    streamPosition(handlePos);\n\n                    obj = readMap0(factory);\n\n                    streamPosition(retPos);\n                }\n\n                return (Map)obj;\n            }\n\n            default:\n                return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param factory Factory."
  },
  {
    "id": 43,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public boolean onUnswap(KeyCacheObject key, CacheObject val) throws IgniteCheckedException {\n        assert val != null : \"Key=\" + key;\n\n        return onSwapUnswap(key, val);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 44,
    "type": "Param",
    "comment": "@param storeName List of all read-only stores",
    "code": "    public long getROGlobalMaxVersion(String storeName) {\n        long maxVersionId = 0L;\n        for(Node node: currentCluster.getNodes()) {\n            long currentNodeVersion = getROMaxVersion(node.getId(), storeName);\n            if(currentNodeVersion > maxVersionId) {\n                maxVersionId = currentNodeVersion;\n            }\n        }\n        return maxVersionId;\n    }\n\n",
    "label": 1,
    "rec": "@param storeName The name of the read-only store"
  },
  {
    "id": 45,
    "type": "Param",
    "comment": "@param ccfg Cache configuration.",
    "code": "    public VisorCacheConfiguration from(Ignite ignite, CacheConfiguration ccfg) {\n        name = ccfg.getName();\n        mode = ccfg.getCacheMode();\n        atomicityMode = ccfg.getAtomicityMode();\n        atomicWriteOrderMode = ccfg.getAtomicWriteOrderMode();\n        eagerTtl = ccfg.isEagerTtl();\n        writeSynchronizationMode = ccfg.getWriteSynchronizationMode();\n        swapEnabled = ccfg.isSwapEnabled();\n        invalidate = ccfg.isInvalidate();\n        startSize = ccfg.getStartSize();\n        tmLookupClsName = ccfg.getTransactionManagerLookupClassName();\n        offHeapMaxMemory = ccfg.getOffHeapMaxMemory();\n        maxConcurrentAsyncOps = ccfg.getMaxConcurrentAsyncOperations();\n        memoryMode = ccfg.getMemoryMode();\n        interceptor = compactClass(ccfg.getInterceptor());\n        typeMeta = VisorCacheTypeMetadata.list(ccfg.getTypeMetadata());\n        statisticsEnabled = ccfg.isStatisticsEnabled();\n        mgmtEnabled = ccfg.isManagementEnabled();\n        ldrFactory = compactClass(ccfg.getCacheLoaderFactory());\n        writerFactory = compactClass(ccfg.getCacheWriterFactory());\n        expiryPlcFactory = compactClass(ccfg.getExpiryPolicyFactory());\n\n        affinityCfg = VisorCacheAffinityConfiguration.from(ccfg);\n        rebalanceCfg = VisorCacheRebalanceConfiguration.from(ccfg);\n        evictCfg = VisorCacheEvictionConfiguration.from(ccfg);\n        nearCfg = VisorCacheNearConfiguration.from(ccfg);\n        dfltCfg = VisorCacheDefaultConfiguration.from(ccfg);\n        storeCfg = VisorCacheStoreConfiguration.from(ignite, ccfg);\n        qryCfg = VisorCacheQueryConfiguration.from(ccfg);\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 46,
    "type": "Param",
    "comment": "@param pathStr String representing path to the property. May contains dots '.' to identify nested fields.",
    "code": "    private static ClassProperty buildClassProperty(Class<?> keyCls, Class<?> valCls, String pathStr, Class<?> resType)\n        throws IgniteCheckedException {\n        ClassProperty res = buildClassProperty(true, keyCls, pathStr, resType);\n\n        if (res == null) // We check key before value consistently with PortableProperty.\n            res = buildClassProperty(false, valCls, pathStr, resType);\n\n        if (res == null)\n            throw new IgniteCheckedException(\"Failed to initialize property '\" + pathStr + \"' for \" +\n                \"key class '\" + keyCls + \"' and value class '\" + valCls + \"'. \" +\n                \"Make sure that one of these classes contains respective getter method or field.\");\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param pathStr Path string."
  },
  {
    "id": 47,
    "type": "Param",
    "comment": "@param commandLine the complete command line including command name and arguments",
    "code": "    public boolean dispatchCommand(CommandSender sender, String commandLine, List<String> tabResults)\n    {\n        String[] split = argsSplit.split( commandLine );\n        // Check for chat that only contains \" \"\n        if ( split.length == 0 )\n        {\n            return false;\n        }\n\n        String commandName = split[0].toLowerCase();\n        if ( proxy.getDisabledCommands().contains( commandName ) )\n        {\n            return false;\n        }\n        Command command = commandMap.get( commandName );\n        if ( command == null )\n        {\n            return false;\n        }\n\n        String permission = command.getPermission();\n        if ( permission != null && !permission.isEmpty() && !sender.hasPermission( permission ) )\n        {\n            sender.sendMessage( proxy.getTranslation( \"no_permission\" ) );\n            return true;\n        }\n\n        String[] args = Arrays.copyOfRange( split, 1, split.length );\n        try\n        {\n            if ( tabResults == null )\n            {\n                command.execute( sender, args );\n            } else if ( command instanceof TabExecutor )\n            {\n                tabResults.addAll( ( (TabExecutor) command ).onTabComplete( sender, args ) );\n            }\n        } catch ( Exception ex )\n        {\n            sender.sendMessage( ChatColor.RED + \"An internal error occurred whilst executing this command, please check the console log for details.\" );\n            ProxyServer.getInstance().getLogger().log( Level.WARNING, \"Error in dispatching command\", ex );\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 48,
    "type": "Param",
    "comment": "@param wsResultVector The result vector to fetch an action from",
    "code": "    public static List fetchAllActionResults(\n        List resultList,\n        int action, \n        List actionResultList\n    ) {\n        for (int i = 0; i < resultList.size(); i++) {\n            //\n            // Check the result of every action whether it matches the given action\n            //\n            WSSecurityEngineResult result = \n                (WSSecurityEngineResult) resultList.get(i);\n            int resultAction = \n                ((java.lang.Integer)result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n            if (resultAction == action) {\n                actionResultList.add(result);\n            }\n        }\n        return actionResultList;\n    }\n\n",
    "label": 1,
    "rec": "@param resultList The result list to fetch an action from"
  },
  {
    "id": 49,
    "type": "Param",
    "comment": "@param authentication the authentication of the current user, to be retrieved when the code is consumed",
    "code": "\tpublic String createAuthorizationCode(OAuth2Authentication authentication) {\n\t\tString code = generator.generate();\n\t\t\n\t\tAuthorizationCodeEntity entity = new AuthorizationCodeEntity(code, authentication);\n\t\trepository.save(entity);\n\t\t\n\t\treturn code;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 50,
    "type": "Param",
    "comment": "@param sUrl , input string",
    "code": "    public static String urlDecode(String stringToEncode) {\n        try {\n            return URLDecoder.decode(stringToEncode, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param stringToEncode , input string"
  },
  {
    "id": 51,
    "type": "Param",
    "comment": "@param entry Preloaded entry.",
    "code": "        private boolean preloadEntry(ClusterNode pick, int p, GridCacheEntryInfo<K, V> entry, AffinityTopologyVersion topVer)\n            throws IgniteCheckedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isIgfsDataCache() &&\n                        cctx.dht().igfsDataSpaceUsed() > cctx.dht().igfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload IGFS data cache (IGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (IgniteUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false, null, null, null);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (IgniteInterruptedCheckedException e) {\n                throw e;\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteCheckedException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 52,
    "type": "Param",
    "comment": "@param size Size.",
    "code": "    public IgniteConfiguration setRebalanceThreadPoolSize(int rebalanceThreadPoolSize) {\n        this.rebalanceThreadPoolSize = rebalanceThreadPoolSize;\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param rebalanceThreadPoolSize Number of system threads that will be assigned for partition transfer during rebalancing."
  },
  {
    "id": 53,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    private GridDhtLocalPartition localPartition(int p, AffinityTopologyVersion topVer, boolean create, boolean updateSeq) {\n        while (true) {\n            boolean belongs = cctx.affinity().localNode(p, topVer);\n\n            GridDhtLocalPartition loc = locParts.get(p);\n\n            if (loc != null && loc.state() == EVICTED) {\n                locParts.remove(p, loc);\n\n                if (!create)\n                    return null;\n\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Adding entry to evicted partition [part=\" + p +\n                        \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n\n                continue;\n            }\n\n            if (loc == null && create) {\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Creating partition which does not belong [part=\" +\n                        p + \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n\n                lock.writeLock().lock();\n\n                try {\n                    GridDhtLocalPartition old = locParts.putIfAbsent(p,\n                        loc = new GridDhtLocalPartition(cctx, p));\n\n                    if (old != null)\n                        loc = old;\n                    else {\n                        if (updateSeq)\n                            this.updateSeq.incrementAndGet();\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"Created local partition: \" + loc);\n                    }\n                }\n                finally {\n                    lock.writeLock().unlock();\n                }\n            }\n\n            return loc;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 54,
    "type": "Param",
    "comment": "@param cacheName Cache name.",
    "code": "    public static VisorCache from(Ignite ignite, GridCache c, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param c Actual cache."
  },
  {
    "id": 55,
    "type": "Param",
    "comment": "@param pX",
    "code": "    private String createImageFile(TempDir tempDir, double[] pVals, String pName, String pX, String pY) throws IOException {\n        XYSeries series = new XYSeries(pName);\n        for (int i = 0; i < mN; i++) {\n            series.add(i, pVals[i]);\n        }\n        XYSeriesCollection dataSet = new XYSeriesCollection();\n        dataSet.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createXYLineChart(\n                pName,\n                pX,\n                pY,\n                dataSet,\n                PlotOrientation.VERTICAL,\n                true,\n                false,\n                false);\n        XYPlot plot = (XYPlot) chart.getPlot();\n        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();\n        renderer.setSeriesLinesVisible(0, false);\n        renderer.setSeriesShapesVisible(0, true);\n        renderer.setSeriesShape(0, new java.awt.geom.Ellipse2D.Double(0, 0, 1, 1));\n        plot.setBackgroundPaint(java.awt.Color.WHITE);\n        plot.setDomainGridlinePaint(java.awt.Color.GRAY);\n        plot.setRangeGridlinePaint(java.awt.Color.GRAY);\n        plot.setRenderer(renderer);\n\n        String imageFile = \"\";\n\n        ChartRenderingInfo info = new ChartRenderingInfo(new StandardEntityCollection());\n        String fileName = pY + \".png\";\n        File file1 = tempDir.createFile(fileName);\n        imageFile = \"<IMG SRC=\\\"file:\" + file1.getAbsolutePath() + \"\\\" \" + \"WIDTH=\\\"600\\\" HEIGHT=\\\"400\\\" BORDER=\\\"0\\\" USEMAP=\\\"#chart\\\"></IMG>\";\n\n        ChartUtilities.saveChartAsPNG(file1, chart, 600, 400, info);\n\n        return imageFile;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 56,
    "type": "Param",
    "comment": "@param prj Projection to guard.",
    "code": "    @Nullable public CacheOperationContext enter(@Nullable CacheOperationContext opCtx) {\n        try {\n            GridCacheAdapter<K, V> cache = ctx.cache();\n\n            GridCachePreloader<K, V> preldr = cache != null ? cache.preloader() : null;\n\n            if (preldr == null)\n                throw new IllegalStateException(\"Grid is in invalid state to perform this operation. \" +\n                    \"It either not started yet or has already being or have stopped [gridName=\" + ctx.gridName() + ']');\n\n            preldr.startFuture().get();\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(\"Failed to wait for cache preloader start [cacheName=\" +\n                ctx.name() + \"]\", e);\n        }\n\n        onEnter();\n\n        rwLock.readLock();\n\n        if (stopped) {\n            rwLock.readUnlock();\n\n            throw new IllegalStateException(\"Cache has been stopped: \" + ctx.name());\n        }\n\n        // Must unlock in case of unexpected errors to avoid\n        // deadlocks during kernal stop.\n        try {\n            return setOperationContextPerCall(opCtx);\n        }\n        catch (RuntimeException e) {\n            rwLock.readUnlock();\n\n            throw e;\n        }\n    }\n",
    "label": 1,
    "rec": "@param opCtx Cache operation context to guard."
  },
  {
    "id": 57,
    "type": "Param",
    "comment": "@param dep Deployment.",
    "code": "    @Nullable private ClusterNode cacheAffinityNode(GridDeployment dep, ComputeJob job, Collection<ClusterNode> nodes)\n        throws GridException {\n        assert dep != null;\n        assert job != null;\n        assert nodes != null;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Looking for cache affinity node [job=\" + job + \"]\");\n\n        Object key = dep.annotatedValue(job, GridCacheAffinityKeyMapped.class);\n\n        if (key == null)\n            return null;\n\n        String cacheName = (String)dep.annotatedValue(job, GridCacheName.class);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Affinity properties [key=\" + key + \", cacheName=\" + cacheName + \"]\");\n\n        try {\n            ClusterNode node = ctx.affinity().mapKeyToNode(cacheName, key);\n\n            if (node == null)\n                throw new GridException(\"Failed to map key to node (is cache with given name started?) [gridName=\" +\n                    ctx.gridName() + \", key=\" + key + \", cacheName=\" + cacheName +\n                    \", nodes=\" + U.toShortString(nodes) + ']');\n\n            if (!nodes.contains(node))\n                throw new GridException(\"Failed to map key to node (projection nodes do not contain affinity node) \" +\n                    \"[gridName=\" + ctx.gridName() + \", key=\" + key + \", cacheName=\" + cacheName +\n                    \", nodes=\" + U.toShortString(nodes) + \", node=\" + U.toShortString(node) + ']');\n\n            return node;\n        }\n        catch (GridException e) {\n            throw new GridException(\"Failed to map affinity key to node for job [gridName=\" + ctx.gridName() +\n                \", job=\" + job + ']', e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 58,
    "type": "Param",
    "comment": "@param child the child",
    "code": "    public static String makePath(String parent, String... children)\n    {\n        StringBuilder path = new StringBuilder();\n\n        // Add parent piece, with no trailing slash.\n        if ( (parent != null) && (parent.length() > 0) )\n        {\n            if ( !parent.startsWith(PATH_SEPARATOR) )\n            {\n                path.append(PATH_SEPARATOR);\n            }\n            if ( parent.endsWith(PATH_SEPARATOR) )\n            {\n                path.append(parent.substring(0, parent.length() - 1));\n            }\n            else\n            {\n                path.append(parent);\n            }\n        }\n\n        if (children == null || children.length == 0)\n        {\n            // Special case, empty parent and child\n            if ( path.length() == 0 )\n            {\n                return PATH_SEPARATOR;\n            }\n            return path.toString();\n        }\n\n        for (String child : children)\n        {\n            if ( (child == null) || (child.length() == 0) || (child.equals(PATH_SEPARATOR)) )\n            {\n                // Special case, empty parent and child\n                if ( path.length() == 0 )\n                {\n                    path.append(PATH_SEPARATOR);\n                }\n\n                continue;\n            }\n\n            // Now add the separator between parent and child.\n            path.append(PATH_SEPARATOR);\n\n            if ( child.startsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(1);\n            }\n\n            if ( child.endsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(0, child.length() - 1);\n            }\n\n            // Finally, add the child.\n            path.append(child);\n        }\n\n        return path.toString();\n    }\n",
    "label": 1,
    "rec": "@param children the children"
  },
  {
    "id": 59,
    "type": "Param",
    "comment": "@param ldr Class loader.",
    "code": "    private boolean undeploy(ClassLoader ldr, GridCacheEntryEx e, GridCacheAdapter cache) {\n        KeyCacheObject key = e.key();\n\n        GridCacheEntryEx entry = cache.peekEx(key);\n\n        if (entry == null)\n            return false;\n\n        Object key0;\n        Object val0;\n\n        try {\n            CacheObject v = entry.peek(GridCachePeekMode.GLOBAL, CU.empty0());\n\n            key0 = key.value(cache.context().cacheObjectContext(), false);\n\n            assert key0 != null : \"Key cannot be null for cache entry: \" + e;\n\n            val0 = CU.value(v, cache.context(), false);\n        }\n        catch (GridCacheEntryRemovedException ignore) {\n            return false;\n        }\n        catch (IgniteException ignore) {\n            // Peek can throw runtime exception if unmarshalling failed.\n            return true;\n        }\n\n        ClassLoader keyLdr = U.detectObjectClassLoader(key0);\n        ClassLoader valLdr = U.detectObjectClassLoader(val0);\n\n        boolean res = F.eq(ldr, keyLdr) || F.eq(ldr, valLdr);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Finished examining entry [entryCls=\" + e.getClass() +\n                \", key=\" + key0 + \", keyCls=\" + key0.getClass() +\n                \", valCls=\" + (val0 != null ? val0.getClass() : \"null\") +\n                \", keyLdr=\" + keyLdr + \", valLdr=\" + valLdr + \", res=\" + res + ']');\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 60,
    "type": "Param",
    "comment": "@param searchedEntryName The content to be checked",
    "code": "    public static boolean hasEntry(File file, String entryName)\n            throws IOException {\n        List<String> elements = getEntryNames(file);\n        return elements.contains(entryName);\n    }\n\n",
    "label": 1,
    "rec": "@param entryName The content to be checked"
  },
  {
    "id": 61,
    "type": "Param",
    "comment": "@param site",
    "code": "    public List<ConfigInfo> getConfigList(SysSite site, Locale locale, boolean showAll) {\n        List<ConfigInfo> configList = new ArrayList<>();\n        List<String> configCodeList = new ArrayList<>();\n        if (CommonUtils.notEmpty(configPluginList)) {\n            for (Config config : configPluginList) {\n                String code = config.getCode(site, showAll);\n                if (CommonUtils.notEmpty(code) && !configCodeList.contains(code)) {\n                    configList.add(new ConfigInfo(code, config.getCodeDescription(locale)));\n                    configCodeList.add(code);\n                }\n            }\n        }\n        for (Entry<String, SysConfig> entry : getMap(site).entrySet()) {\n            if (!configCodeList.contains(entry.getKey())) {\n                ConfigInfo configInfo = new ConfigInfo(entry.getKey(), entry.getValue().getDescription());\n                configInfo.setCustomed(true);\n                configList.add(configInfo);\n                configCodeList.add(entry.getKey());\n            }\n        }\n        return configList;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 62,
    "type": "Param",
    "comment": "@param idpInitiatedURI",
    "code": "    public SAMLDocumentHolder idpInitiatedLogin(UserRepresentation user, Binding expectedResponseBinding, boolean consentRequired, boolean consent) {\n        return getSamlResponse(expectedResponseBinding, (client, context, strategy) -> {\n            HttpGet get = new HttpGet(samlEndpoint);\n            CloseableHttpResponse response = client.execute(get);\n            assertThat(response, statusCodeIsHC(Response.Status.OK));\n\n            String loginPageText = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n            response.close();\n\n            assertThat(loginPageText, containsString(\"login\"));\n\n            HttpUriRequest loginRequest = handleLoginPage(user, loginPageText);\n\n            if (consentRequired) {\n                // Client requires consent\n                response = client.execute(loginRequest, context);\n                String consentPageText = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n                loginRequest = handleConsentPage(consentPageText, consent);\n            }\n\n            strategy.setRedirectable(false);\n            return client.execute(loginRequest, context);\n        });\n    }\n",
    "label": 1,
    "rec": "@param samlEndpoint"
  },
  {
    "id": 63,
    "type": "Param",
    "comment": "@param path Path.",
    "code": "    private static boolean startsWith(IgniteFsPath path, IgniteFsPath prefix) {\n        List<String> p1Comps = path.components();\n        List<String> p2Comps = prefix.components();\n\n        if (p2Comps.size() > p1Comps.size())\n            return false;\n\n        for (int i = 0; i < p1Comps.size(); i++) {\n            if (i >= p2Comps.size() || p2Comps.get(i) == null)\n                // All prefix components already matched.\n                return true;\n\n            if (!p1Comps.get(i).equals(p2Comps.get(i)))\n                return false;\n        }\n\n        // Path and prefix components had same length and all of them matched.\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 64,
    "type": "Param",
    "comment": "@param nt2 another node type",
    "code": "    public float getHorizontalSpacing(final NodeType t1, final NodeType t2) {\n        return nodeTypeSpacings[t1.ordinal()][t2.ordinal()];\n    }\n\n",
    "label": 1,
    "rec": "@param t2 the type of the other node"
  },
  {
    "id": 65,
    "type": "Param",
    "comment": "@param key the key of the element to return.",
    "code": "    public V get(K key) throws CacheException {\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Getting object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\n            }\n            if (key == null) {\n                return null;\n            } else {\n                Element element = cache.get(key);\n                if (element == null) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Element for [\" + key + \"] is null.\");\n                    }\n                    return null;\n                } else {\n                    //noinspection unchecked\n                    return (V) element.getObjectValue();\n                }\n            }\n        } catch (Throwable t) {\n            throw new CacheException(t);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 66,
    "type": "Param",
    "comment": "@param delete If lock ID is required for file deletion.",
    "code": "    private IgniteUuid createFileLockId(boolean del) {\n        if (del)\n            return IgfsUtils.DELETE_LOCK_ID;\n\n        return IgniteUuid.fromUuid(locNode.id());\n    }\n",
    "label": 1,
    "rec": "@param del If lock ID is required for file deletion."
  },
  {
    "id": 67,
    "type": "Param",
    "comment": "@param metricsPublisher Implementation of  HystrixMetricsPublisher to use.  See  HystrixMetricsPublisher class header JavaDocs for precedence of how this is retrieved.",
    "code": "    public static HystrixMetricsPublisherThreadPool createOrRetrievePublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {\n        // attempt to retrieve from cache first\n        HystrixMetricsPublisherThreadPool publisher = threadPoolPublishers.get(threadPoolKey.name());\n        if (publisher != null) {\n            return publisher;\n        }\n        // it doesn't exist so we need to create it\n        publisher = HystrixPlugins.getInstance().getMetricsPublisher().getMetricsPublisherForThreadPool(threadPoolKey, metrics, properties);\n        // attempt to store it (race other threads)\n        HystrixMetricsPublisherThreadPool existing = threadPoolPublishers.putIfAbsent(threadPoolKey.name(), publisher);\n        if (existing == null) {\n            // we won the thread-race to store the instance we created so initialize it\n            publisher.initialize();\n            // done registering, return instance that got cached\n            return publisher;\n        } else {\n            // we lost so return 'existing' and let the one we created be garbage collected\n            // without calling initialize() on it\n            return existing;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 68,
    "type": "Param",
    "comment": "@param dataSet",
    "code": "\tpublic static ReportTable generate(Queryer queryer, ReportParameter parameter) {\n\t\treturn generate(getDataSet(queryer, parameter), parameter);\n\t}\n",
    "label": 1,
    "rec": "@param queryer"
  },
  {
    "id": 69,
    "type": "Param",
    "comment": "@param uri GAR file deployment URI.",
    "code": "    private static GridUriDeploymentFileProcessorResult processNoDescriptorFile(File file, String uri, IgniteLogger log)\n        throws GridSpiException {\n        ClassLoader clsLdr = GridUriDeploymentClassLoaderFactory.create(U.gridClassLoader(), file, log);\n\n        Set<Class<? extends ComputeTask<?, ?>>> clss = GridUriDeploymentDiscovery.getClasses(clsLdr, file);\n\n        GridUriDeploymentFileProcessorResult res = new GridUriDeploymentFileProcessorResult();\n\n        res.setFile(file);\n        res.setClassLoader(clsLdr);\n\n        if (clss != null) {\n            List<Class<? extends ComputeTask<?, ?>>> validTasks =\n                new ArrayList<>(clss.size());\n\n            for (Class<? extends ComputeTask<?, ?>> cls : clss) {\n                if (isAllowedTaskClass(cls)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Found grid deployment task: \" + cls.getName());\n\n                    validTasks.add(cls);\n                }\n            }\n\n            if (!validTasks.isEmpty())\n                res.setTaskClasses(validTasks);\n            else if (log.isDebugEnabled())\n                log.debug(\"No tasks loaded from file [file=\" + file.getAbsolutePath() +\n                    \", uri=\" + U.hidePassword(uri) + ']');\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 70,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public CacheObject applyEntryProcessors(CacheObject cacheVal) {\n        Object key = CU.value(this.key, ctx, false);\n        Object val = CU.value(cacheVal, ctx, false);\n\n        for (T2<EntryProcessor<Object, Object, Object>, Object[]> t : entryProcessors()) {\n            try {\n                CacheInvokeEntry<Object, Object> invokeEntry = new CacheInvokeEntry<>(ctx, key, val);\n\n                EntryProcessor processor = t.get1();\n\n                processor.process(invokeEntry, t.get2());\n\n                val = invokeEntry.getValue();\n            }\n            catch (Exception ignore) {\n                // No-op.\n            }\n        }\n\n        return ctx.toCacheObject(val);\n// TODO IGNITE-51\n//        if (ctx.portableEnabled())\n//            val = (V)ctx.marshalToPortable(val);\n//\n//        return val;\n    }\n",
    "label": 1,
    "rec": "@param cacheVal Value."
  },
  {
    "id": 71,
    "type": "Param",
    "comment": "@param e Event",
    "code": "        private boolean filterByTaskSessionId(GridEvent e, IgniteUuid taskSessionId) {\n            if (e.getClass().equals(GridTaskEvent.class)) {\n                GridTaskEvent te = (GridTaskEvent)e;\n\n                return te.taskSessionId().equals(taskSessionId);\n            }\n\n            if (e.getClass().equals(GridJobEvent.class)) {\n                GridJobEvent je = (GridJobEvent)e;\n\n                return je.taskSessionId().equals(taskSessionId);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 72,
    "type": "Param",
    "comment": "@param additionalData additional data",
    "code": "  private byte[] decrypt(ByteBuffer ciphertext, final byte[] associatedData)\n      throws GeneralSecurityException {\n    if (ciphertext.remaining() < snuffle.nonceSizeInBytes() + MAC_TAG_SIZE_IN_BYTES) {\n      throw new GeneralSecurityException(\"ciphertext too short\");\n    }\n    int firstPosition = ciphertext.position();\n    byte[] tag = new byte[MAC_TAG_SIZE_IN_BYTES];\n    ciphertext.position(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);\n    ciphertext.get(tag);\n    // rewind to read ciphertext and compute tag.\n    ciphertext.position(firstPosition);\n    ciphertext.limit(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);\n    byte[] nonce = new byte[snuffle.nonceSizeInBytes()];\n    ciphertext.get(nonce);\n    byte[] aad = associatedData;\n    if (aad == null) {\n      aad = new byte[0];\n    }\n    try {\n      Poly1305.verifyMac(getMacKey(nonce), macDataRfc7539(aad, ciphertext), tag);\n    } catch (GeneralSecurityException ex) {\n      throw new AEADBadTagException(ex.toString());\n    }\n\n    // rewind to decrypt the ciphertext.\n    ciphertext.position(firstPosition);\n    return snuffle.decrypt(ciphertext);\n  }\n",
    "label": 1,
    "rec": "@param associatedData associated authenticated data"
  },
  {
    "id": 73,
    "type": "Param",
    "comment": "@param primary If  true includes primary entries.",
    "code": "    public int swapEntriesCount(boolean primary, boolean backup, AffinityTopologyVersion topVer) throws IgniteCheckedException {\n        assert primary || backup;\n\n        if (!swapEnabled)\n            return 0;\n\n        if (!(primary && backup)) {\n            Set<Integer> parts = primary ? cctx.affinity().primaryPartitions(cctx.localNodeId(), topVer) :\n                cctx.affinity().backupPartitions(cctx.localNodeId(), topVer);\n\n            return (int)swapMgr.swapKeys(spaceName, parts);\n        }\n        else\n            return (int)swapMgr.swapKeys(spaceName);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 74,
    "type": "Param",
    "comment": "@param info Task info.",
    "code": "    private GridHadoopTaskOutput createOutput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case REDUCE:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case MAP:\n                if (locCombiner) {\n                    assert local == null;\n\n                    local = get(job.info(), SHUFFLE_COMBINER_NO_SORTING, false) ?\n                        new GridHadoopHashMultimap(job, mem, get(job.info(), COMBINER_HASHMAP_SIZE, 8 * 1024)):\n                        new GridHadoopSkipList(job, mem, ctx.sortComparator()); // TODO replace with red-black tree\n\n                    return local.startAdding(ctx);\n                }\n\n            default:\n                return createOutput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param ctx Task info."
  },
  {
    "id": 75,
    "type": "Param",
    "comment": "@param authority Authority.",
    "code": "    private static Configuration configuration(String authority, boolean tcp) {\n        Configuration cfg = new Configuration();\n\n        cfg.set(\"fs.defaultFS\", \"igfs://\" + authority + \"/\");\n        cfg.set(\"fs.igfs.impl\", org.apache.ignite.hadoop.fs.v1.IgniteHadoopFileSystem.class.getName());\n        cfg.set(\"fs.AbstractFileSystem.igfs.impl\",\n            IgniteHadoopFileSystem.class.getName());\n\n        cfg.setBoolean(\"fs.igfs.impl.disable.cache\", true);\n\n        if (tcp)\n            cfg.setBoolean(String.format(PARAM_IGFS_ENDPOINT_NO_EMBED, authority), true);\n        else\n            cfg.setBoolean(String.format(PARAM_IGFS_ENDPOINT_NO_LOCAL_TCP, authority), true);\n\n        cfg.setBoolean(String.format(PARAM_IGFS_ENDPOINT_NO_LOCAL_SHMEM, authority), true);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 76,
    "type": "Param",
    "comment": "@param mini_batch number of training rows to be processed per iteration",
    "code": "  private static float computeRowUsageFraction(final long numRows, long train_samples_per_iteration, boolean replicate_training_data) {\n    float rowUsageFraction = (float)train_samples_per_iteration / numRows;\n    if (replicate_training_data) rowUsageFraction /= H2O.CLOUD.size();\n    assert(rowUsageFraction > 0 && rowUsageFraction <= 1.);\n    return rowUsageFraction;\n  }\n",
    "label": 1,
    "rec": "@param train_samples_per_iteration number of training rows to be processed per iteration"
  },
  {
    "id": 77,
    "type": "Param",
    "comment": "@param ccfg Cache configuration.",
    "code": "    public static VisorCacheAffinityConfiguration from(CacheConfiguration ccfg) {\n        GridCacheAffinityFunction aff = ccfg.getAffinity();\n\n        Integer dfltReplicas = null;\n        Boolean excludeNeighbors = null;\n\n        if (aff instanceof GridCacheConsistentHashAffinityFunction) {\n            GridCacheConsistentHashAffinityFunction hashAffFunc = (GridCacheConsistentHashAffinityFunction)aff;\n\n            dfltReplicas = hashAffFunc.getDefaultReplicas();\n            excludeNeighbors = hashAffFunc.isExcludeNeighbors();\n        }\n\n        VisorCacheAffinityConfiguration cfg = new VisorCacheAffinityConfiguration();\n\n        cfg.function(compactClass(aff));\n        cfg.mapper(compactClass(ccfg.getAffinityMapper()));\n        cfg.partitionedBackups(ccfg.getBackups());\n        cfg.defaultReplicas(dfltReplicas);\n        cfg.excludeNeighbors(excludeNeighbors);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 78,
    "type": "Param",
    "comment": "@param ds",
    "code": "\tpublic static ReportDataSet getDataSet(Queryer queryer, ReportParameter parameter) {\n\t\treturn new DataExecutor(queryer, parameter).execute();\n\t}\n",
    "label": 1,
    "rec": "@param queryer"
  },
  {
    "id": 79,
    "type": "Param",
    "comment": "@param model",
    "code": "    public String delete(String id, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        SysSite site = getSite(request);\n        if (ControllerUtils.verifyCustom(\"noright\", !siteComponent.isMaster(site.getId()), model)\n                || ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysModule entity = service.getEntity(id);\n        if (null != entity) {\n            service.delete(id);\n            @SuppressWarnings(\"unchecked\")\n            List<SysRoleModule> roleModuleList = (List<SysRoleModule>) roleModuleService.getPage(null, id, null, null).getList();\n            roleModuleService.deleteByModuleId(id);\n            dealRoleAuthorized(roleModuleList);\n            logOperateService.save(new LogOperate(getSite(request).getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.module\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 80,
    "type": "Param",
    "comment": "@param select",
    "code": "    public List<String> getTableList(Statement statement) {\n        init();\n        statement.accept(this);\n        return tables;\n    }\n",
    "label": 1,
    "rec": "@param delete"
  },
  {
    "id": 81,
    "type": "Param",
    "comment": "@param pageSize",
    "code": "    public PageHandler getPage(String hql, Map<String, Object> parameters, Integer pageIndex, Integer pageSize) {\n        return dao.getPage(hql, parameters, pageIndex, pageSize);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 82,
    "type": "Param",
    "comment": "@param rootIds Root page IDs.",
    "code": "    protected ReuseList createReuseList(int cacheId, PageMemory pageMem, long rootId, boolean initNew)\n        throws IgniteCheckedException {\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param rootId Root page ID."
  },
  {
    "id": 83,
    "type": "Param",
    "comment": "@param writer Writer.",
    "code": "    private boolean writeHeader(Object obj, BinaryWriterExImpl writer) {\n        if (writer.tryWriteAsHandle(obj))\n            return false;\n\n        PortableUtils.writeHeader(\n            writer,\n            userType,\n            registered ? typeId : GridPortableMarshaller.UNREGISTERED_TYPE_ID,\n            obj instanceof CacheObjectImpl ? 0 : obj.hashCode(),\n            registered ? null : cls.getName()\n        );\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 84,
    "type": "Param",
    "comment": "@param authSession for current request",
    "code": "    protected Response handleBrowserAuthenticationRequest(ClientSessionModel clientSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(clientSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, clientSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(clientSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.sessions().removeClientSession(realm, clientSession);\n                    return response;\n                }\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(clientSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.sessions().removeClientSession(realm, clientSession);\n                    return response;\n\n                }\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, clientSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow();\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param clientSession for current request"
  },
  {
    "id": 85,
    "type": "Param",
    "comment": "@param err Creation error.",
    "code": "    private IgniteCheckedException componentException(Throwable err) {\n        return new IgniteCheckedException(\"Failed to create Ignite component (consider adding \" + module +\n            \" module to classpath) [component=\" + this + \", cls=\" + clsName + ']', err);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 86,
    "type": "Param",
    "comment": "@param url XML file URL.",
    "code": "    private ApplicationContext initContext(Resource res) throws IgniteCheckedException {\n        GenericApplicationContext springCtx;\n\n        try {\n            springCtx = new GenericApplicationContext();\n\n            XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(springCtx);\n\n            reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);\n\n            reader.loadBeanDefinitions(res);\n\n            springCtx.refresh();\n        }\n        catch (BeansException e) {\n            if (X.hasCause(e, ClassNotFoundException.class))\n                throw new IgniteCheckedException(\"Failed to instantiate Spring XML application context \" +\n                    \"(make sure all classes used in Spring configuration are present at CLASSPATH) \" +\n                    \"[resource=\" + res + ']', e);\n            else\n                throw new IgniteCheckedException(\"Failed to instantiate Spring XML application context [resource=\" +\n                    res + \", err=\" + e.getMessage() + ']', e);\n        }\n\n        return springCtx;\n    }\n",
    "label": 1,
    "rec": "@param res Resource to load Spring configuration."
  },
  {
    "id": 87,
    "type": "Param",
    "comment": "@param fr Input frame",
    "code": "  public static Frame shuffleAndBalance(final Frame fr, long seed, final boolean local, final boolean shuffle) {\n    int cores = 0;\n    for( H2ONode node : H2O.CLOUD._memary ) {\n      if (local) cores = Math.max(cores, node._heartbeat._num_cpus);\n      else cores += node._heartbeat._num_cpus;\n    }\n    final int splits = 4*cores;\n\n    // rebalance only if the number of chunks is less than the number of cores\n    if( (fr.vecs()[0].nChunks() < cores || shuffle) && fr.numRows() > splits) {\n      Vec[] vecs = fr.vecs().clone();\n      Log.info(\"Load balancing dataset, splitting it into up to \" + splits + \" chunks.\");\n      long[] idx = null;\n      if (shuffle) {\n        idx = new long[splits];\n        for (int r=0; r<idx.length; ++r) idx[r] = r;\n        Utils.shuffleArray(idx, seed);\n      }\n      Key keys[] = new Vec.VectorGroup().addVecs(vecs.length);\n      final long rows_per_new_chunk = (long)(Math.ceil((double)fr.numRows()/splits));\n      //loop over cols (same indexing for each column)\n      Futures fs = new Futures();\n      for(int col=0; col<vecs.length; col++) {\n        AppendableVec vec = new AppendableVec(keys[col]);\n        // create outgoing chunks for this col\n        NewChunk[] outCkg = new NewChunk[splits];\n        for(int i=0; i<splits; ++i)\n          outCkg[i] = new NewChunk(vec, i);\n        //loop over all incoming chunks\n        for( int ckg = 0; ckg < vecs[col].nChunks(); ckg++ ) {\n          final Chunk inCkg = vecs[col].chunkForChunkIdx(ckg);\n          // loop over local rows of incoming chunks (fast path)\n          for (int row = 0; row < inCkg._len; ++row) {\n            int outCkgIdx = (int)((inCkg._start + row) / rows_per_new_chunk); // destination chunk idx\n            if (shuffle) outCkgIdx = (int)(idx[outCkgIdx]); //shuffle: choose a different output chunk\n            assert(outCkgIdx >= 0 && outCkgIdx < splits);\n            outCkg[outCkgIdx].addNum(inCkg.at0(row));\n          }\n        }\n        for(int i=0; i<outCkg.length; ++i)\n          outCkg[i].close(i, fs);\n        Vec t = vec.close(fs);\n        t._domain = vecs[col]._domain;\n        vecs[col] = t;\n      }\n      fs.blockForPending();\n      Log.info(\"Load balancing done.\");\n      return new Frame(fr.names(), vecs);\n    }\n    return fr;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 88,
    "type": "Param",
    "comment": "@param contentRequest the request that we wish to remove notification for.",
    "code": "    private boolean match( CachedSpiceRequest< ? > cachedSpiceRequest, SpiceRequest< ? > spiceRequest ) {\n        if ( spiceRequest instanceof CachedSpiceRequest ) {\n            return spiceRequest == cachedSpiceRequest;\n        } else {\n            return cachedSpiceRequest.getSpiceRequest() == spiceRequest;\n        }\n    }\n",
    "label": 1,
    "rec": "@param spiceRequest the request that we wish to remove notification for."
  },
  {
    "id": 89,
    "type": "Param",
    "comment": "@param fastMap Flag indicating whether mapping is performed for fast-circuit update.",
    "code": "    private Collection<ClusterNode> mapKey(K key, AffinityTopologyVersion topVer, boolean fastMap) {\n        GridCacheAffinityManager<K, V> affMgr = cctx.affinity();\n\n        // If we can send updates in parallel - do it.\n        return fastMap ?\n            cctx.topology().nodes(affMgr.partition(key), topVer) :\n            Collections.singletonList(affMgr.primary(key, topVer));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 90,
    "type": "Param",
    "comment": "@param taskInfo Task info.",
    "code": "    public GridHadoopTaskInput input(GridHadoopTaskContext taskCtx) throws GridException {\n        switch (taskCtx.taskInfo().type()) {\n            case COMBINE:\n                return combinerMap.input(taskCtx, (Comparator<Object>) taskCtx.combineGroupComparator());\n\n            case REDUCE:\n                int reducer = taskCtx.taskInfo().taskNumber();\n\n                GridHadoopMultimap m = maps.get(reducer);\n\n                if (m != null)\n                    return m.input(taskCtx, (Comparator<Object>)taskCtx.reduceGroupComparator());\n\n                return new GridHadoopTaskInput() { // Empty input.\n                    @Override public boolean next() {\n                        return false;\n                    }\n\n                    @Override public Object key() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public Iterator<?> values() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public void close() {\n                        // No-op.\n                    }\n                };\n\n            default:\n                throw new IllegalStateException(\"Illegal type: \" + taskCtx.taskInfo().type());\n        }\n    }\n",
    "label": 1,
    "rec": "@param taskCtx Task info."
  },
  {
    "id": 91,
    "type": "Param",
    "comment": "@param status Finalization status.",
    "code": "    private boolean salvageTx(IgniteInternalTx<K, V> tx, boolean warn, IgniteInternalTx.FinalizationStatus status) {\n        assert tx != null;\n\n        IgniteTxState state = tx.state();\n\n        if (state == ACTIVE || state == PREPARING || state == PREPARED) {\n            try {\n                if (!tx.markFinalizing(status)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Will not try to commit invalidate transaction (could not mark finalized): \" + tx);\n\n                    return false;\n                }\n\n                tx.systemInvalidate(true);\n\n                tx.prepare();\n\n                if (tx.state() == PREPARING) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Ignoring transaction in PREPARING state as it is currently handled \" +\n                            \"by another thread: \" + tx);\n\n                    return false;\n                }\n\n                if (tx instanceof IgniteTxRemoteEx) {\n                    IgniteTxRemoteEx<K, V> rmtTx = (IgniteTxRemoteEx<K, V>)tx;\n\n                    rmtTx.doneRemote(tx.xidVersion(), Collections.<GridCacheVersion>emptyList(),\n                        Collections.<GridCacheVersion>emptyList(), Collections.<GridCacheVersion>emptyList());\n                }\n\n                tx.commit();\n\n                if (warn) {\n                    // This print out cannot print any peer-deployed entity either\n                    // directly or indirectly.\n                    U.warn(log, \"Invalidated transaction because originating node either \" +\n                        \"crashed or left grid: \" + CU.txString(tx));\n                }\n            }\n            catch (IgniteTxOptimisticCheckedException ignore) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Optimistic failure while invalidating transaction (will rollback): \" +\n                        tx.xidVersion());\n\n                try {\n                    tx.rollback();\n                }\n                catch (IgniteCheckedException e) {\n                    U.error(log, \"Failed to rollback transaction: \" + tx.xidVersion(), e);\n                }\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to invalidate transaction: \" + tx, e);\n            }\n        }\n        else if (state == MARKED_ROLLBACK) {\n            try {\n                tx.rollback();\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to rollback transaction: \" + tx.xidVersion(), e);\n            }\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 92,
    "type": "Param",
    "comment": "@param nd indices of other dimensions",
    "code": "\tpublic SparseMatrix slice(int rowDim, int colDim, int... otherKeys) {\n\n\t\tif (otherKeys.length != numDimensions - 2)\n\t\t\tthrow new Error(\"The input dimensions do not match the tensor specification!\");\n\n\t\t// find an indexed array to search \n\t\tint d = -1;\n\t\tboolean cond1 = indexedDimensions.size() == 0;\n\t\tboolean cond2 = (indexedDimensions.contains(rowDim) || indexedDimensions.contains(colDim))\n\t\t\t\t&& indexedDimensions.size() == 1;\n\t\tboolean cond3 = indexedDimensions.contains(rowDim) && indexedDimensions.contains(colDim)\n\t\t\t\t&& indexedDimensions.size() == 2;\n\t\tif (cond1 || cond2 || cond3) {\n\t\t\tfor (d = 0; d < numDimensions; d++) {\n\t\t\t\tif (d != rowDim && d != colDim)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuildIndex(d);\n\t\t} else {\n\t\t\tfor (int dd : indexedDimensions) {\n\t\t\t\tif (dd != rowDim && dd != colDim) {\n\t\t\t\t\td = dd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// get search key\n\t\tint key = -1;\n\t\tfor (int dim = 0, i = 0; dim < numDimensions; dim++) {\n\t\t\tif (dim == rowDim || dim == colDim)\n\t\t\t\tcontinue;\n\n\t\t\tif (dim == d) {\n\t\t\t\tkey = otherKeys[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t// all relevant positions\n\t\tCollection<Integer> indices = keyIndices[d].get(key);\n\t\tif (indices == null || indices.size() == 0)\n\t\t\treturn null;\n\n\t\tTable<Integer, Integer, Double> dataTable = HashBasedTable.create();\n\t\tMultimap<Integer, Integer> colMap = HashMultimap.create();\n\n\t\t// for each possible position\n\t\tfor (int index : indices) {\n\t\t\tboolean found = true;\n\t\t\tfor (int dd = 0, j = 0; dd < numDimensions; dd++) {\n\n\t\t\t\tif (dd == rowDim || dd == colDim)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (otherKeys[j++] != key(dd, index)) {\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tint row = ndKeys[rowDim].get(index);\n\t\t\t\tint col = ndKeys[colDim].get(index);\n\t\t\t\tdouble val = values.get(index);\n\n\t\t\t\tdataTable.put(row, col, val);\n\t\t\t\tcolMap.put(col, row);\n\t\t\t}\n\t\t}\n\n\t\treturn new SparseMatrix(dimensions[rowDim], dimensions[colDim], dataTable, colMap);\n\t}\n",
    "label": 1,
    "rec": "@param otherKeys keys of other dimensions"
  },
  {
    "id": 93,
    "type": "Param",
    "comment": "@param event",
    "code": "    public static boolean isValid(final GitHubEvent event) {\n        if (event == null || event.payload() == null)\n            return false;\n\n        final GitHubEventType type = event.type();\n\n        return CommitCommentEvent.equals(type) //\n                || (CreateEvent.equals(type) //\n                && ((CreatePayload) event.payload()).refType() != null) //\n                || DeleteEvent.equals(type) //\n                || DownloadEvent.equals(type) //\n                || FollowEvent.equals(type) //\n                || ForkEvent.equals(type) //\n                || (GistEvent.equals(type)\n                && ((GistPayload) event.payload()).gist() != null)\n                || GollumEvent.equals(type) //\n                || (IssueCommentEvent.equals(type) //\n                && ((IssueCommentPayload) event.payload()).issue() != null) //\n                || (IssuesEvent.equals(type) //\n                && ((IssuesPayload) event.payload()).issue() != null) //\n                || MemberEvent.equals(type) //\n                || PublicEvent.equals(type) //\n                || PullRequestEvent.equals(type) //\n                || PullRequestReviewCommentEvent.equals(type) //\n                || PushEvent.equals(type) //\n                || TeamAddEvent.equals(type) //\n                || WatchEvent.equals(type);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 94,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public List<BuilderTryBlock> getTryBlocks(String methodSignature) {\n        dexifyClassIfNecessary(methodSignature);\n\n        return methodSignatureToTryBlocks.get(methodSignature);\n    }\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 95,
    "type": "Param",
    "comment": "@param repo",
    "code": "    public Commit refreshCommit(final Repository repo, final String id) throws IOException {\n        Commit commit = ServiceGenerator.createService(context, RepositoryCommitService.class)\n                .getCommit(repo.owner().login(), repo.name(), id)\n                .toBlocking()\n                .first();\n\n        return addCommit(repo, commit);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 96,
    "type": "Param",
    "comment": "@param time a valid timestamp in milliseconds",
    "code": "    public T getWindowValue(long timeMillis) {\n        if (timeMillis < 0) {\n            return null;\n        }\n        int idx = calculateTimeIdx(timeMillis);\n\n        WindowWrap<T> bucket = array.get(idx);\n\n        if (bucket == null || !bucket.isTimeInWindow(timeMillis)) {\n            return null;\n        }\n\n        return bucket.value();\n    }\n",
    "label": 1,
    "rec": "@param timeMillis a valid timestamp in milliseconds"
  },
  {
    "id": 97,
    "type": "Param",
    "comment": "@param cacheName Name of cache on which affinity is requested.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, ClusterNode n)\n        throws GridException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        GridCacheAffinityFunction f = (GridCacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        GridCacheAffinityKeyMapper m = (GridCacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        Boolean portableEnabled = U.portableEnabled(n, cacheName);\n\n        return new AffinityInfo(f, m, t.get3(), portableEnabled != null && portableEnabled);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 98,
    "type": "Param",
    "comment": "@param path path to evaluate in criteria",
    "code": "    public static Criteria create(String left, String operator, String right) {\n        Object leftPrepared = left;\n        Object rightPrepared = right;\n        Path leftPath = null;\n        Path rightPath = null;\n\n        if(isPath(left)){\n            leftPath = PathCompiler.compile(left);\n            if(!leftPath.isDefinite()){\n                throw new InvalidPathException(\"the predicate path: \" + left + \" is not definite\");\n            }\n            leftPrepared = leftPath;\n        } else if(isString(left)) {\n            leftPrepared = left.substring(1, left.length() - 1);\n        }\n\n        if(isPath(right)){\n            rightPath = PathCompiler.compile(right);\n            if(!rightPath.isDefinite()){\n                throw new InvalidPathException(\"the predicate path: \" + right + \" is not definite\");\n            }\n            rightPrepared = rightPath;\n        } else if(isString(right)) {\n            rightPrepared = right.substring(1, right.length() - 1);\n        }\n\n        if(leftPath != null && operator.isEmpty()){\n            return Criteria.where(leftPath).exists(true);\n        } else {\n            return new Criteria(leftPrepared, CriteriaType.parse(operator), rightPrepared);\n        }\n    }\n",
    "label": 1,
    "rec": "@param left path to evaluate in criteria"
  },
  {
    "id": 99,
    "type": "Param",
    "comment": "@param addr Address to send message to.",
    "code": "    @Nullable private Integer sendMessageDirectly(TcpDiscoveryAbstractMessage msg, InetSocketAddress addr)\n        throws IgniteSpiException {\n        assert msg != null;\n        assert addr != null;\n\n        Collection<Throwable> errs = null;\n\n        Socket sock = null;\n\n        long ackTimeout0 = ackTimeout;\n\n        int connectAttempts = 1;\n\n        boolean joinReqSent = false;\n\n        UUID locNodeId = ignite.configuration().getNodeId();\n\n        for (int i = 0; i < reconCnt; i++) {\n            // Need to set to false on each new iteration,\n            // since remote node may leave in the middle of the first iteration.\n            joinReqSent = false;\n\n            boolean openSock = false;\n\n            try {\n                long tstamp = U.currentTimeMillis();\n\n                sock = openSocket(addr);\n\n                openSock = true;\n\n                // Handshake.\n                writeToSocket(sock, new TcpDiscoveryHandshakeRequest(locNodeId));\n\n                TcpDiscoveryHandshakeResponse res = readMessage(sock, null, ackTimeout0);\n\n                if (locNodeId.equals(res.creatorNodeId())) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Handshake response from local node: \" + res);\n\n                    break;\n                }\n\n                stats.onClientSocketInitialized(U.currentTimeMillis() - tstamp);\n\n                // Send message.\n                tstamp = U.currentTimeMillis();\n\n                writeToSocket(sock, msg);\n\n                stats.onMessageSent(msg, U.currentTimeMillis() - tstamp);\n\n                if (debugMode)\n                    debugLog(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                // Connection has been established, but\n                // join request may not be unmarshalled on remote host.\n                // E.g. due to class not found issue.\n                joinReqSent = msg instanceof TcpDiscoveryJoinRequestMessage;\n\n                return readReceipt(sock, ackTimeout0);\n            }\n            catch (ClassCastException e) {\n                // This issue is rarely reproducible on AmazonEC2, but never\n                // on dedicated machines.\n                if (log.isDebugEnabled())\n                    U.error(log, \"Class cast exception on direct send: \" + addr, e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n            }\n            catch (IOException | IgniteCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.error(\"Exception on direct send: \" + e.getMessage(), e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n\n                if (!openSock) {\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break; // Don't retry if we can not establish connection.\n                }\n\n                if (e instanceof SocketTimeoutException || X.hasCause(e, SocketTimeoutException.class)) {\n                    ackTimeout0 *= 2;\n\n                    if (!checkAckTimeout(ackTimeout0))\n                        break;\n                }\n            }\n            finally {\n                U.closeQuiet(sock);\n            }\n        }\n\n        if (joinReqSent) {\n            if (log.isDebugEnabled())\n                log.debug(\"Join request has been sent, but receipt has not been read (returning RES_WAIT).\");\n\n            // Topology will not include this node,\n            // however, warning on timed out join will be output.\n            return RES_OK;\n        }\n\n        throw new IgniteSpiException(\n            \"Failed to send message to address [addr=\" + addr + \", msg=\" + msg + ']',\n            U.exceptionWithSuppressed(\"Failed to send message to address \" +\n                \"[addr=\" + addr + \", msg=\" + msg + ']', errs));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 100,
    "type": "Param",
    "comment": "@param proxyInterfaces the proxy interfaces",
    "code": "    public static Object createNullObject( ProxyFactory proxyFactory, Class... proxyClasses )\n    {\n        return proxyFactory.createInvocationHandlerProxy( new NullInvocationHandler(), proxyClasses );\n    }\n\n",
    "label": 1,
    "rec": "@param proxyClasses the proxy interfaces"
  },
  {
    "id": 101,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, AffinityTopologyVersion topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        CacheAffinityFunction f = (CacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        CacheAffinityKeyMapper m = (CacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(n, cacheName));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 102,
    "type": "Param",
    "comment": "@param rels the indexes of the relevant columns in the data file",
    "code": "\tpublic SparseMat readData(int[] cols) throws Exception {\n\n\t\tTable<String, String, Double> dataTable = HashBasedTable.create();\n\t\tBufferedReader br = FileIO.getReader(dataPath);\n\t\tString line = null;\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tString[] data = line.split(\"[ \\t,]\");\n\n\t\t\tString user = data[cols[0]];\n\t\t\tString item = data[cols[1]];\n\t\t\tDouble rate = Double.valueOf(data[cols[2]]);\n\n\t\t\t/*if (cols.length >= 4) {\n\t\t\t\tdouble weight = Double.parseDouble(data[cols[3]]);\n\t\t\t\tif (rate == 0 && weight < 1)\n\t\t\t\t\tcontinue;\n\t\t\t}*/\n\n\t\t\tscaleDist.add(rate);\n\t\t\tdataTable.put(user, item, rate);\n\n\t\t\t// inner id starting from 0\n\t\t\tif (!userIds.containsKey(user))\n\t\t\t\tuserIds.put(user, userIds.size());\n\n\t\t\tif (!itemIds.containsKey(item))\n\t\t\t\titemIds.put(item, itemIds.size());\n\t\t}\n\t\tbr.close();\n\n\t\tnumRates = scaleDist.size();\n\t\tscales = new ArrayList<>(scaleDist.elementSet());\n\t\tCollections.sort(scales);\n\n\t\t// if min-rate = 0.0, shift upper a scale\n\t\tdouble minRate = scales.get(0).doubleValue();\n\t\tdouble epsilon = minRate == 0.0 ? scales.get(1).doubleValue() - minRate : 0;\n\t\tif (epsilon > 0) {\n\t\t\tfor (int i = 0, im = scales.size(); i < im; i++) {\n\t\t\t\tdouble val = scales.get(i);\n\t\t\t\tscales.set(i, val + epsilon);\n\t\t\t}\n\t\t}\n\n\t\tint numRows = numUsers(), numCols = numItems();\n\t\tif (isItemAsUser) {\n\t\t\tLogs.debug(\"User amount: {}, scales: {{}}\", numRows, Strings.toString(scales, \", \"));\n\t\t} else {\n\t\t\tLogs.debug(\"User amount: {}, item amount: {}\", numRows, numCols);\n\t\t\tLogs.debug(\"Rating amount: {}, scales: {{}}\", numRates, Strings.toString(scales, \", \"));\n\t\t}\n\n\t\t// build rating matrix\n\t\tint[][] nz = new int[numRows][];\n\n\t\tfor (int uid = 0; uid < nz.length; uid++) {\n\t\t\tString user = getUserId(uid);\n\n\t\t\tnz[uid] = new int[dataTable.row(user).size()];\n\n\t\t\tList<Integer> items = new ArrayList<>();\n\t\t\tfor (String item : dataTable.row(user).keySet())\n\t\t\t\titems.add(getItemId(item));\n\t\t\tCollections.sort(items);\n\n\t\t\tfor (int c = 0, cm = items.size(); c < cm; c++)\n\t\t\t\tnz[uid][c] = items.get(c);\n\t\t}\n\n\t\trateMatrix = new SparseMat(numRows, numCols, nz);\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tString user = getUserId(i);\n\n\t\t\tMap<String, Double> itemRates = dataTable.row(user);\n\t\t\tfor (Entry<String, Double> en : itemRates.entrySet()) {\n\t\t\t\tint j = getItemId(en.getKey());\n\t\t\t\tdouble rate = en.getValue();\n\t\t\t\trateMatrix.set(i, j, rate + epsilon);\n\t\t\t}\n\t\t}\n\n\t\t// release memory of data table\n\t\tdataTable = null;\n\n\t\treturn rateMatrix;\n\t}\n",
    "label": 1,
    "rec": "@param cols the indexes of the relevant columns in the data file"
  },
  {
    "id": 103,
    "type": "Param",
    "comment": "@param userDim dimension of users",
    "code": "\tpublic SparseMatrix rateMatrix() {\n\n\t\tTable<Integer, Integer, Double> dataTable = HashBasedTable.create();\n\t\tMultimap<Integer, Integer> colMap = HashMultimap.create();\n\n\t\tfor (TensorEntry te : this) {\n\t\t\tint u = te.key(userDimension);\n\t\t\tint i = te.key(itemDimension);\n\n\t\t\tdataTable.put(u, i, te.get());\n\t\t\tcolMap.put(i, u);\n\t\t}\n\n\t\treturn new SparseMatrix(dimensions[userDimension], dimensions[itemDimension], dataTable, colMap);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 104,
    "type": "Param",
    "comment": "@param criteriaList list of criteria",
    "code": "    public static Filter filter(Predicate criteria) {\n        return new SingleFilter(criteria);\n    }\n",
    "label": 1,
    "rec": "@param criteria criteria"
  },
  {
    "id": 105,
    "type": "Param",
    "comment": "@param setpoint the setpoint to set.",
    "code": "\tpublic SerialMessage setMessage(int scale, BigDecimal setpoint) {\n\t\tfor (SetpointType setpointType : this.setpointTypes) {\n\t\t\treturn setMessage(scale, setpointType, setpoint);\n\t\t}\n\t\t\n\t\t// in case there are no supported setpoint types, get them.\n\t\treturn this.getSupportedMessage();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 106,
    "type": "Param",
    "comment": "@param algorithm the algorithm to use when determined the nonce length.",
    "code": "    public static ByteString generateNonce(SecurityPolicy securityPolicy) {\n        return generateNonce(getNonceLength(securityPolicy));\n    }\n\n",
    "label": 1,
    "rec": "@param securityPolicy the  SecurityPolicy to use when determining the nonce length."
  },
  {
    "id": 107,
    "type": "Param",
    "comment": "@param v on input, it is the non-zero initial guess of the eigen vector. On output, it is the eigen vector corresponding largest eigen value.",
    "code": "    public static double eigen(Matrix A, double[] v, double p, double tol) {\n        return eigen(A, v, p, tol, Math.max(20, 2 * A.nrows()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 108,
    "type": "Param",
    "comment": "@param sequenceBatch to be updated for the batch range.",
    "code": "    public BatchDescriptor next(final BatchDescriptor batchDescriptor)\n    {\n        if (null == gatingSequences)\n        {\n            throw new NullPointerException(\"gatingSequences must be set before claiming sequences\");\n        }\n\n        final long sequence = claimStrategy.incrementAndGet(batchDescriptor.getSize(), gatingSequences);\n        batchDescriptor.setEnd(sequence);\n        return batchDescriptor;\n    }\n\n",
    "label": 1,
    "rec": "@param batchDescriptor to be updated for the batch range."
  },
  {
    "id": 109,
    "type": "Param",
    "comment": "@param codeIndex The current index into the codeword array.",
    "code": "  private static int textCompaction(int[] codewords, int codeIndex, StringBuilder result) {\n    // 2 character per codeword\n    int[] textCompactionData = new int[codewords[0] << 1];\n    // Used to hold the byte compaction value if there is a mode shift\n    int[] byteCompactionData = new int[codewords[0] << 1];\n\n    int index = 0;\n    boolean end = false;\n    while ((codeIndex < codewords[0]) && !end) {\n      int code = codewords[codeIndex++];\n      if (code < TEXT_COMPACTION_MODE_LATCH) {\n        textCompactionData[index] = code / 30;\n        textCompactionData[index + 1] = code % 30;\n        index += 2;\n      } else {\n        switch (code) {\n          case TEXT_COMPACTION_MODE_LATCH:\n            codeIndex--;\n            end = true;\n            break;\n          case BYTE_COMPACTION_MODE_LATCH:\n            codeIndex--;\n            end = true;\n            break;\n          case NUMERIC_COMPACTION_MODE_LATCH:\n            codeIndex--;\n            end = true;\n            break;\n          case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n            // The Mode Shift codeword 913 shall cause a temporary\n            // switch from Text Compaction mode to Byte Compaction mode.\n            // This switch shall be in effect for only the next codeword,\n            // after which the mode shall revert to the prevailing sub-mode\n            // of the Text Compaction mode. Codeword 913 is only available\n            // in Text Compaction mode; its use is described in 5.4.2.4.\n            textCompactionData[index] = MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n            code = codewords[codeIndex++];\n            byteCompactionData[index] = code; //Integer.toHexString(code);\n            index++;\n            break;\n          case BYTE_COMPACTION_MODE_LATCH_6:\n            codeIndex--;\n            end = true;\n            break;\n        }\n      }\n    }\n    decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n    return codeIndex;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 110,
    "type": "Param",
    "comment": "@param urlBinding the url to find the bound bean type",
    "code": "    public Class<? extends ActionBean> getActionBeanType(String path) {\n        return this.formBeans.get(getUrlBindingFromPath(path));\n    }\n\n",
    "label": 1,
    "rec": "@param path the path segment of a URL"
  },
  {
    "id": 111,
    "type": "Param",
    "comment": "@param log Log.",
    "code": "    private static GridIpcEndpoint connectSharedMemoryEndpoint(int port, IgniteLogger log) throws GridException {\n        return new GridIpcSharedMemoryClientEndpoint(port, log);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 112,
    "type": "Param",
    "comment": "@param info Task info.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input((Comparator<Object>)job.combineGroupComparator());\n                }\n\n            default:\n                return createInput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param ctx Task info."
  },
  {
    "id": 113,
    "type": "Param",
    "comment": "@param skipTx Whether to skip existing transaction.",
    "code": "    private List<IgniteUuid> fileIds(IgniteFsPath path, boolean skipTx) throws GridException {\n        assert path != null;\n\n        // Path components.\n        Collection<String> components = path.components();\n\n        // Collection of file IDs for components of specified path.\n        List<IgniteUuid> ids = new ArrayList<>(components.size() + 1);\n\n        ids.add(ROOT_ID); // Always add root ID.\n\n        IgniteUuid fileId = ROOT_ID;\n\n        for (String s : components) {\n            assert !s.isEmpty();\n\n            if (fileId != null)\n                fileId = fileId(fileId, s, skipTx);\n\n            ids.add(fileId);\n        }\n\n        return ids;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 114,
    "type": "Param",
    "comment": "@param out Output character stream.",
    "code": "    public static int copy(InputStream in, OutputStream out) throws IOException {\n        assert in != null;\n        assert out != null;\n\n        byte[] buf = new byte[BUF_SIZE];\n\n        int cnt = 0;\n\n        for (int n; (n = in.read(buf)) > 0;) {\n            out.write(buf, 0, n);\n\n            cnt += n;\n        }\n\n        return cnt;\n    }\n",
    "label": 1,
    "rec": "@param out Output byte stream."
  },
  {
    "id": 115,
    "type": "Param",
    "comment": "@param taskId",
    "code": "    protected String getTagsAsString(long taskId, String separator, boolean includeEmergent) {\n        StringBuilder tagBuilder = new StringBuilder();\n        TodorooCursor<Metadata> tags = getTags(taskId, includeEmergent);\n        try {\n            int length = tags.getCount();\n            Metadata metadata = new Metadata();\n            for (int i = 0; i < length; i++) {\n                tags.moveToNext();\n                metadata.readFromCursor(tags);\n                tagBuilder.append(metadata.getValue(TAG));\n                if (i < length - 1)\n                    tagBuilder.append(separator);\n            }\n        } finally {\n            tags.close();\n        }\n        return tagBuilder.toString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 116,
    "type": "Param",
    "comment": "@param type Type description.",
    "code": "    protected int fillKeyParameters(PreparedStatement stmt, EntryMapping m, Object key) throws CacheException {\n        return fillKeyParameters(stmt, 1, m, key);\n    }\n",
    "label": 1,
    "rec": "@param m Type mapping description."
  },
  {
    "id": 117,
    "type": "Param",
    "comment": "@param event",
    "code": "    public UserPair getUsers(final GitHubEvent event) {\n        if (event == null || event.payload() == null)\n            return null;\n\n        GitHubEventType type = event.type();\n        if (GitHubEventType.FollowEvent.equals(type)) {\n            User from = event.actor();\n            User to = ((FollowPayload) event.payload()).target();\n            if (from != null && to != null)\n                return new UserPair(from, to);\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 118,
    "type": "Param",
    "comment": "@param duration The durationInMilliseconds the crouton will be displayed  Crouton in milliseconds.",
    "code": "\t\tpublic Builder setDuration(int durationInMilliseconds) {\n\t\t\tthis.durationInMilliseconds = durationInMilliseconds;\n\n\t\t\treturn this;\n\t\t}\n",
    "label": 1,
    "rec": "@param durationInMilliseconds The durationInMilliseconds the crouton will be displayed  Crouton in milliseconds."
  },
  {
    "id": 119,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    protected boolean owns(KeyCacheObject key) {\n        assert key != null;\n\n        // Avoid hash code and remainder calculation in case there is no actual split.\n        return totalCnt == 1 || key.hashCode() % totalCnt == id;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 120,
    "type": "Param",
    "comment": "@param expFwdId Expected forward page ID.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        Page page = page(pageId);\n\n        if (page == null)\n            return true; // Page was removed, retry.\n\n        try {\n            for (;;) {\n                // Init args.\n                g.pageId = pageId;\n                g.fwdId = fwdId;\n\n                int res = readPage(page, search, g, lvl, Get.RETRY);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.fwdId != fwdId || fwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.fwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false; // We are done.\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        assert false: res;\n                }\n            }\n        }\n        finally {\n            if (g.canRelease(page, lvl))\n                page.close();\n        }\n    }\n",
    "label": 1,
    "rec": "@param fwdId Expected forward page ID."
  },
  {
    "id": 121,
    "type": "Param",
    "comment": "@param height Height of item at position. If -1, this function calculates this height.",
    "code": "    private int getShuffleEdge(int position, int top) {\n\n        final int numHeaders = getHeaderViewsCount();\n        final int numFooters = getFooterViewsCount();\n\n        // shuffle edges are defined between items that can be\n        // dragged; there are N-1 of them if there are N draggable\n        // items.\n\n        if (position <= numHeaders || (position >= getCount() - numFooters)) {\n            return top;\n        }\n\n        int divHeight = getDividerHeight();\n\n        int edge;\n\n        int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;\n        int childHeight = getChildHeight(position);\n        int itemHeight = getItemHeight(position);\n\n        // first calculate top of item given that floating View is\n        // centered over src position\n        int otop = top;\n        if (mSecondExpPos <= mSrcPos) {\n            // items are expanded on and/or above the source position\n\n            if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {\n                if (position == mSrcPos) {\n                    otop = top + itemHeight - mFloatViewHeight;\n                } else {\n                    int blankHeight = itemHeight - childHeight;\n                    otop = top + blankHeight - maxBlankHeight;\n                }\n            } else if (position > mSecondExpPos && position <= mSrcPos) {\n                otop = top - maxBlankHeight;\n            }\n\n        } else {\n            // items are expanded on and/or below the source position\n\n            if (position > mSrcPos && position <= mFirstExpPos) {\n                otop = top + maxBlankHeight;\n            } else if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {\n                int blankHeight = itemHeight - childHeight;\n                otop = top + blankHeight;\n            }\n        }\n\n        // otop is set\n        if (position <= mSrcPos) {\n            edge = otop + (mFloatViewHeight - divHeight - getChildHeight(position - 1)) / 2;\n        } else {\n            edge = otop + (childHeight - divHeight - mFloatViewHeight) / 2;\n        }\n\n        return edge;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 122,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public BuilderMethod getMethod(String methodSignature) {\n        dexifyClassIfNecessary(methodSignature);\n\n        return methodSignatureToMethod.get(methodSignature);\n    }\n\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 123,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorEmailConfiguration from(IgniteConfiguration c) {\n        VisorEmailConfiguration cfg = new VisorEmailConfiguration();\n\n        cfg.smtpHost(getProperty(GG_SMTP_HOST, c.getSmtpHost()));\n        cfg.smtpPort(intValue(GG_SMTP_PORT, c.getSmtpPort()));\n        cfg.smtpUsername(getProperty(GG_SMTP_USERNAME, c.getSmtpUsername()));\n        cfg.adminEmails(getProperty(GG_ADMIN_EMAILS, compactArray(c.getAdminEmails())));\n        cfg.smtpFromEmail(getProperty(GG_SMTP_FROM, c.getSmtpFromEmail()));\n        cfg.smtpSsl(boolValue(GG_SMTP_SSL, c.isSmtpSsl()));\n        cfg.smtpStartTls(boolValue(GG_SMTP_STARTTLS, c.isSmtpStartTls()));\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 124,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskOutput createOutput(GridHadoopTaskInfo info, boolean locCombiner) throws GridException {\n        switch (info.type()) {\n            case SETUP:\n            case REDUCE:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case MAP:\n                if (locCombiner) {\n                    assert local == null;\n\n                    local = get(job.info(), SHUFFLE_COMBINER_NO_SORTING, false) ?\n                        new GridHadoopHashMultimap(job, mem, get(job.info(), COMBINER_HASHMAP_SIZE, 8 * 1024)):\n                        new GridHadoopSkipList(job, mem, job.sortComparator()); // TODO replace with red-black tree\n\n                    return local.startAdding();\n                }\n\n            default:\n                return createOutput(info);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 125,
    "type": "Param",
    "comment": "@param metrics Metrics.",
    "code": "    private static byte[] serializeMetrics(UUID nodeId, ClusterNodeMetricsMBean metrics) {\n        assert nodeId != null;\n        assert metrics != null;\n\n        byte[] buf = new byte[16 + DiscoveryMetricsHelper.METRICS_SIZE];\n\n        U.longToBytes(nodeId.getMostSignificantBits(), buf, 0);\n        U.longToBytes(nodeId.getLeastSignificantBits(), buf, 8);\n\n        serialize(buf, 16, metrics);\n\n        return buf;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 126,
    "type": "Param",
    "comment": "@param image1",
    "code": "    public static BufferedImage deepCopy(BufferedImage source) {\n        return Java2DFrameConverter.cloneBufferedImage(source);\n    }\n",
    "label": 1,
    "rec": "@param source"
  },
  {
    "id": 127,
    "type": "Param",
    "comment": "@param mode The byte compaction mode i.e. 901 or 924",
    "code": "  private static int byteCompaction(int mode, int[] codewords, int codeIndex, StringBuilder result) {\n    if (mode == BYTE_COMPACTION_MODE_LATCH) {\n      // Total number of Byte Compaction characters to be encoded\n      // is not a multiple of 6\n      int count = 0;\n      long value = 0;\n      char[] decodedData = new char[6];\n      int[] byteCompactedCodewords = new int[6];\n      boolean end = false;\n      while ((codeIndex < codewords[0]) && !end) {\n        int code = codewords[codeIndex++];\n        if (code < TEXT_COMPACTION_MODE_LATCH) {\n          byteCompactedCodewords[count] = code;\n          count++;\n          // Base 900\n          value = 900 * value + code;\n        } else {\n          if (code == TEXT_COMPACTION_MODE_LATCH ||\n              code == BYTE_COMPACTION_MODE_LATCH ||\n              code == NUMERIC_COMPACTION_MODE_LATCH ||\n              code == BYTE_COMPACTION_MODE_LATCH_6 ||\n              code == BEGIN_MACRO_PDF417_CONTROL_BLOCK ||\n              code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD ||\n              code == MACRO_PDF417_TERMINATOR) {\n            codeIndex--;\n            end = true;\n          }\n        }\n        if ((count % 5 == 0) && (count > 0)) {\n          // Decode every 5 codewords\n          // Convert to Base 256\n          for (int j = 0; j < 6; ++j) {\n            decodedData[5 - j] = (char) (value % 256);\n            value >>= 8;\n          }\n          result.append(decodedData);\n          count = 0;\n        }\n      }\n      // If Byte Compaction mode is invoked with codeword 901,\n      // the final group of codewords is interpreted directly\n      // as one byte per codeword, without compaction.\n      for (int i = (count / 5) * 5; i < count; i++) {\n        result.append((char) byteCompactedCodewords[i]);\n      }\n\n    } else if (mode == BYTE_COMPACTION_MODE_LATCH_6) {\n      // Total number of Byte Compaction characters to be encoded\n      // is an integer multiple of 6\n      int count = 0;\n      long value = 0;\n      boolean end = false;\n      while (codeIndex < codewords[0] && !end) {\n        int code = codewords[codeIndex++];\n        if (code < TEXT_COMPACTION_MODE_LATCH) {\n          count++;\n          // Base 900\n          value = 900 * value + code;\n        } else {\n          if (code == TEXT_COMPACTION_MODE_LATCH ||\n              code == BYTE_COMPACTION_MODE_LATCH ||\n              code == NUMERIC_COMPACTION_MODE_LATCH ||\n              code == BYTE_COMPACTION_MODE_LATCH_6 ||\n              code == BEGIN_MACRO_PDF417_CONTROL_BLOCK ||\n              code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD ||\n              code == MACRO_PDF417_TERMINATOR) {\n            codeIndex--;\n            end = true;\n          }\n        }\n        if ((count % 5 == 0) && (count > 0)) {\n          // Decode every 5 codewords\n          // Convert to Base 256\n          char[] decodedData = new char[6];\n          for (int j = 0; j < 6; ++j) {\n            decodedData[5 - j] = (char) (value & 0xFF);\n            value >>= 8;\n          }\n          result.append(decodedData);\n        }\n      }\n    }\n    return codeIndex;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 128,
    "type": "Param",
    "comment": "@param name item name",
    "code": "\tprivate AbstractNikobusItemConfig parseItem(Item item, String config) throws BindingConfigParseException {\n\n\t\tif (config == null || config.trim().length() == 0) {\n\t\t\tthrow new BindingConfigParseException(\"Invalid config for item \" + item.getName());\n\t\t}\n\n\t\tif (config.matches(BUTTON_CONFIG_PATTERN)) {\n\t\t\treturn new Button(item.getName(), config);\n\t\t}\n\n\t\tif (config.matches(MODULE_CHANNEL_PATTERN)) {\n\t\t\tString address = config.split(\":\")[0];\n\t\t\tint channelNum = Integer.parseInt(config.split(\":\")[1]);\n\t\t\tint group = channelNum > 6 ? 2 : 1;\n\t\t\tString moduleKey = address + \"-\" + group;\n\t\t\tNikobusModule module = getModule(moduleKey);\n\t\t\tif (module == null) {\n\t\t\t\tlog.trace(\"Creating channel group {}\", moduleKey);\n\t\t\t\tmodule = new ModuleChannelGroup(address, group);\n\t\t\t\tallModules.add(module);\n\t\t\t\tmodules.put(moduleKey, module);\n\t\t\t}\n\t\t\treturn ((ModuleChannelGroup) module).addChannel(item.getName(), channelNum, item.getAcceptedCommandTypes());\n\t\t}\n\n\t\tthrow new BindingConfigParseException(\"Could not determine item type from config: \" + config);\n\t}\n",
    "label": 1,
    "rec": "@param item.getName() item name"
  },
  {
    "id": 129,
    "type": "Param",
    "comment": "@param path GGFS path.",
    "code": "    private Path convert(IgniteFsPath path) {\n        URI uri = fileSys.getUri();\n\n        return new Path(uri.getScheme(), uri.getAuthority(), path.toString());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 130,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public CacheObject applyEntryProcessors(CacheObject cacheVal) {\n        Object key = CU.value(this.key, ctx);\n        Object val = CU.value(cacheVal, ctx);\n\n        for (T2<EntryProcessor<Object, Object, Object>, Object[]> t : entryProcessors()) {\n            try {\n                CacheInvokeEntry<Object, Object> invokeEntry = new CacheInvokeEntry<>(ctx, key, val);\n\n                EntryProcessor processor = t.get1();\n\n                processor.process(invokeEntry, t.get2());\n\n                val = invokeEntry.getValue();\n            }\n            catch (Exception ignore) {\n                // No-op.\n            }\n        }\n\n        return ctx.toCacheObject(val);\n// TODO IGNITE-51\n//        if (ctx.portableEnabled())\n//            val = (V)ctx.marshalToPortable(val);\n//\n//        return val;\n    }\n",
    "label": 1,
    "rec": "@param cacheVal Value."
  },
  {
    "id": 131,
    "type": "Param",
    "comment": "@param expirationTime Expiration time.",
    "code": "    public boolean update(KeyCacheObject key, CacheObject val, GridCacheVersion ver, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, val, ver, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 132,
    "type": "Param",
    "comment": "@param t2 the second type",
    "code": "\tpublic boolean isSubtype(TypeMirror potentialSubtype, TypeMirror potentialSupertype) {\n\n\t\tif (processingEnv.getTypeUtils().isSubtype(potentialSubtype, potentialSupertype)) {\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tif (potentialSubtype instanceof DeclaredType) {\n\n\t\t\t\tDeclaredType potentialDeclaredSubtype = (DeclaredType) potentialSubtype;\n\n\t\t\t\tElement potentialSubElement = potentialDeclaredSubtype.asElement();\n\t\t\t\tif (potentialSubElement instanceof TypeElement) {\n\t\t\t\t\tTypeElement potentialSubDeclaredElement = (TypeElement) potentialSubElement;\n\n\t\t\t\t\tTypeMirror superclassTypeMirror = potentialSubDeclaredElement.getSuperclass();\n\n\t\t\t\t\tif (isRootObjectClass(superclassTypeMirror)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (superclassTypeMirror instanceof ErrorType) {\n\n\t\t\t\t\t\t\tErrorType errorType = (ErrorType) superclassTypeMirror;\n\n\t\t\t\t\t\t\tElement errorElement = errorType.asElement();\n\n\t\t\t\t\t\t\tString errorElementSimpleName = errorElement.getSimpleName().toString();\n\t\t\t\t\t\t\tif (errorElementSimpleName.endsWith(GENERATION_SUFFIX)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The supertype %s of the potential subElement %s of potential supertype %s is an ErrorType that doesn't end with %s\", errorElement, potentialSubElement, potentialSupertype, GENERATION_SUFFIX));\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn isSubtype(superclassTypeMirror, potentialSupertype);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The potential subElement %s of potential supertype %s is not a TypeElement but a %s\", potentialSubElement, potentialSupertype, potentialSubElement.getClass()));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The potential subtype %s of potential supertype %s is not a DeclaredType but a %s\", potentialSubtype, potentialSupertype, potentialSubtype.getClass()));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param potentialSupertype the second type"
  },
  {
    "id": 133,
    "type": "Param",
    "comment": "@param repository",
    "code": "    public Issue refreshIssue(Repository repository, int number) throws IOException {\n        Issue issue = service.getIssue(repository.owner().login(), repository.name(), number)\n                .toBlocking()\n                .first();\n        return addIssue(repository, issue);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 134,
    "type": "Param",
    "comment": "@param aObject the a object",
    "code": "    public static int hash(int seed, Object o) {\n        int result = seed;\n        if (o == null) {\n            result = hash(result, 0);\n        } else if (!isArray(o)) {\n            result = hash(result, o.hashCode());\n        } else {\n            int length = Array.getLength(o);\n            for (int idx = 0; idx < length; ++idx) {\n                Object item = Array.get(o, idx);\n                // recursive call!\n                result = hash(result, item);\n            }\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param o the object"
  },
  {
    "id": 135,
    "type": "Param",
    "comment": "@param threadId Thread id. If -1, all threads will be checked.",
    "code": "    public boolean isLockedByThread(KeyCacheObject key, long threadId) {\n        if (threadId < 0) {\n            for (GridCacheExplicitLockSpan span : pendingExplicit.values()) {\n                GridCacheMvccCandidate cand = span.candidate(key, null);\n\n                if (cand != null && cand.owner())\n                    return true;\n            }\n        }\n        else {\n            GridCacheExplicitLockSpan span = pendingExplicit.get(threadId);\n\n            if (span != null) {\n                GridCacheMvccCandidate cand = span.candidate(key, null);\n\n                return cand != null && cand.owner();\n            }\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 136,
    "type": "Param",
    "comment": "@param milis miliseconds entered in a positive value",
    "code": "    public static XMLGregorianCalendar subtract(XMLGregorianCalendar value, long millis) {\n        return add(value, - millis);\n    }\n",
    "label": 1,
    "rec": "@param millis miliseconds entered in a positive value"
  },
  {
    "id": 137,
    "type": "Param",
    "comment": "@param e Entry to verify.",
    "code": "    boolean isAll(CacheEntry<K, V> e, boolean noNulls) {\n        CacheFlag[] f = cctx.forceLocalRead();\n\n        try {\n            return F.isAll(e, entryFilter(noNulls));\n        }\n        finally {\n            cctx.forceFlags(f);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 138,
    "type": "Param",
    "comment": "@param buf String buffer.",
    "code": "    private StringBuilder addFlag(StringBuilder sb, int flags, int mask, String flagName) {\n        if ((flags & mask) > 0)\n            sb.append(sb.length() > 0 ? \",\" : \"\").append(flagName);\n\n        return sb;\n    }\n\n",
    "label": 1,
    "rec": "@param sb String builder."
  },
  {
    "id": 139,
    "type": "Param",
    "comment": "@param msg Message to send.",
    "code": "    @Nullable private Integer sendMessageDirectly(TcpDiscoveryAbstractMessage msg, InetSocketAddress addr)\n        throws IgniteSpiException {\n        assert msg != null;\n        assert addr != null;\n\n        Collection<Throwable> errs = null;\n\n        long ackTimeout0 = spi.ackTimeout;\n\n        int connectAttempts = 1;\n\n        boolean joinReqSent = false;\n\n        UUID locNodeId = getLocalNodeId();\n\n        for (int i = 0; i < spi.reconCnt; i++) {\n            // Need to set to false on each new iteration,\n            // since remote node may leave in the middle of the first iteration.\n            joinReqSent = false;\n\n            boolean openSock = false;\n\n            Socket sock = null;\n\n            try {\n                long tstamp = U.currentTimeMillis();\n\n                sock = spi.openSocket(addr);\n\n                openSock = true;\n\n                // Handshake.\n                spi.writeToSocket(sock, new TcpDiscoveryHandshakeRequest(locNodeId));\n\n                TcpDiscoveryHandshakeResponse res = spi.readMessage(sock, null, ackTimeout0);\n\n                if (locNodeId.equals(res.creatorNodeId())) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Handshake response from local node: \" + res);\n\n                    break;\n                }\n\n                spi.stats.onClientSocketInitialized(U.currentTimeMillis() - tstamp);\n\n                // Send message.\n                tstamp = U.currentTimeMillis();\n\n                spi.writeToSocket(sock, msg);\n\n                spi.stats.onMessageSent(msg, U.currentTimeMillis() - tstamp);\n\n                if (debugMode)\n                    debugLog(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                // Connection has been established, but\n                // join request may not be unmarshalled on remote host.\n                // E.g. due to class not found issue.\n                joinReqSent = msg instanceof TcpDiscoveryJoinRequestMessage;\n\n                return spi.readReceipt(sock, ackTimeout0);\n            }\n            catch (ClassCastException e) {\n                // This issue is rarely reproducible on AmazonEC2, but never\n                // on dedicated machines.\n                if (log.isDebugEnabled())\n                    U.error(log, \"Class cast exception on direct send: \" + addr, e);\n\n                onException(\"Class cast exception on direct send: \" + addr, e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n            }\n            catch (IOException | IgniteCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.error(\"Exception on direct send: \" + e.getMessage(), e);\n\n                onException(\"Exception on direct send: \" + e.getMessage(), e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n\n                if (!openSock) {\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break; // Don't retry if we can not establish connection.\n                }\n\n                if (e instanceof SocketTimeoutException || X.hasCause(e, SocketTimeoutException.class)) {\n                    ackTimeout0 *= 2;\n\n                    if (!checkAckTimeout(ackTimeout0))\n                        break;\n                }\n            }\n            finally {\n                U.closeQuiet(sock);\n            }\n        }\n\n        if (joinReqSent) {\n            if (log.isDebugEnabled())\n                log.debug(\"Join request has been sent, but receipt has not been read (returning RES_WAIT).\");\n\n            // Topology will not include this node,\n            // however, warning on timed out join will be output.\n            return RES_OK;\n        }\n\n        throw new IgniteSpiException(\n            \"Failed to send message to address [addr=\" + addr + \", msg=\" + msg + ']',\n            U.exceptionWithSuppressed(\"Failed to send message to address \" +\n                \"[addr=\" + addr + \", msg=\" + msg + ']', errs));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 140,
    "type": "Param",
    "comment": "@param executable  HystrixExecutable",
    "code": "    public static Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {\n        Validate.notNull(invokable);\n        Validate.notNull(metaHolder);\n\n        switch (executionType) {\n            case SYNCHRONOUS: {\n                return castToExecutable(invokable, executionType).execute();\n            }\n            case ASYNCHRONOUS: {\n                HystrixExecutable executable = castToExecutable(invokable, executionType);\n                if (metaHolder.hasFallbackMethodCommand()\n                        && ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) {\n                    return new FutureDecorator(executable.queue());\n                }\n                return executable.queue();\n            }\n            case OBSERVABLE: {\n                HystrixObservable observable = castToObservable(invokable);\n                return ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();\n            }\n            default:\n                throw new RuntimeException(\"unsupported execution type: \" + executionType);\n        }\n    }\n",
    "label": 1,
    "rec": "@param invokable  HystrixInvokable"
  },
  {
    "id": 141,
    "type": "Param",
    "comment": "@param threadId Thread id.",
    "code": "    @Nullable public GridCacheMvccCandidate explicitLock(long threadId, KeyCacheObject key) {\n        if (threadId < 0)\n            return explicitLock(key, null);\n        else {\n            GridCacheExplicitLockSpan span = pendingExplicit.get(threadId);\n\n            return span == null ? null : span.candidate(key, null);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 142,
    "type": "Param",
    "comment": "@param callbackId The callback id used when calling back into JavaScript",
    "code": "    public boolean execute(String action, JSONArray data, CallbackContext callbackContext) {\n        boolean actionValid = true;\n        if (NOTIFY.equals(action)) {\n            try {\n                String tag = data.getString(0);\n                String title = data.getString(1);\n                String body = data.getString(2);\n                String flag = data.getString(3);\n                Log.d(\"NotificationPlugin\", \"Notification: \" + tag + \", \" + title + \", \" + body);\n                int notificationFlag = getFlagValue(flag);\n                showNotification(tag, title, body, notificationFlag);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \"\n                        + jsonEx.getMessage());\n                actionValid = false;\n            }\n        } else if (CLEAR.equals(action)){\n            try {\n                String tag = data.getString(0);\n                Log.d(\"NotificationPlugin\", \"Notification cancel: \" + tag);\n                clearNotification(tag);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \" + jsonEx.getMessage());\n                actionValid = false;\n            }\n        } else {\n            actionValid = false;\n            Log.d(\"NotificationPlugin\", \"Invalid action : \"+action+\" passed\");\n        }\n        return actionValid;\n    }\n",
    "label": 1,
    "rec": "@param callbackContext The callback context used when calling back into JavaScript."
  },
  {
    "id": 143,
    "type": "Param",
    "comment": "@param file file for digest calculations.",
    "code": "    private static boolean addFileDigest(File file, MessageDigest digest, @Nullable IgniteLogger log) {\n        if (!file.isFile()) {\n            U.error(log, \"Failed to add file to directory digest (will not check MD5 hash): \" + file);\n\n            return false;\n        }\n\n        InputStream in = null;\n\n        try {\n            in = new BufferedInputStream(new FileInputStream(file));\n\n            byte[] buf = new byte[1024];\n\n            int read = in.read(buf, 0, 1024);\n\n            while (read > -1) {\n                digest.update(buf, 0, read);\n\n                read = in.read(buf, 0, 1024);\n            }\n        }\n        catch (IOException e) {\n            U.error(log, \"Failed to add file to directory digest (will not check MD5 hash): \" + file, e);\n\n            return false;\n        }\n        finally {\n            U.closeQuiet(in);\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 144,
    "type": "Param",
    "comment": "@param dest the file containing the new name.",
    "code": "    public boolean renameTo(File newPath) {\n        if (path.isEmpty() || newPath.path.isEmpty()) {\n            return false;\n        }\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkWrite(path);\n            security.checkWrite(newPath.path);\n        }\n        return renameToImpl(absolutePath, newPath.absolutePath);\n    }\n\n",
    "label": 1,
    "rec": "@param newPath the new path."
  },
  {
    "id": 145,
    "type": "Param",
    "comment": "@param properties Pass-thru to  HystrixMetricsPublisher#getMetricsPublisherForThreadPool implementation",
    "code": "    public static HystrixMetricsPublisherThreadPool createOrRetrievePublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {\n        // attempt to retrieve from cache first\n        HystrixMetricsPublisherThreadPool publisher = threadPoolPublishers.get(threadPoolKey.name());\n        if (publisher != null) {\n            return publisher;\n        }\n        // it doesn't exist so we need to create it\n        publisher = HystrixPlugins.getInstance().getMetricsPublisher().getMetricsPublisherForThreadPool(threadPoolKey, metrics, properties);\n        // attempt to store it (race other threads)\n        HystrixMetricsPublisherThreadPool existing = threadPoolPublishers.putIfAbsent(threadPoolKey.name(), publisher);\n        if (existing == null) {\n            // we won the thread-race to store the instance we created so initialize it\n            publisher.initialize();\n            // done registering, return instance that got cached\n            return publisher;\n        } else {\n            // we lost so return 'existing' and let the one we created be garbage collected\n            // without calling initialize() on it\n            return existing;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 146,
    "type": "Param",
    "comment": "@param integer",
    "code": "  public Long decrBy(final byte[] key, final long decrement) {\n    checkIsInMultiOrPipeline();\n    client.decrBy(key, decrement);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param decrement"
  },
  {
    "id": 147,
    "type": "Param",
    "comment": "@param pageMem Page memory.",
    "code": "    protected ReuseList createReuseList(int cacheId, PageMemory pageMem, long rootId, boolean initNew)\n        throws IgniteCheckedException {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 148,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static CacheQueue<String> initializeQueue(Ignite ignite, String queueName) throws IgniteCheckedException {\n        // Initialize new FIFO queue.\n        CacheQueue<String> queue = ignite.cache(CACHE_NAME).dataStructures().queue(queueName, 0, false, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < ignite.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 149,
    "type": "Param",
    "comment": "@param nodeId Node ID.",
    "code": "    private static byte[] serializeMetrics(UUID nodeId, ClusterMetrics metrics) {\n        assert nodeId != null;\n        assert metrics != null;\n\n        byte[] buf = new byte[16 + ClusterMetricsSnapshot.METRICS_SIZE];\n\n        U.longToBytes(nodeId.getMostSignificantBits(), buf, 0);\n        U.longToBytes(nodeId.getLeastSignificantBits(), buf, 8);\n\n        ClusterMetricsSnapshot.serialize(buf, 16, metrics);\n\n        return buf;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 150,
    "type": "Param",
    "comment": "@param settings",
    "code": "\tprivate Object getValue(ByteBuffer byteBuffer, TelegramValue telegramValue) {\n\n\t\tString type = telegramValue.getType().toLowerCase();\n\t\tint pos = telegramValue.getPos() != null ? telegramValue.getPos() : -1;\n\n\t\tObject value = null;\n\n\t\t// requested pos is greater as whole buffer\n\t\tif(pos > byteBuffer.position()) {\n\t\t\tlogger.warn(\"eBus buffer pos error! Can happen ...\");\n\t\t}\n\n\t\t// replace similar data types\n\t\tif(type.equals(\"uint\"))\n\t\t\ttype = \"word\";\n\t\tif(type.equals(\"byte\"))\n\t\t\ttype = \"uchar\";\n\n\t\tbyte[] bytes = null;\n\t\tif(type.equals(\"data2b\") || type.equals(\"data2c\") || type.equals(\"word\")) {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos), byteBuffer.get(pos-1)};\n\t\t} else {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos-1)};\n\t\t}\n\n\t\tif(type.equals(\"bit\")) {\n\t\t\tint bit = telegramValue.getBit();\n\t\t\tvalue = bytes[0];\n\n\t\t\tboolean isSet = ((Byte)value >> bit& 0x1) == 1;\n\t\t\tvalue = isSet;\n\n\t\t} else {\n\t\t\tvalue = NumberUtils.toBigDecimal(EBusCodecUtils.decode(type, bytes, telegramValue.getReplaceValue()));\n\t\t}\n\n\t\t// if BigDecimal check for min, max and replace value\n\t\tif(value instanceof BigDecimal) {\n\t\t\tBigDecimal b = (BigDecimal)value;\n\n\t\t\t// multiply before check min and max\n\t\t\tif(b != null && telegramValue.getFactor() != null) {\n\t\t\t\tlogger.trace(\"Value multiplied ...\");\n\t\t\t\tvalue = b = b.multiply(telegramValue.getFactor());\n\t\t\t}\n\n\t\t\t// value is below min value, return null\n\t\t\tif(telegramValue.getMin() != null && b != null && b.compareTo(telegramValue.getMin()) == -1) {\n\t\t\t\tlogger.trace(\"Minimal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\n\t\t\t\t// value is above max value, return null\n\t\t\t} else if (telegramValue.getMax() != null && b != null && b.compareTo(telegramValue.getMax()) == 1) {\n\t\t\t\tlogger.trace(\"Maximal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\t\t\t}\n\n\t\t}\n\n\t\treturn value;\n\t}\n",
    "label": 1,
    "rec": "@param telegramValue"
  },
  {
    "id": 151,
    "type": "Param",
    "comment": "@param setSelected Whether to set the given time as selected",
    "code": "    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n\n        // Set the selected day\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = (day.year - mController.getMinYear())\n                * SimpleMonthAdapter.MONTHS_IN_YEAR + day.month;\n\n        View child;\n        int i = 0;\n        int top = 0;\n        // Find a child that's completely in the view\n        do {\n            child = getChildAt(i++);\n            if (child == null) {\n                break;\n            }\n            top = child.getTop();\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.d(TAG, \"child at \" + (i - 1) + \" has top \" + top);\n            }\n        } while (top < 0);\n\n        // Compute the first and last position visible\n        int selectedPosition;\n        if (child != null) {\n            selectedPosition = getPositionForView(child);\n        } else {\n            selectedPosition = 0;\n        }\n\n        if (setSelected) {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n        // Check if the selected day is now outside of our visible range\n        // and if so scroll to the month that contains it\n        if (position != selectedPosition || forceScroll) {\n            setMonthDisplayed(mTempDay);\n            mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;\n            if (animate && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n                smoothScrollToPositionFromTop(\n                        position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);\n                return true;\n            } else {\n                postSetSelection(position);\n            }\n        } else if (setSelected) {\n            setMonthDisplayed(mSelectedDay);\n        }\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 152,
    "type": "Param",
    "comment": "@param msg request",
    "code": "  private boolean needAsync(TransportMethod method) {\n    return !(method == TransportMethod.GET_CLOCKS || method == TransportMethod.UPDATE_CLOCK);\n  }\n\n",
    "label": 1,
    "rec": "@param method request type"
  },
  {
    "id": 153,
    "type": "Param",
    "comment": "@param blockId Block ID.",
    "code": "    private GridGgfsBlockKey blockKey(IgniteFsPath path, long blockId) throws Exception {\n        GridGgfsEx ggfs0 = (GridGgfsEx)grid(0).fileSystem(GGFS_NAME);\n\n        IgniteUuid fileId = ggfs0.context().meta().fileId(path);\n\n        return new GridGgfsBlockKey(fileId, null, true, blockId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 154,
    "type": "Param",
    "comment": "@param pStruct",
    "code": "    public double finalQ(int[] struct, double[] degrees, HierarchicalUndirectedGraph graph, AttributeModel attributeModel) {\n        AttributeTable nodeTable = attributeModel.getNodeTable();\n        AttributeColumn modCol = nodeTable.getColumn(MODULARITY_CLASS);\n        if (modCol == null) {\n            modCol = nodeTable.addColumn(MODULARITY_CLASS, \"Modularity Class\", AttributeType.INT, AttributeOrigin.COMPUTED, new Integer(0));\n        }\n\n        double res = 0;\n        double[] internal = new double[degrees.length];\n        for (Node n : graph.getNodes()) {\n            int n_index = structure.map.get(n);\n            AttributeRow row = (AttributeRow) n.getNodeData().getAttributes();\n            row.setValue(modCol, struct[n_index]);\n            for (Node neighbor : graph.getNeighbors(n)) {\n                if (n == neighbor) {\n                    continue;\n                }\n                int neigh_index = structure.map.get(neighbor);\n                if (struct[neigh_index] == struct[n_index]) {\n                    internal[struct[neigh_index]]++;\n                }\n            }\n        }\n        for (int i = 0; i < degrees.length; i++) {\n            internal[i] /= 2.0;\n            res += (internal[i] / graph.getEdgeCount()) - Math.pow(degrees[i] / (2 * graph.getEdgeCount()), 2);\n        }\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param struct"
  },
  {
    "id": 155,
    "type": "Param",
    "comment": "@param curve the elliptic curve",
    "code": "  public static byte[] ecPointEncode(EllipticCurve curve, PointFormatEnum format, ECPoint point)\n      throws GeneralSecurityException {\n    EcUtil.checkPointOnCurve(point, curve);\n    int coordinateSize = EcUtil.fieldSizeInBytes(curve);\n    switch (format) {\n      case UNCOMPRESSED:\n        {\n          byte[] encoded = new byte[2 * coordinateSize + 1];\n          byte[] x = point.getAffineX().toByteArray();\n          byte[] y = point.getAffineY().toByteArray();\n          // Order of System.arraycopy is important because x,y can have leading 0's.\n          System.arraycopy(y, 0, encoded, 1 + 2 * coordinateSize - y.length, y.length);\n          System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);\n          encoded[0] = 4;\n          return encoded;\n        }\n      case COMPRESSED:\n        {\n          byte[] encoded = new byte[coordinateSize + 1];\n          byte[] x = point.getAffineX().toByteArray();\n          System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);\n          encoded[0] = (byte) (point.getAffineY().testBit(0) ? 3 : 2);\n          return encoded;\n        }\n      default:\n        throw new GeneralSecurityException(\"invalid format:\" + format);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 156,
    "type": "Param",
    "comment": "@param string",
    "code": "    public Long rpush(final byte[] key, final byte[]... strings) {\n        checkIsInMulti();\n        client.rpush(key, strings);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param strings"
  },
  {
    "id": 157,
    "type": "Param",
    "comment": "@param bridge Initialized Velux bridge handler.",
    "code": "    public Channel retrieve(VeluxBridge bridge) {\n        logger.trace(\"retrieve() called.\");\n\n        if (this.channel == null) {\n            this.channel = new Channel();\n        }\n\n        GetLANConfig bcp = bridge.bridgeAPI().getLANConfig();\n        if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) {\n            logger.trace(\"retrieve() found successfully configuration {}.\", bcp.getLANConfig());\n            channel.openHABipAddress = new StringType(bcp.getLANConfig().getIpAddress());\n            channel.openHABsubnetMask = new StringType(bcp.getLANConfig().getSubnetMask());\n            channel.openHABdefaultGW = new StringType(bcp.getLANConfig().getDefaultGW());\n            channel.openHABenabledDHCP = bcp.getLANConfig().getDHCP() ? OnOffType.ON : OnOffType.OFF;\n            channel.isRetrieved = true;\n            return channel;\n        } else {\n            logger.trace(\"retrieve() finished with failure.\");\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 158,
    "type": "Param",
    "comment": "@param contributor",
    "code": "    public AvatarLoader bind(final ImageView view, final SearchUser user) {\n        if (user == null)\n            return setImage(loadingAvatar, view);\n\n        final String avatarUrl = getAvatarUrl(user.getGravatarId());\n\n        if (TextUtils.isEmpty(avatarUrl))\n            return setImage(loadingAvatar, view);\n\n        final String userId = user.getId();\n\n        BitmapDrawable loadedImage = loaded.get(userId);\n        if (loadedImage != null)\n            return setImage(loadedImage, view);\n\n        setImage(loadingAvatar, view, userId);\n        fetchAvatarTask(avatarUrl, userId, view).execute();\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param user"
  },
  {
    "id": 159,
    "type": "Param",
    "comment": "@param matcher decides whether argument matches",
    "code": "    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 160,
    "type": "Param",
    "comment": "@param cacheName Cache name.",
    "code": "    public static VisorCache from(Ignite ignite, GridCache c, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param c Actual cache."
  },
  {
    "id": 161,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, long topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!U.hasNearCache(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listen(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        cctx.kernalContext().closure().runLocalSafe(new GridPlainRunnable() {\n                            @Override public void run() {\n                                synchronized (this) {\n                                    // Release memory.\n                                    reader0.resetTxFuture();\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 162,
    "type": "Param",
    "comment": "@param value",
    "code": "  public Double incrByFloat(final String key, final double increment) {\n    checkIsInMultiOrPipeline();\n    client.incrByFloat(key, increment);\n    String dval = client.getBulkReply();\n    return (dval != null ? new Double(dval) : null);\n  }\n",
    "label": 1,
    "rec": "@param increment"
  },
  {
    "id": 163,
    "type": "Param",
    "comment": "@param recursive Recursive flag.",
    "code": "    public boolean deleteDual(final Igfs fs, final IgfsPath path, final boolean recursive)\n        throws IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert path != null;\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgfsPath, IgfsFileInfo> infos) throws Exception {\n                        IgfsFileInfo info = infos.get(path);\n\n                        if (info == null)\n                            return false; // File doesn't exist in the secondary file system.\n\n                        if (!fs.delete(path, recursive))\n                            return false; // Delete failed remotely.\n\n                        if (path.parent() != null) {\n                            assert infos.containsKey(path.parent());\n\n                            softDeleteNonTx(infos.get(path.parent()).id(), path.name(), info.id());\n                        }\n                        else {\n                            assert ROOT_ID.equals(info.id());\n\n                            softDeleteNonTx(null, path.name(), info.id());\n                        }\n\n                        // Update the deleted file info with path information for delete worker.\n                        id2InfoPrj.invoke(info.id(), new UpdatePath(path));\n\n                        return true; // No additional handling is required.\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path delete in DUAL mode failed [path=\" + path + \", recursive=\" + recursive + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to delete the path due to secondary file system exception: \",\n                            err);\n                    }\n                };\n\n                Boolean res = synchronizeAndExecute(task, fs, false, Collections.singleton(TRASH_ID), path);\n\n                delWorker.signal();\n\n                return res;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to delete in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 164,
    "type": "Param",
    "comment": "@param member",
    "code": "    public Long srem(final String key, final String... members) {\n        checkIsInMulti();\n        client.srem(key, members);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param members"
  },
  {
    "id": 165,
    "type": "Param",
    "comment": "@param Ap the preconditioned matrix of A.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol, int maxIter) {\n        if (tol <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid tolerance: \" + tol);\n        }\n\n        if (maxIter <= 0) {\n            throw new IllegalArgumentException(\"Invalid maximum number of iterations: \" + maxIter);\n        }\n\n        if (itol < 1 || itol > 4) {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        double err = 0.0;\n        double ak, akden, bk, bkden = 1.0, bknum, bnrm, dxnrm, xnrm, zm1nrm, znrm = 0.0;\n        int j, n = b.length;\n\n        double[] p = new double[n];\n        double[] pp = new double[n];\n        double[] r = new double[n];\n        double[] rr = new double[n];\n        double[] z = new double[n];\n        double[] zz = new double[n];\n\n        A.ax(x, r);\n        for (j = 0; j < n; j++) {\n            r[j] = b[j] - r[j];\n            rr[j] = r[j];\n        }\n\n        if (itol == 1) {\n            bnrm = snorm(b, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 2) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 3 || itol == 4) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n            znrm = snorm(z, itol);\n        } else {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        for (int iter = 1; iter <= maxIter; iter++) {\n            Ap.asolve(rr, zz);\n            for (bknum = 0.0, j = 0; j < n; j++) {\n                bknum += z[j] * rr[j];\n            }\n            if (iter == 1) {\n                for (j = 0; j < n; j++) {\n                    p[j] = z[j];\n                    pp[j] = zz[j];\n                }\n            } else {\n                bk = bknum / bkden;\n                for (j = 0; j < n; j++) {\n                    p[j] = bk * p[j] + z[j];\n                    pp[j] = bk * pp[j] + zz[j];\n                }\n            }\n            bkden = bknum;\n            A.ax(p, z);\n            for (akden = 0.0, j = 0; j < n; j++) {\n                akden += z[j] * pp[j];\n            }\n            ak = bknum / akden;\n            A.atx(pp, zz);\n            for (j = 0; j < n; j++) {\n                x[j] += ak * p[j];\n                r[j] -= ak * z[j];\n                rr[j] -= ak * zz[j];\n            }\n            Ap.asolve(r, z);\n            if (itol == 1) {\n                err = snorm(r, itol) / bnrm;\n            } else if (itol == 2) {\n                err = snorm(z, itol) / bnrm;\n            } else if (itol == 3 || itol == 4) {\n                zm1nrm = znrm;\n                znrm = snorm(z, itol);\n                if (Math.abs(zm1nrm - znrm) > Math.EPSILON * znrm) {\n                    dxnrm = Math.abs(ak) * snorm(p, itol);\n                    err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n                xnrm = snorm(x, itol);\n                if (err <= 0.5 * xnrm) {\n                    err /= xnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n            }\n\n            if (iter % 10 == 0) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n            }\n\n            if (err <= tol) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n                break;\n            }\n        }\n\n        return err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 166,
    "type": "Param",
    "comment": "@param weightingMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&api.xy=\" from the URL of the web UI",
    "code": "    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )\n    {\n        String weighting = wMap.getWeighting();\n        Weighting result;\n\n        if (\"shortest\".equalsIgnoreCase(weighting))\n        {\n            result = new ShortestWeighting();\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty())\n        {\n            if (encoder.supports(PriorityWeighting.class))\n                result = new PriorityWeighting(encoder);\n            else\n                result = new FastestWeighting(encoder);\n        } else\n        {\n            throw new UnsupportedOperationException(\"weighting \" + weighting + \" not supported\");\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param wMap all parameters influencing the weighting. E.g. URL parameters coming via GHRequest"
  },
  {
    "id": 167,
    "type": "Param",
    "comment": "@param path GGFS path.",
    "code": "    private Path convert(IgfsPath path) {\n        URI uri = fileSys.getUri();\n\n        return new Path(uri.getScheme(), uri.getAuthority(), path.toString());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 168,
    "type": "Param",
    "comment": "@param nodeLabelInsets the additional insets for node labels on this node",
    "code": "    public static ElkPadding calculateRequiredNodeLabelSpace(final NodeAdapter<?> node,\n            final double labelSpacing, final ElkPadding nodeLabelPadding,\n            final Map<LabelLocation, LabelGroup> labelGroupsBoundingBoxes, final ElkPadding padding) {\n\n        // Check if there are any labels\n        if (!node.getLabels().iterator().hasNext()) {\n            return padding;\n        }\n        \n        // Retrieve the node's label placement policy\n        final Set<NodeLabelPlacement> nodeLabelPlacement = node.getProperty(CoreOptions.NODE_LABELS_PLACEMENT);\n        final LabelLocation nodeLabelLocation = LabelLocation.fromNodeLabelPlacement(nodeLabelPlacement);\n        \n        // Compute a bounding box for each location where labels should be placed.\n        // The size is calculated from the size of all labels stacked vertically at that location.\n        for (final LabelAdapter<?> label : node.getLabels()) {\n            LabelLocation labelPlacement =\n                    LabelLocation.fromNodeLabelPlacement(label.getProperty(CoreOptions.NODE_LABELS_PLACEMENT));\n            \n            // If no valid placement is set on the label, use the node's placement policy.\n            if (labelPlacement == LabelLocation.UNDEFINED) {\n                labelPlacement = nodeLabelLocation;\n            }\n            \n            // Save the location of this label in its id field for later use.\n            label.setVolatileId(labelPlacement.ordinal());\n            \n            // Create or retrieve the label group for the current label.\n            final Rectangle boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);\n            boundingBox.width = Math.max(boundingBox.width, label.getSize().x);\n            boundingBox.height += label.getSize().y + labelSpacing;\n        }\n        \n        // We need to count different label placement boxes towards different kinds of padding, depending on whether\n        // or not H_PRIORITY is set on the node itself (see H_PRIORITY documentation)\n        boolean hPrio = nodeLabelPlacement.contains(NodeLabelPlacement.H_PRIORITY);\n        \n        // Calculate the node label space required inside the node (only label groups on the inside\n        // are relevant here).\n        for (final Entry<LabelLocation, LabelGroup> entry : labelGroupsBoundingBoxes.entrySet()) {\n            final Rectangle boundingBox = entry.getValue();\n            \n            // From each existing label group, remove the last superfluous label spacing\n            // (the mere existence of a label group implies that it contains at least one label)\n            boundingBox.height -= labelSpacing;\n            switch (entry.getKey()) {\n            case IN_T_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_T_C:\n                padding.top = Math.max(\n                        padding.top,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                break;\n                \n            case IN_T_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_C_L:\n                padding.left = Math.max(\n                        padding.left,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                break;\n                \n            case IN_C_R:\n                padding.right = Math.max(\n                        padding.right,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                break;\n                \n            case IN_B_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            case IN_B_C:\n                padding.bottom = Math.max(\n                        padding.bottom,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                break;\n                \n            case IN_B_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            default:\n                // In all other cases, no specific action is required\n            }\n        }\n\n        // Add node label padding that aren't set yet\n        // This happens if e.g. a top inset is set but no top label is present\n        padding.top    = Math.max(padding.top, nodeLabelPadding.top);\n        padding.left   = Math.max(padding.left, nodeLabelPadding.left);\n        padding.right  = Math.max(padding.right, nodeLabelPadding.right);\n        padding.bottom = Math.max(padding.bottom, nodeLabelPadding.bottom);\n\n        return padding;\n    }\n\n",
    "label": 1,
    "rec": "@param nodeLabelPadding the additional padding for node labels on this node"
  },
  {
    "id": 169,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean update(CacheObject key, CacheObject val, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, val, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 170,
    "type": "Param",
    "comment": "@param buf String buffer.",
    "code": "    private StringBuilder addFlag(StringBuilder sb, int flags, int mask, String flagName) {\n        if ((flags & mask) > 0)\n            sb.append(sb.length() > 0 ? \",\" : \"\").append(flagName);\n\n        return sb;\n    }\n",
    "label": 1,
    "rec": "@param sb String builder."
  },
  {
    "id": 171,
    "type": "Param",
    "comment": "@param idToken",
    "code": "    public static ProtocolMapperRepresentation createAddressMapper(boolean idToken, boolean accessToken, boolean userInfo) {\n        return ModelToRepresentation.toRepresentation(AddressMapper.createAddressMapper(idToken, accessToken, userInfo));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 172,
    "type": "Param",
    "comment": "@param clazz",
    "code": "    private Set<Field> scanForInjection(final Object testClassInstance, final Class<?> clazz) {\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null != field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }\n",
    "label": 1,
    "rec": "@param clazz Current class in the hierarchy of the test"
  },
  {
    "id": 173,
    "type": "Param",
    "comment": "@param task",
    "code": "    public static Metadata newTagMetadata(Task task, String tagName, BigInteger tagUuid) {\n        return newTagMetadata(task.getId(), task.getValue(Task.UUID), tagName, tagUuid);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 174,
    "type": "Param",
    "comment": "@param grid Grid instance.",
    "code": "    private GridSwapSpaceManager getSwapSpaceManager(Ignite ignite) {\n        assert ignite != null;\n\n        return ((GridKernal) ignite).context().swap();\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid instance."
  },
  {
    "id": 175,
    "type": "Param",
    "comment": "@param val New value.",
    "code": "    @Override protected void clearIndex(CacheObject val, GridCacheVersion ver) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 176,
    "type": "Param",
    "comment": "@param base",
    "code": "    public int startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode) {\n        if (mFrom == DLConstants.FROM_INTERNAL) {\n            dlIntent.setClassName(context, dlIntent.getPluginClass());\n            performStartActivityForResult(context, dlIntent, requestCode);\n            return DLPluginManager.START_RESULT_SUCCESS;\n        }\n\n        String packageName = dlIntent.getPluginPackage();\n        if (packageName == null) {\n            throw new NullPointerException(\"disallow null packageName.\");\n        }\n        DLPluginPackage pluginPackage = mPackagesHolder.get(packageName);\n        if (pluginPackage == null) {\n            return START_RESULT_NO_PKG;\n        } \n\n        DexClassLoader classLoader = pluginPackage.classLoader;\n        String className = dlIntent.getPluginClass();\n        className = (className == null ? pluginPackage.getDefaultActivity() : className);\n        if (className.startsWith(\".\")) {\n            className = packageName + className;\n        }\n        Class<?> clazz = null;\n        try {\n            clazz = classLoader.loadClass(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return START_RESULT_NO_CLASS;\n        }\n\n        Class<? extends Activity> activityClass = null;\n        if (DLBasePluginActivity.class.isAssignableFrom(clazz)) {\n            activityClass = DLProxyActivity.class;\n        } else if (DLBasePluginFragmentActivity.class.isAssignableFrom(clazz)) {\n            activityClass = DLProxyFragmentActivity.class;\n        } else {\n            return START_RESULT_TYPE_ERROR;\n        }\n\n        dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);\n        dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);\n        dlIntent.setClass(mContext, activityClass);\n        performStartActivityForResult(context, dlIntent, requestCode);\n        return START_RESULT_SUCCESS;\n    }\n",
    "label": 1,
    "rec": "@param context"
  },
  {
    "id": 177,
    "type": "Param",
    "comment": "@param storeName",
    "code": "    public int rebalanceNode(String storeName, RebalancePartitionsInfo stealInfo) {\n        VAdminProto.InitiateRebalanceNodeRequest rebalanceNodeRequest = VAdminProto.InitiateRebalanceNodeRequest.newBuilder()\n                                                                                                                .setAttempt(stealInfo.getAttempt())\n                                                                                                                .setDonorId(stealInfo.getDonorId())\n                                                                                                                .setStealerId(stealInfo.getStealerId())\n                                                                                                                .setCurrentStore(storeName)\n                                                                                                                .addAllPartitions(stealInfo.getPartitionList())\n                                                                                                                .addAllUnbalancedStore(stealInfo.getUnbalancedStoreList())\n                                                                                                                .build();\n        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()\n                                                                                          .setType(VAdminProto.AdminRequestType.INITIATE_REBALANCE_NODE)\n                                                                                          .setInitiateRebalanceNode(rebalanceNodeRequest)\n                                                                                          .build();\n        VAdminProto.AsyncOperationStatusResponse.Builder response = sendAndReceive(stealInfo.getStealerId(),\n                                                                                   adminRequest,\n                                                                                   VAdminProto.AsyncOperationStatusResponse.newBuilder());\n\n        if(response.hasError())\n            throwException(response.getError());\n\n        return response.getRequestId();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 178,
    "type": "Param",
    "comment": "@param openShiftClient the OpenShift client to use",
    "code": "  public static OpenShiftConfig withApiGroup(OkHttpClient httpClient, String apiGroupName, OpenShiftConfig config) {\n    OpenShiftClient openShiftClient = new DefaultOpenShiftClient(httpClient, config);\n    return withApiGroup(openShiftClient, apiGroupName, config);\n  }\n",
    "label": 1,
    "rec": "@param httpClient the HTTP client to use"
  },
  {
    "id": 179,
    "type": "Param",
    "comment": "@param entry Preloaded entry.",
    "code": "        private boolean preloadEntry(GridNode pick, int p, GridCacheEntryInfo<K, V> entry, long topVer)\n            throws GridException, GridInterruptedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isGgfsDataCache() &&\n                        cctx.dht().ggfsDataSpaceUsed() > cctx.dht().ggfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload GGFS data cache (GGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (GridUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (GridInterruptedException e) {\n                throw e;\n            }\n            catch (GridException e) {\n                throw new GridException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 180,
    "type": "Param",
    "comment": "@param encoder the FlagEncoder (to specify the vehicle)",
    "code": "    public Weighting createWeighting( String weighting, FlagEncoder encoder )\n    {\n        // ignore case\n        weighting = weighting.toLowerCase();\n        if (\"fastest\".equals(weighting))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                return new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                return new FastestWeighting(encoder);\n        }\n        return new ShortestWeighting();\n    }\n",
    "label": 1,
    "rec": "@param encoder"
  },
  {
    "id": 181,
    "type": "Param",
    "comment": "@param maxIter the maximum number of iterations in case that the algorithm does not converge.",
    "code": "    public static double eigen(Matrix A, double[] v, double p, double tol, int maxIter) {\n        if (A.nrows() != A.ncols()) {\n            throw new IllegalArgumentException(\"Matrix is not square.\");\n        }\n\n        if (tol <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid tolerance: \" + tol);            \n        }\n        \n        if (maxIter <= 0) {\n            throw new IllegalArgumentException(\"Invalid maximum number of iterations: \" + maxIter);            \n        }\n        \n        int n = A.nrows();\n        tol = Math.max(tol, Math.EPSILON * n);\n\n        double[] z = new double[n];\n        double lambda = ax(A, v, z, p);\n\n        for (int iter = 1; iter <= maxIter; iter++) {\n            double l = lambda;\n            lambda = ax(A, v, z, p);\n\n            double eps = Math.abs(lambda - l);\n            if (iter % 10 == 0) {\n                logger.trace(String.format(\"Largest eigenvalue after %3d power iterations: %.5f\\n\", iter, lambda + p));\n            }\n\n            if (eps < tol) {\n                logger.info(String.format(\"Largest eigenvalue after %3d power iterations: %.5f\\n\", iter, lambda + p));\n                return lambda + p;\n            }\n        }\n\n        logger.info(String.format(\"Largest eigenvalue after %3d power iterations: %.5f\\n\", maxIter, lambda + p));\n        logger.error(\"Power iteration exceeded the maximum number of iterations.\");\n        return lambda + p;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 182,
    "type": "Param",
    "comment": "@param igniteHome  Ignition installation folder.",
    "code": "    public IgniteConfiguration setIgniteHome(String ggHome) {\n        this.ggHome = ggHome;\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param ggHome  Ignition installation folder."
  },
  {
    "id": 183,
    "type": "Param",
    "comment": "@param prj Projection.",
    "code": "    protected GridMessaging message(ClusterGroup prj) {\n        return prj.grid().message(prj);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 184,
    "type": "Param",
    "comment": "@param part Partition.",
    "code": "    public Collection<ClusterNode> backups(Object key, AffinityTopologyVersion topVer) {\n        return backups(partition(key), topVer);\n    }\n",
    "label": 1,
    "rec": "@param key Key to check."
  },
  {
    "id": 185,
    "type": "Param",
    "comment": "@param b the right hand side of linear equations.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol, int maxIter) {\n        if (tol <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid tolerance: \" + tol);\n        }\n\n        if (maxIter <= 0) {\n            throw new IllegalArgumentException(\"Invalid maximum number of iterations: \" + maxIter);\n        }\n\n        if (itol < 1 || itol > 4) {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        double err = 0.0;\n        double ak, akden, bk, bkden = 1.0, bknum, bnrm, dxnrm, xnrm, zm1nrm, znrm = 0.0;\n        int j, n = b.length;\n\n        double[] p = new double[n];\n        double[] pp = new double[n];\n        double[] r = new double[n];\n        double[] rr = new double[n];\n        double[] z = new double[n];\n        double[] zz = new double[n];\n\n        A.ax(x, r);\n        for (j = 0; j < n; j++) {\n            r[j] = b[j] - r[j];\n            rr[j] = r[j];\n        }\n\n        if (itol == 1) {\n            bnrm = snorm(b, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 2) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 3 || itol == 4) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n            znrm = snorm(z, itol);\n        } else {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        for (int iter = 1; iter <= maxIter; iter++) {\n            Ap.asolve(rr, zz);\n            for (bknum = 0.0, j = 0; j < n; j++) {\n                bknum += z[j] * rr[j];\n            }\n            if (iter == 1) {\n                for (j = 0; j < n; j++) {\n                    p[j] = z[j];\n                    pp[j] = zz[j];\n                }\n            } else {\n                bk = bknum / bkden;\n                for (j = 0; j < n; j++) {\n                    p[j] = bk * p[j] + z[j];\n                    pp[j] = bk * pp[j] + zz[j];\n                }\n            }\n            bkden = bknum;\n            A.ax(p, z);\n            for (akden = 0.0, j = 0; j < n; j++) {\n                akden += z[j] * pp[j];\n            }\n            ak = bknum / akden;\n            A.atx(pp, zz);\n            for (j = 0; j < n; j++) {\n                x[j] += ak * p[j];\n                r[j] -= ak * z[j];\n                rr[j] -= ak * zz[j];\n            }\n            Ap.asolve(r, z);\n            if (itol == 1) {\n                err = snorm(r, itol) / bnrm;\n            } else if (itol == 2) {\n                err = snorm(z, itol) / bnrm;\n            } else if (itol == 3 || itol == 4) {\n                zm1nrm = znrm;\n                znrm = snorm(z, itol);\n                if (Math.abs(zm1nrm - znrm) > Math.EPSILON * znrm) {\n                    dxnrm = Math.abs(ak) * snorm(p, itol);\n                    err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n                xnrm = snorm(x, itol);\n                if (err <= 0.5 * xnrm) {\n                    err /= xnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n            }\n\n            if (iter % 10 == 0) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n            }\n\n            if (err <= tol) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n                break;\n            }\n        }\n\n        return err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 186,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public boolean methodHasImplementation(String methodSignature) {\n        BuilderMethod method = getMethod(methodSignature);\n\n        return null != method.getImplementation();\n    }\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 187,
    "type": "Param",
    "comment": "@param mode One of  #PRIMARY,  #BACKUP or  #NOT_PRIMARY_AND_BACKUP.",
    "code": "    private Integer key(Ignite ignite, int mode) {\n        GridCache<Integer, Integer> cache = ignite.cache(null);\n\n        GridCacheAffinity<Integer> aff = cache.affinity();\n\n        Integer key = null;\n\n        for (int i = lastKey + 1; i < 1_000_000; i++) {\n            boolean pass = false;\n\n            switch(mode) {\n                case PRIMARY: pass = aff.isPrimary(ignite.cluster().localNode(), i); break;\n\n                case BACKUP: pass = aff.isBackup(ignite.cluster().localNode(), i); break;\n\n                case NOT_PRIMARY_AND_BACKUP: pass = !aff.isPrimaryOrBackup(ignite.cluster().localNode(), i); break;\n\n                default: fail();\n            }\n\n            lastKey = i;\n\n            if (pass) {\n                key = i;\n\n                break;\n            }\n        }\n\n        assertNotNull(key);\n\n        return key;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 188,
    "type": "Param",
    "comment": "@param r The $r$ value.",
    "code": "    public NaorPinkasShare<T> getShare(BigInteger r, T gr) {\n        T x = group.pow(gr, pi);\n        return new NaorPinkasShare<T>(t, r, i, x, group);\n    }\n\n",
    "label": 1,
    "rec": "@param r The integer $r$."
  },
  {
    "id": 189,
    "type": "Param",
    "comment": "@param key property key",
    "code": "    public Object getMapValue(Object obj, String key, boolean signalUndefined){\n        Map m = (Map) obj;\n        if(!m.containsKey(key) && signalUndefined){\n            return JsonProvider.UNDEFINED;\n        } else {\n            return m.get(key);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 190,
    "type": "Param",
    "comment": "@param userName the username from the user to remove",
    "code": "\tpublic boolean removeUser(String userId) {\n\n\t\tif (getUsers().containsKey(userId.toLowerCase())) {\n\t\t\tgetUsers().remove(userId.toLowerCase());\n\t\t\tsetUsersChanged(true);\n\t\t\tif (GroupManager.isLoaded())\n\t\t\t\tGroupManager.getGMEventHandler().callEvent(userId, GMUserEvent.Action.USER_REMOVED);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "label": 1,
    "rec": "@param userId the UUID or username for the user to remove"
  },
  {
    "id": 191,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, KeyCacheObject key, CacheObject val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key.internal())\n                return true;\n\n            Object storeKey = key.value(cctx);\n            Object storeVal = val.value(cctx);\n\n            if (convertPortable) {\n                storeKey = cctx.unwrapPortableIfNeeded(storeKey, false);\n                storeVal = cctx.unwrapPortableIfNeeded(storeVal, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(storeKey, locStore ? F.t(storeVal, ver) : storeVal));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + storeKey + \", val=\" + storeVal + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 192,
    "type": "Param",
    "comment": "@param additionalData additional data",
    "code": "  public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n      throws GeneralSecurityException {\n    if (plaintext.length > Integer.MAX_VALUE - snuffle.nonceSizeInBytes() - MAC_TAG_SIZE_IN_BYTES) {\n      throw new GeneralSecurityException(\"plaintext too long\");\n    }\n    ByteBuffer ciphertext =\n        ByteBuffer.allocate(plaintext.length + snuffle.nonceSizeInBytes() + MAC_TAG_SIZE_IN_BYTES);\n\n    encrypt(ciphertext, plaintext, associatedData);\n    return ciphertext.array();\n  }\n",
    "label": 1,
    "rec": "@param associatedData associated authenticated data"
  },
  {
    "id": 193,
    "type": "Param",
    "comment": "@param offset",
    "code": "    public boolean setbit(String key, long offset, boolean value) {\n        client.setbit(key, offset, value);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 194,
    "type": "Param",
    "comment": "@param username",
    "code": "    public List<MetadataBlock> reRoot(UUID rootBlockIdent, MetadataBlock targetBlock, MetadataBlock newTargetBlock) {\n        //Find all references to targetBlock and create new blocks restoring the original path to the user's root\n        // block\n        neo4JStorage.pathsFromTo(rootBlockIdent, targetBlock.ident);\n        //For all those references, do the same??\n        //LAST BLOCK MUST BE THE NEW ROOT\n        return Arrays.asList(MetadataBlock.emptyRandomBlock());\n    }\n\n",
    "label": 1,
    "rec": "@param rootBlockIdent"
  },
  {
    "id": 195,
    "type": "Param",
    "comment": "@param mode Mode.",
    "code": "    private GridGgfsFileInfo resolveFileInfo(IgniteFsPath path, GridGgfsMode mode) throws GridException {\n        assert path != null;\n        assert mode != null;\n\n        GridGgfsFileInfo info = null;\n\n        switch (mode) {\n            case PRIMARY:\n                info = meta.info(meta.fileId(path));\n\n                break;\n\n            case DUAL_SYNC:\n            case DUAL_ASYNC:\n                info = meta.info(meta.fileId(path));\n\n                if (info == null) {\n                    GridGgfsFile status = secondaryFs.info(path);\n\n                    if (status != null)\n                        info = status.isDirectory() ? new GridGgfsFileInfo(true, status.properties()) :\n                            new GridGgfsFileInfo(status.blockSize(), status.length(), null, null, false,\n                            status.properties());\n                }\n\n                break;\n\n            default:\n                assert false : \"Unknown mode: \" + mode;\n        }\n\n        return info;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 196,
    "type": "Param",
    "comment": "@param operateTimeout",
    "code": "    public BleManager setOperateTimeout(int count) {\n        this.operateTimeout = count;\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param count"
  },
  {
    "id": 197,
    "type": "Param",
    "comment": "@param negotiateHeader",
    "code": "    protected Response optionalChallengeRedirect(AuthenticationFlowContext context, String negotiateHeader) {\n        String accessCode = context.generateAccessCode();\n        URI action = getActionUrl(context, accessCode);\n\n        StringBuilder builder = new StringBuilder();\n\n        builder.append(\"<HTML>\");\n        builder.append(\"<HEAD>\");\n\n        builder.append(\"<TITLE>Kerberos Unsupported</TITLE>\");\n        builder.append(\"</HEAD>\");\n        if (bypassChallengeJavascript) {\n            builder.append(\"<BODY>\");\n\n        } else {\n            builder.append(\"<BODY Onload=\\\"document.forms[0].submit()\\\">\");\n        }\n        builder.append(\"<FORM METHOD=\\\"POST\\\" ACTION=\\\"\" + action.toString() + \"\\\">\");\n        builder.append(\"<NOSCRIPT>\");\n        builder.append(\"<P>JavaScript is disabled. We strongly recommend to enable it. You were unable to login via Kerberos.  Click the button below to login via an alternative method .</P>\");\n        builder.append(\"<INPUT name=\\\"continue\\\" TYPE=\\\"SUBMIT\\\" VALUE=\\\"CONTINUE\\\" />\");\n        builder.append(\"</NOSCRIPT>\");\n\n        builder.append(\"</FORM></BODY></HTML>\");\n        return Response.status(Response.Status.UNAUTHORIZED)\n                .header(HttpHeaders.WWW_AUTHENTICATE, negotiateHeader)\n                .type(MediaType.TEXT_HTML_TYPE)\n                .entity(builder.toString()).build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 198,
    "type": "Param",
    "comment": "@param defaultValue Default value.",
    "code": "    private boolean getBooleanProperty(String name, boolean dfltVal) {\n        String val = manager.getProperty(name);\n\n        if (val == null)\n            return dfltVal;\n\n        val = val.toLowerCase();\n\n        if (\"true\".equals(val) || \"1\".equals(val))\n            return true;\n\n        if (\"false\".equals(val) || \"0\".equals(val))\n            return false;\n\n        return dfltVal;\n    }\n",
    "label": 1,
    "rec": "@param dfltVal Default value."
  },
  {
    "id": 199,
    "type": "Param",
    "comment": "@param node Grid node.",
    "code": "    private GridClientNodeBean createNodeBean(ClusterNode node, boolean mtr, boolean attr) {\n        assert node != null;\n\n        GridClientNodeBean nodeBean = new GridClientNodeBean();\n\n        nodeBean.setNodeId(node.id());\n        nodeBean.setConsistentId(node.consistentId());\n        nodeBean.setTcpPort(attribute(node, ATTR_REST_TCP_PORT, 0));\n\n        nodeBean.setTcpAddresses(nonEmptyList(node.<Collection<String>>attribute(ATTR_REST_TCP_ADDRS)));\n        nodeBean.setTcpHostNames(nonEmptyList(node.<Collection<String>>attribute(ATTR_REST_TCP_HOST_NAMES)));\n\n        Integer dfltReplicaCnt = node.attribute(GridCacheConsistentHashAffinityFunction.DFLT_REPLICA_COUNT_ATTR_NAME);\n\n        if (dfltReplicaCnt == null)\n            dfltReplicaCnt = GridCacheConsistentHashAffinityFunction.DFLT_REPLICA_COUNT;\n\n        nodeBean.setReplicaCount(dfltReplicaCnt);\n\n        GridCacheAttributes[] caches = node.attribute(ATTR_CACHE);\n\n        if (!F.isEmpty(caches)) {\n            Map<String, String> cacheMap = new HashMap<>();\n\n            for (GridCacheAttributes cacheAttr : caches) {\n                if (ctx.cache().systemCache(cacheAttr.cacheName()))\n                    continue;\n\n                if (cacheAttr.cacheName() != null)\n                    cacheMap.put(cacheAttr.cacheName(), cacheAttr.cacheMode().toString());\n                else\n                    nodeBean.setDefaultCacheMode(cacheAttr.cacheMode().toString());\n            }\n\n            nodeBean.setCaches(cacheMap);\n        }\n\n        if (mtr) {\n            GridNodeMetrics metrics = node.metrics();\n\n            GridClientNodeMetricsBean metricsBean = new GridClientNodeMetricsBean();\n\n            metricsBean.setStartTime(metrics.getStartTime());\n            metricsBean.setAverageActiveJobs(metrics.getAverageActiveJobs());\n            metricsBean.setAverageCancelledJobs(metrics.getAverageCancelledJobs());\n            metricsBean.setAverageCpuLoad(metrics.getAverageCpuLoad());\n            metricsBean.setAverageJobExecuteTime(metrics.getAverageJobExecuteTime());\n            metricsBean.setAverageJobWaitTime(metrics.getAverageJobWaitTime());\n            metricsBean.setAverageRejectedJobs(metrics.getAverageRejectedJobs());\n            metricsBean.setAverageWaitingJobs(metrics.getAverageWaitingJobs());\n            metricsBean.setCurrentActiveJobs(metrics.getCurrentActiveJobs());\n            metricsBean.setCurrentCancelledJobs(metrics.getCurrentCancelledJobs());\n            metricsBean.setCurrentCpuLoad(metrics.getCurrentCpuLoad());\n            metricsBean.setCurrentGcCpuLoad(metrics.getCurrentGcCpuLoad());\n            metricsBean.setCurrentDaemonThreadCount(metrics.getCurrentDaemonThreadCount());\n            metricsBean.setCurrentIdleTime(metrics.getCurrentIdleTime());\n            metricsBean.setCurrentJobExecuteTime(metrics.getCurrentJobExecuteTime());\n            metricsBean.setCurrentJobWaitTime(metrics.getCurrentJobWaitTime());\n            metricsBean.setCurrentRejectedJobs(metrics.getCurrentRejectedJobs());\n            metricsBean.setCurrentThreadCount(metrics.getCurrentThreadCount());\n            metricsBean.setCurrentWaitingJobs(metrics.getCurrentWaitingJobs());\n            metricsBean.setHeapMemoryCommitted(metrics.getHeapMemoryCommitted());\n            metricsBean.setHeapMemoryInitialized(metrics.getHeapMemoryInitialized());\n            metricsBean.setHeapMemoryMaximum(metrics.getHeapMemoryMaximum());\n            metricsBean.setHeapMemoryUsed(metrics.getHeapMemoryUsed());\n            metricsBean.setLastDataVersion(metrics.getLastDataVersion());\n            metricsBean.setLastUpdateTime(metrics.getLastUpdateTime());\n            metricsBean.setMaximumActiveJobs(metrics.getMaximumActiveJobs());\n            metricsBean.setMaximumCancelledJobs(metrics.getMaximumCancelledJobs());\n            metricsBean.setMaximumJobExecuteTime(metrics.getMaximumJobExecuteTime());\n            metricsBean.setMaximumJobWaitTime(metrics.getMaximumJobWaitTime());\n            metricsBean.setMaximumRejectedJobs(metrics.getMaximumRejectedJobs());\n            metricsBean.setMaximumThreadCount(metrics.getMaximumThreadCount());\n            metricsBean.setMaximumWaitingJobs(metrics.getMaximumWaitingJobs());\n            metricsBean.setNodeStartTime(metrics.getNodeStartTime());\n            metricsBean.setNonHeapMemoryCommitted(metrics.getNonHeapMemoryCommitted());\n            metricsBean.setNonHeapMemoryInitialized(metrics.getNonHeapMemoryInitialized());\n            metricsBean.setNonHeapMemoryMaximum(metrics.getNonHeapMemoryMaximum());\n            metricsBean.setNonHeapMemoryUsed(metrics.getNonHeapMemoryUsed());\n            metricsBean.setStartTime(metrics.getStartTime());\n            metricsBean.setTotalCancelledJobs(metrics.getTotalCancelledJobs());\n            metricsBean.setTotalCpus(metrics.getTotalCpus());\n            metricsBean.setTotalExecutedJobs(metrics.getTotalExecutedJobs());\n            metricsBean.setTotalIdleTime(metrics.getTotalIdleTime());\n            metricsBean.setTotalRejectedJobs(metrics.getTotalRejectedJobs());\n            metricsBean.setTotalStartedThreadCount(metrics.getTotalStartedThreadCount());\n            metricsBean.setTotalExecutedTasks(metrics.getTotalExecutedTasks());\n            metricsBean.setSentMessagesCount(metrics.getSentMessagesCount());\n            metricsBean.setSentBytesCount(metrics.getSentBytesCount());\n            metricsBean.setReceivedMessagesCount(metrics.getReceivedMessagesCount());\n            metricsBean.setReceivedBytesCount(metrics.getReceivedBytesCount());\n            metricsBean.setUpTime(metrics.getUpTime());\n\n            nodeBean.setMetrics(metricsBean);\n        }\n\n        if (attr) {\n            Map<String, Object> attrs = new HashMap<>(node.attributes());\n\n            attrs.remove(ATTR_CACHE);\n            attrs.remove(ATTR_SECURITY_SUBJECT);\n            attrs.remove(ATTR_SECURITY_CREDENTIALS);\n\n            for (Iterator<Map.Entry<String, Object>> i = attrs.entrySet().iterator(); i.hasNext();) {\n                Map.Entry<String, Object> e = i.next();\n\n                if (!e.getKey().startsWith(\"org.gridgain.\") && System.getProperty(e.getKey()) == null) {\n                    i.remove();\n\n                    continue;\n                }\n\n                if (e.getValue() != null) {\n                  if (e.getValue().getClass().isEnum() || e.getValue() instanceof InetAddress)\n                      e.setValue(e.getValue().toString());\n                  else if (e.getValue().getClass().isArray())\n                      i.remove();\n                }\n            }\n\n            nodeBean.setAttributes(attrs);\n        }\n\n        return nodeBean;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 200,
    "type": "Param",
    "comment": "@param executionType  ExecutionType",
    "code": "    public static Object execute(HystrixExecutable executable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {\n        Validate.notNull(executable);\n        Validate.notNull(metaHolder);\n\n        switch (executionType) {\n            case SYNCHRONOUS: {\n                return executable.execute();\n            }\n            case ASYNCHRONOUS: {\n                if(metaHolder.hasFallbackMethodCommand()\n                        && ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()){\n                    return new FutureDecorator(executable.queue());\n                }\n                return executable.queue();\n            }\n            case OBSERVABLE: {\n                return executable.observe();\n            }\n            default:\n                throw new RuntimeException(\"unsupported execution type: \" + executionType);\n        }\n    }\n",
    "label": 1,
    "rec": "@param metaHolder  MetaHolder"
  },
  {
    "id": 201,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private Collection<GridNode> affinityNodes(Ignite g, int p) {\n        return affinity(g).mapPartitionToPrimaryAndBackups(p);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 202,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static TimerTask scheduleQuery(final Ignite g, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = g.streamer(\"priceBars\");\n\n                try {\n                    Collection<Bar> bars = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext, Collection<Bar>>() {\n                            @Override public Collection<Bar> apply(StreamerContext ctx) {\n                                Collection<Bar> values = ctx.<String, Bar>localSpace().values();\n\n                                Collection<Bar> res = new ArrayList<>(values.size());\n\n                                for (Bar bar : values)\n                                    res.add(bar.copy());\n\n                                return res;\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new IgniteReducer<Collection<Bar>, Collection<Bar>>() {\n                            private final Collection<Bar> res = new ArrayList<>();\n\n                            @Override public boolean collect(@Nullable Collection<Bar> col) {\n                                res.addAll(col);\n\n                                return true;\n                            }\n\n                            @Override public Collection<Bar> reduce() {\n                                return res;\n                            }\n                        }\n                    );\n\n                    for (Bar bar : bars)\n                        System.out.println(bar.toString());\n\n                    System.out.println(\"-----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 2000, 2000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 203,
    "type": "Param",
    "comment": "@param cfg Configuration to check.",
    "code": "    public static boolean isAffinityNode(CacheConfiguration cfg) {\n        if (cfg.getCacheMode() == LOCAL)\n            return true;\n\n        GridCacheDistributionMode partTax = cfg.getDistributionMode();\n\n        if (partTax == null)\n            partTax = distributionMode(cfg);\n\n        return partTax == GridCacheDistributionMode.PARTITIONED_ONLY ||\n            partTax == GridCacheDistributionMode.NEAR_PARTITIONED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 204,
    "type": "Param",
    "comment": "@param resource",
    "code": "\tprivate NormalizedURI normalizeResource(String identifier) {\n\t\t// try to parse the URI\t\t\n\t\t// NOTE: we can't use the Java built-in URI class because it doesn't split the parts appropriately\n\t\t\n\t\tif (Strings.isNullOrEmpty(identifier)) {\n\t\t\tlogger.warn(\"Can't normalize null or empty URI: \" + identifier);\n\t\t\treturn null; // nothing we can do\n\t\t} else {\n\t\t\t\t\n    \t\tNormalizedURI n = new NormalizedURI();    \t\t\n    \t\tMatcher m = pattern.matcher(identifier);\n\t\t\n\t\t\tif (m.matches()) {\n\t\t\t\tn.scheme = m.group(1); // includes colon and maybe initial slashes\n\t\t\t\tn.user = m.group(2); // includes at sign\n\t\t\t\tn.hostportpath = m.group(4);\n\t\t\t\tn.query = m.group(5); // includes question mark\n\t\t\t\tn.hash = m.group(7); // includes hash mark\n\t\t\t\t\n\t\t\t\t// normalize scheme portion\n\t\t\t\tif (Strings.isNullOrEmpty(n.scheme)) {\n\t\t\t\t\tif (!Strings.isNullOrEmpty(n.user)) {\n\t\t\t\t\t\t// no scheme, but have a user, assume acct:\n\t\t\t\t\t\tn.scheme = \"acct:\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// no scheme, no user, assume https://\n\t\t\t\t\t\tn.scheme = \"https://\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tn.source = Strings.nullToEmpty(n.scheme) +\n\t\t\t\t\t\tStrings.nullToEmpty(n.user) +\n\t\t\t\t\t\tStrings.nullToEmpty(n.hostportpath) + \n\t\t\t\t\t\tStrings.nullToEmpty(n.query); // note: leave fragment off\n\t\t\t\t\n\t\t\t\treturn n;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Parser couldn't match input: \" + identifier);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n",
    "label": 1,
    "rec": "@param identifier"
  },
  {
    "id": 205,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public List<ClusterNode> nodes(Object key, long topVer) {\n        return nodes(partition(key), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 206,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static CacheSet<String> initializeSet(Ignite ignite, String setName) throws IgniteCheckedException {\n        // Initialize new set.\n        CacheSet<String> set = ignite.cache(CACHE_NAME).dataStructures().set(setName, false, true);\n\n        // Initialize set items.\n        for (int i = 0; i < 10; i++)\n            set.add(Integer.toString(i));\n\n        System.out.println(\"Set size after initializing: \" + set.size());\n\n        return set;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 207,
    "type": "Param",
    "comment": "@param storeName Name of the store",
    "code": "    private Node getNodeIfPresent(int proxyNodeId) {\n        try {\n            return metadata.getCluster().getNodeById(proxyNodeId);\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to get proxyNode \" + proxyNodeId\n                                         + \" from current cluster \" + metadata.getCluster()\n                                         + \" at node \" + metadata.getNodeId(), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 208,
    "type": "Param",
    "comment": "@param throwOnMissing if true a PathNotFoundException is thrown if property is missing",
    "code": "    public Object getMapValue(Object obj, String key, boolean signalUndefined){\n        Map m = (Map) obj;\n        if(!m.containsKey(key) && signalUndefined){\n            return JsonProvider.UNDEFINED;\n        } else {\n            return m.get(key);\n        }\n    }\n",
    "label": 1,
    "rec": "@param signalUndefined if true the constant  com.jayway.jsonpath.spi.json.JsonProvider#UNDEFINED is returned for missing properties"
  },
  {
    "id": 209,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public IgniteInternalFuture<Boolean> finishTxs(AffinityTopologyVersion topVer) {\n        GridCompoundFuture<IgniteInternalTx, Boolean> res =\n            new GridCompoundFuture<>(context().kernalContext(),\n                new IgniteReducer<IgniteInternalTx, Boolean>() {\n                    @Override public boolean collect(IgniteInternalTx e) {\n                        return true;\n                    }\n\n                    @Override public Boolean reduce() {\n                        return true;\n                    }\n                });\n\n        for (IgniteInternalTx<K, V> tx : txs()) {\n            // Must wait for all transactions, even for DHT local and DHT remote since preloading may acquire\n            // values pending to be overwritten by prepared transaction.\n\n            if (tx.concurrency() == PESSIMISTIC) {\n                if (tx.topologyVersion().compareTo(AffinityTopologyVersion.ZERO) > 0\n                    && tx.topologyVersion().compareTo(topVer) < 0)\n                    // For PESSIMISTIC mode we must wait for all uncompleted txs\n                    // as we do not know in advance which keys will participate in tx.\n                    res.add(tx.finishFuture());\n            }\n            else if (tx.concurrency() == OPTIMISTIC) {\n                // For OPTIMISTIC mode we wait only for txs in PREPARING state that\n                // have keys for given partitions.\n                TransactionState state = tx.state();\n                AffinityTopologyVersion txTopVer = tx.topologyVersion();\n\n                if ((state == PREPARING || state == PREPARED || state == COMMITTING)\n                    && txTopVer.compareTo(AffinityTopologyVersion.ZERO) > 0 && txTopVer.compareTo(topVer) < 0) {\n                    res.add(tx.finishFuture());\n                }\n            }\n        }\n\n        res.markInitialized();\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 210,
    "type": "Param",
    "comment": "@param authorizationRequest the current authorization request",
    "code": "\tprotected boolean isRefreshTokenSupported(String grantType) {\n\t\treturn \"authorization_code\".equals(grantType) || \"password\".equals(grantType)\n\t\t\t\t|| \"refresh_token\".equals(grantType);\n\t}\n",
    "label": 1,
    "rec": "@param grantType the current grant type"
  },
  {
    "id": 211,
    "type": "Param",
    "comment": "@param fileName Name of the file to read.",
    "code": "    protected String readAndSortFile(String fileName, Configuration conf) throws Exception {\n        final List<String> list = new ArrayList<>();\n\n        final boolean snappyDecode = conf != null && conf.getBoolean(FileOutputFormat.COMPRESS, false);\n\n        if (snappyDecode) {\n            try (SequenceFile.Reader reader = new SequenceFile.Reader(conf,\n                    SequenceFile.Reader.file(new Path(fileName)))) {\n                Text key = new Text();\n\n                IntWritable val = new IntWritable();\n\n                while (reader.next(key, val))\n                    list.add(key + \"\\t\" + val);\n            }\n        }\n        else {\n            try (InputStream is0 = igfs.open(new IgfsPath(fileName))) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is0));\n\n                String line;\n\n                while ((line = reader.readLine()) != null)\n                    list.add(line);\n            }\n        }\n\n        Collections.sort(list);\n\n        return Joiner.on('\\n').join(list) + \"\\n\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 212,
    "type": "Param",
    "comment": "@param image the scanned barcode image.",
    "code": "  private static ResultPoint[] findVertices180(BitMatrix matrix) throws ReaderException {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    int[] loc = null;\n    // Top Left\n    for (int i = height - 1; i > 0; i--) {\n      loc = findGuardPattern(matrix, halfWidth, i, halfWidth, START_PATTERN_REVERSE);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[1], i);\n        result[4] = new ResultPoint(loc[0], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom Left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, START_PATTERN_REVERSE);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[1], i);\n          result[5] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Top Right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        loc = findGuardPattern(matrix, 0, i, halfWidth, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[0], i);\n          result[6] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom Right\n    if (found) { // Found the Top Right vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        loc = findGuardPattern(matrix, 0, i, halfWidth, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[0], i);\n          result[7] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n",
    "label": 1,
    "rec": "@param matrix the scanned barcode image."
  },
  {
    "id": 213,
    "type": "Param",
    "comment": "@param msg the message",
    "code": "  private static int determineConsecutiveDigitCount(CharSequence msg, int startpos) {\n    int count = 0;\n    int len = msg.length();\n    int idx = startpos;\n    if (idx < len) {\n      char ch = msg.charAt(idx);\n      while (isDigit(ch) && idx < len) {\n        count++;\n        idx++;\n        if (idx < len) {\n          ch = msg.charAt(idx);\n        }\n      }\n    }\n    return count;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 214,
    "type": "Param",
    "comment": "@param createDate",
    "code": "    public int delete(Date now) {\n        if (null != now) {\n            QueryHandler queryHandler = getQueryHandler(\"delete from SysUserToken bean\");\n            queryHandler.condition(\"bean.expiryDate is not null\");\n            queryHandler.condition(\"bean.expiryDate <= :expiryDate\").setParameter(\"expiryDate\", now);\n            return delete(queryHandler);\n        }\n        return 0;\n    }\n",
    "label": 1,
    "rec": "@param now"
  },
  {
    "id": 215,
    "type": "Param",
    "comment": "@param listId",
    "code": "    public String getListName(String listId) {\n        readLists();\n        for(StoreObject list : lists)\n            if(list.getValue(GtasksList.REMOTE_ID).equals(listId))\n                return list.getValue(GtasksList.NAME);\n        return LIST_NOT_FOUND;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 216,
    "type": "Param",
    "comment": "@param originatingHost the originating host InetAddress of the external party (user, 3rd party product, etc) that is attempting to initiate the session, or  null if not known.",
    "code": "    public Session createSession(String host) {\n        return new SimpleSession(host);\n    }\n",
    "label": 1,
    "rec": "@param host the originating host name or IP string of the external party (user, 3rd party product, etc) that is attempting to initiate the session, or  null if not known."
  },
  {
    "id": 217,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    private boolean map(KeyCacheObject key, Collection<GridDhtLocalPartition> parts) {\n        GridDhtLocalPartition part = topVer > 0 ?\n            cache().topology().localPartition(cctx.affinity().partition(key), topVer, true) :\n            cache().topology().localPartition(key, false);\n\n        if (part == null)\n            return false;\n\n        if (!parts.contains(part)) {\n            // By reserving, we make sure that partition won't be unloaded while processed.\n            if (part.reserve()) {\n                parts.add(part);\n\n                return true;\n            }\n            else\n                return false;\n        }\n        else\n            return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 218,
    "type": "Param",
    "comment": "@param field the field to extract from the document alt. the documents contained in the array",
    "code": "    private Object getContainerValue(Object container, JSONPathFragment fragment) {\n        Object result;\n\n        if (container instanceof JSONArray) {\n            List list = new LinkedList();\n            for (Object doc : toArray(container)) {\n                list.add(getContainerValue(doc, fragment));\n            }\n            result = list;\n\n        } else if (container instanceof JSONObject) {\n            JSONObject document = toDocument(container);\n\n            if (!document.containsKey(fragment.value())) {\n                throw new InvalidPathException(\"Invalid path element: \" + currentPath + \" <==\");\n            }\n\n            result = document.get(fragment.value());\n        } else {\n            throw new InvalidPathException(\"Invalid path element: \" + currentPath + \" <==\");\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param fragment the field to extract from the document alt. the documents contained in the array"
  },
  {
    "id": 219,
    "type": "Param",
    "comment": "@param msgId Message ID.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, long topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!U.hasNearCache(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listen(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        cctx.kernalContext().closure().runLocalSafe(new GridPlainRunnable() {\n                            @Override public void run() {\n                                synchronized (this) {\n                                    // Release memory.\n                                    reader0.resetTxFuture();\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 220,
    "type": "Param",
    "comment": "@param ctx Cache context.",
    "code": "    public static boolean cacheNode(String cacheName, GridCacheAttributes[] caches) {\n        if (caches != null)\n            for (GridCacheAttributes attrs : caches)\n                if (F.eq(cacheName, attrs.cacheName()))\n                    return true;\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param cacheName Cache name."
  },
  {
    "id": 221,
    "type": "Param",
    "comment": "@param msg",
    "code": "    public ZuulMessage processSyncFilter(ZuulMessage msg, SyncZuulFilter filter, boolean shouldSendErrorResponse)\n    {\n        final FilterExecInfo info = new FilterExecInfo();\n        info.bDebug = msg.getContext().debugRouting();\n\n        if (info.bDebug) {\n            Debug.addRoutingDebug(msg.getContext(), \"Filter \" + filter.filterType().toString() + \" \" + filter.filterOrder() + \" \" + filter.filterName());\n            info.debugCopy = msg.clone();\n        }\n\n        // Apply this filter.\n        ZuulMessage result;\n        long ltime = System.currentTimeMillis();\n        try {\n            if (filter.isDisabled()) {\n                result = filter.getDefaultOutput(msg);\n                info.status = DISABLED;\n            }\n            else if (msg.getContext().shouldStopFilterProcessing()) {\n                // This is typically set by a filter when wanting to reject a request, and also reduce load on the server by\n                // not processing any more filters.\n                result = filter.getDefaultOutput(msg);\n                info.status = SKIPPED;\n            }\n            else {\n                // Only apply the filter if both the shouldFilter() method AND the filter has a priority of\n                // equal or above the requested.\n                int requiredPriority = msg.getContext().getFilterPriorityToApply();\n                ZuulMessage input = chooseFilterInput(filter, msg);\n                if (isFilterPriority(filter, requiredPriority) && filter.shouldFilter(input)) {\n                    result = filter.apply(input);\n\n                    // If no result returned from filter, then use the original input.\n                    if (result == null) {\n                        result = filter.getDefaultOutput(msg);\n                    }\n                }\n                else {\n                    result = filter.getDefaultOutput(msg);\n                    info.status = SKIPPED;\n                }\n            }\n        }\n        catch (Exception e) {\n            result = filter.getDefaultOutput(msg);\n            msg.getContext().setError(e);\n            if (shouldSendErrorResponse) msg.getContext().setShouldSendErrorResponse(true);\n            info.status = FAILED;\n            recordFilterError(filter, msg, e);\n        }\n\n        // Record info when filter processing completes.\n        if (info.status == null) {\n            info.status = SUCCESS;\n        }\n        info.execTime = System.currentTimeMillis() - ltime;\n        recordFilterCompletion(result, filter, info);\n\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 222,
    "type": "Param",
    "comment": "@param weightingParameters the request parameters",
    "code": "    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )\n    {\n        String weighting = wMap.getWeighting();\n        Weighting result;\n\n        if (\"shortest\".equalsIgnoreCase(weighting))\n        {\n            result = new ShortestWeighting();\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty())\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                result = new PriorityWeighting(encoder);\n            else\n                result = new FastestWeighting(encoder);\n        } else\n        {\n            throw new UnsupportedOperationException(\"weighting \" + weighting + \" not supported\");\n        }\n\n        if (encoder.supportsTurnCosts())\n        {\n            result = new TurnWeighting(result, encoder, (TurnCostStorage) graph.getExtendedStorage());\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param wMap all parameters influencing the weighting. E.g. URL parameters coming via GHRequest"
  },
  {
    "id": 223,
    "type": "Param",
    "comment": "@param cfg Cache configuration.",
    "code": "    private GridCacheQueryManager queryManager(CacheConfiguration cfg) {\n        return cfg.getCacheMode() == LOCAL ? new GridCacheLocalQueryManager() : new GridCacheDistributedQueryManager();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 224,
    "type": "Param",
    "comment": "@param expected expected value",
    "code": "    public static Criteria create(String left, String operator, String right) {\n        Object leftPrepared = left;\n        Object rightPrepared = right;\n        Path leftPath = null;\n        Path rightPath = null;\n\n        if(isPath(left)){\n            leftPath = PathCompiler.compile(left);\n            if(!leftPath.isDefinite()){\n                throw new InvalidPathException(\"the predicate path: \" + left + \" is not definite\");\n            }\n            leftPrepared = leftPath;\n        } else if(isString(left)) {\n            leftPrepared = left.substring(1, left.length() - 1);\n        }\n\n        if(isPath(right)){\n            rightPath = PathCompiler.compile(right);\n            if(!rightPath.isDefinite()){\n                throw new InvalidPathException(\"the predicate path: \" + right + \" is not definite\");\n            }\n            rightPrepared = rightPath;\n        } else if(isString(right)) {\n            rightPrepared = right.substring(1, right.length() - 1);\n        }\n\n        if(leftPath != null && operator.isEmpty()){\n            return Criteria.where(leftPath).exists(true);\n        } else {\n            return new Criteria(leftPrepared, CriteriaType.parse(operator), rightPrepared);\n        }\n    }\n",
    "label": 1,
    "rec": "@param right expected value"
  },
  {
    "id": 225,
    "type": "Param",
    "comment": "@param originKey The unique identifier used to reference the identity provider in UAA.",
    "code": "    public static IdentityProvider createIdentityProvider(String name, String originKey, boolean addShadowUserOnLogin, String baseUrl, ServerRunning serverRunning, SamlIdentityProviderDefinition samlIdentityProviderDefinition) throws Exception {\n        String zoneAdminToken = getZoneAdminToken(baseUrl, serverRunning);\n\n        samlIdentityProviderDefinition.setAddShadowUserOnLogin(addShadowUserOnLogin);\n        IdentityProvider provider = new IdentityProvider();\n        provider.setIdentityZoneId(OriginKeys.UAA);\n        provider.setType(OriginKeys.SAML);\n        provider.setActive(true);\n        provider.setConfig(samlIdentityProviderDefinition);\n        provider.setOriginKey(samlIdentityProviderDefinition.getIdpEntityAlias());\n        provider.setName(name);\n        provider = IntegrationTestUtils.createOrUpdateProvider(zoneAdminToken,baseUrl,provider);\n        assertNotNull(provider.getId());\n        return provider;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 226,
    "type": "Param",
    "comment": "@param edges an  Iterable of edges that shall be checked",
    "code": "    public static Iterator<KEdge> getConnectedEdges(final Iterable<KEdge> kedges) {\n        return Iterators.concat(\n                Iterators.transform(kedges.iterator(), new Function<KEdge, Iterator<KEdge>>() {\n\n            public Iterator<KEdge> apply(final KEdge kedge) {\n                return getConnectedEdges(kedge);\n            }\n        }));\n    }\n\n",
    "label": 1,
    "rec": "@param kedges an  Iterable of  KEdge KEdges that shall be checked"
  },
  {
    "id": 227,
    "type": "Param",
    "comment": "@param update Value to set.",
    "code": "    public boolean checkAndSet(IgnitePredicate<Long> p, long update) {\n        while (true) {\n            long cur = get();\n\n            if (p.apply(cur)) {\n                if (compareAndSet(cur, update))\n                    return true;\n            }\n            else\n                return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 228,
    "type": "Param",
    "comment": "@param clazz Class or inteface to extend or implement",
    "code": "    public static Factory enhance(Class cls, MethodInterceptor ih) {\n        return (Factory)enhanceHelper(cls.isInterface() ? null : cls,\n                                      cls.isInterface() ? new Class[]{ cls } : null,\n                                      ih, cls.getClassLoader(), null, null );\n    }\n\n",
    "label": 1,
    "rec": "@param cls Class or interface to extend or implement"
  },
  {
    "id": 229,
    "type": "Param",
    "comment": "@param value",
    "code": "    public static XMLGregorianCalendar subtract(XMLGregorianCalendar value, long millis) {\n        return add(value, - millis);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 230,
    "type": "Param",
    "comment": "@param createDate",
    "code": "    public int delete(Date now) {\n        return dao.delete(now);\n    }\n",
    "label": 1,
    "rec": "@param now"
  },
  {
    "id": 231,
    "type": "Param",
    "comment": "@param session",
    "code": "    public String delete(String path, Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysUser user = ControllerUtils.getAdminFromSession(session);\n        SysDept dept = sysDeptService.getEntity(user.getDeptId());\n        if (ControllerUtils.verifyNotEmpty(\"deptId\", user.getDeptId(), model)\n                || ControllerUtils.verifyNotEmpty(\"deptId\", dept, model)\n                || ControllerUtils.verifyCustom(\"noright\",\n                        !(dept.isOwnsAllPage() || null != sysDeptPageService.getEntity(new SysDeptPageId(user.getDeptId(),\n                                CommonConstants.SEPARATOR + TemplateComponent.INCLUDE_DIRECTORY + path))),\n                        model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        if (CommonUtils.notEmpty(ids)) {\n            SysSite site = getSite(request);\n            service.delete(site.getId(), ids, path);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.place\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), StringUtils.join(ids, ',')));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 232,
    "type": "Param",
    "comment": "@param end",
    "code": "  public String ltrim(final String key, final long start, final long stop) {\n    checkIsInMultiOrPipeline();\n    client.ltrim(key, start, stop);\n    return client.getStatusCodeReply();\n  }\n",
    "label": 1,
    "rec": "@param stop"
  },
  {
    "id": 233,
    "type": "Param",
    "comment": "@param expirationTime Expiration time.",
    "code": "    public boolean update(KeyCacheObject key, CacheObject val, GridCacheVersion ver, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, val, ver, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 234,
    "type": "Param",
    "comment": "@param cls Collection class.",
    "code": "    private Collection readCollection0(@Nullable BinaryCollectionFactory factory)\n        throws BinaryObjectException {\n        switch (checkFlag(COL)) {\n            case NORMAL:\n                return (Collection)PortableUtils.doReadCollection(in, ctx, ldr, this, true, factory);\n\n            case HANDLE: {\n                int handlePos = PortableUtils.positionForHandle(in) - in.readInt();\n\n                Object obj = getHandle(handlePos);\n\n                if (obj == null) {\n                    int retPos = in.position();\n\n                    streamPosition(handlePos);\n\n                    obj = readCollection0(factory);\n\n                    streamPosition(retPos);\n                }\n\n                return (Collection)obj;\n            }\n\n            default:\n                return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param factory Collection factory."
  },
  {
    "id": 235,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public List<ClusterNode> nodes(K key, long topVer) {\n        return nodes(partition(key), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 236,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskOutput createOutput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case REDUCE:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case MAP:\n                if (locCombiner) {\n                    assert local == null;\n\n                    local = get(job.info(), SHUFFLE_COMBINER_NO_SORTING, false) ?\n                        new GridHadoopHashMultimap(job, mem, get(job.info(), COMBINER_HASHMAP_SIZE, 8 * 1024)):\n                        new GridHadoopSkipList(job, mem, job.sortComparator()); // TODO replace with red-black tree\n\n                    return local.startAdding();\n                }\n\n            default:\n                return createOutput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 237,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorLifecycleConfiguration from(IgniteConfiguration c) {\n        VisorLifecycleConfiguration cfg = new VisorLifecycleConfiguration();\n\n        cfg.beans(compactArray(c.getLifecycleBeans()));\n        cfg.emailNotification(boolValue(GG_LIFECYCLE_EMAIL_NOTIFY, c.isLifeCycleEmailNotification()));\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 238,
    "type": "Param",
    "comment": "@param typeDescriptor",
    "code": "    public boolean isSafe(String typeSignature) {\n        String[] parts = typeSignature.split(\"->\");\n        String className = parts[0];\n\n        if (safeClasses.contains(className) && !unsafeMethods.contains(typeSignature)) {\n            return true;\n        }\n\n        if (parts.length > 1) {\n            // It's a method name\n            if (safeMethods.contains(typeSignature)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param typeSignature"
  },
  {
    "id": 239,
    "type": "Param",
    "comment": "@param ann Annotation.",
    "code": "    private GridLogger resource(IgniteLoggerResource ann, Object target) {\n        Class<?> cls = ann.categoryClass();\n        String cat = ann.categoryName();\n\n        GridLogger rsrc = getResource();\n\n        if (cls != null && cls != Void.class)\n            rsrc = rsrc.getLogger(cls);\n        else if (cat != null && !cat.isEmpty())\n            rsrc = rsrc.getLogger(cat);\n        else\n            rsrc = rsrc.getLogger(target.getClass());\n\n        return rsrc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 240,
    "type": "Param",
    "comment": "@param host the originating host name or IP string of the external party (user, 3rd party product, etc) that is attempting to initiate the session, or  null if not known.",
    "code": "    public Session createSession(SessionContext initData) {\r\n        if (initData != null) {\r\n            String host = initData.getHost();\r\n            if (host != null) {\r\n                return new SimpleSession(host);\r\n            }\r\n        }\r\n        return new SimpleSession();\r\n    }\r\n\n",
    "label": 1,
    "rec": "@param initData the initialization data to be used during  Session creation."
  },
  {
    "id": 241,
    "type": "Param",
    "comment": "@param key",
    "code": "  public Long incrBy(final String key, final long increment) {\n    checkIsInMultiOrPipeline();\n    client.incrBy(key, increment);\n    return client.getIntegerReply();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 242,
    "type": "Param",
    "comment": "@param requestCode if this equals the requestCode specified by constructor, then results of voice-recognition",
    "code": "    public boolean handleActivityResult(int activityRequestCode, int resultCode, Intent data) {\n        boolean result = false;\n        // handle the result of voice recognition, put it into the textfield\n        if (activityRequestCode == this.requestCode) {\n            // this was handled here, even if voicerecognition fails for any reason\n            // so your program flow wont get chaotic if you dont explicitly state\n            // your own requestCodes.\n            result = true;\n            if (resultCode == Activity.RESULT_OK) {\n                // Fill the quickAddBox-view with the string the recognizer thought it could have heard\n                ArrayList<String> match = data.getStringArrayListExtra(\n                        RecognizerIntent.EXTRA_RESULTS);\n                // make sure we only do this if there is SomeThing (tm) returned\n                if (match != null && match.size() > 0 && match.get(0).length() > 0) {\n                    Editable currentText = textField.getText();\n                    String recognizedSpeech = match.get(0);\n\n                    if (currentText.length() > 0) {\n                        // if something is already typed in, append the recognized speech,\n                        // add a space if it isn't already there\n                        textField.append((currentText.toString().endsWith(\" \") ? recognizedSpeech : \" \"+recognizedSpeech ));\n                    } else {\n                        textField.setText(recognizedSpeech);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param activityRequestCode if this equals the requestCode specified by constructor, then results of voice-recognition"
  },
  {
    "id": 243,
    "type": "Param",
    "comment": "@param size the population size of Genetic Algorithm.",
    "code": "    public BitString[] learn(int size, int generation, double[][] x, int[] y, int k, ClassificationMeasure measure, BiFunction<double[][], int[], Classifier<double[]>> trainer) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        ClassificationFitness fitness = new ClassificationFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 244,
    "type": "Param",
    "comment": "@param ver Version.",
    "code": "    public IgniteInternalFuture<Boolean> txCommitted(GridCacheVersion xidVer) {\n        final GridFutureAdapter<Boolean> resFut = new GridFutureAdapter<>();\n\n        final IgniteInternalTx tx = cctx.tm().tx(xidVer);\n\n        if (tx != null) {\n            assert tx.near() && tx.local() : tx;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Found near transaction, will wait for completion: \" + tx);\n\n            tx.finishFuture().listen(new CI1<IgniteInternalFuture<IgniteInternalTx>>() {\n                @Override public void apply(IgniteInternalFuture<IgniteInternalTx> fut) {\n                    TransactionState state = tx.state();\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Near transaction finished with state: \" + state);\n\n                    resFut.onDone(state == COMMITTED);\n                }\n            });\n\n            return resFut;\n        }\n\n        Boolean committed = null;\n\n        for (Map.Entry<GridCacheVersion, Boolean> entry : completedVers.entrySet()) {\n            if (entry.getValue() == null)\n                continue;\n\n            if (entry.getKey() instanceof CommittedVersion) {\n                CommittedVersion comm = (CommittedVersion)entry.getKey();\n\n                if (comm.nearVer.equals(xidVer)) {\n                    committed = entry.getValue();\n\n                    break;\n                }\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Near transaction committed: \" + committed);\n\n        resFut.onDone(committed != null && committed);\n\n        return resFut;\n    }\n",
    "label": 1,
    "rec": "@param xidVer Version."
  },
  {
    "id": 245,
    "type": "Param",
    "comment": "@param keys Key.",
    "code": "    public boolean removeAllFromStore(@Nullable GridCacheTx tx, Collection<? extends K> keys) throws IgniteCheckedException {\n        if (F.isEmpty(keys))\n            return true;\n\n        if (keys.size() == 1) {\n            K key = keys.iterator().next();\n\n            return removeFromStore(tx, key);\n        }\n\n        if (store != null) {\n            Collection<? extends K> keys0;\n\n            keys0 = convertPortable ?\n                F.viewReadOnly(keys, new C1<K, K>() {\n                    @Override public K apply(K k) {\n                        return (K)cctx.unwrapPortableIfNeeded(k, false);\n                    }\n                }) :\n                keys;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Removing values from cache store [keys=\" + keys0 + ']');\n\n            try {\n                store.removeAll(tx, keys0);\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Removed values from cache store [keys=\" + keys0 + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 246,
    "type": "Param",
    "comment": "@param tweet the Tweet to send",
    "code": "\tpublic static boolean sendTweet(String tweetTxt) {\n\t\tif (!isEnabled) {\n\t\t\tlogger.debug(\"Twitter client is disabled > execution aborted!\");\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// abbreviate the Tweet to meet the 140 character limit ...\n\t\t\ttweetTxt = StringUtils.abbreviate(tweetTxt, CHARACTER_LIMIT);\n\t\t\t// send the Tweet\n\t\t\tStatus status = client.updateStatus(tweetTxt);\n\t\t\tlogger.debug(\"Successfully sent Tweet '{}'\", status.getText());\n\t\t\treturn true;\n\t\t} catch (TwitterException e) {\n\t\t\tlogger.error(\"Failed to send Tweet '\" + tweetTxt + \"' because of: \" + e.getLocalizedMessage());\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param tweetTxt the Tweet to send"
  },
  {
    "id": 247,
    "type": "Param",
    "comment": "@param end",
    "code": "    public String ltrim(final String key, final long start, final long end) {\n        checkIsInMulti();\n        client.ltrim(key, start, end);\n        return client.getStatusCodeReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 248,
    "type": "Param",
    "comment": "@param incrementBy Amount used to pay off this charge",
    "code": "    public Money updatePaidAmountBy(final Money incrementBy,final Integer installmentNumber) {\n        Money processAmount = Money.zero(incrementBy.getCurrency());\n        if(this.isInstalmentFee()){\n            if(installmentNumber == null){\n                processAmount = getUnpaidInstallmentLoanCharge().updatePaidAmountBy(incrementBy);\n            }else{\n                processAmount = getInstallmentLoanCharge(installmentNumber).updatePaidAmountBy(incrementBy);\n            }\n        }else{\n            processAmount = incrementBy;\n        }\n        Money amountPaidToDate = Money.of(processAmount.getCurrency(), this.amountPaid);\n        final Money amountOutstanding = Money.of(processAmount.getCurrency(), this.amountOutstanding);\n\n        Money amountPaidOnThisCharge = Money.zero(processAmount.getCurrency());\n        if (processAmount.isGreaterThanOrEqualTo(amountOutstanding)) {\n            amountPaidOnThisCharge = amountOutstanding;\n            amountPaidToDate = amountPaidToDate.plus(amountOutstanding);\n            this.amountPaid = amountPaidToDate.getAmount();\n            this.amountOutstanding = BigDecimal.ZERO;\n        } else {\n            amountPaidOnThisCharge = processAmount;\n            amountPaidToDate = amountPaidToDate.plus(processAmount);\n            this.amountPaid = amountPaidToDate.getAmount();\n\n            final Money amountExpected = Money.of(processAmount.getCurrency(), this.amount);\n            this.amountOutstanding = amountExpected.minus(amountPaidToDate).getAmount();\n        }\n\n        this.paid = determineIfFullyPaid();\n\n        return amountPaidOnThisCharge;\n    }\n",
    "label": 1,
    "rec": "@param processAmount Amount used to pay off this charge"
  },
  {
    "id": 249,
    "type": "Param",
    "comment": "@param parameter",
    "code": "\tpublic static ReportDataSet getDataSet(Queryer queryer, ReportParameter parameter) {\n\t\treturn new DataExecutor(queryer, parameter).execute();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 250,
    "type": "Param",
    "comment": "@param bytecodeName a method name in bytecode",
    "code": "  public boolean isAssociatedWithBytecodeName(String name) {\n    if (hasBytecodeName(name)) return true;\n    if (dataProcessor != null && dataProcessor.hasBytecodeName(name)) return true;\n    for (MethodInfo provider : dataProviders)\n      if (provider.hasBytecodeName(name)) return true;\n    return false;\n  }\n",
    "label": 1,
    "rec": "@param name a method name in bytecode"
  },
  {
    "id": 251,
    "type": "Param",
    "comment": "@param outputFilename the output filename of the shared library",
    "code": "    int compile(String[] sourceFilenames, String outputFilename, ClassProperties properties, File workingDirectory)\n            throws IOException, InterruptedException {\n        ArrayList<String> command = new ArrayList<String>();\n\n        includeJavaPaths(properties, header);\n\n        String platform  = Loader.getPlatform();\n        String compilerPath = properties.getProperty(\"platform.compiler\");\n        command.add(compilerPath);\n\n        {\n            String p = properties.getProperty(\"platform.sysroot.prefix\", \"\");\n            for (String s : properties.get(\"platform.sysroot\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.includepath.prefix\", \"\");\n            for (String s : properties.get(\"platform.includepath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n            for (String s : properties.get(\"platform.includeresource\")) {\n                for (File f : Loader.cacheResources(s)) {\n                    if (f.isDirectory()) {\n                        if (p.endsWith(\" \")) {\n                            command.add(p.trim()); command.add(f.getCanonicalPath());\n                        } else {\n                            command.add(p + f.getCanonicalPath());\n                        }\n                    }\n                }\n            }\n        }\n\n        for (String sourceFilename : sourceFilenames) {\n            command.add(sourceFilename);\n        }\n\n        List<String> allOptions = properties.get(\"platform.compiler.*\");\n        if (!allOptions.contains(\"!default\") && !allOptions.contains(\"default\")) {\n            allOptions.add(0, \"default\");\n        }\n        for (String s : allOptions) {\n            if (s == null || s.length() == 0) {\n                continue;\n            }\n            String p = \"platform.compiler.\" + s;\n            String options = properties.getProperty(p);\n            if (options != null && options.length() > 0) {\n                command.addAll(Arrays.asList(options.split(\" \")));\n            } else if (!\"!default\".equals(s) && !\"default\".equals(s)) {\n                logger.warn(\"Could not get the property named \\\"\" + p + \"\\\"\");\n            }\n        }\n\n        command.addAll(compilerOptions);\n\n        String output = properties.getProperty(\"platform.compiler.output\");\n        for (int i = 1; i < 2 || output != null; i++,\n                output = properties.getProperty(\"platform.compiler.output\" + i)) {\n            if (output != null && output.length() > 0) {\n                command.addAll(Arrays.asList(output.split(\" \")));\n            }\n\n            if (output == null || output.length() == 0 || output.endsWith(\" \")) {\n                command.add(outputFilename);\n            } else {\n                command.add(command.remove(command.size() - 1) + outputFilename);\n            }\n        }\n\n        {\n            String p  = properties.getProperty(\"platform.linkpath.prefix\", \"\");\n            String p2 = properties.getProperty(\"platform.linkpath.prefix2\");\n            for (String s : properties.get(\"platform.linkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                    if (p2 != null) {\n                        if (p2.endsWith(\" \")) {\n                            command.add(p2.trim()); command.add(s);\n                        } else {\n                            command.add(p2 + s);\n                        }\n                    }\n                }\n            }\n            for (String s : properties.get(\"platform.linkresource\")) {\n                for (File f : Loader.cacheResources(s)) {\n                    if (f.isDirectory()) {\n                        if (p.endsWith(\" \")) {\n                            command.add(p.trim()); command.add(f.getCanonicalPath());\n                        } else {\n                            command.add(p + f.getCanonicalPath());\n                        }\n                        if (p2 != null) {\n                            if (p2.endsWith(\" \")) {\n                                command.add(p2.trim()); command.add(f.getCanonicalPath());\n                            } else {\n                                command.add(p2 + f.getCanonicalPath());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.link.prefix\", \"\");\n            String x = properties.getProperty(\"platform.link.suffix\", \"\");\n            int i = command.size(); // to inverse order and satisfy typical compilers\n            for (String s : properties.get(\"platform.link\")) {\n                String[] libnameversion = s.split(\"#\")[0].split(\"@\");\n                if (libnameversion.length == 3 && libnameversion[1].length() == 0) {\n                    // Only use the version number when the user gave us a double @\n                    s = libnameversion[0] + libnameversion[2];\n                } else {\n                    s = libnameversion[0];\n                }\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s); command.add(i + 2, x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(i, p + s); command.add(i + 1, x.trim());\n                } else {\n                    command.add(i, p + s + x);\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.frameworkpath.prefix\", \"\");\n            for (String s : properties.get(\"platform.frameworkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.framework.prefix\", \"\");\n            String x = properties.getProperty(\"platform.framework.suffix\", \"\");\n            for (String s : properties.get(\"platform.framework\")) {\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(p.trim()); command.add(s); command.add(x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(p.trim()); command.add(s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(p + s); command.add(x.trim());\n                } else {\n                    command.add(p + s + x);\n                }\n            }\n        }\n\n        String text = \"\";\n        boolean windows = platform.startsWith(\"windows\");\n        for (String s : command) {\n            boolean hasSpaces = s.indexOf(\" \") > 0;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += s;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += \" \";\n        }\n        logger.info(text);\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        // Use the library output path as the working directory so that all\n        // build files, including intermediate ones from MSVC, are dumped there\n        pb.directory(workingDirectory);\n        if (environmentVariables != null) {\n            pb.environment().putAll(environmentVariables);\n        }\n        return pb.inheritIO().start().waitFor();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 252,
    "type": "Param",
    "comment": "@param config path to config file.",
    "code": "    public static ClusterProperties from(String cfg) {\n        try {\n            Properties props = null;\n\n            if (cfg != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(cfg));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.mesosUrl = getStringProperty(MESOS_MASTER_URL, props, DEFAULT_MESOS_MASTER_URL);\n\n            prop.httpSrvHost = getStringProperty(IGNITE_HTTP_SERVER_HOST, props, getNonLoopbackAddress());\n\n            String port = System.getProperty(\"PORT0\");\n\n            if (port != null && !port.isEmpty())\n                prop.httpSrvPort = Integer.valueOf(port);\n            else\n                prop.httpSrvPort = Integer.valueOf(getStringProperty(IGNITE_HTTP_SERVER_PORT, props,\n                    DEFAULT_HTTP_SERVER_PORT));\n\n            prop.clusterName = getStringProperty(IGNITE_CLUSTER_NAME, props, DEFAULT_CLUSTER_NAME);\n\n            prop.userLibsUrl = getStringProperty(IGNITE_USERS_LIBS_URL, props, null);\n            prop.ignitePkgUrl = getStringProperty(IGNITE_PACKAGE_URL, props, null);\n            prop.ignitePkgPath = getStringProperty(IGNITE_PACKAGE_PATH, props, null);\n            prop.licenceUrl = getStringProperty(LICENCE_URL, props, null);\n            prop.igniteCfgUrl = getStringProperty(IGNITE_CONFIG_XML_URL, props, null);\n\n            prop.cpu = getDoubleProperty(IGNITE_TOTAL_CPU, props, UNLIMITED);\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RUN_CPU_PER_NODE, props, UNLIMITED);\n            prop.mem = getDoubleProperty(IGNITE_TOTAL_MEMORY, props, UNLIMITED);\n            prop.memPerNode = getDoubleProperty(IGNITE_MEMORY_PER_NODE, props, UNLIMITED);\n            prop.disk = getDoubleProperty(IGNITE_TOTAL_DISK_SPACE, props, UNLIMITED);\n            prop.diskPerNode = getDoubleProperty(IGNITE_DISK_SPACE_PER_NODE, props, 1024.0);\n            prop.nodeCnt = getDoubleProperty(IGNITE_NODE_COUNT, props, UNLIMITED);\n            prop.minCpu = getDoubleProperty(IGNITE_MIN_CPU_PER_NODE, props, DEFAULT_RESOURCE_MIN_CPU);\n            prop.minMemory = getDoubleProperty(IGNITE_MIN_MEMORY_PER_NODE, props, DEFAULT_RESOURCE_MIN_MEM);\n\n            prop.jvmOpts = getStringProperty(IGNITE_JVM_OPTS, props, \"\");\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORK_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            String ptrn = getStringProperty(IGNITE_HOSTNAME_CONSTRAINT, props, null);\n\n            if (ptrn != null) {\n                try {\n                    prop.hostnameConstraint = Pattern.compile(ptrn);\n                }\n                catch (PatternSyntaxException e) {\n                    log.log(Level.WARNING, \"IGNITE_HOSTNAME_CONSTRAINT has invalid pattern. It will be ignore.\", e);\n                }\n            }\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 1,
    "rec": "@param cfg path to config file."
  },
  {
    "id": 253,
    "type": "Param",
    "comment": "@param pick Node picked for preloading.",
    "code": "        private boolean preloadEntry(ClusterNode pick, int p, GridCacheEntryInfo entry, long topVer)\n            throws IgniteCheckedException {\n            try {\n                GridCacheEntryEx cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isIgfsDataCache() &&\n                        cctx.dht().igfsDataSpaceUsed() > cctx.dht().igfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload IGFS data cache (IGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            null,\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (IgniteUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false, null, null, null);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (IgniteInterruptedCheckedException e) {\n                throw e;\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteCheckedException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 254,
    "type": "Param",
    "comment": "@param string",
    "code": "    public static byte[] md5(String input) {\n        MD5Digest digest = new MD5Digest();\n        byte[] bytes = input.getBytes();\n        digest.update(bytes, 0, bytes.length);\n        byte[] md5 = new byte[digest.getDigestSize()];\n        digest.doFinal(md5, 0);\n        StringBuffer hex = new StringBuffer(md5.length * 2);\n        for (int i = 0; i < md5.length; i++) {\n            byte b = md5[i];\n            if ((b & 0xFF) < 0x10) {\n                hex.append(\"0\");\n            }\n            hex.append(Integer.toHexString(b & 0xFF));\n        }\n        return hexStringToByteArray(hex.toString());\n    }\n",
    "label": 1,
    "rec": "@param input"
  },
  {
    "id": 255,
    "type": "Param",
    "comment": "@param image booleans representing white/black QR Code modules",
    "code": "  public DecoderResult decode(boolean[][] image, Map<DecodeHintType,?> hints)\n      throws ChecksumException, FormatException {\n    int dimension = image.length;\n    BitMatrix bits = new BitMatrix(dimension);\n    for (int i = 0; i < dimension; i++) {\n      for (int j = 0; j < dimension; j++) {\n        if (image[i][j]) {\n          bits.set(j, i);\n        }\n      }\n    }\n    return decode(bits, hints);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 256,
    "type": "Param",
    "comment": "@param activeElementIndex index of newly active element (from 0)",
    "code": "    protected int calculateNewPagerPosition(int newActiveElement) {\n        newActiveElement++;\n        if (newActiveElement <= 0)\n            newActiveElement = 1;\n        int pagerActiveElemCenterPosX = mPagerElementActiveSize / 2\n                + newActiveElement * mPagerElementLeftMargin\n                + (newActiveElement - 1) * (mPagerElementNormalSize + mPagerElementRightMargin);\n        return mRootLayout.getWidth() / 2 - pagerActiveElemCenterPosX;\n    }\n",
    "label": 1,
    "rec": "@param newActiveElement index of newly active element (from 0)"
  },
  {
    "id": 257,
    "type": "Param",
    "comment": "@param address The Bitcoin address to send the money to.",
    "code": "    public Transaction createSend(Address address, Coin value) throws InsufficientMoneyException {\n        SendRequest req = SendRequest.to(address, value);\n        if (params == UnitTestParams.get())\n            req.shuffleOutputs = false;\n        completeTx(req);\n        return req.tx;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 258,
    "type": "Param",
    "comment": "@param integer",
    "code": "  public Long incrBy(final byte[] key, final long increment) {\n    checkIsInMultiOrPipeline();\n    client.incrBy(key, increment);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param increment"
  },
  {
    "id": 259,
    "type": "Param",
    "comment": "@param acm AttributeColumnsManipulator",
    "code": "    private JCommandButton prepareJCommandButton(final Table table, final Column[] columns, final AttributeColumnsManipulator acm) {\n        JCommandButton manipulatorButton;\n        if (acm.getIcon() != null) {\n            manipulatorButton = new JCommandButton(acm.getName(), ImageWrapperResizableIcon.getIcon(acm.getIcon(), new Dimension(16, 16)));\n        } else {\n            manipulatorButton = new JCommandButton(acm.getName());\n        }\n        manipulatorButton.setCommandButtonKind(JCommandButton.CommandButtonKind.POPUP_ONLY);\n        manipulatorButton.setDisplayState(CommandButtonDisplayState.MEDIUM);\n        if (acm.getDescription() != null && !acm.getDescription().isEmpty()) {\n            manipulatorButton.setPopupRichTooltip(new RichTooltip(NbBundle.getMessage(DataTableTopComponent.class, \"DataTableTopComponent.RichToolTip.title.text\"), acm.getDescription()));\n        }\n\n        final ArrayList<Column> availableColumns = new ArrayList<Column>();\n        for (final Column column : columns) {\n            if (acm.canManipulateColumn(table, column)) {\n                availableColumns.add(column);\n            }\n        }\n\n        if (!availableColumns.isEmpty()) {\n            manipulatorButton.setPopupCallback(new PopupPanelCallback() {\n\n                public JPopupPanel getPopupPanel(JCommandButton jcb) {\n                    JCommandPopupMenu popup = new JCommandPopupMenu();\n\n                    JCommandMenuButton button;\n                    for (final Column column : availableColumns) {\n\n                        button = new JCommandMenuButton(column.getTitle(), ImageWrapperResizableIcon.getIcon(ImageUtilities.loadImage(\"org/gephi/desktop/datalab/resources/column.png\"), new Dimension(16, 16)));\n                        button.addActionListener(new ActionListener() {\n\n                            public void actionPerformed(ActionEvent e) {\n                                DataLaboratoryHelper.getDefault().executeAttributeColumnsManipulator(acm, table, column);\n                            }\n                        });\n                        popup.addMenuButton(button);\n                    }\n                    return popup;\n                }\n            });\n        } else {\n            manipulatorButton.setEnabled(false);\n        }\n\n        return manipulatorButton;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 260,
    "type": "Param",
    "comment": "@param user",
    "code": "    public AvatarLoader bind(final ImageView view, final Contributor contributor) {\n        if (contributor == null)\n            return setImage(loadingAvatar, view);\n\n        final String avatarUrl = contributor.getAvatarUrl();\n\n        if (TextUtils.isEmpty(avatarUrl))\n            return setImage(loadingAvatar, view);\n\n        final String contributorId = contributor.getLogin();\n\n        BitmapDrawable loadedImage = loaded.get(contributorId);\n        if (loadedImage != null)\n            return setImage(loadedImage, view);\n\n        setImage(loadingAvatar, view, contributorId);\n        fetchAvatarTask(avatarUrl, contributorId, view).execute();\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param contributor"
  },
  {
    "id": 261,
    "type": "Param",
    "comment": "@param parent the parent",
    "code": "    public static String makePath(String parent, String... children)\n    {\n        StringBuilder path = new StringBuilder();\n\n        // Add parent piece, with no trailing slash.\n        if ( (parent != null) && (parent.length() > 0) )\n        {\n            if ( !parent.startsWith(PATH_SEPARATOR) )\n            {\n                path.append(PATH_SEPARATOR);\n            }\n            if ( parent.endsWith(PATH_SEPARATOR) )\n            {\n                path.append(parent.substring(0, parent.length() - 1));\n            }\n            else\n            {\n                path.append(parent);\n            }\n        }\n\n        if (children == null || children.length == 0)\n        {\n            // Special case, empty parent and child\n            if ( path.length() == 0 )\n            {\n                return PATH_SEPARATOR;\n            }\n            return path.toString();\n        }\n\n        for (String child : children)\n        {\n            if ( (child == null) || (child.length() == 0) || (child.equals(PATH_SEPARATOR)) )\n            {\n                // Special case, empty parent and child\n                if ( path.length() == 0 )\n                {\n                    path.append(PATH_SEPARATOR);\n                }\n\n                continue;\n            }\n\n            // Now add the separator between parent and child.\n            path.append(PATH_SEPARATOR);\n\n            if ( child.startsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(1);\n            }\n\n            if ( child.endsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(0, child.length() - 1);\n            }\n\n            // Finally, add the child.\n            path.append(child);\n        }\n\n        return path.toString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 262,
    "type": "Param",
    "comment": "@param ggfsCfg GGFS configuration.",
    "code": "    protected IgniteConfiguration getConfiguration(String gridName, IgfsConfiguration igfsCfg) throws Exception {\n        IgniteConfiguration cfg = IgnitionEx.loadConfiguration(\"config/hadoop/default-config.xml\").get1();\n\n        assert cfg != null;\n\n        cfg.setGridName(gridName);\n\n        cfg.setIncludeEventTypes(concat(EVTS_IGFS, EVT_TASK_FAILED, EVT_TASK_FINISHED, EVT_JOB_MAPPED));\n\n        cfg.setIgfsConfiguration(igfsCfg);\n\n        cfg.setCacheConfiguration(getCacheConfiguration(gridName));\n\n        cfg.setHadoopConfiguration(null);\n\n        TcpDiscoverySpi discoSpi = new TcpDiscoverySpi();\n\n        discoSpi.setIpFinder(new TcpDiscoveryVmIpFinder(true));\n\n        cfg.setDiscoverySpi(discoSpi);\n\n        return cfg;\n    }\n",
    "label": 1,
    "rec": "@param igfsCfg GGFS configuration."
  },
  {
    "id": 263,
    "type": "Param",
    "comment": "@param dest Destination path.",
    "code": "    public boolean renameDual(final IgfsSecondaryFileSystem fs, final IgfsPath src, final IgfsPath dest) throws\n        IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert src != null;\n                assert dest != null;\n\n                if (src.parent() == null)\n                    return false; // Root directory cannot be renamed.\n\n                // Events to fire (can be done outside of a transaction).\n                final Collection<IgfsEvent> pendingEvts = new LinkedList<>();\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgfsPath, IgfsFileInfo> infos) throws Exception {\n                        IgfsFileInfo srcInfo = infos.get(src);\n                        IgfsFileInfo srcParentInfo = infos.get(src.parent());\n                        IgfsFileInfo destInfo = infos.get(dest);\n                        IgfsFileInfo destParentInfo = dest.parent() != null ? infos.get(dest.parent()) : null;\n\n                        // Source path and destination (or destination parent) must exist.\n                        if (srcInfo == null)\n                            throw fsException(new IgfsFileNotFoundException(\"Failed to rename \" +\n                                    \"(source path not found): \" + src));\n\n                        if (destInfo == null && destParentInfo == null)\n                            throw fsException(new IgfsFileNotFoundException(\"Failed to rename \" +\n                                \"(destination path not found): \" + dest));\n\n                        // Delegate to the secondary file system.\n                        fs.rename(src, dest);\n\n                        // Rename was successful, perform compensation in the local file system.\n                        if (destInfo == null) {\n                            // Move and rename.\n                            assert destParentInfo != null;\n\n                            moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), dest.name(), destParentInfo.id());\n                        }\n                        else {\n                            // Move.\n                            if (destInfo.isFile())\n                                throw fsException(\"Failed to rename the path in the local file system \" +\n                                    \"because destination path already exists and it is a file: \" + dest);\n                            else\n                                moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), src.name(), destInfo.id());\n                        }\n\n                        // Record event if needed.\n                        if (srcInfo.isFile()) {\n                            if (evts.isRecordable(EVT_IGFS_FILE_RENAMED))\n                                pendingEvts.add(new IgfsEvent(\n                                    src,\n                                    destInfo == null ? dest : new IgfsPath(dest, src.name()),\n                                    locNode,\n                                    EVT_IGFS_FILE_RENAMED));\n                        }\n                        else if (evts.isRecordable(EVT_IGFS_DIR_RENAMED))\n                            pendingEvts.add(new IgfsEvent(src, dest, locNode, EVT_IGFS_DIR_RENAMED));\n\n                        return true;\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path rename in DUAL mode failed [source=\" + src + \", destination=\" + dest + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to rename the path due to secondary file system \" +\n                            \"exception: \" + src, err);\n                    }\n                };\n\n                try {\n                    return synchronizeAndExecute(task, fs, false, src, dest);\n                }\n                finally {\n                    for (IgfsEvent evt : pendingEvts)\n                        evts.record(evt);\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to rename in DUAL mode because Grid is stopping [src=\" + src +\n                \", dest=\" + dest + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 264,
    "type": "Param",
    "comment": "@param barCode resource identifier",
    "code": "    Observable<Parsed> fetchAndPersist(@Nonnull final Key key) {\n        try {\n            return inFlightRequests.get(key, new Callable<Observable<Parsed>>() {\n                @Nonnull\n                @Override\n                public Observable<Parsed> call() {\n                    return response(key);\n                }\n            });\n        } catch (ExecutionException e) {\n            return Observable.empty();\n        }\n    }\n",
    "label": 1,
    "rec": "@param key resource identifier"
  },
  {
    "id": 265,
    "type": "Param",
    "comment": "@param m GGFS metrics.",
    "code": "    public static VisorGgfsMetrics from(IgfsMetrics m) {\n        assert m != null;\n\n        VisorGgfsMetrics metrics = new VisorGgfsMetrics();\n\n        metrics.totalSpaceSize(m.maxSpaceSize());\n        metrics.usedSpaceSize(m.localSpaceSize());\n        metrics.foldersCount(m.directoriesCount());\n        metrics.filesCount(m.filesCount());\n        metrics.filesOpenedForRead(m.filesOpenedForRead());\n        metrics.filesOpenedForWrite(m.filesOpenedForWrite());\n        metrics.blocksRead(m.blocksReadTotal());\n        metrics.blocksReadRemote(m.blocksReadRemote());\n        metrics.blocksWritten(m.blocksWrittenTotal());\n        metrics.blocksWrittenRemote(m.blocksWrittenRemote());\n        metrics.bytesRead(m.bytesRead());\n        metrics.bytesReadTime(m.bytesReadTime());\n        metrics.bytesWritten(m.bytesWritten());\n        metrics.bytesWriteTime(m.bytesWriteTime());\n\n        return metrics;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 266,
    "type": "Param",
    "comment": "@param time a valid timestamp",
    "code": "    public WindowWrap<T> getPreviousWindow(long timeMillis) {\n        if (timeMillis < 0) {\n            return null;\n        }\n        int idx = calculateTimeIdx(timeMillis);\n\n        long previousTime = timeMillis - windowLengthInMs;\n        WindowWrap<T> wrap = array.get(idx);\n\n        if (wrap == null || isWindowDeprecated(wrap)) {\n            return null;\n        }\n\n        if (wrap.windowStart() + windowLengthInMs < previousTime) {\n            return null;\n        }\n\n        return wrap;\n    }\n",
    "label": 1,
    "rec": "@param timeMillis a valid timestamp in milliseconds"
  },
  {
    "id": 267,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public int offheapEntriesCount(boolean primary, boolean backup, AffinityTopologyVersion topVer) throws IgniteCheckedException {\n        assert primary || backup;\n\n        if (!offheapEnabled)\n            return 0;\n\n        if (!(primary && backup)) {\n            Set<Integer> parts = primary ? cctx.affinity().primaryPartitions(cctx.localNodeId(), topVer) :\n                cctx.affinity().backupPartitions(cctx.localNodeId(), topVer);\n\n            return (int)offheap.entriesCount(spaceName, parts);\n        }\n        else\n            return (int)offheap.entriesCount(spaceName);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 268,
    "type": "Param",
    "comment": "@param testClass",
    "code": "    private Set<Field> scanForInjection(final Object testClassInstance, final Class<?> clazz) {\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null != field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }\n",
    "label": 1,
    "rec": "@param testClassInstance Instance of the test"
  },
  {
    "id": 269,
    "type": "Param",
    "comment": "@param c Cache.",
    "code": "    public static VisorCacheMetrics from(IgniteEx ignite, GridCache c) {\n        VisorCacheMetrics cm = new VisorCacheMetrics();\n\n        CacheMetrics m = c.metrics();\n\n        GridCacheProcessor cacheProcessor = ignite.context().cache();\n\n        cm.name = c.name();\n        cm.mode = cacheProcessor.cacheMode(c.name());\n        cm.sys = cacheProcessor.systemCache(c.name());\n\n        cm.size = m.getSize();\n        cm.keySize = m.getKeySize();\n\n        cm.reads = m.getCacheGets();\n        cm.writes = m.getCachePuts() + m.getCacheRemovals();\n        cm.hits = m.getCacheHits();\n        cm.misses = m.getCacheMisses();\n\n        cm.txCommits = m.getCacheTxCommits();\n        cm.txRollbacks = m.getCacheTxRollbacks();\n\n        cm.avgTxCommitTime = m.getAverageTxCommitTime();\n        cm.avgTxRollbackTime = m.getAverageTxRollbackTime();\n\n        cm.puts = m.getCachePuts();\n        cm.removals = m.getCacheRemovals();\n        cm.evictions = m.getCacheEvictions();\n\n        cm.avgReadTime = m.getAverageGetTime();\n        cm.avgPutTime = m.getAveragePutTime();\n        cm.avgRemovalTime = m.getAverageRemoveTime();\n\n        cm.readsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageGetTime());\n        cm.writesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAveragePutTime());\n        cm.hitsPerSec = -1;\n        cm.missesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageRemoveTime());\n        cm.commitsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxCommitTime());\n        cm.rollbacksPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxRollbackTime());\n\n        cm.qryMetrics = VisorCacheQueryMetrics.from(c.queries().metrics());\n\n        cm.dhtEvictQueueCurrSize = m.getDhtEvictQueueCurrentSize();\n        cm.txThreadMapSize = m.getTxThreadMapSize();\n        cm.txXidMapSize = m.getTxXidMapSize();\n        cm.txCommitQueueSize = m.getTxCommitQueueSize();\n        cm.txPrepareQueueSize = m.getTxPrepareQueueSize();\n        cm.txStartVerCountsSize = m.getTxStartVersionCountsSize();\n        cm.txCommittedVersionsSize = m.getTxCommittedVersionsSize();\n        cm.txRolledbackVersionsSize = m.getTxRolledbackVersionsSize();\n        cm.txDhtThreadMapSize = m.getTxDhtThreadMapSize();\n        cm.txDhtXidMapSize = m.getTxDhtXidMapSize();\n        cm.txDhtCommitQueueSize = m.getTxDhtCommitQueueSize();\n        cm.txDhtPrepareQueueSize = m.getTxDhtPrepareQueueSize();\n        cm.txDhtStartVerCountsSize = m.getTxDhtStartVersionCountsSize();\n        cm.txDhtCommittedVersionsSize = m.getTxDhtCommittedVersionsSize();\n        cm.txDhtRolledbackVersionsSize = m.getTxDhtRolledbackVersionsSize();\n\n        return cm;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 270,
    "type": "Param",
    "comment": "@param local whether to only create enough chunks to max out all cores on one node only",
    "code": "  private Frame reBalance(final Frame fr, long seed) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@param seed RNG seed"
  },
  {
    "id": 271,
    "type": "Param",
    "comment": "@param pubKey Public key to be tested with.",
    "code": "    private static boolean verify0(String jarName, PublicKey pubKey, boolean allSigned, IgniteLogger log)\n        throws IOException {\n        JarFile jarFile = null;\n\n        try {\n            jarFile = new JarFile(jarName, true);\n\n            Manifest manifest = jarFile.getManifest();\n\n            // Manifest must be included in signed GAR file.\n            if (manifest == null)\n                return pubKey == null;\n\n            Set<String> manifestFiles = getSignedFiles(manifest);\n\n            Enumeration<JarEntry> entries = jarFile.entries();\n\n            while (entries.hasMoreElements()) {\n                JarEntry jarEntry = entries.nextElement();\n\n                if (jarEntry.isDirectory())\n                    continue;\n\n                // Verify by reading the file if altered.\n                // Will return quietly if no problem.\n                verifyDigestsImplicitly(jarFile.getInputStream(jarEntry));\n\n                if (verifyEntry(jarEntry, manifest, pubKey, allSigned, false) == false)\n                    return false;\n\n                manifestFiles.remove(jarEntry.getName());\n            }\n\n            return manifestFiles.size() <= 0;\n        }\n        catch (SecurityException e) {\n            if (log.isDebugEnabled())\n                log.debug(\"Got security error (ignoring): \" + e.getMessage());\n        }\n        finally {\n            U.close(jarFile, log);\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 272,
    "type": "Param",
    "comment": "@param prj Cluster to check size for.",
    "code": "    public static boolean checkMinTopologySize(ClusterGroup grp, int size) {\n        int prjSize = grp.nodes().size();\n\n        if (prjSize < size) {\n            System.err.println(\">>> Please start at least \" + size + \" cluster nodes to run example.\");\n\n            return false;\n        }\n\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param grp Cluster to check size for."
  },
  {
    "id": 273,
    "type": "Param",
    "comment": "@param response the outgoing ServletResponse",
    "code": "    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 274,
    "type": "Param",
    "comment": "@param target the managed target to lookup",
    "code": "\tpublic File lookup(String managedFile, boolean add) throws IOException {\n\t\tif (!open)\n\t\t\tthrow new IOException(EclipseAdaptorMsg.fileManager_notOpen);\n\t\tEntry entry = (Entry) table.get(managedFile);\n\t\tif (entry == null) {\n\t\t\tif (add) {\n\t\t\t\tadd(managedFile);\n\t\t\t\tentry = (Entry) table.get(managedFile);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn new File(getAbsolutePath(managedFile + '.' + entry.getReadId()));\n\t}\n\n",
    "label": 1,
    "rec": "@param managedFile the managed file to lookup"
  },
  {
    "id": 275,
    "type": "Param",
    "comment": "@param fs Secondary file system.",
    "code": "    public boolean deleteDual(final Igfs fs, final IgfsPath path, final boolean recursive)\n        throws IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert path != null;\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgfsPath, IgfsFileInfo> infos) throws Exception {\n                        IgfsFileInfo info = infos.get(path);\n\n                        if (info == null)\n                            return false; // File doesn't exist in the secondary file system.\n\n                        if (!fs.delete(path, recursive))\n                            return false; // Delete failed remotely.\n\n                        if (path.parent() != null) {\n                            assert infos.containsKey(path.parent());\n\n                            softDeleteNonTx(infos.get(path.parent()).id(), path.name(), info.id());\n                        }\n                        else {\n                            assert ROOT_ID.equals(info.id());\n\n                            softDeleteNonTx(null, path.name(), info.id());\n                        }\n\n                        // Update the deleted file info with path information for delete worker.\n                        id2InfoPrj.invoke(info.id(), new UpdatePath(path));\n\n                        return true; // No additional handling is required.\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path delete in DUAL mode failed [path=\" + path + \", recursive=\" + recursive + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to delete the path due to secondary file system exception: \",\n                            err);\n                    }\n                };\n\n                Boolean res = synchronizeAndExecute(task, fs, false, Collections.singleton(TRASH_ID), path);\n\n                delWorker.signal();\n\n                return res;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to delete in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 276,
    "type": "Param",
    "comment": "@param clientSession for current request",
    "code": "    protected Response handleBrowserAuthenticationRequest(LoginSessionModel loginSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(loginSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, loginSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    // processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(loginSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.loginSessions().removeLoginSession(realm, loginSession);\n                    return response;\n                }\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(loginSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.loginSessions().removeLoginSession(realm, loginSession);\n                    return response;\n                }\n\n                // Attach session once no requiredActions or other things are required\n                processor.attachSession();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                // TODO: Check if this is required...\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, loginSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow();\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param loginSession for current request"
  },
  {
    "id": 277,
    "type": "Param",
    "comment": "@param x training instances.",
    "code": "    public BitString[] learn(int size, int generation, BiFunction<double[][], int[], Classifier<double[]>> trainer, ClassificationMeasure measure, double[][] x, int[] y, int k) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        ClassificationFitness fitness = new ClassificationFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 278,
    "type": "Param",
    "comment": "@param defaultValue Default value.",
    "code": "    private int getIntProperty(String name, int dfltVal) {\n        String val = manager.getProperty(name);\n\n        if (val == null)\n            return dfltVal;\n\n        try {\n            return Integer.parseInt(val.trim());\n        }\n        catch (Exception ex) {\n            ex.printStackTrace();\n\n            return dfltVal;\n        }\n    }\n",
    "label": 1,
    "rec": "@param dfltVal Default value."
  },
  {
    "id": 279,
    "type": "Param",
    "comment": "@param position",
    "code": "    private int getShuffleEdge(int position, int top) {\n\n        final int numHeaders = getHeaderViewsCount();\n        final int numFooters = getFooterViewsCount();\n\n        // shuffle edges are defined between items that can be\n        // dragged; there are N-1 of them if there are N draggable\n        // items.\n\n        if (position <= numHeaders || (position >= getCount() - numFooters)) {\n            return top;\n        }\n\n        int divHeight = getDividerHeight();\n\n        int edge;\n\n        int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;\n        int childHeight = getChildHeight(position);\n        int itemHeight = getItemHeight(position);\n\n        // first calculate top of item given that floating View is\n        // centered over src position\n        int otop = top;\n        if (mSecondExpPos <= mSrcPos) {\n            // items are expanded on and/or above the source position\n\n            if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {\n                if (position == mSrcPos) {\n                    otop = top + itemHeight - mFloatViewHeight;\n                } else {\n                    int blankHeight = itemHeight - childHeight;\n                    otop = top + blankHeight - maxBlankHeight;\n                }\n            } else if (position > mSecondExpPos && position <= mSrcPos) {\n                otop = top - maxBlankHeight;\n            }\n\n        } else {\n            // items are expanded on and/or below the source position\n\n            if (position > mSrcPos && position <= mFirstExpPos) {\n                otop = top + maxBlankHeight;\n            } else if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {\n                int blankHeight = itemHeight - childHeight;\n                otop = top + blankHeight;\n            }\n        }\n\n        // otop is set\n        if (position <= mSrcPos) {\n            edge = otop + (mFloatViewHeight - divHeight - getChildHeight(position - 1)) / 2;\n        } else {\n            edge = otop + (childHeight - divHeight - mFloatViewHeight) / 2;\n        }\n\n        return edge;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 280,
    "type": "Param",
    "comment": "@param k k-fold cross validation for the evaluation.",
    "code": "    public BitString[] learn(int size, int generation, BiFunction<double[][], int[], Classifier<double[]>> trainer, ClassificationMeasure measure, double[][] x, int[] y, int k) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        ClassificationFitness fitness = new ClassificationFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 281,
    "type": "Param",
    "comment": "@param attributes service attributes",
    "code": "  public static AttributeFilter attributes(final Map<String, ?> sampleAttributes) {\n    return new AttributeFilter() {\n      public boolean matches(final Map<String, ?> attributes) {\n        return null != attributes && attributes.entrySet().containsAll(sampleAttributes.entrySet());\n      }\n    };\n  }\n\n",
    "label": 1,
    "rec": "@param sampleAttributes sample attributes"
  },
  {
    "id": 282,
    "type": "Param",
    "comment": "@param pos",
    "code": "\tprivate Object getValue(ByteBuffer byteBuffer, TelegramValue telegramValue) {\n\n\t\tString type = telegramValue.getType().toLowerCase();\n\t\tint pos = telegramValue.getPos() != null ? telegramValue.getPos() : -1;\n\n\t\tObject value = null;\n\n\t\t// requested pos is greater as whole buffer\n\t\tif(pos > byteBuffer.position()) {\n\t\t\tlogger.warn(\"eBus buffer pos error! Can happen ...\");\n\t\t}\n\n\t\t// replace similar data types\n\t\tif(type.equals(\"uint\"))\n\t\t\ttype = \"word\";\n\t\tif(type.equals(\"byte\"))\n\t\t\ttype = \"uchar\";\n\n\t\tbyte[] bytes = null;\n\t\tif(type.equals(\"data2b\") || type.equals(\"data2c\") || type.equals(\"word\")) {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos), byteBuffer.get(pos-1)};\n\t\t} else {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos-1)};\n\t\t}\n\n\t\tif(type.equals(\"bit\")) {\n\t\t\tint bit = telegramValue.getBit();\n\t\t\tvalue = bytes[0];\n\n\t\t\tboolean isSet = ((Byte)value >> bit& 0x1) == 1;\n\t\t\tvalue = isSet;\n\n\t\t} else {\n\t\t\tvalue = NumberUtils.toBigDecimal(EBusCodecUtils.decode(type, bytes, telegramValue.getReplaceValue()));\n\t\t}\n\n\t\t// if BigDecimal check for min, max and replace value\n\t\tif(value instanceof BigDecimal) {\n\t\t\tBigDecimal b = (BigDecimal)value;\n\n\t\t\t// multiply before check min and max\n\t\t\tif(b != null && telegramValue.getFactor() != null) {\n\t\t\t\tlogger.trace(\"Value multiplied ...\");\n\t\t\t\tvalue = b = b.multiply(telegramValue.getFactor());\n\t\t\t}\n\n\t\t\t// value is below min value, return null\n\t\t\tif(telegramValue.getMin() != null && b != null && b.compareTo(telegramValue.getMin()) == -1) {\n\t\t\t\tlogger.trace(\"Minimal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\n\t\t\t\t// value is above max value, return null\n\t\t\t} else if (telegramValue.getMax() != null && b != null && b.compareTo(telegramValue.getMax()) == 1) {\n\t\t\t\tlogger.trace(\"Maximal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\t\t\t}\n\n\t\t}\n\n\t\treturn value;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 283,
    "type": "Param",
    "comment": "@param textColor The resource id of the text colorResourceId.",
    "code": "\t\tpublic Builder setTextColor(int textColorResourceId) {\n\t\t\tthis.textColorResourceId = textColorResourceId;\n\n\t\t\treturn this;\n\t\t}\n",
    "label": 1,
    "rec": "@param textColorResourceId The resource id of the text colorResourceId."
  },
  {
    "id": 284,
    "type": "Param",
    "comment": "@param key Key to map.",
    "code": "    private Collection<ClusterNode> mapKey(KeyCacheObject key, long topVer, boolean fastMap) {\n        GridCacheAffinityManager affMgr = cctx.affinity();\n\n        // If we can send updates in parallel - do it.\n        return fastMap ?\n            cctx.topology().nodes(affMgr.partition(key), topVer) :\n            Collections.singletonList(affMgr.primary(key, topVer));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 285,
    "type": "Param",
    "comment": "@param segments Segments.",
    "code": "    protected ReuseList createReuseList(int cacheId, PageMemory pageMem, long[] rootIds, boolean initNew)\n        throws IgniteCheckedException {\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param rootIds Root page IDs."
  },
  {
    "id": 286,
    "type": "Param",
    "comment": "@param fs Secondary file system.",
    "code": "    public IgfsFileInfo updateDual(final IgfsSecondaryFileSystem fs, final IgfsPath path, final Map<String, String> props)\n        throws IgniteCheckedException {\n        assert fs != null;\n        assert path != null;\n        assert props != null && !props.isEmpty();\n\n        if (busyLock.enterBusy()) {\n            try {\n                SynchronizationTask<IgfsFileInfo> task = new SynchronizationTask<IgfsFileInfo>() {\n                    @Override public IgfsFileInfo onSuccess(Map<IgfsPath, IgfsFileInfo> infos)\n                        throws Exception {\n                        if (infos.get(path) == null)\n                            return null;\n\n                        fs.update(path, props);\n\n                        assert path.parent() == null || infos.get(path.parent()) != null;\n\n                        return updatePropertiesNonTx(infos.get(path.parent()).id(), infos.get(path).id(), path.name(),\n                            props);\n                    }\n\n                    @Override public IgfsFileInfo onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path update in DUAL mode failed [path=\" + path + \", properties=\" + props + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to update the path due to secondary file system exception: \" +\n                            path, err);\n                    }\n                };\n\n                return synchronizeAndExecute(task, fs, false, path);\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to update in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 287,
    "type": "Param",
    "comment": "@param strings",
    "code": "    public Long lpush(final byte[] key, final byte[]... string) {\n        checkIsInMulti();\n        client.lpush(key, string);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param string"
  },
  {
    "id": 288,
    "type": "Param",
    "comment": "@param parentId Parent file ID.",
    "code": "    public IgniteUuid putIfAbsent(IgniteUuid parentId, String fileName, GridGgfsFileInfo newFileInfo)\n        throws GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert validTxState(false);\n                assert parentId != null;\n                assert fileName != null;\n                assert newFileInfo != null;\n\n                IgniteUuid res = null;\n\n                GridCacheTx tx = metaCache.txStart(PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    res = putIfAbsentNonTx(parentId, fileName, newFileInfo);\n\n                    tx.commit();\n                }\n                finally {\n                    tx.close();\n                }\n\n                return res;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to put file because Grid is stopping [parentId=\" + parentId +\n                \", fileName=\" + fileName + \", newFileInfo=\" + newFileInfo + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 289,
    "type": "Param",
    "comment": "@param grid Grid",
    "code": "    private static UUID primaryId(Ignite ignite, Object key) {\n        GridCacheAffinity aff = ignite.cache(null).cache().affinity();\n\n        Collection<GridNode> affNodes = aff.mapPartitionToPrimaryAndBackups(aff.partition(key));\n\n        GridNode first = F.first(affNodes);\n\n        assert first != null;\n\n        return first.id();\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid"
  },
  {
    "id": 290,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorRestConfiguration from(IgniteConfiguration c) {\n        VisorRestConfiguration cfg = new VisorRestConfiguration();\n\n        GridClientConnectionConfiguration clnCfg = c.getClientConnectionConfiguration();\n\n        boolean restEnabled = clnCfg != null;\n\n        cfg.restEnabled(restEnabled);\n\n        if (restEnabled) {\n            cfg.tcpSslEnabled(clnCfg.isRestTcpSslEnabled());\n            cfg.accessibleFolders(clnCfg.getRestAccessibleFolders());\n            cfg.jettyPath(clnCfg.getRestJettyPath());\n            cfg.jettyHost(getProperty(GG_JETTY_HOST));\n            cfg.jettyPort(intValue(GG_JETTY_PORT, null));\n            cfg.tcpHost(clnCfg.getRestTcpHost());\n            cfg.tcpPort(clnCfg.getRestTcpPort());\n            cfg.tcpSslContextFactory(compactClass(clnCfg.getRestTcpSslContextFactory()));\n        }\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 291,
    "type": "Param",
    "comment": "@param account the Account stored in the system matching the token principal.",
    "code": "    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n        Object tokenCredentials = getCredentials(token);\n        Object accountCredentials = getCredentials(info);\n        return equals(tokenCredentials, accountCredentials);\n    }\n",
    "label": 1,
    "rec": "@param info the AuthenticationInfo stored in the system matching the token principal."
  },
  {
    "id": 292,
    "type": "Param",
    "comment": "@param job Callable job.",
    "code": "    private GridFuture<Integer> callAsync(int idx, Callable<Integer> job, @Nullable IgnitePredicate<ClusterNode> p)\n        throws GridException {\n        assert idx >= 0 && idx < NODES_CNT;\n        assert job != null;\n\n        execCntr.set(0);\n\n        GridCompute comp = p != null ? compute(grid(idx).forPredicate(p)) : grid(idx).compute();\n\n        comp = comp.enableAsync();\n\n        comp.call(job);\n\n        return comp.future();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 293,
    "type": "Param",
    "comment": "@param byteArray the potentially encrypted fragment.",
    "code": "\tprivate byte[] decryptFragment(byte[] ciphertextFragment) throws GeneralSecurityException {\r\n\t\tif (session == null) {\r\n\t\t\treturn ciphertextFragment;\r\n\t\t}\r\n\r\n\t\tbyte[] fragment = ciphertextFragment;\r\n\r\n\t\tCipherSuite cipherSuite = session.getReadState().getCipherSuite();\r\n\t\tLOGGER.log(Level.FINER, \"Decrypting record fragment using current read state\\n{0}\", session.getReadState());\r\n\t\t\r\n\t\tswitch (cipherSuite.getCipherType()) {\r\n\t\tcase NULL:\r\n\t\t\t// do nothing\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase AEAD:\r\n\t\t\tfragment = decryptAEAD(ciphertextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase BLOCK:\r\n\t\t\tfragment = decryptBlockCipher(ciphertextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase STREAM:\r\n\t\t\t// Currently, Scandium does not support any stream ciphers\r\n\t\t\t// RC4 is explicitly ruled out from being used in DTLS\r\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.2\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn fragment;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "@param ciphertextFragment the TLSCiphertext.fragment to decrypt"
  },
  {
    "id": 294,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorBasicConfiguration from(IgniteEx g, IgniteConfiguration c) {\n        VisorBasicConfiguration cfg = new VisorBasicConfiguration();\n\n        cfg.gridName(c.getGridName());\n        cfg.ggHome(getProperty(IGNITE_HOME, c.getIgniteHome()));\n        cfg.localHost(getProperty(IGNITE_LOCAL_HOST, c.getLocalHost()));\n        cfg.nodeId(g.localNode().id());\n        cfg.marshaller(compactClass(c.getMarshaller()));\n        cfg.deploymentMode(compactObject(c.getDeploymentMode()));\n        cfg.daemon(boolValue(IGNITE_DAEMON, c.isDaemon()));\n        cfg.jmxRemote(g.isJmxRemoteEnabled());\n        cfg.restart(g.isRestartEnabled());\n        cfg.networkTimeout(c.getNetworkTimeout());\n        cfg.logger(compactClass(c.getGridLogger()));\n        cfg.discoStartupDelay(c.getDiscoveryStartupDelay());\n        cfg.mBeanServer(compactClass(c.getMBeanServer()));\n        cfg.noAscii(boolValue(IGNITE_NO_ASCII, false));\n        cfg.noDiscoOrder(boolValue(IGNITE_NO_DISCO_ORDER, false));\n        cfg.noShutdownHook(boolValue(IGNITE_NO_SHUTDOWN_HOOK, false));\n        cfg.programName(getProperty(IGNITE_PROG_NAME));\n        cfg.quiet(boolValue(IGNITE_QUIET, true));\n        cfg.successFile(getProperty(IGNITE_SUCCESS_FILE));\n        cfg.updateNotifier(boolValue(IGNITE_UPDATE_NOTIFIER, true));\n        cfg.securityCredentialsProvider(compactClass(c.getSecurityCredentialsProvider()));\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 295,
    "type": "Param",
    "comment": "@param trackClass the class name with which the service was registered, or null for all services.",
    "code": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString className, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(className, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(className, filterString);\n\t\t}\n\t}\n\n",
    "label": 1,
    "rec": "@param className The class name with which the service was registered, or null for all services."
  },
  {
    "id": 296,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "        private GridCacheMapEntry put0(KeyCacheObject key, int hash, CacheObject val, AffinityTopologyVersion topVer, long ttl) {\n            try {\n                SegmentHeader hdr = this.hdr;\n\n                int c = hdr.size();\n\n                if (c++ > threshold) {// Ensure capacity.\n                    rehash();\n\n                    hdr = this.hdr;\n                }\n\n                int hdrId = hdr.id();\n\n                GridCacheMapEntry[] tab = hdr.table();\n\n                int idx = hash & (tab.length - 1);\n\n                GridCacheMapEntry bin = tab[idx];\n\n                GridCacheMapEntry e = bin;\n\n                while (e != null && (e.hash() != hash || !key.equals(e.key)))\n                    e = e.next(hdrId);\n\n                GridCacheMapEntry retVal;\n\n                if (e != null) {\n                    retVal = e;\n\n                    e.rawPut(val, ttl);\n                }\n                else {\n                    GridCacheMapEntry next = bin != null ? bin : null;\n\n                    GridCacheMapEntry newRoot = factory.create(ctx, topVer, key, hash, val, next, ttl, hdr.id());\n\n                    // Avoiding delete (decrement) before creation (increment).\n                    synchronized (newRoot) {\n                        tab[idx] = newRoot;\n\n                        retVal = newRoot;\n\n                        // Modify counters.\n                        if (!retVal.isInternal()) {\n                            mapPubSize.increment();\n\n                            pubSize.increment();\n                        }\n                    }\n\n                    mapSize.increment();\n\n                    hdr.size(c);\n                }\n\n                return retVal;\n            }\n            finally {\n                if (DEBUG)\n                    checkSegmentConsistency();\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 297,
    "type": "Param",
    "comment": "@param groupId Group Id for kafka subscriber.",
    "code": "    private ConsumerConfig createDefaultConsumerConfig(String zooKeeper, String grpId) {\n        A.notNull(zooKeeper, \"zookeeper\");\n        A.notNull(grpId, \"groupId\");\n\n        Properties props = new Properties();\n\n        props.put(\"zookeeper.connect\", zooKeeper);\n        props.put(\"group.id\", grpId);\n        props.put(\"zookeeper.session.timeout.ms\", \"400\");\n        props.put(\"zookeeper.sync.time.ms\", \"200\");\n        props.put(\"auto.commit.interval.ms\", \"1000\");\n        props.put(\"auto.offset.reset\", \"smallest\");\n\n        return new ConsumerConfig(props);\n    }\n",
    "label": 1,
    "rec": "@param grpId Group Id for kafka subscriber."
  },
  {
    "id": 298,
    "type": "Param",
    "comment": "@param struct",
    "code": "    public double finalQ(int[] struct, double[] degrees, HierarchicalUndirectedGraph hgraph, AttributeModel attributeModel) {\n        AttributeTable nodeTable = attributeModel.getNodeTable();\n        AttributeColumn modCol = nodeTable.getColumn(MODULARITY_CLASS);\n        if (modCol == null) {\n            modCol = nodeTable.addColumn(MODULARITY_CLASS, \"Modularity Class\", AttributeType.INT, AttributeOrigin.COMPUTED, new Integer(0));\n        }\n\n        double res = 0;\n        double[] internal = new double[degrees.length];\n        for (Node n : hgraph.getNodes()) {\n            int n_index = structure.map.get(n);\n            AttributeRow row = (AttributeRow) n.getNodeData().getAttributes();\n            row.setValue(modCol, struct[n_index]);\n            for (Node neighbor : hgraph.getNeighbors(n)) {\n                if (n == neighbor) {\n                    continue;\n                }\n                int neigh_index = structure.map.get(neighbor);\n                if (struct[neigh_index] == struct[n_index]) {\n                    internal[struct[neigh_index]]++;\n                }\n            }\n        }\n        for (int i = 0; i < degrees.length; i++) {\n            internal[i] /= 2.0;\n            res += (internal[i] / hgraph.getTotalEdgeCount()) - Math.pow(degrees[i] / (2 * hgraph.getTotalEdgeCount()), 2);\n        }\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 299,
    "type": "Param",
    "comment": "@param binding the field or local to check",
    "code": "public boolean cannotBeNull(LocalVariableBinding local) {\n\treturn isDefinitelyNonNull(local) || isProtectedNonNull(local);\n}\n\n",
    "label": 1,
    "rec": "@param local the variable to ckeck"
  },
  {
    "id": 300,
    "type": "Param",
    "comment": "@param chol",
    "code": "  public Cholesky cholesky(Cholesky chol, int parallelize) {\n    long start = System.currentTimeMillis();\n    if( chol == null ) {\n      double[][] xx = _xx.clone();\n      for( int i = 0; i < xx.length; ++i )\n        xx[i] = xx[i].clone();\n      chol = new Cholesky(xx, _diag.clone());\n    }\n    final Cholesky fchol = chol;\n    final int sparseN = _diag.length;\n    final int denseN = _fullN - sparseN;\n    boolean spd=true;\n    // compute the cholesky of the diagonal and diagonal*dense parts\n    if( _diag != null ) for( int i = 0; i < sparseN; ++i ) {\n      double d = 1.0 / (chol._diag[i] = Math.sqrt(_diag[i]));\n      for( int j = 0; j < denseN; ++j )\n        chol._xx[j][i] = d*_xx[j][i];\n    }\n    Futures fs = new Futures();\n    // compute the outer product of diagonal*dense\n    final int chk = Math.max(denseN/10, 1); \n    Log.info(\"SPARSEN = \" + sparseN + \"    DENSEN = \" + denseN);\n\n    for( int i = 0; i < denseN; ++i ) {\n      final int fi = i;\n      fs.add(new RecursiveAction() {\n          @Override protected void compute() {\n            for( int j = 0; j <= fi; ++j ) {\n              double s = 0;\n              for( int k = 0; k < sparseN; ++k )\n                s += fchol._xx[fi][k] * fchol._xx[j][k];\n                 fchol._xx[fi][j + sparseN] = _xx[fi][j + sparseN] - s;\n            }\n          }\n        }.fork());\n    }\n    fs.blockForPending();\n    // compute the cholesky of dense*dense-outer_product(diagonal*dense)\n    // TODO we still use Jama, which requires (among other things) copy and expansion of the matrix. Do it here without copy and faster.\n    double[][] arr = new double[denseN][];\n    for( int i = 0; i < arr.length; ++i )\n      arr[i] = Arrays.copyOfRange(fchol._xx[i], sparseN, sparseN + denseN);\n\n    Log.info (\"CHOLESKY PRECOMPUTE TIME \" + (System.currentTimeMillis()-start));\n    start = System.currentTimeMillis();\n    // parallelize cholesky\n    if (parallelize == 1) {\n      int p = Runtime.getRuntime().availableProcessors();\n      InPlaceCholesky d = InPlaceCholesky.decompose_2(arr, 10, p);\n      fchol.setSPD(d.isSPD());\n      arr = d.getL();\n      Log.info (\"H2O CHOLESKY DECOMPOSE TAKES: \" + (System.currentTimeMillis()-start));\n    } else {\n      // make it symmetric\n      for( int i = 0; i < arr.length; ++i )\n        for( int j = 0; j < i; ++j )\n          arr[j][i] = arr[i][j];\n      CholeskyDecomposition c = new Matrix(arr).chol();\n      fchol.setSPD(c.isSPD());\n      arr = c.getL().getArray();\n      Log.info (\"JAMA CHOLESKY DECOMPOSE TAKES: \" + (System.currentTimeMillis()-start));\n    }\n    for( int i = 0; i < arr.length; ++i )\n      System.arraycopy(arr[i], 0, fchol._xx[i], sparseN, i + 1);\n    return chol;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 301,
    "type": "Param",
    "comment": "@param deviceNumber The bulb number the bridge has filed the bulb under.",
    "code": "\tpublic int getHue(String deviceId) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tObject hue = settingsData.node(\"lights\")\n\t\t\t\t.node(deviceId).node(\"state\")\n\t\t\t\t.value(\"hue\");\n\t\tif(hue instanceof Integer) {\n\t\t\treturn (Integer) hue;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param deviceId The bulb id the bridge has filed the bulb under."
  },
  {
    "id": 302,
    "type": "Param",
    "comment": "@param ver Obsolete entry version.",
    "code": "    public boolean addRemoved(GridCacheContext<K, V> cacheCtx, GridCacheVersion ver) {\n        if (cacheCtx.isNear() || cacheCtx.isLocal())\n            return true;\n\n        boolean ret = rmvLocks.add(ver);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Added removed lock version: \" + ver);\n\n        return ret;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 303,
    "type": "Param",
    "comment": "@param partitions the partitions.",
    "code": "\tpublic TopicBuilder partitions(int partitionCount) {\n\t\tthis.partitions = partitionCount;\n\t\treturn this;\n\t}\n",
    "label": 1,
    "rec": "@param partitionCount the partitions."
  },
  {
    "id": 304,
    "type": "Param",
    "comment": "@param dest Destination path.",
    "code": "    public boolean renameDual(final Igfs fs, final IgfsPath src, final IgfsPath dest) throws\n        IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert src != null;\n                assert dest != null;\n\n                if (src.parent() == null)\n                    return false; // Root directory cannot be renamed.\n\n                // Events to fire (can be done outside of a transaction).\n                final Collection<IgfsEvent> pendingEvts = new LinkedList<>();\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgfsPath, IgfsFileInfo> infos) throws Exception {\n                        IgfsFileInfo srcInfo = infos.get(src);\n                        IgfsFileInfo srcParentInfo = infos.get(src.parent());\n                        IgfsFileInfo destInfo = infos.get(dest);\n                        IgfsFileInfo destParentInfo = dest.parent() != null ? infos.get(dest.parent()) : null;\n\n                        // Source path and destination (or destination parent) must exist.\n                        if (srcInfo == null)\n                            throw fsException(new IgfsFileNotFoundException(\"Failed to rename \" +\n                                    \"(source path not found): \" + src));\n\n                        if (destInfo == null && destParentInfo == null)\n                            throw fsException(new IgfsFileNotFoundException(\"Failed to rename \" +\n                                \"(destination path not found): \" + dest));\n\n                        // Delegate to the secondary file system.\n                        fs.rename(src, dest);\n\n                        // Rename was successful, perform compensation in the local file system.\n                        if (destInfo == null) {\n                            // Move and rename.\n                            assert destParentInfo != null;\n\n                            moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), dest.name(), destParentInfo.id());\n                        }\n                        else {\n                            // Move.\n                            if (destInfo.isFile())\n                                throw fsException(\"Failed to rename the path in the local file system \" +\n                                    \"because destination path already exists and it is a file: \" + dest);\n                            else\n                                moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), src.name(), destInfo.id());\n                        }\n\n                        // Record event if needed.\n                        if (srcInfo.isFile()) {\n                            if (evts.isRecordable(EVT_IGFS_FILE_RENAMED))\n                                pendingEvts.add(new IgfsEvent(\n                                    src,\n                                    destInfo == null ? dest : new IgfsPath(dest, src.name()),\n                                    locNode,\n                                    EVT_IGFS_FILE_RENAMED));\n                        }\n                        else if (evts.isRecordable(EVT_IGFS_DIR_RENAMED))\n                            pendingEvts.add(new IgfsEvent(src, dest, locNode, EVT_IGFS_DIR_RENAMED));\n\n                        return true;\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path rename in DUAL mode failed [source=\" + src + \", destination=\" + dest + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to rename the path due to secondary file system \" +\n                            \"exception: \" + src, err);\n                    }\n                };\n\n                try {\n                    return synchronizeAndExecute(task, fs, false, src, dest);\n                }\n                finally {\n                    for (IgfsEvent evt : pendingEvts)\n                        evts.record(evt);\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to rename in DUAL mode because Grid is stopping [src=\" + src +\n                \", dest=\" + dest + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 305,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input(ctx, (Comparator<Object>) ctx.combineGroupComparator());\n                }\n\n            default:\n                return createInput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 306,
    "type": "Param",
    "comment": "@param image The pixel data to decode",
    "code": "  public Result decode(BinaryBitmap image, Map<DecodeHintType,?> hints) throws NotFoundException {\n    setHints(hints);\n    return decodeInternal(image);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 307,
    "type": "Param",
    "comment": "@param loc Enforce local.",
    "code": "    private ClusterGroup projection(boolean local) {\n        return local || ctx.isLocal() || ctx.isReplicated() ? ctx.kernalContext().grid().forLocal() : null;\n    }\n",
    "label": 1,
    "rec": "@param local Enforce local."
  },
  {
    "id": 308,
    "type": "Param",
    "comment": "@param topOrder Maximum allowed node order.",
    "code": "    public static Collection<ClusterNode> aliveRemoteNodes(final GridCacheContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().aliveRemoteCacheNodes(ctx.namex(), topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 309,
    "type": "Param",
    "comment": "@param k The key",
    "code": "    public int getCheckedInResourcesCount(K key) {\n        Pool<V> resourcePool = getResourcePoolForExistingKey(key);\n        return resourcePool.queue.size();\n    }\n",
    "label": 1,
    "rec": "@param key The key"
  },
  {
    "id": 310,
    "type": "Param",
    "comment": "@param exclude Versions to ignore.",
    "code": "    public boolean isLocallyOwnedByThread(long threadId, boolean allowDhtLoc, GridCacheVersion... exclude) {\n        GridCacheMvccCandidate<K> owner = localOwner();\n\n        return owner != null && owner.threadId() == threadId && owner.nodeId().equals(cctx.nodeId()) &&\n            (allowDhtLoc || !owner.dhtLocal()) && !U.containsObjectArray(exclude, owner.version());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 311,
    "type": "Param",
    "comment": "@param method Plugin data from bukkit, Internal Class file.",
    "code": "\tpublic static boolean setMethod(PluginManager manager)\n\t{\n\t\tif (hasMethod())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif (self)\n\t\t{\n\t\t\tself = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tint count = 0;\n\t\tboolean match = false;\n\t\tPlugin plugin = null;\n\n\t\tfor (String name : getDependencies())\n\t\t{\n\t\t\tif (hasMethod())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tplugin = manager.getPlugin(name);\n\t\t\tif (plugin == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tMethod current = createMethod(plugin);\n\t\t\tif (current == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (preferred.isEmpty())\n\t\t\t{\n\t\t\t\tMethod = current;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAttachables.add(current);\n\t\t\t}\n\t\t}\n\n\t\tif (!preferred.isEmpty())\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (hasMethod())\n\t\t\t\t{\n\t\t\t\t\tmatch = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (Method attached : Attachables)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (attached == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hasMethod())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (preferred.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMethod = attached;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (preferred.equalsIgnoreCase(attached.getName()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMethod = attached;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMethod = attached;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!match);\n\t\t}\n\n\t\treturn hasMethod();\n\t}\n",
    "label": 1,
    "rec": "@param PluginManager the plugin manager for the server"
  },
  {
    "id": 312,
    "type": "Param",
    "comment": "@param prj Projection to check size for.",
    "code": "    public static boolean checkMinTopologySize(ClusterGroup prj, int size) {\n        int prjSize = prj.nodes().size();\n\n        if (prjSize < size) {\n            System.out.println();\n            System.out.println(\">>> Please start at least \" + size + \" grid nodes to run example.\");\n            System.out.println();\n\n            return false;\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 313,
    "type": "Param",
    "comment": "@param key If this is a key property.",
    "code": "    private static ClassProperty buildClassProperty(Class<?> keyCls, Class<?> valCls, String pathStr, Class<?> resType)\n        throws IgniteCheckedException {\n        ClassProperty res = buildClassProperty(true, keyCls, pathStr, resType);\n\n        if (res == null) // We check key before value consistently with PortableProperty.\n            res = buildClassProperty(false, valCls, pathStr, resType);\n\n        if (res == null)\n            throw new IgniteCheckedException(\"Failed to initialize property '\" + pathStr + \"' for \" +\n                \"key class '\" + keyCls + \"' and value class '\" + valCls + \"'. \" +\n                \"Make sure that one of these classes contains respective getter method or field.\");\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param keyCls Key class."
  },
  {
    "id": 314,
    "type": "Param",
    "comment": "@param node Node to get version from.",
    "code": "    public static GridProductVersion productVersion(ClusterNode node) {\n        String verStr = node.attribute(ATTR_BUILD_VER);\n        String buildDate = node.attribute(ATTR_BUILD_DATE);\n\n        if (buildDate != null)\n            verStr += '-' + buildDate;\n\n        return GridProductVersion.fromString(verStr);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 315,
    "type": "Param",
    "comment": "@param o an option or an option container.",
    "code": "  public Collection<Property> availableOptionPropertiesFor(EObject optionContainer) {\n    if (optionContainer instanceof Protobuf) return fileOptions();\n    if (optionContainer instanceof Enum) return enumOptions();\n    if (optionContainer instanceof Message) return messageOptions();\n    return emptyList();\n  }\n\n",
    "label": 1,
    "rec": "@param optionContainer the given container of an option."
  },
  {
    "id": 316,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    @Nullable protected V peek0(K key, @Nullable Collection<GridCachePeekMode> modes, IgniteTxEx<K, V> tx)\n        throws IgniteCheckedException {\n        try {\n            GridTuple<V> peek = peek0(false, key, modes, tx);\n\n            return peek != null ? peek.get() : null;\n        }\n        catch (GridCacheFilterFailedException ex) {\n            ex.printStackTrace();\n\n            assert false; // Should never happen.\n\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 317,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static IgniteSet<String> initializeSet(Ignite g, String setName) throws IgniteCheckedException {\n        IgniteCollectionConfiguration setCfg = new IgniteCollectionConfiguration();\n\n        // Initialize new set.\n        IgniteSet<String> set = g.set(setName, setCfg, true);\n\n        // Initialize set items.\n        for (int i = 0; i < 10; i++)\n            set.add(Integer.toString(i));\n\n        System.out.println(\"Set size after initializing: \" + set.size());\n\n        return set;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 318,
    "type": "Param",
    "comment": "@param request the SendRequest that describes what to do, get one using static methods on SendRequest itself.",
    "code": "    public SendResult sendCoins(TransactionBroadcaster broadcaster, SendRequest request) {\n        // Does not need to be synchronized as sendCoinsOffline is and the rest is all thread-local.\n\n        // Commit the TX to the wallet immediately so the spent coins won't be reused.\n        // TODO: We should probably allow the request to specify tx commit only after the network has accepted it.\n        Transaction tx = sendCoinsOffline(request);\n        if (tx == null)\n            return null;  // Not enough money.\n        SendResult result = new SendResult();\n        result.tx = tx;\n        // The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has\n        // a txConfidenceListener registered. Once the tx is broadcast the peers will update the memory pool with the\n        // count of seen peers, the memory pool will update the transaction confidence object, that will invoke the\n        // txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged\n        // method.\n        result.broadcastComplete = broadcaster.broadcastTransaction(tx);\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 319,
    "type": "Param",
    "comment": "@param token the authentication token provided by the user.",
    "code": "    protected AuthorizingAccount queryForLdapAccount( Object principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principal instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        List<String> roleNames;\n\n        try {\n\n            roleNames = getRoleNamesForUser(username, ldapContext);\n\n        } finally {\n\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizingAccount( roleNames, null );\n    }\n",
    "label": 1,
    "rec": "@param principal the principal of the Subject whose Account is being retrieved."
  },
  {
    "id": 320,
    "type": "Param",
    "comment": "@param target Extracted parameters.",
    "code": "    private static List<Object> findParams(GridSqlQuery qry, Object[] params, ArrayList<Object> target) {\n        if (params.length == 0)\n            return target;\n\n        for (GridSqlElement el : qry.select())\n            findParams(el, params, target);\n\n        findParams(qry.from(), params, target);\n        findParams(qry.where(), params, target);\n\n        for (GridSqlElement el : qry.groups())\n            findParams(el, params, target);\n\n        findParams(qry.having(), params, target);\n\n        for (GridSqlElement el : qry.sort().keySet())\n            findParams(el, params, target);\n\n        findParams(qry.limit(), params, target);\n        findParams(qry.offset(), params, target);\n\n        return target;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 321,
    "type": "Param",
    "comment": "@param userId",
    "code": "    protected BitmapDrawable fetchAvatar(final String url, final String cachedAvatarFilename) {\n        File rawAvatar = new File(avatarDir, cachedAvatarFilename + \"-raw\");\n        HttpRequest request = HttpRequest.get(url);\n        if (request.ok())\n            request.receive(rawAvatar);\n\n        if (!rawAvatar.exists() || rawAvatar.length() == 0)\n            return null;\n\n        Bitmap bitmap = decode(rawAvatar);\n        if (bitmap == null) {\n            rawAvatar.delete();\n            return null;\n        }\n\n        bitmap = ImageUtils.roundCorners(bitmap, cornerRadius);\n        if (bitmap == null) {\n            rawAvatar.delete();\n            return null;\n        }\n\n        File roundedAvatar = new File(avatarDir, cachedAvatarFilename);\n        FileOutputStream output = null;\n        try {\n            output = new FileOutputStream(roundedAvatar);\n            if (bitmap.compress(PNG, 100, output))\n                return new BitmapDrawable(context.getResources(), bitmap);\n            else\n                return null;\n        } catch (IOException e) {\n            Log.d(TAG, \"Exception writing rounded avatar\", e);\n            return null;\n        } finally {\n            if (output != null)\n                try {\n                    output.close();\n                } catch (IOException e) {\n                    // Ignored\n                }\n            rawAvatar.delete();\n        }\n    }\n",
    "label": 1,
    "rec": "@param cachedAvatarFilename"
  },
  {
    "id": 322,
    "type": "Param",
    "comment": "@param entry Preloaded entry.",
    "code": "        private boolean preloadEntry(ClusterNode pick, int p, GridCacheEntryInfo<K, V> entry, AffinityTopologyVersion topVer)\n            throws IgniteCheckedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isIgfsDataCache() &&\n                        cctx.dht().igfsDataSpaceUsed() > cctx.dht().igfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload IGFS data cache (IGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (IgniteUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false, null, null, null);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (IgniteInterruptedCheckedException e) {\n                throw e;\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteCheckedException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 323,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    public static VisorBasicConfiguration from(IgniteEx ignite, IgniteConfiguration c) {\n        VisorBasicConfiguration cfg = new VisorBasicConfiguration();\n\n        cfg.gridName(c.getGridName());\n        cfg.ggHome(getProperty(IGNITE_HOME, c.getIgniteHome()));\n        cfg.localHost(getProperty(IGNITE_LOCAL_HOST, c.getLocalHost()));\n        cfg.nodeId(ignite.localNode().id());\n        cfg.marshaller(compactClass(c.getMarshaller()));\n        cfg.deploymentMode(compactObject(c.getDeploymentMode()));\n        cfg.daemon(boolValue(IGNITE_DAEMON, c.isDaemon()));\n        cfg.jmxRemote(ignite.isJmxRemoteEnabled());\n        cfg.restart(ignite.isRestartEnabled());\n        cfg.networkTimeout(c.getNetworkTimeout());\n        cfg.logger(compactClass(c.getGridLogger()));\n        cfg.discoStartupDelay(c.getDiscoveryStartupDelay());\n        cfg.mBeanServer(compactClass(c.getMBeanServer()));\n        cfg.noAscii(boolValue(IGNITE_NO_ASCII, false));\n        cfg.noDiscoOrder(boolValue(IGNITE_NO_DISCO_ORDER, false));\n        cfg.noShutdownHook(boolValue(IGNITE_NO_SHUTDOWN_HOOK, false));\n        cfg.programName(getProperty(IGNITE_PROG_NAME));\n        cfg.quiet(boolValue(IGNITE_QUIET, true));\n        cfg.successFile(getProperty(IGNITE_SUCCESS_FILE));\n        cfg.updateNotifier(boolValue(IGNITE_UPDATE_NOTIFIER, true));\n\n        return cfg;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 324,
    "type": "Param",
    "comment": "@param height Image height",
    "code": "    public BufferedImage createTimeIntervalImage(double starts[], double ends[], int width, int height, Color fill, Color border, Color background) {\n        if (starts.length != ends.length) {\n            throw new IllegalArgumentException(\"start and ends length should be equal\");\n        }\n        if (fill == null) {\n            fill = DEFAULT_FILL;\n        }\n        if (border == null) {\n            border = DEFAULT_BORDER;\n        }\n\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n\n        final Graphics2D g = image.createGraphics();\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n        //Draw brackground if any:\n        if (background != null) {\n            g.setBackground(background);\n            g.clearRect(0, 0, width, height);\n        }\n\n        g.translate(1, 0);//Start drawing at pixel 1\n\n        width -= 2;//Reduce fill area in 2 pixels for the borders\n        double xTickWidth = (double) width / range;\n\n        //Draw time interval filled parts:\n        if (range == 0) {//No range, Min=Max\n            //Fill all drawing area:\n            g.setColor(fill);\n            g.fillRect(0, 0, width, height);\n            g.setColor(border);\n            //Draw borders:\n            g.drawLine(-1, 0, -1, height);\n            g.drawLine(width, 0, width, height);\n        } else {\n            int startPixel, endPixel;\n            for (int i = 0; i < starts.length; i++) {\n                g.setColor(fill);\n                startPixel = (int) (xTickWidth * (normalizeToRange(starts[i]) - min));\n                endPixel = (int) (xTickWidth * (normalizeToRange(ends[i]) - min));\n\n                int rectWidth = endPixel - startPixel;\n                if (rectWidth == 0) {\n                    rectWidth = 1;//Draw at least 1 pixel if a range is small\n                }\n                g.fillRect(startPixel, 0, rectWidth, height);\n\n                //Draw borders:\n                g.setColor(border);\n                g.drawLine(startPixel, 0, startPixel, height);\n                g.drawLine(endPixel, 0, endPixel, height);\n            }\n        }\n\n        return image;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 325,
    "type": "Param",
    "comment": "@param nodeId Node ID.",
    "code": "    public boolean alive(ClusterNode node) {\n        assert node != null;\n\n        return alive(node.id());\n    }\n",
    "label": 1,
    "rec": "@param node Node."
  },
  {
    "id": 326,
    "type": "Param",
    "comment": "@param tx Transaction to check.",
    "code": "    public boolean isCompleted(IgniteInternalTx<K, V> tx) {\n        return committedVers.contains(tx.xidVersion()) || rolledbackVers.contains(tx.xidVersion());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 327,
    "type": "Param",
    "comment": "@param member",
    "code": "    public Long zrem(final String key, final String... members) {\n        checkIsInMulti();\n        client.zrem(key, members);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param members"
  },
  {
    "id": 328,
    "type": "Param",
    "comment": "@param queueName Name of queue.",
    "code": "    private static CacheQueue<String> initializeQueue(Ignite ignite, String queueName) throws IgniteCheckedException {\n        // Initialize new FIFO queue.\n        CacheQueue<String> queue = ignite.cache(CACHE_NAME).dataStructures().queue(queueName, 0, false, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < ignite.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 329,
    "type": "Param",
    "comment": "@param path the typeface path",
    "code": "    public static Typeface getTypeface(Context context, IconSet iconSet) {\n        String path = iconSet.fontPath().toString();\n\n        if (TYPEFACE_MAP.get(path) == null) {\n            final Typeface font = Typeface.createFromAsset(context.getAssets(), path);\n            TYPEFACE_MAP.put(path, font);\n        }\n        return TYPEFACE_MAP.get(path);\n    }\n",
    "label": 1,
    "rec": "@param iconSet the icon typeface"
  },
  {
    "id": 330,
    "type": "Param",
    "comment": "@param tx Cache transaction.",
    "code": "    public boolean putToStore(@Nullable IgniteTxEx tx, K key, V val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = (K)cctx.unwrapPortableIfNeeded(key, false);\n                val = (V)cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(key, locStore ? F.t(val, ver) : val));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 331,
    "type": "Param",
    "comment": "@param expFwdId Expected forward page ID.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        for (;;) {\n            try (Page page = page(pageId)) {\n                if (page == null)\n                    return true; // Page was removed, retry.\n\n                // Init args.\n                g.pageId = pageId;\n                g.fwdId = fwdId;\n\n                int res = readPage(page, search, g, lvl);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.fwdId != fwdId || fwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.fwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false; // We are done.\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        assert false: res;\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param fwdId Expected forward page ID."
  },
  {
    "id": 332,
    "type": "Param",
    "comment": "@param scope Scope",
    "code": "    public boolean connect(IConnection conn) {\n        // ensure the log is not null at this point\n        if (log == null) {\n            log = Red5LoggerFactory.getLogger(this.getClass());\n        }\n        // get the scope from the connection\n        IScope scope = conn.getScope();\n        log.debug(\"connect: {} > {}\", conn, scope);\n        return connect(conn, scope, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 333,
    "type": "Param",
    "comment": "@param encoder",
    "code": "    public Weighting createWeighting( String weightingStr, FlagEncoder encoder )\n    {\n        // ignore case\n        Weighting weighting;\n        weightingStr = weightingStr.toLowerCase();\n        if (\"fastest\".equals(weightingStr))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                weighting = new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                weighting = new FastestWeighting(encoder);\n        } else\n            weighting = new ShortestWeighting();\n\n        if (encoder.supportsTurnCosts())\n            weighting = new TurnWeighting(weighting, encoder, (TurnCostStorage) graph.getExtendedStorage());\n\n        return weighting;\n    }\n",
    "label": 1,
    "rec": "@param encoder the FlagEncoder (to specify the vehicle)"
  },
  {
    "id": 334,
    "type": "Param",
    "comment": "@param resultCode",
    "code": "    public boolean handleActivityResult(int activityRequestCode, int resultCode, Intent data) {\n        boolean result = false;\n        // handle the result of voice recognition, put it into the textfield\n        if (activityRequestCode == this.requestCode) {\n            // this was handled here, even if voicerecognition fails for any reason\n            // so your program flow wont get chaotic if you dont explicitly state\n            // your own requestCodes.\n            result = true;\n            if (resultCode == Activity.RESULT_OK) {\n                // Fill the quickAddBox-view with the string the recognizer thought it could have heard\n                ArrayList<String> match = data.getStringArrayListExtra(\n                        RecognizerIntent.EXTRA_RESULTS);\n                // make sure we only do this if there is SomeThing (tm) returned\n                if (match != null && match.size() > 0 && match.get(0).length() > 0) {\n                    Editable currentText = textField.getText();\n                    String recognizedSpeech = match.get(0);\n\n                    if (currentText.length() > 0) {\n                        // if something is already typed in, append the recognized speech,\n                        // add a space if it isn't already there\n                        textField.append((currentText.toString().endsWith(\" \") ? recognizedSpeech : \" \"+recognizedSpeech ));\n                    } else {\n                        textField.setText(recognizedSpeech);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 335,
    "type": "Param",
    "comment": "@param action the privileged action to run",
    "code": "    public static Callable<Object> callable(Runnable task) {\n        if (task == null) {\n            throw new NullPointerException();\n        }\n        return new RunnableAdapter<Object>(task, null);\n    }\n",
    "label": 1,
    "rec": "@param task the task to run"
  },
  {
    "id": 336,
    "type": "Param",
    "comment": "@param collocated Collocation flag.",
    "code": "    private static GridCacheQueueItemKey itemKey(IgniteUuid id, String queueName, boolean collocated, long idx) {\n        return collocated ? new CollocatedItemKey(id, queueName, idx) :\n            new GridCacheQueueItemKey(id, queueName, idx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 337,
    "type": "Param",
    "comment": "@param destination: topic-name",
    "code": "    public CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadata(TopicName topicName) {\n    \treturn httpClient.get(String.format(\"admin/%s/partitions\", topicName.getLookupName()),\n                PartitionedTopicMetadata.class);\n    }\n",
    "label": 1,
    "rec": "@param topicName topic-name"
  },
  {
    "id": 338,
    "type": "Param",
    "comment": "@param newCount the new value to attempt",
    "code": "    public boolean  trySetCount(VersionedValue<Integer> previous, int newCount) throws Exception\n    {\n        VersionedValue<byte[]> previousCopy = new VersionedValue<byte[]>(previous.getVersion(), toBytes(previous.getValue()));\n        return sharedValue.trySetValue(previousCopy, toBytes(newCount));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 339,
    "type": "Param",
    "comment": "@param c Cache.",
    "code": "    public static VisorCacheMetrics from(IgniteEx ignite, String cacheName) {\n        VisorCacheMetrics cm = new VisorCacheMetrics();\n\n        GridCacheProcessor cacheProcessor = ignite.context().cache();\n\n        IgniteCache<Object, Object> c = cacheProcessor.jcache(cacheName);\n\n        cm.name = cacheName;\n        cm.mode = cacheProcessor.cacheMode(cacheName);\n        cm.sys = cacheProcessor.systemCache(cacheName);\n\n        CacheMetrics m = c.metrics();\n\n        cm.size = m.getSize();\n        cm.keySize = m.getKeySize();\n\n        cm.reads = m.getCacheGets();\n        cm.writes = m.getCachePuts() + m.getCacheRemovals();\n        cm.hits = m.getCacheHits();\n        cm.misses = m.getCacheMisses();\n\n        cm.txCommits = m.getCacheTxCommits();\n        cm.txRollbacks = m.getCacheTxRollbacks();\n\n        cm.avgTxCommitTime = m.getAverageTxCommitTime();\n        cm.avgTxRollbackTime = m.getAverageTxRollbackTime();\n\n        cm.puts = m.getCachePuts();\n        cm.removals = m.getCacheRemovals();\n        cm.evictions = m.getCacheEvictions();\n\n        cm.avgReadTime = m.getAverageGetTime();\n        cm.avgPutTime = m.getAveragePutTime();\n        cm.avgRemovalTime = m.getAverageRemoveTime();\n\n        cm.readsPerSec = perSecond(m.getAverageGetTime());\n        cm.putsPerSec = perSecond(m.getAveragePutTime());\n        cm.removalsPerSec = perSecond(m.getAverageRemoveTime());\n        cm.commitsPerSec = perSecond(m.getAverageTxCommitTime());\n        cm.rollbacksPerSec = perSecond(m.getAverageTxRollbackTime());\n\n        cm.qryMetrics = VisorCacheQueryMetrics.from(c.queryMetrics());\n\n        cm.dhtEvictQueueCurrSize = m.getDhtEvictQueueCurrentSize();\n        cm.txThreadMapSize = m.getTxThreadMapSize();\n        cm.txXidMapSize = m.getTxXidMapSize();\n        cm.txCommitQueueSize = m.getTxCommitQueueSize();\n        cm.txPrepareQueueSize = m.getTxPrepareQueueSize();\n        cm.txStartVerCountsSize = m.getTxStartVersionCountsSize();\n        cm.txCommittedVersionsSize = m.getTxCommittedVersionsSize();\n        cm.txRolledbackVersionsSize = m.getTxRolledbackVersionsSize();\n        cm.txDhtThreadMapSize = m.getTxDhtThreadMapSize();\n        cm.txDhtXidMapSize = m.getTxDhtXidMapSize();\n        cm.txDhtCommitQueueSize = m.getTxDhtCommitQueueSize();\n        cm.txDhtPrepareQueueSize = m.getTxDhtPrepareQueueSize();\n        cm.txDhtStartVerCountsSize = m.getTxDhtStartVersionCountsSize();\n        cm.txDhtCommittedVersionsSize = m.getTxDhtCommittedVersionsSize();\n        cm.txDhtRolledbackVersionsSize = m.getTxDhtRolledbackVersionsSize();\n\n        return cm;\n    }\n",
    "label": 1,
    "rec": "@param cacheName Cache name."
  },
  {
    "id": 340,
    "type": "Param",
    "comment": "@param type",
    "code": "\tprivate Object getValue(ByteBuffer byteBuffer, TelegramValue telegramValue) {\n\n\t\tString type = telegramValue.getType().toLowerCase();\n\t\tint pos = telegramValue.getPos() != null ? telegramValue.getPos() : -1;\n\n\t\tObject value = null;\n\n\t\t// requested pos is greater as whole buffer\n\t\tif(pos > byteBuffer.position()) {\n\t\t\tlogger.warn(\"eBus buffer pos error! Can happen ...\");\n\t\t}\n\n\t\t// replace similar data types\n\t\tif(type.equals(\"uint\"))\n\t\t\ttype = \"word\";\n\t\tif(type.equals(\"byte\"))\n\t\t\ttype = \"uchar\";\n\n\t\tbyte[] bytes = null;\n\t\tif(type.equals(\"data2b\") || type.equals(\"data2c\") || type.equals(\"word\")) {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos), byteBuffer.get(pos-1)};\n\t\t} else {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos-1)};\n\t\t}\n\n\t\tif(type.equals(\"bit\")) {\n\t\t\tint bit = telegramValue.getBit();\n\t\t\tvalue = bytes[0];\n\n\t\t\tboolean isSet = ((Byte)value >> bit& 0x1) == 1;\n\t\t\tvalue = isSet;\n\n\t\t} else {\n\t\t\tvalue = NumberUtils.toBigDecimal(EBusCodecUtils.decode(type, bytes, telegramValue.getReplaceValue()));\n\t\t}\n\n\t\t// if BigDecimal check for min, max and replace value\n\t\tif(value instanceof BigDecimal) {\n\t\t\tBigDecimal b = (BigDecimal)value;\n\n\t\t\t// multiply before check min and max\n\t\t\tif(b != null && telegramValue.getFactor() != null) {\n\t\t\t\tlogger.trace(\"Value multiplied ...\");\n\t\t\t\tvalue = b = b.multiply(telegramValue.getFactor());\n\t\t\t}\n\n\t\t\t// value is below min value, return null\n\t\t\tif(telegramValue.getMin() != null && b != null && b.compareTo(telegramValue.getMin()) == -1) {\n\t\t\t\tlogger.trace(\"Minimal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\n\t\t\t\t// value is above max value, return null\n\t\t\t} else if (telegramValue.getMax() != null && b != null && b.compareTo(telegramValue.getMax()) == 1) {\n\t\t\t\tlogger.trace(\"Maximal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\t\t\t}\n\n\t\t}\n\n\t\treturn value;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 341,
    "type": "Param",
    "comment": "@param action the command action",
    "code": "    Object process(Action action) throws RuntimeException {\n        Object result;\n        try {\n            result = action.execute();\n        } catch (Throwable throwable) {\n            if (isIgnorable(throwable)) {\n                throw new HystrixBadRequestException(throwable.getMessage(), throwable);\n            }\n            throw Throwables.propagate(throwable);\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param action the action"
  },
  {
    "id": 342,
    "type": "Param",
    "comment": "@param entry Entry to touch.",
    "code": "    private boolean touch(CacheEvictableEntry<K, V> entry) {\n        Node<CacheEvictableEntry<K, V>> node = entry.meta();\n\n        // Entry has not been enqueued yet.\n        if (node == null) {\n            while (true) {\n                node = queue.offerLastx(entry);\n\n                if (entry.putMetaIfAbsent(node) != null) {\n                    // Was concurrently added, need to clear it from queue.\n                    queue.unlinkx(node);\n\n                    // Queue has not been changed.\n                    return false;\n                }\n                else if (node.item() != null) {\n                    if (!entry.isCached()) {\n                        // Was concurrently evicted, need to clear it from queue.\n                        queue.unlinkx(node);\n\n                        return false;\n                    }\n\n                    return true;\n                }\n                // If node was unlinked by concurrent shrink() call, we must repeat the whole cycle.\n                else if (!entry.removeMeta(node))\n                    return false;\n            }\n        }\n        else if (queue.unlinkx(node)) {\n            // Move node to tail.\n            Node<CacheEvictableEntry<K, V>> newNode = queue.offerLastx(entry);\n\n            if (!entry.replaceMeta(node, newNode))\n                // Was concurrently added, need to clear it from queue.\n                queue.unlinkx(newNode);\n        }\n\n        // Entry is already in queue.\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 343,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    private boolean checkDeployed(Ignite ignite, String taskName) {\n        Map<String, Class<? extends GridComputeTask<?, ?>>> locTasks = ignite.compute().localTasks();\n\n        if (log().isInfoEnabled())\n            log().info(\"Local tasks found: \" + locTasks);\n\n        return locTasks.get(taskName) != null;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 344,
    "type": "Param",
    "comment": "@param cctx Cache context.",
    "code": "    public static ClusterNode oldest(GridCacheContext cctx, long topOrder) {\n        ClusterNode oldest = null;\n\n        for (ClusterNode n : aliveNodes(cctx, topOrder))\n            if (oldest == null || n.order() < oldest.order())\n                oldest = n;\n\n        assert oldest != null;\n        assert oldest.order() <= topOrder || topOrder < 0;\n\n        return oldest;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 345,
    "type": "Param",
    "comment": "@param disconnect Whether to abort if there's a pre-existing connection or not.",
    "code": "    ConnectionResult connect(Map<Sha256Hash, Transaction> transactions, ConnectMode mode) {\n        Transaction tx = transactions.get(outpoint.getHash());\n        if (tx == null) {\n            return TransactionInput.ConnectionResult.NO_SUCH_TX;\n        }\n        TransactionOutput out = tx.getOutputs().get((int) outpoint.getIndex());\n        if (!out.isAvailableForSpending()) {\n            if (mode == ConnectMode.DISCONNECT_ON_CONFLICT) {\n                out.markAsUnspent();\n            } else if (mode == ConnectMode.ABORT_ON_CONFLICT) {\n                outpoint.fromTx = checkNotNull(out.parentTransaction);\n                return TransactionInput.ConnectionResult.ALREADY_SPENT;\n            }\n        }\n        connect(out);\n        return TransactionInput.ConnectionResult.SUCCESS;\n    }\n",
    "label": 1,
    "rec": "@param mode Whether to abort if there's a pre-existing connection or not."
  },
  {
    "id": 346,
    "type": "Param",
    "comment": "@param digest digest object to add file.",
    "code": "    private static boolean addFileDigest(File file, MessageDigest digest, @Nullable IgniteLogger log) {\n        if (!file.isFile()) {\n            U.error(log, \"Failed to add file to directory digest (will not check MD5 hash): \" + file);\n\n            return false;\n        }\n\n        InputStream in = null;\n\n        try {\n            in = new BufferedInputStream(new FileInputStream(file));\n\n            byte[] buf = new byte[1024];\n\n            int read = in.read(buf, 0, 1024);\n\n            while (read > -1) {\n                digest.update(buf, 0, read);\n\n                read = in.read(buf, 0, 1024);\n            }\n        }\n        catch (IOException e) {\n            U.error(log, \"Failed to add file to directory digest (will not check MD5 hash): \" + file, e);\n\n            return false;\n        }\n        finally {\n            U.closeQuiet(in);\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 347,
    "type": "Param",
    "comment": "@param maxCount",
    "code": "    public BleManager setMaxConnectCount(int count) {\n        if (count > DEFAULT_MAX_MULTIPLE_DEVICE)\n            count = DEFAULT_MAX_MULTIPLE_DEVICE;\n        this.maxConnectCount = count;\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param count"
  },
  {
    "id": 348,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, KeyCacheObject key, CacheObject val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key.internal())\n                return true;\n\n            Object storeKey = key.value(cctx.cacheObjectContext(), false);\n            Object storeVal = val.value(cctx.cacheObjectContext(), false);\n\n            if (convertPortable) {\n                storeKey = cctx.unwrapPortableIfNeeded(storeKey, false);\n                storeVal = cctx.unwrapPortableIfNeeded(storeVal, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(storeKey, locStore ? F.t(storeVal, ver) : storeVal));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + storeKey + \", val=\" + storeVal + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 349,
    "type": "Param",
    "comment": "@param store Cache store.",
    "code": "    private CacheConfiguration cacheConfiguration(String cacheName, Factory<CacheStore> factory) {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setNearConfiguration(null);\n        cfg.setName(cacheName);\n\n        cfg.setBackups(1);\n\n        if (factory != null) {\n            cfg.setCacheStoreFactory(factory);\n\n            cfg.setWriteThrough(true);\n        }\n\n        return cfg;\n    }\n",
    "label": 1,
    "rec": "@param factory Factory to use."
  },
  {
    "id": 350,
    "type": "Param",
    "comment": "@param nodeId Reader to add.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, AffinityTopologyVersion topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!U.hasNearCache(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listenAsync(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        synchronized (this) {\n                            // Release memory.\n                            reader0.resetTxFuture();\n                        }\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 351,
    "type": "Param",
    "comment": "@param s Node shadow to check.",
    "code": "    public static boolean cacheNode(String cacheName, GridCacheAttributes[] caches) {\n        if (caches != null)\n            for (GridCacheAttributes attrs : caches)\n                if (F.eq(cacheName, attrs.cacheName()))\n                    return true;\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param caches Node cache attributes."
  },
  {
    "id": 352,
    "type": "Param",
    "comment": "@param n Node from which affinity is requested.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, ClusterNode n)\n        throws GridException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        GridCacheAffinityFunction f = (GridCacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        GridCacheAffinityKeyMapper m = (GridCacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        Boolean portableEnabled = U.portableEnabled(n, cacheName);\n\n        return new AffinityInfo(f, m, t.get3(), portableEnabled != null && portableEnabled);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 353,
    "type": "Param",
    "comment": "@param authParamsString string which represents parameters for the Authentication-Plugin, e.g., \"key1:val1,key2:val2\"",
    "code": "    public static Authentication create(String authPluginClassName, Map<String, String> authParams)\n            throws UnsupportedAuthenticationException {\n        try {\n            return DefaultImplementation.createAuthentication(authPluginClassName, authParams);\n        } catch (Throwable t) {\n            throw new UnsupportedAuthenticationException(t);\n        }\n    }\n",
    "label": 1,
    "rec": "@param authParams map which represents parameters for the Authentication-Plugin"
  },
  {
    "id": 354,
    "type": "Param",
    "comment": "@param direct  true to use a direct buffer, see  Indexer for details",
    "code": "    public static ByteIndexer create(final BytePointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new ByteRawIndexer(pointer, sizes, strides)\n                                             : new ByteBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            byte[] array = new byte[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new ByteArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 355,
    "type": "Param",
    "comment": "@param relativePath whether the path is relative to the root path",
    "code": "    public ExtendedHierarchicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation) {\n        ExtendedHierarchicKey parent = get(parentPath, relative, createParent);\n        int nAttempts = 0;\n        while (nAttempts++ < MAX_CHILD_DERIVATION_ATTEMPTS) {\n            try {\n                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getChildNumberPath(), privateDerivation);\n                return deriveChild(parent, createChildNumber);\n            } catch (HDDerivationException ignore) { }\n        }\n        throw new HDDerivationException(\"Maximum number of child derivation attempts reached, this is probably an indication of a bug.\");\n    }\n",
    "label": 1,
    "rec": "@param relative whether the path is relative to the root path"
  },
  {
    "id": 356,
    "type": "Param",
    "comment": "@param path Path to create.",
    "code": "    public boolean mkdirsDual(final IgfsSecondaryFileSystem fs, final IgfsPath path, final Map<String, String> props)\n        throws IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert path != null;\n                assert props != null;\n\n                if (path.parent() == null)\n                    return true; // No additional handling for root directory is needed.\n\n                // Events to fire (can be done outside of a transaction).\n                final Deque<IgfsEvent> pendingEvts = new LinkedList<>();\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgfsPath, IgfsFileInfo> infos) throws Exception {\n                        fs.mkdirs(path, props);\n\n                        assert !infos.isEmpty();\n\n                        // Now perform synchronization again starting with the last created parent.\n                        IgfsPath parentPath = null;\n\n                        for (IgfsPath curPath : infos.keySet()) {\n                            if (parentPath == null || curPath.isSubDirectoryOf(parentPath))\n                                parentPath = curPath;\n                        }\n\n                        assert parentPath != null;\n\n                        IgfsFileInfo parentPathInfo = infos.get(parentPath);\n\n                        synchronize(fs, parentPath, parentPathInfo, path, true, null);\n\n                        if (evts.isRecordable(EVT_IGFS_DIR_CREATED)) {\n                            IgfsPath evtPath = path;\n\n                            while (!parentPath.equals(evtPath)) {\n                                pendingEvts.addFirst(new IgfsEvent(evtPath, locNode, EVT_IGFS_DIR_CREATED));\n\n                                evtPath = evtPath.parent();\n\n                                assert evtPath != null; // If this fails, then ROOT does not exist.\n                            }\n                        }\n\n                        return true;\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Directory creation in DUAL mode failed [path=\" + path + \", properties=\" + props +\n                            ']', err);\n\n                        throw new IgniteCheckedException(\"Failed to create the path due to secondary file system exception: \" +\n                            path, err);\n                    }\n                };\n\n                try {\n                    return synchronizeAndExecute(task, fs, false, path.parent());\n                }\n                finally {\n                    for (IgfsEvent evt : pendingEvts)\n                        evts.record(evt);\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to create directory in DUAL mode because Grid is stopping: \" +\n                path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 357,
    "type": "Param",
    "comment": "@param l2 Vector containing L2 reconstruction errors",
    "code": "  public double calcOutlierThreshold(Vec mse, double quantile) {\n    Frame mse_frame = new Frame(Key.make(), new String[]{\"Reconstruction.MSE\"}, new Vec[]{mse});\n    QuantilesPage qp = new QuantilesPage();\n    qp.column = mse_frame.vec(0);\n    qp.source_key = mse_frame;\n    qp.quantile = quantile;\n    qp.invoke();\n    DKV.remove(mse_frame._key);\n    return qp.result;\n  }\n",
    "label": 1,
    "rec": "@param mse Vector containing reconstruction errors"
  },
  {
    "id": 358,
    "type": "Param",
    "comment": "@param rotation rotation",
    "code": "    public Frame getFrame(@NonNull T data, long time, int rotation) {\n        if (!isSetUp()) {\n            throw new IllegalStateException(\"Can't call getFrame() after releasing \" +\n                    \"or before setUp.\");\n        }\n\n        Frame frame = mFrameQueue.poll();\n        if (frame != null) {\n            LOG.v(\"getFrame for time:\", time, \"RECYCLING.\");\n        } else {\n            LOG.v(\"getFrame for time:\", time, \"CREATING.\");\n            frame = new Frame(this);\n        }\n        frame.setContent(data, time, rotation, mFrameSize, mFrameFormat);\n        return frame;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 359,
    "type": "Param",
    "comment": "@param start Start of the interval (must be greater or equal than minimum time)",
    "code": "    public BufferedImage createTimeIntervalImage(double starts[], double ends[], int width, int height, Color fill, Color border, Color background) {\n        if (starts.length != ends.length) {\n            throw new IllegalArgumentException(\"start and ends length should be equal\");\n        }\n        if (fill == null) {\n            fill = DEFAULT_FILL;\n        }\n        if (border == null) {\n            border = DEFAULT_BORDER;\n        }\n\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n\n        final Graphics2D g = image.createGraphics();\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n        //Draw brackground if any:\n        if (background != null) {\n            g.setBackground(background);\n            g.clearRect(0, 0, width, height);\n        }\n\n        g.translate(1, 0);//Start drawing at pixel 1\n\n        width -= 2;//Reduce fill area in 2 pixels for the borders\n        double xTickWidth = (double) width / range;\n\n        //Draw time interval filled parts:\n        if (range == 0) {//No range, Min=Max\n            //Fill all drawing area:\n            g.setColor(fill);\n            g.fillRect(0, 0, width, height);\n            g.setColor(border);\n            //Draw borders:\n            g.drawLine(-1, 0, -1, height);\n            g.drawLine(width, 0, width, height);\n        } else {\n            int startPixel, endPixel;\n            for (int i = 0; i < starts.length; i++) {\n                g.setColor(fill);\n                startPixel = (int) (xTickWidth * (normalizeToRange(starts[i]) - min));\n                endPixel = (int) (xTickWidth * (normalizeToRange(ends[i]) - min));\n\n                int rectWidth = endPixel - startPixel;\n                if (rectWidth == 0) {\n                    rectWidth = 1;//Draw at least 1 pixel if a range is small\n                }\n                g.fillRect(startPixel, 0, rectWidth, height);\n\n                //Draw borders:\n                g.setColor(border);\n                g.drawLine(startPixel, 0, startPixel, height);\n                g.drawLine(endPixel, 0, endPixel, height);\n            }\n        }\n\n        return image;\n    }\n",
    "label": 1,
    "rec": "@param starts Starts of the intervals (must be greater or equal than minimum time)"
  },
  {
    "id": 360,
    "type": "Param",
    "comment": "@param manufacturerId The manufacturer ID",
    "code": "\tpublic boolean FindProduct(int manufacturerId, int productType, int productId, String version) {\n\t\tif (FindManufacturer(manufacturerId) == false) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn FindProduct(productType, productId, version);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 361,
    "type": "Param",
    "comment": "@param domainName",
    "code": "    public boolean virify(String name, String domain, String oldName, ModelMap model) {\n        if (CommonUtils.notEmpty(name)) {\n            if (CommonUtils.notEmpty(oldName) && !name.equals(oldName)\n                    && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(name), model)\n                    || CommonUtils.empty(oldName) && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(name), model)) {\n                return false;\n            }\n        }\n        if (CommonUtils.notEmpty(domain) && ControllerUtils.verifyHasExist(\"domain\", service.getEntity(domain), model)) {\n            return false;\n        }\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param domain"
  },
  {
    "id": 362,
    "type": "Param",
    "comment": "@param path path to ensure",
    "code": "    public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, ZPath path)\n    {\n        Set<ExistsOption> options = Collections.singleton(ExistsOption.createParentsAsContainers);\n        return client\n            .checkExists()\n            .withOptions(options)\n            .forPath(path.child(\"foo\").fullPath())\n            .thenApply(__ -> null)\n            ;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 363,
    "type": "Param",
    "comment": "@param user",
    "code": "    public EditAssigneeTask edit(User assignee) {\n        String assigneeLogin = assignee != null ? assignee.login() : \"\";\n\n        IssueRequest edit = IssueRequest.builder()\n                .assignees(Collections.singletonList(assigneeLogin))\n                .build();\n\n        store.editIssue(repositoryId, issueNumber, edit)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .compose(activity.bindToLifecycle())\n                .subscribe(observer);\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param assignee The user the assign"
  },
  {
    "id": 364,
    "type": "Param",
    "comment": "@param key",
    "code": "    public Long hdel(final String key, final String... fields) {\n        checkIsInMulti();\n        client.hdel(key, fields);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 365,
    "type": "Param",
    "comment": "@param info the AuthenticationInfo returned by  #doAuthenticate after the successful attempt.",
    "code": "    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, Account account ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, account );\n    }\n",
    "label": 1,
    "rec": "@param account the Account returned by  #doAuthenticate after the successful attempt."
  },
  {
    "id": 366,
    "type": "Param",
    "comment": "@param channel",
    "code": "    public String callback(@PathVariable(\"channel\") String channel, String state, String code, HttpServletRequest request,\n            HttpSession session, HttpServletResponse response, ModelMap model) {\n        Oauth oauthComponent = oauthChannelMap.get(channel);\n        SysSite site = getSite(request);\n        Cookie stateCookie = RequestUtils.getCookie(request.getCookies(), STATE_COOKIE_NAME);\n        if (null != oauthComponent && oauthComponent.enabled(site.getId()) && null != stateCookie && null != state\n                && state.equals(stateCookie.getValue())) {\n            try {\n                OauthAccess oauthAccess = oauthComponent.getOpenId(site.getId(), code);\n                if (null != oauthAccess && null != oauthAccess.getOpenId()) {\n                    Cookie cookie = RequestUtils.getCookie(request.getCookies(), RETURN_URL);\n                    String returnUrl = site.getDynamicPath();\n                    if (null != cookie && null != cookie.getValue()) {\n                        returnUrl = cookie.getValue();\n                    }\n                    SysUserToken entity = sysUserTokenService.getEntity(oauthAccess.getOpenId());\n                    if (null != entity) {\n                        if (entity.getChannel().equals(channel)) {\n                            ControllerUtils.setUserToSession(session, sysUserService.getEntity(entity.getUserId()));\n                            return UrlBasedViewResolver.REDIRECT_URL_PREFIX + returnUrl;\n                        }\n                    } else {\n                        SysUser user = ControllerUtils.getUserFromSession(session);\n                        if (null == user) {\n                            OauthUser oauthUser = oauthComponent.getUserInfo(site.getId(), oauthAccess);\n                            Map<String, String> config = configComponent.getConfigData(site.getId(), AbstractOauth.CONFIG_CODE);\n                            if (null != oauthUser && CommonUtils.notEmpty(config)\n                                    && CommonUtils.notEmpty(config.get(LoginConfigComponent.CONFIG_REGISTER_URL))) {\n                                model.addAttribute(\"nickname\", oauthUser.getNickname());\n                                model.addAttribute(\"openId\", oauthUser.getOpenId());\n                                model.addAttribute(\"avatar\", oauthUser.getAvatar());\n                                model.addAttribute(\"gender\", oauthUser.getGender());\n                                model.addAttribute(\"channel\", channel);\n                                model.addAttribute(\"returnUrl\", returnUrl);\n                                return UrlBasedViewResolver.REDIRECT_URL_PREFIX\n                                        + config.get(LoginConfigComponent.CONFIG_REGISTER_URL);\n                            }\n                        } else {\n                            String authToken = new StringBuilder(channel).append(CommonConstants.DOT).append(site.getId())\n                                    .append(CommonConstants.DOT).append(oauthAccess.getOpenId()).toString();\n                            Date now = CommonUtils.getDate();\n                            Map<String, String> config = configComponent.getConfigData(site.getId(), Config.CONFIG_CODE_SITE);\n                            int expiryMinutes = ConfigComponent.getInt(config.get(LoginConfigComponent.CONFIG_EXPIRY_MINUTES_WEB),\n                                    LoginConfigComponent.DEFAULT_EXPIRY_MINUTES);\n                            entity = new SysUserToken(authToken, site.getId(), user.getId(), channel, now,\n                                    DateUtils.addMinutes(now, expiryMinutes), RequestUtils.getIpAddress(request));\n                            sysUserTokenService.save(entity);\n                            LoginController.addLoginStatus(user, authToken, request, response, expiryMinutes);\n                            return UrlBasedViewResolver.REDIRECT_URL_PREFIX + returnUrl;\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                log.error(e);\n            }\n        }\n        return UrlBasedViewResolver.REDIRECT_URL_PREFIX + site.getDynamicPath();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 367,
    "type": "Param",
    "comment": "@param nd the other fixed dimension indices",
    "code": "\tpublic SparseVector fiber(int dim, int... keys) {\n\t\tif ((keys.length != numDimensions - 1) || size() < 1)\n\t\t\tthrow new Error(\"The input indices do not match the fiber specification!\");\n\n\t\t// find an indexed dimension for searching indices\n\t\tint d = -1;\n\t\tif ((indexedDimensions.size() == 0) || (indexedDimensions.contains(dim) && indexedDimensions.size() == 1)) {\n\t\t\td = (dim != 0 ? 0 : 1);\n\t\t\tbuildIndex(d);\n\t\t} else {\n\t\t\tfor (int dd : indexedDimensions) {\n\t\t\t\tif (dd != dim) {\n\t\t\t\t\td = dd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSparseVector res = new SparseVector(dimensions[dim]);\n\n\t\t// all relevant positions\n\t\tCollection<Integer> indices = keyIndices[d].get(keys[d < dim ? d : d - 1]);\n\t\tif (indices == null || indices.size() == 0)\n\t\t\treturn res;\n\n\t\t// for each possible position\n\t\tfor (int index : indices) {\n\t\t\tboolean found = true;\n\t\t\tfor (int dd = 0, ndi = 0; dd < numDimensions; dd++) {\n\n\t\t\t\tif (dd == dim)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (keys[ndi++] != key(dd, index)) {\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tres.set(key(dim, index), value(index));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n",
    "label": 1,
    "rec": "@param keys the other fixed dimension keys"
  },
  {
    "id": 368,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public Collection<ClusterNode> backups(Object key, long topVer) {\n        return backups(partition(key), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 369,
    "type": "Param",
    "comment": "@param results where to store the found results data for the action",
    "code": "    public static List fetchAllActionResults(\n        List resultList,\n        int action, \n        List actionResultList\n    ) {\n        for (int i = 0; i < resultList.size(); i++) {\n            //\n            // Check the result of every action whether it matches the given action\n            //\n            WSSecurityEngineResult result = \n                (WSSecurityEngineResult) resultList.get(i);\n            int resultAction = \n                ((java.lang.Integer)result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n            if (resultAction == action) {\n                actionResultList.add(result);\n            }\n        }\n        return actionResultList;\n    }\n\n",
    "label": 1,
    "rec": "@param actionResultList where to store the found results data for the action"
  },
  {
    "id": 370,
    "type": "Param",
    "comment": "@param generation the maximum number of iterations.",
    "code": "    public BitString[] learn(int size, int generation, BiFunction<double[][], double[], Regression<double[]>> trainer, RegressionMeasure measure, double[][] x, double[] y, int k) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        RegressionFitness fitness = new RegressionFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 371,
    "type": "Param",
    "comment": "@param transactions Map of txhash->transaction.",
    "code": "    public ConnectionResult connect(Transaction transaction, ConnectMode mode) {\n        if (!transaction.getHash().equals(outpoint.getHash()))\n            return ConnectionResult.NO_SUCH_TX;\n        checkElementIndex((int) outpoint.getIndex(), transaction.getOutputs().size(), \"Corrupt transaction\");\n        TransactionOutput out = transaction.getOutput((int) outpoint.getIndex());\n        if (!out.isAvailableForSpending()) {\n            if (mode == ConnectMode.DISCONNECT_ON_CONFLICT) {\n                out.markAsUnspent();\n            } else if (mode == ConnectMode.ABORT_ON_CONFLICT) {\n                outpoint.fromTx = checkNotNull(out.parentTransaction);\n                return TransactionInput.ConnectionResult.ALREADY_SPENT;\n            }\n        }\n        connect(out);\n        return TransactionInput.ConnectionResult.SUCCESS;\n    }\n",
    "label": 1,
    "rec": "@param transaction The transaction to try."
  },
  {
    "id": 372,
    "type": "Param",
    "comment": "@param nodeId Reader to add.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, long topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!U.hasNearCache(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listen(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        cctx.kernalContext().closure().runLocalSafe(new GridPlainRunnable() {\n                            @Override public void run() {\n                                synchronized (this) {\n                                    // Release memory.\n                                    reader0.resetTxFuture();\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 373,
    "type": "Param",
    "comment": "@param deserializePortable Deserialize portable flag.",
    "code": "    @Nullable public V get(K key, boolean deserializePortable, @Nullable IgnitePredicate<Cache.Entry<K, V>> filter)\n        throws IgniteCheckedException {\n        return getAllAsync(F.asList(key), deserializePortable, filter).get().get(key);\n    }\n",
    "label": 1,
    "rec": "@param filter Filter to evaluate."
  },
  {
    "id": 374,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorMetricsConfiguration from(IgniteConfiguration c) {\n        VisorMetricsConfiguration cfg = new VisorMetricsConfiguration();\n\n        cfg.expireTime(c.getMetricsExpireTime());\n        cfg.historySize(c.getMetricsHistorySize());\n        cfg.loggerFrequency(c.getMetricsLogFrequency());\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 375,
    "type": "Param",
    "comment": "@param end",
    "code": "  public List<String> lrange(final String key, final long start, final long stop) {\n    checkIsInMultiOrPipeline();\n    client.lrange(key, start, stop);\n    return client.getMultiBulkReply();\n  }\n",
    "label": 1,
    "rec": "@param stop"
  },
  {
    "id": 376,
    "type": "Param",
    "comment": "@param dataset Dataset to parse.",
    "code": "  public static DParseTask createPassOne(Value dataset, Job job, CustomParser.Type parserType) {\n    return new DParseTask(dataset,job,parserType);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 377,
    "type": "Param",
    "comment": "@param address the memory address of the AllocationPointerOperations",
    "code": "\tpublic static final String print(final long address[]) {\n\t\tif(address==null || address.length==0) throw new IllegalArgumentException(\"Address array was null or zero length\");\n\t\tfinal byte dim = getDimension(address[0]);\n\t\tStringBuilder b = new StringBuilder(String.format(\"AllocationPointer >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[0]), getCapacity(address[0]), getEndOffset(address[0])));\n\t\tif(dim>1) {\n\t\t\tb.append(String.format(\"\\n\\tAllocation Sizes >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[1]), getCapacity(address[1]), getEndOffset(address[1])));\n\t\t\tif(dim>2) b.append(String.format(\"\\n\\tAllocation Alignment Overheads >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[2]), getCapacity(address[2]), getEndOffset(address[2])));\n\t\t}\n\t\treturn b.toString();\n\t}\n\n",
    "label": 1,
    "rec": "@param address The address array of the allocation pointer memory block which could be a length of: Simple address management Address management with memory tracking Address management with memory tracking and cache-line alignment overhead "
  },
  {
    "id": 378,
    "type": "Param",
    "comment": "@param node Node.",
    "code": "    public boolean belongs(ClusterNode node, K key, AffinityTopologyVersion topVer) {\n        assert node != null;\n\n        return belongs(node, partition(key), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 379,
    "type": "Param",
    "comment": "@param type type",
    "code": "    public FallbackMethod getFallbackMethod(Class<?> enclosingType, Method commandMethod, boolean extended) {\n        if (commandMethod.isAnnotationPresent(HystrixCommand.class)) {\n            return FALLBACK_METHOD_FINDER.find(enclosingType, commandMethod, extended);\n        }\n        return FallbackMethod.ABSENT;\n    }\n",
    "label": 1,
    "rec": "@param enclosingType the enclosing class"
  },
  {
    "id": 380,
    "type": "Param",
    "comment": "@param commit",
    "code": "    public static String abbreviate(final GitCommit commit) {\n        return commit != null ? abbreviate(commit.sha) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 381,
    "type": "Param",
    "comment": "@param title",
    "code": "    public EditMilestoneTask edit(Milestone milestone) {\n        if (milestone != null)\n            milestoneNumber = milestone.getNumber();\n        else\n            milestoneNumber = -1;\n\n        dismissProgress();\n        showIndeterminate(string.updating_milestone);\n\n        super.execute();\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param milestone"
  },
  {
    "id": 382,
    "type": "Param",
    "comment": "@param data",
    "code": "    public boolean handleActivityResult(int activityRequestCode, int resultCode, Intent data, EditText textField) {\n        boolean result = false;\n        // handle the result of voice recognition, put it into the textfield\n        if (activityRequestCode == this.requestCode) {\n            // this was handled here, even if voicerecognition fails for any reason\n            // so your program flow wont get chaotic if you dont explicitly state\n            // your own requestCodes.\n            result = true;\n            if (resultCode == Activity.RESULT_OK) {\n                // Fill the quickAddBox-view with the string the recognizer thought it could have heard\n                ArrayList<String> match = data.getStringArrayListExtra(\n                        RecognizerIntent.EXTRA_RESULTS);\n                // make sure we only do this if there is SomeThing (tm) returned\n                if (match != null && match.size() > 0 && match.get(0).length() > 0) {\n                    String recognizedSpeech = match.get(0);\n                    recognizedSpeech = recognizedSpeech.substring(0, 1).toUpperCase() +\n                        recognizedSpeech.substring(1).toLowerCase();\n\n                    if(append)\n                        textField.setText((textField.getText() + \" \" + recognizedSpeech).trim());\n                    else\n                        textField.setText(recognizedSpeech);\n                }\n            }\n        }\n\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 383,
    "type": "Param",
    "comment": "@param userName",
    "code": "\tpublic User surpassOverload(String userId) {\n\n\t\tif (!isOverloaded(userId)) {\n\t\t\treturn getUser(userId);\n\t\t}\n\t\tif (getUsers().containsKey(userId.toLowerCase())) {\n\t\t\treturn getUsers().get(userId.toLowerCase());\n\t\t}\n\t\tUser newUser = createUser(userId);\n\t\treturn newUser;\n\t}\n",
    "label": 1,
    "rec": "@param userId"
  },
  {
    "id": 384,
    "type": "Param",
    "comment": "@param recursive Recursive flag.",
    "code": "    public boolean deleteDual(final GridGgfsFileSystem fs, final GridGgfsPath path, final boolean recursive)\n        throws GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert path != null;\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<GridGgfsPath, GridGgfsFileInfo> infos) throws Exception {\n                        GridGgfsFileInfo info = infos.get(path);\n\n                        if (info == null)\n                            return false; // File doesn't exist in the secondary file system.\n\n                        if (!fs.delete(secondaryPath(path), recursive))\n                            return false; // Delete failed remotely.\n\n                        if (path.parent() != null) {\n                            assert infos.containsKey(path.parent());\n\n                            softDeleteNonTx(infos.get(path.parent()).id(), path.name(), info.id());\n                        }\n                        else {\n                            assert ROOT_ID.equals(info.id());\n\n                            softDeleteNonTx(null, path.name(), info.id());\n                        }\n\n                        // Update the deleted file info with path information for delete worker.\n                        id2InfoPrj.transform(info.id(), new UpdatePath(path));\n\n                        return true; // No additional handling is required.\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws GridException {\n                        U.error(log, \"Path delete in DUAL mode failed [path=\" + path + \", recursive=\" + recursive + ']',\n                            err);\n\n                        throw new GridException(\"Failed to delete the path due to secondary file system exception: \",\n                            err);\n                    }\n                };\n\n                Boolean res = synchronizeAndExecute(task, fs, false, Collections.singleton(TRASH_ID), path);\n\n                delWorker.signal();\n\n                return res;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to delete in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 385,
    "type": "Param",
    "comment": "@param elements an array of model elements",
    "code": "\tprivate boolean allOfSameKind(IFolder[] folders) {\n\t\tint libraryFolderCount = 0;\n\n\t\t// count the library folders in the array\n\t\tfor (IResource folder : folders) {\n\t\t\tif (LibraryFolderManager.getInstance().isInLibraryFolder(folder)) {\n\t\t\t\tlibraryFolderCount++;\n\t\t\t}\n\t\t}\n\n\t\t// If the number of library folders is 0, then all folders are source\n\t\t// folders. If the number of library folders equals the number of given\n\t\t// folders, then all folders are library folders. In any other case,\n\t\t// there is a mixture of library folders and source folders.\n\t\treturn libraryFolderCount == 0 || libraryFolderCount == folders.length;\n\t}\n\n",
    "label": 1,
    "rec": "@param folders an array of folders"
  },
  {
    "id": 386,
    "type": "Param",
    "comment": "@param msg Message.",
    "code": "    protected boolean ensured(TcpDiscoveryAbstractMessage msg) {\n        return U.getAnnotation(msg.getClass(), TcpDiscoveryEnsureDelivery.class) != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 387,
    "type": "Param",
    "comment": "@param field",
    "code": "    public Long hdel(final String key, final String... fields) {\n        checkIsInMulti();\n        client.hdel(key, fields);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param fields"
  },
  {
    "id": 388,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static Iterable<VisorCacheConfiguration> list(IgniteEx ignite, CacheConfiguration[] caches) {\n        if (caches == null)\n            return Collections.emptyList();\n\n        final Collection<VisorCacheConfiguration> cfgs = new ArrayList<>(caches.length);\n\n        for (CacheConfiguration cache : caches)\n            cfgs.add(from(ignite, cache));\n\n        return cfgs;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 389,
    "type": "Param",
    "comment": "@param c Actual cache.",
    "code": "    public static VisorCache from(Ignite ignite, String cacheName, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && ca.context().affinityNode();\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(AffinityTopologyVersion.NONE)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param cacheName Cache name."
  },
  {
    "id": 390,
    "type": "Param",
    "comment": "@param pX",
    "code": "    private String createImageFile(double[] pVals, String pName, String pX, String pY) {\n        XYSeries series = new XYSeries(pName);\n        for (int i = 0; i < N; i++) {\n            series.add(i, pVals[i]);\n        }\n        XYSeriesCollection dataSet = new XYSeriesCollection();\n        dataSet.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createXYLineChart(\n                pName,\n                pX,\n                pY,\n                dataSet,\n                PlotOrientation.VERTICAL,\n                true,\n                false,\n                false);\n        XYPlot plot = (XYPlot) chart.getPlot();\n        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();\n        renderer.setSeriesLinesVisible(0, false);\n        renderer.setSeriesShapesVisible(0, true);\n        renderer.setSeriesShape(0, new java.awt.geom.Ellipse2D.Double(0, 0, 1, 1));\n        plot.setBackgroundPaint(java.awt.Color.WHITE);\n        plot.setDomainGridlinePaint(java.awt.Color.GRAY);\n        plot.setRangeGridlinePaint(java.awt.Color.GRAY);\n        plot.setRenderer(renderer);\n\n        String imageFile = \"\";\n        try {\n            final ChartRenderingInfo info = new ChartRenderingInfo(new StandardEntityCollection());\n            final File file1 = new File(pY + \".png\");\n            String fullPath = file1.getAbsolutePath();\n\n            fullPath = fullPath.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\");\n\n            imageFile = \"<IMG SRC=\\\"file:\\\\\\\\\\\\\\\\\" + fullPath + \"\\\" \" + \"WIDTH=\\\"600\\\" HEIGHT=\\\"400\\\" BORDER=\\\"0\\\" USEMAP=\\\"#chart\\\"></IMG>\";\n\n            File f2 = new File(fullPath);\n            ChartUtilities.saveChartAsPNG(file1, chart, 600, 400, info);\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        }\n\n        return imageFile;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 391,
    "type": "Param",
    "comment": "@param weightingMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&amp;api.xy=\" from the URL of the web UI",
    "code": "    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder) {\n        String weighting = hintsMap.getWeighting().toLowerCase();\n\n        if (encoder.supports(GenericWeighting.class)) {\n            DataFlagEncoder dataEncoder = (DataFlagEncoder) encoder;\n            return new GenericWeighting(dataEncoder, dataEncoder.readStringMap(hintsMap));\n        } else if (\"shortest\".equalsIgnoreCase(weighting)) {\n            return new ShortestWeighting(encoder);\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty()) {\n            if (encoder.supports(PriorityWeighting.class))\n                return new PriorityWeighting(encoder, hintsMap);\n            else\n                return new FastestWeighting(encoder, hintsMap);\n        } else if (\"curvature\".equalsIgnoreCase(weighting)) {\n            if (encoder.supports(CurvatureWeighting.class))\n                return new CurvatureWeighting(encoder, hintsMap);\n\n        } else if (\"short_fastest\".equalsIgnoreCase(weighting)) {\n            return new ShortFastestWeighting(encoder, hintsMap);\n        }\n\n        throw new IllegalArgumentException(\"weighting \" + weighting + \" not supported\");\n    }\n",
    "label": 1,
    "rec": "@param hintsMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&amp;api.xy=\" from the URL of the web UI"
  },
  {
    "id": 392,
    "type": "Param",
    "comment": "@param key Key to check.",
    "code": "    public boolean containsKey(KeyCacheObject key, byte[] keyBytes) throws IgniteCheckedException {\n        if (!offheapEnabled && !swapEnabled)\n            return false;\n\n        checkIteratorQueue();\n\n        int part = cctx.affinity().partition(key);\n\n        // First check off-heap store.\n        if (offheapEnabled)\n            if (offheap.contains(spaceName, part, key, keyBytes))\n                return true;\n\n        if (swapEnabled) {\n            assert key != null;\n\n            byte[] valBytes = swapMgr.read(spaceName, new SwapKey(key, part, keyBytes),\n                cctx.deploy().globalLoader());\n\n            return valBytes != null;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 393,
    "type": "Param",
    "comment": "@param cls Input split class.",
    "code": "    public static GridHadoopFileBlock readFileBlock(String clsName, FSDataInputStream in, @Nullable String[] hosts)\n        throws GridException {\n        if (!FileSplit.class.getName().equals(clsName))\n            return null;\n\n        FileSplit split = new FileSplit();\n\n        try {\n            split.readFields(in);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n\n        if (hosts == null)\n            hosts = EMPTY_HOSTS;\n\n        return new GridHadoopFileBlock(hosts, split.getPath().toUri(), split.getStart(), split.getLength());\n    }\n",
    "label": 1,
    "rec": "@param clsName Input split class."
  },
  {
    "id": 394,
    "type": "Param",
    "comment": "@param text",
    "code": "    public static ProgressDialog progressDialog(Activity context, String text) {\n        ProgressDialog dialog = new ProgressDialog(context);\n        dialog.setIndeterminate(true);\n        dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);\n        dialog.setMessage(text);\n        dialog.show();\n        dialog.setOwnerActivity(context);\n        return dialog;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 395,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<Cache.Entry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<Cache.Entry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n//        TODO ignite-96\n//        while (it.hasNext() && cnt < sz) {\n//            memSz += it.next().memorySize();\n//\n//            cnt++;\n//        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 396,
    "type": "Param",
    "comment": "@param vis Visitor.",
    "code": "            @Override public void apply(Cache.Entry<K, V> e) {\n                if (isAll(e, true))\n                    vis.apply(e);\n            }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 397,
    "type": "Param",
    "comment": "@param target the base name of the managed target to open.",
    "code": "\tpublic InputStream getInputStream(String managedFile) throws IOException {\n\t\treturn getInputStream(managedFile, ReliableFile.OPEN_BEST_AVAILABLE);\n\t}\n\n",
    "label": 1,
    "rec": "@param managedFile the name of the managed file to open."
  },
  {
    "id": 398,
    "type": "Param",
    "comment": "@param pointer data to access via a buffer or to copy to an array",
    "code": "    public static CharIndexer create(final CharPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new CharRawIndexer(pointer, sizes, strides)\n                                             : new CharBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            char[] array = new char[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new CharArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 399,
    "type": "Param",
    "comment": "@param annotatedGuy The annotated class or producer method",
    "code": "    public static InjectionResolver<?> getInjectionResolver(\n            ServiceLocatorImpl locator, Injectee injectee) throws IllegalStateException {\n        return getInjectionResolver(locator, injectee.getParent(), injectee.getPosition());\n\n    }\n\n",
    "label": 1,
    "rec": "@param injectee Injectee from which the annotation should be extracted"
  },
  {
    "id": 400,
    "type": "Param",
    "comment": "@param key",
    "code": "    public Long lrem(final String key, final int count, final String value) {\n        runChecks();\n        client.lrem(key, count, value);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 401,
    "type": "Param",
    "comment": "@param itol specify which convergence test is applied. If itol = 1, iteration stops when |Ax - b| / |b| is less than the parameter tolerance. If itol = 2, the stop criterion is |A-1 (Ax - b)| / |A-1b| is less than tolerance. If tol = 3, |xk+1 - xk|2 is less than tolerance. The setting of tol = 4 is same as tol = 3 except that the L&infin; norm instead of L2.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol) {\n        return solve(A, Ap, b, x, tol, itol, 2 * Math.max(A.nrows(), A.ncols()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 402,
    "type": "Param",
    "comment": "@param rawFormatInfo",
    "code": "  static FormatInformation decodeFormatInformation(int maskedFormatInfo) {\n    FormatInformation formatInfo = doDecodeFormatInformation(maskedFormatInfo);\n    if (formatInfo != null) {\n      return formatInfo;\n    }\n    // Should return null, but, some QR codes apparently\n    // do not mask this info. Try again by actually masking the pattern\n    // first\n    return doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR);\n  }\n",
    "label": 1,
    "rec": "@param maskedFormatInfo format info indicator, with mask still applied"
  },
  {
    "id": 403,
    "type": "Param",
    "comment": "@param where",
    "code": "    public int deleteWhere(AbstractDatabase database, Criterion where) {\n        return database.getDatabase().delete(Metadata.TABLE.getName(),\n                where.toString(), null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 404,
    "type": "Param",
    "comment": "@param jCommander JCommander instance.",
    "code": "    private String reformatArguments(List<String> args) {\n        StringBuilder sb = new StringBuilder();\n\n        addArgWithValue(sb, \"INTERACTIVE\", formatBooleanValue(interactive));\n        addArgWithValue(sb, \"QUIET\", \"-DGRIDGAIN_QUIET=\" + !verbose);\n        addArgWithValue(sb, \"NO_PAUSE\", formatBooleanValue(noPause));\n        addArgWithValue(sb, \"HADOOP_LIB_DIR\", useHadoop1 ? \"hadoop1\" : \"hadoop2\");\n\n        parseJvmOptionsAndSpringConfig(args);\n\n        addArgWithValue(sb, \"JVM_XOPTS\", jvmOptions);\n        addArgWithValue(sb, \"CONFIG\", springCfgPath);\n\n        return sb.toString().trim();\n    }\n",
    "label": 1,
    "rec": "@param args Non-standard arguments."
  },
  {
    "id": 405,
    "type": "Param",
    "comment": "@param filter Entry filter.",
    "code": "    public boolean visitable(CacheEntryPredicate[] filter) {\n        try {\n            if (obsoleteOrDeleted() || (filter != CU.empty0() &&\n                !cctx.isAll(this, filter)))\n                return false;\n        }\n        catch (IgniteCheckedException e) {\n            U.error(log, \"An exception was thrown while filter checking.\", e);\n\n            RuntimeException ex = e.getCause(RuntimeException.class);\n\n            if (ex != null)\n                throw ex;\n\n            Error err = e.getCause(Error.class);\n\n            if (err != null)\n                throw err;\n\n            return false;\n        }\n\n        IgniteInternalTx tx = cctx.tm().localTxx();\n\n        return tx == null || !tx.removed(txKey());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 406,
    "type": "Param",
    "comment": "@param mavenCoordinate the coordinate to retrieve an archive file for",
    "code": "  @Nullable\n  public static File getArchiveForCoordinate(GradleCoordinate gradleCoordinate) {\n    SdkManager sdk = AndroidSdkUtils.tryToChooseAndroidSdk();\n\n    if (sdk == null) {\n      return null;\n    }\n\n    // Get the parameters to include in the path\n    String sdkLocation = sdk.getLocation();\n    String artifactId = gradleCoordinate.getArtifactId();\n    String revision = gradleCoordinate.getFullRevision();\n    RepositoryLibrary library = EXTRAS_REPOSITORY.get(artifactId);\n\n    File path = new File(String.format(library.basePath, sdkLocation, library.id));\n    String revisionPath = String.format(MAVEN_REVISION_PATH, library.id, revision) + library.archiveExtension;\n\n    return new File(path, revisionPath);\n  }\n\n",
    "label": 1,
    "rec": "@param gradleCoordinate the coordinate to retrieve an archive file for"
  },
  {
    "id": 407,
    "type": "Param",
    "comment": "@param keyBytes Key bytes.",
    "code": "    boolean removeOffheap(final KeyCacheObject key, byte[] keyBytes) throws IgniteCheckedException {\n        assert offheapEnabled;\n\n        checkIteratorQueue();\n\n        int part = cctx.affinity().partition(key);\n\n        return offheap.removex(spaceName, part, key, keyBytes);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 408,
    "type": "Param",
    "comment": "@param configValue the configured value for this filter for the matching path.",
    "code": "    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings."
  },
  {
    "id": 409,
    "type": "Param",
    "comment": "@param chol",
    "code": "  public Cholesky cholesky(Cholesky chol, int parallelize) {\n    if( chol == null ) {\n      double[][] xx = _xx.clone();\n      for( int i = 0; i < xx.length; ++i )\n        xx[i] = xx[i].clone();\n      chol = new Cholesky(xx, _diag.clone());\n    }\n    final Cholesky fchol = chol;\n    final int sparseN = _diag.length;\n    final int denseN = _fullN - sparseN;\n    boolean spd=true;\n    // compute the cholesky of the diagonal and diagonal*dense parts\n    if( _diag != null ) for( int i = 0; i < sparseN; ++i ) {\n      double d = 1.0 / (chol._diag[i] = Math.sqrt(_diag[i]));\n      for( int j = 0; j < denseN; ++j )\n        chol._xx[j][i] = d*_xx[j][i];\n    }\n    Futures fs = new Futures();\n    // compute the outer product of diagonal*dense\n    for( int i = 0; i < denseN; ++i ) {\n      final int fi = i;\n      fs.add(new RecursiveAction() {\n        @Override protected void compute() {\n          for( int j = 0; j <= fi; ++j ) {\n            double s = 0;\n            for( int k = 0; k < sparseN; ++k )\n              s += fchol._xx[fi][k] * fchol._xx[j][k];\n            fchol._xx[fi][j + sparseN] = _xx[fi][j + sparseN] - s;\n          }\n        }\n      }.fork());\n    }\n    fs.blockForPending();\n        \n    // compute the cholesky of dense*dense-outer_product(diagonal*dense)\n    // TODO we still use Jama, which requires (among other things) copy and expansion of the matrix. Do it here without copy and faster.\n    double[][] arr = new double[denseN][];\n    for( int i = 0; i < arr.length; ++i )\n      arr[i] = Arrays.copyOfRange(fchol._xx[i], sparseN, sparseN + denseN);\n    // parallelize cholesky\n    if (parallelize == 1) {\n      int p = Runtime.getRuntime().availableProcessors();\n      InPlaceCholesky d = InPlaceCholesky.decompose_2(arr, 10, p);\n      fchol.setSPD(d.isSPD());\n      arr = d.getL();\n    } else {\n      // make it symmetric\n      for( int i = 0; i < arr.length; ++i )\n        for( int j = 0; j < i; ++j )\n          arr[j][i] = arr[i][j];\n      CholeskyDecomposition c = new Matrix(arr).chol();\n      fchol.setSPD(c.isSPD());\n      arr = c.getL().getArray();\n    }\n    for( int i = 0; i < arr.length; ++i )\n      System.arraycopy(arr[i], 0, fchol._xx[i], sparseN, i + 1);\n    return chol;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 410,
    "type": "Param",
    "comment": "@param encoder the FlagEncoder (to specify the vehicle)",
    "code": "    public Weighting createWeighting( String weighting, FlagEncoder encoder )\n    {\n        // ignore case\n        weighting = weighting.toLowerCase();\n        if (\"fastest\".equals(weighting))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                return new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                return new FastestWeighting(encoder);\n        }\n        return new ShortestWeighting();\n    }\n",
    "label": 1,
    "rec": "@param encoder"
  },
  {
    "id": 411,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite g, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final GridStreamer streamer = g.streamer(\"popular-numbers\");\n\n                try {\n                    // Send reduce query to all 'popular-numbers' streamers\n                    // running on local and remote nodes.\n                    Collection<GridStreamerIndexEntry<Integer, Integer, Long>> col = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new GridClosure<GridStreamerContext,\n                            Collection<GridStreamerIndexEntry<Integer, Integer, Long>>>() {\n                            @Override public Collection<GridStreamerIndexEntry<Integer, Integer, Long>> apply(\n                                GridStreamerContext ctx) {\n                                GridStreamerIndex<Integer, Integer, Long> view = ctx.<Integer>window().index();\n\n                                return view.entries(-1 * POPULAR_NUMBERS_CNT);\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new PopularNumbersReducer());\n\n                    for (GridStreamerIndexEntry<Integer, Integer, Long> cntr : col)\n                        System.out.printf(\"%3d=%d\\n\", cntr.key(), cntr.value());\n\n                    System.out.println(\"----------------\");\n                }\n                catch (GridException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 412,
    "type": "Param",
    "comment": "@param privateKeyToDecode The private key to decrypt",
    "code": "    public byte[] decrypt(EncryptedData dataToDecrypt, KeyParameter aesKey) throws KeyCrypterException {\n        checkNotNull(dataToDecrypt);\n        checkNotNull(aesKey);\n\n        try {\n            ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), dataToDecrypt.initialisationVector);\n\n            // Decrypt the message.\n            BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));\n            cipher.init(false, keyWithIv);\n\n            byte[] cipherBytes = dataToDecrypt.encryptedBytes;\n            byte[] decryptedBytes = new byte[cipher.getOutputSize(cipherBytes.length)];\n            final int length1 = cipher.processBytes(cipherBytes, 0, cipherBytes.length, decryptedBytes, 0);\n            final int length2 = cipher.doFinal(decryptedBytes, length1);\n\n            return Arrays.copyOf(decryptedBytes, length1 + length2);\n        } catch (Exception e) {\n            throw new KeyCrypterException(\"Could not decrypt bytes\", e);\n        }\n    }\n",
    "label": 1,
    "rec": "@param dataToDecrypt The data to decrypt"
  },
  {
    "id": 413,
    "type": "Param",
    "comment": "@param size the population size of Genetic Algorithm.",
    "code": "    public BitString[] learn(int size, int generation, BiFunction<double[][], double[], Regression<double[]>> trainer, RegressionMeasure measure, double[][] x, double[] y, int k) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        RegressionFitness fitness = new RegressionFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 414,
    "type": "Param",
    "comment": "@param imageName",
    "code": "\tpublic String buildStaticFilePath(MerchantStore store) {\n\t\tStringBuilder sb = new StringBuilder().append(Constants.STATIC_URI).append(Constants.FILES_URI).append(Constants.SLASH).append(store.getCode()).append(Constants.SLASH);\n\t\treturn sb.toString();\n\t}\n",
    "label": 1,
    "rec": "@param fileName"
  },
  {
    "id": 415,
    "type": "Param",
    "comment": "@param image The image to decode",
    "code": "  private Result doDecode(BinaryBitmap image, Hashtable hints) throws ReaderException {\n    int width = image.getWidth();\n    int height = image.getHeight();\n    BitArray row = new BitArray(width);\n\n    int middle = height >> 1;\n    boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n    int rowStep = Math.max(1, height >> (tryHarder ? 7 : 4));\n    int maxLines;\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 9; // Nine rows spaced 1/16 apart is roughly the middle half of the image\n    }\n\n    for (int x = 0; x < maxLines; x++) {\n\n      // Scanning from the middle out. Determine which row we're looking at next:\n      int rowStepsAboveOrBelow = (x + 1) >> 1;\n      boolean isAbove = (x & 0x01) == 0; // i.e. is x even?\n      int rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      }\n\n      // Estimate black point for this row and load it:\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ReaderException re) {\n        continue;\n      }      \n\n      // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n      for (int attempt = 0; attempt < 2; attempt++) {\n        if (attempt == 1) { // trying again?\n          row.reverse(); // reverse the row and continue\n        }\n        try {\n          // Look for a barcode\n          Result result = decodeRow(rowNumber, row, hints);\n          // We found our barcode\n          if (attempt == 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType.ORIENTATION, new Integer(180));\n            // And remember to flip the result points horizontally.\n            ResultPoint[] points = result.getResultPoints();\n            points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());\n            points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());\n          }\n          return result;\n        } catch (ReaderException re) {\n          // continue -- just couldn't decode this row\n        }\n      }\n    }\n\n    throw ReaderException.getInstance();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 416,
    "type": "Param",
    "comment": "@param end",
    "code": "  public Long zremrangeByScore(final byte[] key, final double min, final double max) {\n    return zremrangeByScore(key, toByteArray(min), toByteArray(max));\n  }\n",
    "label": 1,
    "rec": "@param max"
  },
  {
    "id": 417,
    "type": "Param",
    "comment": "@param data The byte to crc check",
    "code": "\tpublic static byte crc8_tab(byte data, byte crcInit) {\n\t\tshort ci = (short) (crcInit & 0xFF);\n\t\tbyte crc = (byte) (CRC_TAB_8_VALUE[ci] ^ (data & 0xFF));\n\t\treturn crc;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 418,
    "type": "Param",
    "comment": "@param out Output stream to that file.",
    "code": "    private IgfsFileWorkerBatch newBatch(final IgfsPath path, OutputStream out) throws IgniteCheckedException {\n        assert path != null;\n        assert out != null;\n\n        if (enterBusy()) {\n            try {\n                IgfsFileWorkerBatch batch = new IgfsFileWorkerBatch(path, out);\n\n                while (true) {\n                    IgfsFileWorker worker = workerMap.get(path);\n\n                    if (worker != null) {\n                        if (worker.addBatch(batch)) // Added batch to active worker.\n                            break;\n                        else\n                            workerMap.remove(path, worker); // Worker is stopping. Remove it from map.\n                    }\n                    else {\n                        worker = new IgfsFileWorker(\"ggfs-file-worker-\" + path) {\n                            @Override protected void onFinish() {\n                                workerMap.remove(path, this);\n                            }\n                        };\n\n                        boolean b = worker.addBatch(batch);\n\n                        assert b;\n\n                        if (workerMap.putIfAbsent(path, worker) == null) {\n                            worker.start();\n\n                            break;\n                        }\n                    }\n                }\n\n                return batch;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IgniteCheckedException(\"Cannot create new output stream to the secondary file system because GGFS is \" +\n                \"stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 419,
    "type": "Param",
    "comment": "@param inputRecordContext",
    "code": "    public static ByteBuffer serializeRecordToFlatBuffer(Record<byte[]> record) {\n        DEFAULT_FB_BUILDER.clear();\n        return serializeRecordToFlatBuffer(DEFAULT_FB_BUILDER, record);\n    }\n",
    "label": 1,
    "rec": "@param record"
  },
  {
    "id": 420,
    "type": "Param",
    "comment": "@param key",
    "code": "    public Boolean setbit(byte[] key, long offset, boolean value) {\n\tclient.setbit(key, offset, value);\n\treturn client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 421,
    "type": "Param",
    "comment": "@param sourcePos",
    "code": "    public SuggestionCursor getSourceResult(ComponentName source) {\n        if (mClosed) {\n            throw new IllegalStateException(\"Called getSourceResult(\" + source\n                + \") when closed.\");\n        }\n        return mSourceResultsBySource.get(source);\n    }\n\n",
    "label": 1,
    "rec": "@param source Source name."
  },
  {
    "id": 422,
    "type": "Param",
    "comment": "@param bits booleans representing white/black QR Code modules",
    "code": "  public DecoderResult decode(BitMatrix bits, Hashtable hints) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion();\n    ErrorCorrectionLevel ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser.decode(resultBytes, version, ecLevel, hints);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 423,
    "type": "Param",
    "comment": "@param categories the categories to use for logging level adjusting",
    "code": "\tpublic Log4j2LevelAdjuster categories(boolean merge, String... categoriesToAdjust) {\n\t\treturn new Log4j2LevelAdjuster(this.level, this.classes,\n\t\t\t\tmerge\n\t\t\t\t\t\t? Stream.of(this.categories, categoriesToAdjust).flatMap(Stream::of).toArray(String[]::new)\n\t\t\t\t\t\t: categoriesToAdjust);\n\t}\n",
    "label": 1,
    "rec": "@param categoriesToAdjust the categories to use for logging level adjusting"
  },
  {
    "id": 424,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    @Nullable public GridCacheMvccCandidate explicitLock(IgniteTxKey key, @Nullable GridCacheVersion ver) {\n        for (GridCacheExplicitLockSpan span : pendingExplicit.values()) {\n            GridCacheMvccCandidate cand = span.candidate(key, ver);\n\n            if (cand != null)\n                return cand;\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 425,
    "type": "Param",
    "comment": "@param wMap all parameters influencing the weighting. E.g. URL parameters coming via GHRequest",
    "code": "    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )\n    {\n        String weighting = weightingMap.getWeighting();\n        Weighting result;\n\n        if (\"shortest\".equalsIgnoreCase(weighting))\n        {\n            result = new ShortestWeighting();\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty())\n        {\n            if (encoder.supports(PriorityWeighting.class))\n                result = new PriorityWeighting(encoder);\n            else\n                result = new FastestWeighting(encoder);\n        } else\n        {\n            throw new UnsupportedOperationException(\"weighting \" + weighting + \" not supported\");\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param weightingMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&api.xy=\" from the URL of the web UI"
  },
  {
    "id": 426,
    "type": "Param",
    "comment": "@param path Path.",
    "code": "    private List<IgniteUuid> fileIds(IgfsPath path, boolean skipTx) throws IgniteCheckedException {\n        assert path != null;\n\n        // Path components.\n        Collection<String> components = path.components();\n\n        // Collection of file IDs for components of specified path.\n        List<IgniteUuid> ids = new ArrayList<>(components.size() + 1);\n\n        ids.add(ROOT_ID); // Always add root ID.\n\n        IgniteUuid fileId = ROOT_ID;\n\n        for (String s : components) {\n            assert !s.isEmpty();\n\n            if (fileId != null)\n                fileId = fileId(fileId, s, skipTx);\n\n            ids.add(fileId);\n        }\n\n        return ids;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 427,
    "type": "Param",
    "comment": "@param file",
    "code": "    public static String getName(final String path) {\n        if (TextUtils.isEmpty(path))\n            return path;\n\n        int lastSlash = path.lastIndexOf('/');\n        if (lastSlash != -1 && lastSlash + 1 < path.length())\n            return path.substring(lastSlash + 1);\n        else\n            return path;\n    }\n",
    "label": 1,
    "rec": "@param path"
  },
  {
    "id": 428,
    "type": "Param",
    "comment": "@param key : keyName strings serialized as bytes eg. 'cluster.xml'",
    "code": "    public void put(ByteArray keyBytes, Versioned<byte[]> valueBytes) throws VoldemortException {\n        try {\n            String key = ByteUtils.getString(keyBytes.get(), \"UTF-8\");\n            Versioned<String> value = new Versioned<String>(ByteUtils.getString(valueBytes.getValue(),\n                                                                                \"UTF-8\"),\n                                                            valueBytes.getVersion());\n            if(METADATA_KEYS.contains(key)) {\n\n                // cache all keys\n                metadataCache.put(key, convertBytesToObject(key, value));\n\n                // only persistent_keys should be persisted\n                if(PERSISTENT_KEYS.contains(key)) {\n                    innerStore.put(key, value);\n                }\n            } else {\n                throw new VoldemortException(\"Unhandled Key:\" + key + \" for MetadataStore put()\");\n            }\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to put() for key:\"\n                                         + ByteUtils.getString(keyBytes.get(), \"UTF-8\"), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 429,
    "type": "Param",
    "comment": "@param field",
    "code": "    public Long hdel(final byte[] key, final byte[]... fields) {\n        checkIsInMulti();\n        client.hdel(key, fields);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param fields"
  },
  {
    "id": 430,
    "type": "Param",
    "comment": "@param params Parameters.",
    "code": "    private static List<Object> findParams(GridSqlQuery qry, Object[] params, ArrayList<Object> target) {\n        if (params.length == 0)\n            return target;\n\n        for (GridSqlElement el : qry.select())\n            findParams(el, params, target);\n\n        findParams(qry.from(), params, target);\n        findParams(qry.where(), params, target);\n\n        for (GridSqlElement el : qry.groups())\n            findParams(el, params, target);\n\n        findParams(qry.having(), params, target);\n\n        for (GridSqlElement el : qry.sort().keySet())\n            findParams(el, params, target);\n\n        findParams(qry.limit(), params, target);\n        findParams(qry.offset(), params, target);\n\n        return target;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 431,
    "type": "Param",
    "comment": "@param max the maximum number of bytes a single message can be.",
    "code": "  public T maxInboundMessageSize(int bytes) {\n    // intentional noop rather than throw, this method is only advisory.\n    Preconditions.checkArgument(bytes >= 0, \"bytes must be >= 0\");\n    return thisT();\n  }\n",
    "label": 1,
    "rec": "@param bytes the maximum number of bytes a single message can be."
  },
  {
    "id": 432,
    "type": "Param",
    "comment": "@param node Node to move partition to.",
    "code": "        boolean assign(int part, int tier, ClusterNode node, boolean force, Map<Integer, Queue<Integer>> pendingParts) {\n            UUID nodeId = node.id();\n\n            if (!fullMap.get(nodeId).contains(part)) {\n                tierMaps[tier].get(nodeId).add(part);\n\n                fullMap.get(nodeId).add(part);\n\n                List<ClusterNode> assignment = assignments.get(part);\n\n                if (assignment.size() <= tier)\n                    assignment.add(node);\n                else {\n                    ClusterNode oldNode = assignment.set(tier, node);\n\n                    if (oldNode != null) {\n                        UUID oldNodeId = oldNode.id();\n\n                        tierMaps[tier].get(oldNodeId).remove(part);\n                        fullMap.get(oldNodeId).remove(part);\n                    }\n                }\n\n                return true;\n            }\n            else if (force) {\n                assert !tierMaps[tier].get(nodeId).contains(part);\n\n                // Check previous tiers first.\n                for (int t = 0; t < tier; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part))\n                        return false;\n                }\n\n                // Partition is on some lower tier, switch it.\n                for (int t = tier + 1; t < tierMaps.length; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part)) {\n                        ClusterNode oldNode = assignments.get(part).get(tier);\n\n                        // Move partition from level t to tier.\n                        assignments.get(part).set(tier, node);\n                        assignments.get(part).set(t, null);\n\n                        if (oldNode != null) {\n                            tierMaps[tier].get(oldNode.id()).remove(part);\n                            fullMap.get(oldNode.id()).remove(part);\n                        }\n\n                        tierMaps[tier].get(nodeId).add(part);\n                        tierMaps[t].get(nodeId).remove(part);\n\n                        Queue<Integer> pending = pendingParts.get(t);\n\n                        if (pending == null) {\n                            pending = new LinkedList<>();\n\n                            pendingParts.put(t, pending);\n                        }\n\n                        pending.add(part);\n\n                        return true;\n                    }\n                }\n\n                throw new IllegalStateException(\"Unable to assign partition to node while force is true.\");\n            }\n\n            // !force.\n            return false;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 433,
    "type": "Param",
    "comment": "@param source",
    "code": "\tpublic static boolean isValid(String candidate) {\n\t\treturn candidate == null ? false : PATTERN.matcher(candidate).matches();\n\t}\n",
    "label": 1,
    "rec": "@param candidate"
  },
  {
    "id": 434,
    "type": "Param",
    "comment": "@param tx Cache transaction.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, Object key, Object val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = cctx.unwrapPortableIfNeeded(key, false);\n                val = cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(key, locStore ? F.t(val, ver) : val));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 435,
    "type": "Param",
    "comment": "@param bytes the message converted to a byte array",
    "code": "  private static int determineConsecutiveBinaryCount(String msg, int startpos, Charset encoding)\n      throws WriterException {\n    final CharsetEncoder encoder = encoding.newEncoder();\n    int len = msg.length();\n    int idx = startpos;\n    while (idx < len) {\n      char ch = msg.charAt(idx);\n      int numericCount = 0;\n\n      while (numericCount < 13 && isDigit(ch)) {\n        numericCount++;\n        //textCount++;\n        int i = idx + numericCount;\n        if (i >= len) {\n          break;\n        }\n        ch = msg.charAt(i);\n      }\n      if (numericCount >= 13) {\n        return idx - startpos;\n      }\n      ch = msg.charAt(idx);\n\n      if (!encoder.canEncode(ch)) {\n        throw new WriterException(\"Non-encodable character detected: \" + ch + \" (Unicode: \" + (int) ch + ')');\n      }\n      idx++;\n    }\n    return idx - startpos;\n  }\n",
    "label": 1,
    "rec": "@param startpos the start position within the message"
  },
  {
    "id": 436,
    "type": "Param",
    "comment": "@param size the population size of Genetic Algorithm.",
    "code": "    public BitString[] learn(int size, int generation, double[][] x, double[] y, int k, RegressionMeasure measure, BiFunction<double[][], double[], Regression<double[]>> trainer) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (k < 2) {\n            throw new IllegalArgumentException(\"Invalid k-fold cross validation: \" + k);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        int p = x[0].length;\n        RegressionFitness fitness = new RegressionFitness(trainer, measure, x, y, k);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 437,
    "type": "Param",
    "comment": "@param n number of entries to return",
    "code": "\tpublic Int2IntMap.Entry[] getEntriesSortedByValue(int k) {\n\t\tInt2IntMap.Entry[] entries = getEntriesSortedByValue();\n\n\t\tif (entries == null)\n\t\t\treturn null;\n\n\t\tif (entries.length < k)\n\t\t\treturn entries;\n\n\t\treturn Arrays.copyOfRange(entries, 0, k);\n\t}\n\n",
    "label": 1,
    "rec": "@param k number of entries to return"
  },
  {
    "id": 438,
    "type": "Param",
    "comment": "@param accountCredentials the Account's stored credentials.",
    "code": "    protected boolean equals( byte[] tokenCredentials, byte[] accountCredentials ) {\n\n        return Arrays.equals( tokenCredentials, accountCredentials );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 439,
    "type": "Param",
    "comment": "@param nodeLabelInsets the additional insets for node labels on this node",
    "code": "    public static ElkPadding calculateRequiredNodeLabelSpace(final NodeAdapter<?> node,\n            final double labelSpacing, final ElkPadding nodeLabelPadding,\n            final Map<LabelLocation, LabelGroup> labelGroupsBoundingBoxes, final ElkPadding padding) {\n\n        // Check if there are any labels\n        if (!node.getLabels().iterator().hasNext()) {\n            return padding;\n        }\n        \n        // Retrieve the node's label placement policy\n        final Set<NodeLabelPlacement> nodeLabelPlacement = node.getProperty(CoreOptions.NODE_LABELS_PLACEMENT);\n        final LabelLocation nodeLabelLocation = LabelLocation.fromNodeLabelPlacement(nodeLabelPlacement);\n        \n        // Compute a bounding box for each location where labels should be placed.\n        // The size is calculated from the size of all labels stacked vertically at that location.\n        for (final LabelAdapter<?> label : node.getLabels()) {\n            LabelLocation labelPlacement =\n                    LabelLocation.fromNodeLabelPlacement(label.getProperty(CoreOptions.NODE_LABELS_PLACEMENT));\n            \n            // If no valid placement is set on the label, use the node's placement policy.\n            if (labelPlacement == LabelLocation.UNDEFINED) {\n                labelPlacement = nodeLabelLocation;\n            }\n            \n            // Save the location of this label in its id field for later use.\n            label.setVolatileId(labelPlacement.ordinal());\n            \n            // Create or retrieve the label group for the current label.\n            final Rectangle boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);\n            boundingBox.width = Math.max(boundingBox.width, label.getSize().x);\n            boundingBox.height += label.getSize().y + labelSpacing;\n        }\n        \n        // We need to count different label placement boxes towards different kinds of padding, depending on whether\n        // or not H_PRIORITY is set on the node itself (see H_PRIORITY documentation)\n        boolean hPrio = nodeLabelPlacement.contains(NodeLabelPlacement.H_PRIORITY);\n        \n        // Calculate the node label space required inside the node (only label groups on the inside\n        // are relevant here).\n        for (final Entry<LabelLocation, LabelGroup> entry : labelGroupsBoundingBoxes.entrySet()) {\n            final Rectangle boundingBox = entry.getValue();\n            \n            // From each existing label group, remove the last superfluous label spacing\n            // (the mere existence of a label group implies that it contains at least one label)\n            boundingBox.height -= labelSpacing;\n            switch (entry.getKey()) {\n            case IN_T_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_T_C:\n                padding.top = Math.max(\n                        padding.top,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                break;\n                \n            case IN_T_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_C_L:\n                padding.left = Math.max(\n                        padding.left,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                break;\n                \n            case IN_C_R:\n                padding.right = Math.max(\n                        padding.right,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                break;\n                \n            case IN_B_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            case IN_B_C:\n                padding.bottom = Math.max(\n                        padding.bottom,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                break;\n                \n            case IN_B_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            default:\n                // In all other cases, no specific action is required\n            }\n        }\n\n        // Add node label padding that aren't set yet\n        // This happens if e.g. a top inset is set but no top label is present\n        padding.top    = Math.max(padding.top, nodeLabelPadding.top);\n        padding.left   = Math.max(padding.left, nodeLabelPadding.left);\n        padding.right  = Math.max(padding.right, nodeLabelPadding.right);\n        padding.bottom = Math.max(padding.bottom, nodeLabelPadding.bottom);\n\n        return padding;\n    }\n\n",
    "label": 1,
    "rec": "@param nodeLabelPadding the additional padding for node labels on this node"
  },
  {
    "id": 440,
    "type": "Param",
    "comment": "@param pName",
    "code": "    private String createImageFile(TempDir tempDir, double[] pVals, String pName, String pX, String pY) throws IOException {\n        XYSeries series = new XYSeries(pName);\n        for (int i = 0; i < mN; i++) {\n            series.add(i, pVals[i]);\n        }\n        XYSeriesCollection dataSet = new XYSeriesCollection();\n        dataSet.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createXYLineChart(\n                pName,\n                pX,\n                pY,\n                dataSet,\n                PlotOrientation.VERTICAL,\n                true,\n                false,\n                false);\n        XYPlot plot = (XYPlot) chart.getPlot();\n        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();\n        renderer.setSeriesLinesVisible(0, false);\n        renderer.setSeriesShapesVisible(0, true);\n        renderer.setSeriesShape(0, new java.awt.geom.Ellipse2D.Double(0, 0, 1, 1));\n        plot.setBackgroundPaint(java.awt.Color.WHITE);\n        plot.setDomainGridlinePaint(java.awt.Color.GRAY);\n        plot.setRangeGridlinePaint(java.awt.Color.GRAY);\n        plot.setRenderer(renderer);\n\n        String imageFile = \"\";\n\n        ChartRenderingInfo info = new ChartRenderingInfo(new StandardEntityCollection());\n        String fileName = pY + \".png\";\n        File file1 = tempDir.createFile(fileName);\n        imageFile = \"<IMG SRC=\\\"file:\" + file1.getAbsolutePath() + \"\\\" \" + \"WIDTH=\\\"600\\\" HEIGHT=\\\"400\\\" BORDER=\\\"0\\\" USEMAP=\\\"#chart\\\"></IMG>\";\n\n        ChartUtilities.saveChartAsPNG(file1, chart, 600, 400, info);\n\n        return imageFile;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 441,
    "type": "Param",
    "comment": "@param domain an editing domain",
    "code": "\tpublic static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {\n\t\tif ( resourceSet == null ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tCrossReferenceAdapter result = getExistingCrossReferenceAdapter(\n\t\t\tresourceSet);\n\t\t\n\t\tif (result == null) {\n\t\t\tresult = new CrossReferenceAdapter();\n\t\t\tresourceSet.eAdapters().add(result);\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\n",
    "label": 1,
    "rec": "@param resourceSet the resource set"
  },
  {
    "id": 442,
    "type": "Param",
    "comment": "@param evt Event flag.",
    "code": "    @Override protected void clearIndex(CacheObject val) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 443,
    "type": "Param",
    "comment": "@param context",
    "code": "\tpublic static Drawable getTintDrawable(Drawable drawable, int color, boolean forceTint) {\n\t\tif (forceTint) {\n\t\t\tdrawable.clearColorFilter();\n\t\t\tdrawable.setColorFilter(color, PorterDuff.Mode.SRC_ATOP);\n\t\t\tdrawable.invalidateSelf();\n\t\t\treturn drawable;\n\t\t}\n\t\tDrawable wrapDrawable = DrawableCompat.wrap(drawable);\n\t\tDrawableCompat.setTint(wrapDrawable, color);\n\t\treturn wrapDrawable;\n\t}\n",
    "label": 1,
    "rec": "@param drawable"
  },
  {
    "id": 444,
    "type": "Param",
    "comment": "@param direct  true to use a direct buffer, see  Indexer for details",
    "code": "    public static UShortIndexer create(final ShortPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new UShortRawIndexer(pointer, sizes, strides)\n                                             : new UShortBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            short[] array = new short[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new UShortArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 445,
    "type": "Param",
    "comment": "@param out Output stream to that file.",
    "code": "    private GridGgfsFileWorkerBatch newBatch(final GridGgfsPath path, OutputStream out) throws GridException {\n        assert path != null;\n        assert out != null;\n\n        if (busyLock.enterBusy()) {\n            try {\n                GridGgfsFileWorkerBatch batch = new GridGgfsFileWorkerBatch(path, out);\n\n                while (true) {\n                    GridGgfsFileWorker worker = workerMap.get(path);\n\n                    if (worker != null) {\n                        if (worker.addBatch(batch)) // Added batch to active worker.\n                            break;\n                        else\n                            workerMap.remove(path, worker); // Worker is stopping. Remove it from map.\n                    }\n                    else {\n                        worker = new GridGgfsFileWorker(\"ggfs-file-worker-\" + path) {\n                            @Override protected void onFinish() {\n                                workerMap.remove(path, this);\n                            }\n                        };\n\n                        boolean b = worker.addBatch(batch);\n\n                        assert b;\n\n                        if (workerMap.putIfAbsent(path, worker) == null) {\n                            worker.start();\n\n                            break;\n                        }\n                    }\n                }\n\n                return batch;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new GridException(\"Cannot create new output stream to the secondary file system because GGFS is \" +\n                \"stopping: \" + path);\n    }\n",
    "label": 1,
    "rec": "@param out Output stream of that file."
  },
  {
    "id": 446,
    "type": "Param",
    "comment": "@param cnt Count.",
    "code": "    private long checkCountPerformance0(Ignite g, int cnt) throws Exception {\n        GridCacheAffinity<Object> aff = affinity(g);\n\n        GridTimer timer = new GridTimer(\"test\");\n\n        for (int i = 0; i < cnt; i++) {\n            Object key = RAND.nextInt(Integer.MAX_VALUE);\n\n            Collection<? extends GridNode> affNodes = nodes(aff, key);\n\n            assert excNeighbores ? affNodes.size() == 1 : affNodes.size() == GRIDS;\n        }\n\n        timer.stop();\n\n        return timer.duration();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 447,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskOutput createOutput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case REDUCE:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case MAP:\n                if (locCombiner) {\n                    assert local == null;\n\n                    local = get(job.info(), SHUFFLE_COMBINER_NO_SORTING, false) ?\n                        new GridHadoopHashMultimap(job, mem, get(job.info(), COMBINER_HASHMAP_SIZE, 8 * 1024)):\n                        new GridHadoopSkipList(job, mem, ctx.sortComparator()); // TODO replace with red-black tree\n\n                    return local.startAdding(ctx);\n                }\n\n            default:\n                return createOutput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 448,
    "type": "Param",
    "comment": "@param row row id",
    "code": "\tpublic DenseVector row(int rowId) {\n\t\treturn row(rowId, true);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 449,
    "type": "Param",
    "comment": "@param portName",
    "code": "    public static int chooseIntChannelProperty(String listenAddressName, String propertySuffix, int defaultValue) {\n        String globalPropertyName = \"server.\" + propertySuffix;\n        String listenAddressPropertyName = \"server.\" + listenAddressName + \".\" + propertySuffix;\n        Integer value = new DynamicIntProperty(listenAddressPropertyName, -999).get();\n        if (value == -999) {\n            value = new DynamicIntProperty(globalPropertyName, -999).get();\n            if (value == -999) {\n                value = defaultValue;\n            }\n        }\n        return value;\n    }\n",
    "label": 1,
    "rec": "@param listenAddressName"
  },
  {
    "id": 450,
    "type": "Param",
    "comment": "@param ses Session.",
    "code": "    public Collection<ComputeJobSibling> requestJobSiblings(final ComputeTaskSession ses) throws GridException {\n        assert ses != null;\n\n        final UUID taskNodeId = ses.getTaskNodeId();\n\n        ClusterNode taskNode = ctx.discovery().node(taskNodeId);\n\n        if (taskNode == null)\n            throw new GridException(\"Node that originated task execution has left grid: \" + taskNodeId);\n\n        // Tuple: error message-response.\n        final IgniteBiTuple<String, GridJobSiblingsResponse> t = F.t2();\n\n        final Lock lock = new ReentrantLock();\n        final Condition cond = lock.newCondition();\n\n        GridMessageListener msgLsnr = new GridMessageListener() {\n            @Override public void onMessage(UUID nodeId, Object msg) {\n                String err = null;\n                GridJobSiblingsResponse res = null;\n\n                if (!(msg instanceof GridJobSiblingsResponse))\n                    err = \"Received unexpected message: \" + msg;\n                else if (!nodeId.equals(taskNodeId))\n                    err = \"Received job siblings response from unexpected node [taskNodeId=\" + taskNodeId +\n                        \", nodeId=\" + nodeId + ']';\n                else\n                    // Sender and message type are fine.\n                    res = (GridJobSiblingsResponse)msg;\n\n                if (res.jobSiblings() == null) {\n                    try {\n                        res.unmarshalSiblings(marsh);\n                    }\n                    catch (GridException e) {\n                        U.error(log, \"Failed to unmarshal job siblings.\", e);\n\n                        err = e.getMessage();\n                    }\n                }\n\n                lock.lock();\n\n                try {\n                    if (t.isEmpty()) {\n                        t.set(err, res);\n\n                        cond.signalAll();\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        };\n\n        GridLocalEventListener discoLsnr = new GridLocalEventListener() {\n            @Override public void onEvent(GridEvent evt) {\n                assert evt instanceof GridDiscoveryEvent &&\n                    (evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT) : \"Unexpected event: \" + evt;\n\n                GridDiscoveryEvent discoEvt = (GridDiscoveryEvent)evt;\n\n                if (taskNodeId.equals(discoEvt.eventNode().id())) {\n                    lock.lock();\n\n                    try {\n                        if (t.isEmpty()) {\n                            t.set(\"Node that originated task execution has left grid: \" + taskNodeId, null);\n\n                            cond.signalAll();\n                        }\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n                }\n            }\n        };\n\n        boolean loc = ctx.localNodeId().equals(taskNodeId);\n\n        // 1. Create unique topic name.\n        Object topic = TOPIC_JOB_SIBLINGS.topic(ses.getId(), topicIdGen.getAndIncrement());\n\n        try {\n            // 2. Register listener.\n            ctx.io().addMessageListener(topic, msgLsnr);\n\n            // 3. Send message.\n            ctx.io().send(taskNode, TOPIC_JOB_SIBLINGS,\n                new GridJobSiblingsRequest(ses.getId(),\n                    loc ? topic : null,\n                    loc ? null : marsh.marshal(topic)),\n                SYSTEM_POOL);\n\n            // 4. Listen to discovery events.\n            ctx.event().addLocalEventListener(discoLsnr, EVT_NODE_FAILED, EVT_NODE_LEFT);\n\n            // 5. Check whether node has left before disco listener has been installed.\n            taskNode = ctx.discovery().node(taskNodeId);\n\n            if (taskNode == null)\n                throw new GridException(\"Node that originated task execution has left grid: \" + taskNodeId);\n\n            // 6. Wait for result.\n            lock.lock();\n\n            try {\n                long netTimeout = ctx.config().getNetworkTimeout();\n\n                if (t.isEmpty())\n                    cond.await(netTimeout, MILLISECONDS);\n\n                if (t.isEmpty())\n                    throw new GridException(\"Timed out waiting for job siblings (consider increasing\" +\n                        \"'networkTimeout' configuration property) [ses=\" + ses + \", netTimeout=\" + netTimeout + ']');\n\n                // Error is set?\n                if (t.get1() != null)\n                    throw new GridException(t.get1());\n                else\n                    // Return result\n                    return t.get2().jobSiblings();\n            }\n            catch (InterruptedException e) {\n                throw new GridException(\"Interrupted while waiting for job siblings response: \" + ses, e);\n            }\n            finally {\n                lock.unlock();\n            }\n        }\n        finally {\n            ctx.io().removeMessageListener(topic, msgLsnr);\n            ctx.event().removeLocalEventListener(discoLsnr);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 451,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    public static VisorCache from(Ignite ignite, GridCache c, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 452,
    "type": "Param",
    "comment": "@param port Endpoint port.",
    "code": "    private static GridIpcEndpoint connectSharedMemoryEndpoint(int port, IgniteLogger log) throws GridException {\n        return new GridIpcSharedMemoryClientEndpoint(port, log);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 453,
    "type": "Param",
    "comment": "@param byteArray the fragment to encrypt",
    "code": "\tprivate byte[] encryptFragment(byte[] plaintextFragment) throws GeneralSecurityException {\r\n\t\t\r\n\t\tif (session == null) {\r\n\t\t\treturn plaintextFragment;\r\n\t\t}\r\n\r\n\t\tbyte[] encryptedFragment = plaintextFragment;\r\n\r\n\t\tCipherSuite cipherSuite = session.getWriteState().getCipherSuite();\r\n\t\tLOGGER.log(Level.FINER, \"Encrypting record fragment using current write state\\n{0}\", session.getWriteState());\r\n\t\t\r\n\t\tswitch (cipherSuite.getCipherType()) {\r\n\t\tcase NULL:\r\n\t\t\t// do nothing\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase AEAD:\r\n\t\t\tencryptedFragment = encryptAEAD(plaintextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase BLOCK:\r\n\t\t\tencryptedFragment = encryptBlockCipher(plaintextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase STREAM:\r\n\t\t\t// Currently, Scandium does not support any stream ciphers\r\n\t\t\t// RC4 is explicitly ruled out from being used in DTLS\r\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.2\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn encryptedFragment;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "@param plaintextFragment the TLSPlaintext.fragment to encrypt"
  },
  {
    "id": 454,
    "type": "Param",
    "comment": "@param ipFinder IP finder.",
    "code": "    private IgniteConfiguration dataNode(TcpDiscoveryIpFinder ipFinder, String gridName)\n        throws Exception {\n        GridCacheConfiguration ccfg = new GridCacheConfiguration();\n\n        ccfg.setName(CACHE_NAME);\n        ccfg.setCacheMode(PARTITIONED);\n        ccfg.setAtomicityMode(TRANSACTIONAL);\n        ccfg.setDistributionMode(NEAR_PARTITIONED);\n        ccfg.setWriteSynchronizationMode(FULL_SYNC);\n        ccfg.setBackups(1);\n\n        IgniteConfiguration cfg = getConfiguration(gridName);\n\n        TcpDiscoverySpi spi = new TcpDiscoverySpi();\n\n        spi.setIpFinder(ipFinder);\n\n        cfg.setLocalHost(\"127.0.0.1\");\n        cfg.setDiscoverySpi(spi);\n        cfg.setCacheConfiguration(ccfg);\n        cfg.setIncludeProperties();\n        cfg.setRestEnabled(false);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 455,
    "type": "Param",
    "comment": "@param cnt Key count.",
    "code": "    protected UUID[] primaryKeysForCache(Ignite primary, int cnt) throws GridException {\n        Collection<UUID> keys = new LinkedHashSet<>();\n\n        int iters = 0;\n\n        do {\n            keys.add(primaryKeyForCache(primary));\n\n            iters++;\n\n            if (iters > 10000)\n                throw new IllegalStateException(\"Cannot find keys for primary node [nodeId=\" +\n                    primary.cluster().localNode().id() + \", cnt=\" + cnt + ']');\n        }\n        while (keys.size() < cnt);\n\n        UUID[] res = new UUID[keys.size()];\n\n        return keys.toArray(res);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 456,
    "type": "Param",
    "comment": "@param wallet The wallet that controls addresses and watches scripts.",
    "code": "    public List<TransactionOutput> getWalletOutputs(TransactionBag transactionBag){\n        maybeParse();\n        List<TransactionOutput> walletOutputs = new LinkedList<TransactionOutput>();\n        Coin v = Coin.ZERO;\n        for (TransactionOutput o : outputs) {\n            if (!o.isMineOrWatched(transactionBag)) continue;\n            walletOutputs.add(o);\n        }\n\n        return walletOutputs;\n    }\n",
    "label": 1,
    "rec": "@param transactionBag The wallet that controls addresses and watches scripts."
  },
  {
    "id": 457,
    "type": "Param",
    "comment": "@param properties",
    "code": "    public Task fetchByRemoteId(BigInteger uuid, Property<?>... properties) {\n        TodorooCursor<Task> task = query(Query.select(properties).where(Task.UUID.eq(uuid)));\n        try {\n            if (task.getCount() > 0) {\n                task.moveToFirst();\n                return new Task(task);\n            }\n            return null;\n        } finally {\n            task.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 458,
    "type": "Param",
    "comment": "@param hostPath the combined host and path of the deep link",
    "code": "  DeepLinkEntry parseUri(String uri) {\n    for (DeepLinkEntry entry : registry) {\n      if (entry.matches(uri)) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n",
    "label": 1,
    "rec": "@param uri the combined host and path of the deep link"
  },
  {
    "id": 459,
    "type": "Param",
    "comment": "@param fields Fields.",
    "code": "    private BinaryObject copy(BinaryObject po, Map<String, Object> fields) {\n        BinaryObjectBuilder builder = BinaryObjectBuilderImpl.wrap(po);\n\n        if (fields != null) {\n            for (Map.Entry<String, Object> e : fields.entrySet())\n                builder.setField(e.getKey(), e.getValue());\n        }\n\n        return builder.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 460,
    "type": "Param",
    "comment": "@param lvl Level.",
    "code": "        private boolean merge(Tail<L> prnt) throws IgniteCheckedException {\n            if (prnt.io.getCount(prnt.buf) == 0)\n                return false; // Parent is an empty routing page, child forward page will have another parent.\n\n            Tail<L> right = prnt.down;\n            Tail<L> left = right.sibling;\n\n            assert right.type == Tail.EXACT;\n            assert left != null: \"we must have a partner to merge with\";\n\n            if (left.type != Tail.BACK) { // Flip if it was actually FORWARD but not BACK.\n                assert left.type == Tail.FORWARD: left.type;\n\n                left = right;\n                right = right.sibling;\n            }\n\n            assert right.io == left.io: \"must always be the same\"; // Otherwise can be not compatible.\n\n            if (!mergePages(prnt, left, right))\n                return false;\n\n            // left from BACK becomes EXACT.\n            if (left.type == Tail.BACK) {\n                assert left.sibling == null;\n\n                left.down = right.down;\n                left.type = Tail.EXACT;\n                prnt.down = left;\n            }\n            else { // left is already EXACT.\n                assert left.type == Tail.EXACT: left.type;\n\n                left.sibling = null;\n            }\n\n            return true;\n        }\n",
    "label": 1,
    "rec": "@param prnt Parent for merge."
  },
  {
    "id": 461,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public boolean onUnswap(CacheObject key, CacheObject val) throws IgniteCheckedException {\n        assert val != null : \"Key=\" + key;\n\n        return onSwapUnswap(key, val);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 462,
    "type": "Param",
    "comment": "@param local Enforce local.",
    "code": "    private ClusterGroup projection(boolean loc) {\n        return loc ? ctx.kernalContext().grid().cluster().forLocal() : null;\n    }\n",
    "label": 1,
    "rec": "@param loc Enforce local."
  },
  {
    "id": 463,
    "type": "Param",
    "comment": "@param model",
    "code": "    public boolean virify(String name, String domain, String oldName) {\n        if (CommonUtils.notEmpty(name)) {\n            if (CommonUtils.notEmpty(oldName) && !name.equals(oldName) && null != service.getEntity(name)\n                    || CommonUtils.empty(oldName) && null != service.getEntity(name)) {\n                return false;\n            }\n        }\n        if (CommonUtils.notEmpty(domain) && null != service.getEntity(domain)) {\n            return false;\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 464,
    "type": "Param",
    "comment": "@param account the account being verified for access",
    "code": "    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param info the account being verified for access"
  },
  {
    "id": 465,
    "type": "Param",
    "comment": "@param part Partition number to check.",
    "code": "    public boolean belongs(ClusterNode node, int part, AffinityTopologyVersion topVer) {\n        assert node != null;\n        assert part >= 0 : \"Invalid partition: \" + part;\n\n        return nodes(part, topVer).contains(node);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 466,
    "type": "Param",
    "comment": "@param deviceNumber The bulb number the bridge has filed the bulb under.",
    "code": "\tpublic int getSaturation(String deviceId) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tObject sat = settingsData.node(\"lights\")\n\t\t\t\t.node(deviceId).node(\"state\")\n\t\t\t\t.value(\"sat\");\n\t\tif(sat instanceof Integer) {\n\t\t\treturn (Integer) sat;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param deviceId The bulb id the bridge has filed the bulb under."
  },
  {
    "id": 467,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean update(CacheObject key, CacheObject val, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, val, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 468,
    "type": "Param",
    "comment": "@param rebalanceNodePlan Node plan for a particular stealer node",
    "code": "    private List<RebalancePartitionsInfo> orderedPartitionInfos(List<RebalancePartitionsInfo> clusterRebalancePartitionsInfo) {\n        List<RebalancePartitionsInfo> listPrimaries = new ArrayList<RebalancePartitionsInfo>();\n        List<RebalancePartitionsInfo> listReplicas = new ArrayList<RebalancePartitionsInfo>();\n\n        for(RebalancePartitionsInfo partitionInfo: clusterRebalancePartitionsInfo) {\n            List<Integer> stealMasterPartitions = partitionInfo.getStealMasterPartitions();\n            if(stealMasterPartitions != null && !stealMasterPartitions.isEmpty()) {\n                listPrimaries.add(partitionInfo);\n            } else {\n                listReplicas.add(partitionInfo);\n            }\n        }\n\n        // Add all the plans which list the replicas at the end\n        listPrimaries.addAll(listReplicas);\n\n        return listPrimaries;\n    }\n",
    "label": 1,
    "rec": "@param clusterRebalancePartitionsInfos List of partition info"
  },
  {
    "id": 469,
    "type": "Param",
    "comment": "@param sample Sample size.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 470,
    "type": "Param",
    "comment": "@param reduceAddresses Addresses of reducers.",
    "code": "    public boolean initializeReduceAddresses(T[] reduceAddrs) {\n        if (this.reduceAddrs == null) {\n            this.reduceAddrs = reduceAddrs;\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param reduceAddrs Addresses of reducers."
  },
  {
    "id": 471,
    "type": "Param",
    "comment": "@param ldr Class loader.",
    "code": "    private boolean readSwapBeforeRemove(@Nullable KeyCacheObject key, int partId, SwapKey swapKey, ClassLoader ldr)\n        throws IgniteCheckedException {\n        assert cctx.queries().enabled();\n\n        byte[] entryBytes = swapMgr.read(spaceName, swapKey, ldr);\n\n        if (cctx.config().isStatisticsEnabled())\n            cctx.cache().metrics0().onSwapRead(entryBytes != null);\n\n        if (entryBytes == null)\n            return false;\n\n        GridCacheSwapEntry entry = swapEntry(unmarshalSwapEntry(entryBytes, true));\n\n        if (entry == null)\n            return false;\n\n        if (key == null) {\n            key = cctx.toCacheKeyObject(swapKey.keyBytes());\n\n            partId = cctx.affinity().partition(key);\n        }\n\n        cctx.queries().onUnswap(key, partId, entry.value());\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 472,
    "type": "Param",
    "comment": "@param weighting specify e.g. fastest or shortest (or empty for default)",
    "code": "    public Weighting createWeighting( String weightingStr, FlagEncoder encoder )\n    {\n        // ignore case\n        Weighting weighting;\n        weightingStr = weightingStr.toLowerCase();\n        if (\"fastest\".equals(weightingStr))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                weighting = new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                weighting = new FastestWeighting(encoder);\n        } else\n            weighting = new ShortestWeighting();\n\n        if (encoder.supportsTurnCosts())\n            weighting = new TurnWeighting(weighting, encoder, (TurnCostStorage) graph.getExtendedStorage());\n\n        return weighting;\n    }\n",
    "label": 1,
    "rec": "@param weightingStr specify e.g. fastest or shortest (or empty for default)"
  },
  {
    "id": 473,
    "type": "Param",
    "comment": "@param key",
    "code": "    public String lset(final String key, final long index, final String value) {\n        checkIsInMulti();\n        client.lset(key, index, value);\n        return client.getStatusCodeReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 474,
    "type": "Param",
    "comment": "@param resId The resource id of the text you want to display.",
    "code": "\tpublic static Crouton makeText(Activity activity, int textResourceId, Style style) {\n\t\treturn makeText(activity, activity.getString(textResourceId), style);\n\t}\n",
    "label": 1,
    "rec": "@param textResourceId The resource id of the text you want to display."
  },
  {
    "id": 475,
    "type": "Param",
    "comment": "@param t Event type.",
    "code": "        public int count(LifecycleEventType t) {\n            return callsCntr.get(t).get();\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 476,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = ignite.streamer(\"priceBars\");\n\n                try {\n                    Collection<Bar> bars = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext, Collection<Bar>>() {\n                            @Override public Collection<Bar> apply(StreamerContext ctx) {\n                                Collection<Bar> values = ctx.<String, Bar>localSpace().values();\n\n                                Collection<Bar> res = new ArrayList<>(values.size());\n\n                                for (Bar bar : values)\n                                    res.add(bar.copy());\n\n                                return res;\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new IgniteReducer<Collection<Bar>, Collection<Bar>>() {\n                            private final Collection<Bar> res = new ArrayList<>();\n\n                            @Override public boolean collect(@Nullable Collection<Bar> col) {\n                                res.addAll(col);\n\n                                return true;\n                            }\n\n                            @Override public Collection<Bar> reduce() {\n                                return res;\n                            }\n                        }\n                    );\n\n                    for (Bar bar : bars)\n                        System.out.println(bar.toString());\n\n                    System.out.println(\"-----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 2000, 2000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 477,
    "type": "Param",
    "comment": "@param l Number of added elements.",
    "code": "    private long getAndAdd(IgniteAtomicSequence seq, long l) throws Exception {\n        long locSeqVal = seq.get();\n\n        assertEquals(locSeqVal, seq.getAndAdd(l));\n\n        assertEquals(locSeqVal + l, seq.get());\n\n        return seq.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 478,
    "type": "Param",
    "comment": "@param binding the field or local variable to check",
    "code": "public boolean cannotBeDefinitelyNullOrNonNull(LocalVariableBinding local) {\n\treturn isPotentiallyUnknown(local) ||\n\t\tisPotentiallyNonNull(local) && isPotentiallyNull(local);\n}\n\n",
    "label": 1,
    "rec": "@param local the variable to check"
  },
  {
    "id": 479,
    "type": "Param",
    "comment": "@param path Path.",
    "code": "    @Nullable public GridGgfsFileInfo synchronizeFileDual(final GridGgfsFileSystem fs, final GridGgfsPath path)\n        throws GridException {\n        assert fs != null;\n        assert path != null;\n\n        if (busyLock.enterBusy()) {\n            try {\n                // First, try getting file info without any transactions and synchronization.\n                GridGgfsFileInfo info = info(fileId(path));\n\n                if (info != null)\n                    return info;\n\n                // If failed, try synchronize.\n                SynchronizationTask<GridGgfsFileInfo> task =\n                    new SynchronizationTask<GridGgfsFileInfo>() {\n                        @Override public GridGgfsFileInfo onSuccess(Map<GridGgfsPath, GridGgfsFileInfo> infos)\n                            throws Exception {\n                            return infos.get(path);\n                        }\n\n                        @Override public GridGgfsFileInfo onFailure(@Nullable Exception err) throws GridException {\n                            if (err instanceof GridGgfsException)\n                                throw (GridException)err;\n                            else\n                                throw new GridException(\"Failed to synchronize path due to secondary file system \" +\n                                    \"exception: \" + path, err);\n                        }\n                    };\n\n                return synchronizeAndExecute(task, fs, false, path);\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to synchronize file because Grid is stopping: \" + path);\n\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 480,
    "type": "Param",
    "comment": "@param ldapContextFactory the factory used to build connections to the LDAP server.",
    "code": "    protected AuthorizingAccount queryForLdapAccount( Object principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principal instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        List<String> roleNames;\n\n        try {\n\n            roleNames = getRoleNamesForUser(username, ldapContext);\n\n        } finally {\n\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizingAccount( roleNames, null );\n    }\n",
    "label": 1,
    "rec": "@param ldapContextFactory the factory used to create LDAP connections."
  },
  {
    "id": 481,
    "type": "Param",
    "comment": "@param is GGFS input stream.",
    "code": "    private Delimiter nextDelimiter(IgfsInputStream is, State state) throws IOException {\n        assert is != null;\n        assert state != null;\n\n        Map<Integer, Integer> parts = state.parts;\n        LinkedList<Delimiter> delimQueue = state.delims;\n\n        int nextByte = is.read();\n\n        while (nextByte != -1) {\n            // Process read byte.\n            for (int idx = 0; idx < delims.length; idx++) {\n                byte[] delim = delims[idx];\n\n                int val = parts.containsKey(idx) ? parts.get(idx) : 0;\n\n                if (delim[val] == nextByte) {\n                    if (val == delim.length - 1) {\n                        // Full delimiter is found.\n                        parts.remove(idx);\n\n                        Delimiter newDelim = new Delimiter(is.position() - delim.length, is.position());\n\n                        // Read queue from the end looking for the \"inner\" delimiters.\n                        boolean ignore = false;\n\n                        int replaceIdx = -1;\n\n                        for (int i = delimQueue.size() - 1; i >= 0; i--) {\n                            Delimiter prevDelim = delimQueue.get(i);\n\n                            if (prevDelim.start < newDelim.start) {\n                                if (prevDelim.end > newDelim.start) {\n                                    // Ignore this delimiter.\n                                    ignore = true;\n\n                                    break;\n                                }\n                            }\n                            else if (prevDelim.start == newDelim.start) {\n                                // Ok, we found matching delimiter.\n                                replaceIdx = i;\n\n                                break;\n                            }\n                        }\n\n                        if (!ignore) {\n                            if (replaceIdx >= 0)\n                                delimQueue.removeAll(delimQueue.subList(replaceIdx, delimQueue.size()));\n\n                            delimQueue.add(newDelim);\n                        }\n                    }\n                    else\n                        parts.put(idx, ++val);\n                }\n                else if (val != 0) {\n                    if (delim[0] == nextByte) {\n                        boolean shift = true;\n\n                        for (int k = 1; k < val; k++) {\n                            if (delim[k] != nextByte) {\n                                shift = false;\n\n                                break;\n                            }\n                        }\n\n                        if (!shift)\n                            parts.put(idx, 1);\n                    }\n                    else\n                        // Delimiter sequence is totally broken.\n                        parts.remove(idx);\n                }\n            }\n\n            // Check whether we can be sure that the first delimiter will not change.\n            if (!delimQueue.isEmpty()) {\n                Delimiter delim = delimQueue.get(0);\n\n                if (is.position() - delim.end >= maxDelimLen)\n                    return delimQueue.poll();\n            }\n\n            nextByte = is.read();\n        }\n\n        return delimQueue.poll();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 482,
    "type": "Param",
    "comment": "@param tokenClass the class of the authenticationToken being submitted for authentication.",
    "code": "    public boolean supports(AuthenticationToken token) {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Received null AuthenticationToken.  Returning false for supports(token) implementation (can't \" +\n                \"process null tokens).\" );\n        }\n        return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());\n    }\n",
    "label": 1,
    "rec": "@param token the token being submitted for authentication."
  },
  {
    "id": 483,
    "type": "Param",
    "comment": "@param ws Collection of workers to join.",
    "code": "    public static boolean join(Iterable<? extends GridWorker> ws, IgniteLogger log) {\n        boolean retval = true;\n\n        if (ws != null)\n            for (GridWorker w : ws)\n                if (!join(w, log))\n                    retval = false;\n\n        return retval;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 484,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    public static GridKernalContext context(Ignite ignite) {\n        assert ignite != null;\n\n        return ((GridKernal) ignite).context();\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 485,
    "type": "Param",
    "comment": "@param replicate_training_data whether or not the training data is replicated on each node",
    "code": "  private static long computeTrainSamplesPerIteration(final long train_samples_per_iteration, final long numRows, final boolean replicate_training_data, final boolean single_node_mode, final boolean quiet_mode) {\n    long tspi = train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi >= 1);\n    if (tspi == 0 || (!replicate_training_data && tspi == -1) ) {\n      tspi = numRows;\n      if (!quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n    }\n    else if (tspi == -1) {\n      tspi = H2O.CLOUD.size() * numRows;\n      if (!quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n    }\n    assert(tspi != 0 && tspi != -1 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 486,
    "type": "Param",
    "comment": "@param colocated Colocated query.",
    "code": "    public static GridCacheTwoStepQuery split(JdbcPreparedStatement stmt, Object[] params, boolean collocated) {\n        if (params == null)\n            params = GridCacheSqlQuery.EMPTY_PARAMS;\n\n        GridSqlQuery qry0 = GridSqlQueryParser.parse(stmt);\n\n        GridSqlSelect srcQry;\n\n        if (qry0 instanceof GridSqlSelect)\n            srcQry = (GridSqlSelect)qry0;\n        else { // Handle UNION.\n            srcQry = new GridSqlSelect().from(new GridSqlSubquery(qry0));\n\n            GridSqlSelect left = leftest(qry0);\n\n            int c = 0;\n\n            for (GridSqlElement expr : left.select(true)) {\n                String colName;\n\n                if (expr instanceof GridSqlAlias)\n                    colName = ((GridSqlAlias)expr).alias();\n                else if (expr instanceof GridSqlColumn)\n                    colName = ((GridSqlColumn)expr).columnName();\n                else {\n                    colName = columnName(c);\n\n                    expr = alias(colName, expr);\n\n                    // Set generated alias to the expression.\n                    left.setSelectExpression(c, expr);\n                }\n\n                GridSqlColumn col = column(colName);\n\n                srcQry.addSelectExpression(col, true);\n\n                qry0.sort();\n\n                c++;\n            }\n\n            // ORDER BY\n            if (!qry0.sort().isEmpty()) {\n                for (GridSqlSortColumn col : qry0.sort())\n                    srcQry.addSort(col);\n            }\n        }\n\n        final String mergeTable = TABLE_FUNC_NAME + \"()\"; // table(0); TODO\n\n        // Create map and reduce queries.\n        GridSqlSelect mapQry = srcQry.clone();\n        GridSqlSelect rdcQry = new GridSqlSelect().from(new GridSqlFunction(\"PUBLIC\", TABLE_FUNC_NAME)); // table(mergeTable)); TODO\n\n        // Split all select expressions into map-reduce parts.\n        List<GridSqlElement> mapExps = F.addAll(\n            new ArrayList<GridSqlElement>(srcQry.allColumns()),\n            srcQry.select(false));\n\n        GridSqlElement[] rdcExps = new GridSqlElement[srcQry.visibleColumns()];\n\n        Set<String> colNames = new HashSet<>();\n\n        boolean aggregateFound = false;\n\n        for (int i = 0, len = mapExps.size(); i < len; i++) // Remember len because mapExps list can grow.\n            aggregateFound |= splitSelectExpression(mapExps, rdcExps, colNames, i, collocated);\n\n        // Fill select expressions.\n        mapQry.clearSelect();\n\n        for (GridSqlElement exp : mapExps) // Add all map expressions as visible.\n            mapQry.addSelectExpression(exp, true);\n\n        for (GridSqlElement rdcExp : rdcExps) // Add corresponding visible reduce columns.\n            rdcQry.addSelectExpression(rdcExp, true);\n\n        for (int i = rdcExps.length; i < mapExps.size(); i++)  // Add all extra map columns as invisible reduce columns.\n            rdcQry.addSelectExpression(column(((GridSqlAlias)mapExps.get(i)).alias()), false);\n\n        // -- GROUP BY\n        if (srcQry.hasGroupBy()) {\n            mapQry.clearGroups();\n\n            for (int col : srcQry.groupColumns())\n                mapQry.addGroupExpression(column(((GridSqlAlias)mapExps.get(col)).alias()));\n\n            if (!collocated) {\n                for (int col : srcQry.groupColumns())\n                    rdcQry.addGroupExpression(column(((GridSqlAlias)mapExps.get(col)).alias()));\n            }\n        }\n\n        // -- HAVING\n        if (srcQry.having() != null && !collocated) {\n            // TODO Find aggregate functions in HAVING clause.\n            rdcQry.whereAnd(column(columnName(srcQry.havingColumn())));\n\n            mapQry.having(null);\n        }\n\n        // -- ORDER BY\n        if (!srcQry.sort().isEmpty()) {\n            if (aggregateFound) // Ordering over aggregates does not make sense.\n                mapQry.clearSort(); // Otherwise map sort will be used by offset-limit.\n\n            for (GridSqlSortColumn sortCol : srcQry.sort())\n                rdcQry.addSort(sortCol);\n        }\n\n        // -- LIMIT\n        if (srcQry.limit() != null) {\n            if (aggregateFound)\n                mapQry.limit(null);\n\n            rdcQry.limit(srcQry.limit());\n        }\n\n        // -- OFFSET\n        if (srcQry.offset() != null) {\n            mapQry.offset(null);\n\n            rdcQry.offset(srcQry.offset());\n        }\n\n        // -- DISTINCT\n        if (srcQry.distinct()) {\n            mapQry.distinct(false);\n            rdcQry.distinct(true);\n        }\n\n        // Build resulting two step query.\n        GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(rdcQry.getSQL(),\n            findParams(rdcQry, params, new ArrayList<>()).toArray());\n\n        res.addMapQuery(mergeTable, mapQry.getSQL(),\n            findParams(mapQry, params, new ArrayList<>(params.length)).toArray());\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param collocated Collocated query."
  },
  {
    "id": 487,
    "type": "Param",
    "comment": "@param productId The product ID",
    "code": "\tpublic boolean FindProduct(int productType, int productId) {\n\t\tif (selManufacturer == null)\n\t\t\treturn false;\n\n\t\tfor (ZWaveDbProduct product : selManufacturer.Product) {\n\t\t\tfor (ZWaveDbProductReference reference : product.Reference) {\n\t\t\t\tif (reference.Type == productType && reference.Id == productId) {\n\t\t\t\t\tselProduct = product;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 488,
    "type": "Param",
    "comment": "@param idx The index of the character in the source",
    "code": "    public static int toDigit(char ch, int index) throws IgniteCheckedException {\n        int digit = Character.digit(ch, 16);\n\n        if (digit == -1)\n            throw new IgniteCheckedException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n\n        return digit;\n    }\n",
    "label": 1,
    "rec": "@param index The index of the character in the source"
  },
  {
    "id": 489,
    "type": "Param",
    "comment": "@param themeResId the style resource ID for theming",
    "code": "    public static HmsPickerDialogFragment newInstance(int reference, int themeResId, Integer plusMinusVisibility) {\n        final HmsPickerDialogFragment frag = new HmsPickerDialogFragment();\n        Bundle args = new Bundle();\n        args.putInt(REFERENCE_KEY, reference);\n        args.putInt(THEME_RES_ID_KEY, themeResId);\n        if (plusMinusVisibility != null) {\n            args.putInt(PLUS_MINUS_VISIBILITY_KEY, plusMinusVisibility);\n        }\n        frag.setArguments(args);\n        return frag;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 490,
    "type": "Param",
    "comment": "@param encoder",
    "code": "    public Weighting createWeighting( String weightingStr, FlagEncoder encoder )\n    {\n        // ignore case\n        Weighting weighting;\n        weightingStr = weightingStr.toLowerCase();\n        if (\"fastest\".equals(weightingStr))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                weighting = new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                weighting = new FastestWeighting(encoder);\n        } else\n            weighting = new ShortestWeighting();\n\n        if (hasTurnCosts())\n            weighting = new TurnWeighting(weighting, encoder);\n\n        return weighting;\n    }\n",
    "label": 1,
    "rec": "@param encoder the FlagEncoder (to specify the vehicle)"
  },
  {
    "id": 491,
    "type": "Param",
    "comment": "@param redirectToAuthentication if true redirect to flow url. If initial call to protocol is a POST, you probably want to do this. This is so we can disable the back button on browser",
    "code": "    protected Response handleBrowserAuthenticationRequest(AuthenticationSessionModel authSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(authSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, authSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    // processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                AuthenticationManager.setRolesAndMappersInSession(authSession);\n\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                // Attach session once no requiredActions or other things are required\n                processor.attachSession();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, authSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow(null);\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 492,
    "type": "Param",
    "comment": "@param way: needed to retrieve OSM tags",
    "code": "    protected double applyMaxSpeed( ReaderWay way, double speed )\n    {\n        double maxSpeed = getMaxSpeed(way);\n        // We obay speed limits\n        if (maxSpeed >= 0)\n        {\n            // We assume that the average speed is 90% of the allowed maximum\n            return maxSpeed * 0.9;\n        }\n        return speed;\n    }\n",
    "label": 1,
    "rec": "@param way: needed to retrieve tags"
  },
  {
    "id": 493,
    "type": "Param",
    "comment": "@param itemDim dimension of items",
    "code": "\tpublic SparseMatrix rateMatrix() {\n\n\t\tTable<Integer, Integer, Double> dataTable = HashBasedTable.create();\n\t\tMultimap<Integer, Integer> colMap = HashMultimap.create();\n\n\t\tfor (TensorEntry te : this) {\n\t\t\tint u = te.key(userDimension);\n\t\t\tint i = te.key(itemDimension);\n\n\t\t\tdataTable.put(u, i, te.get());\n\t\t\tcolMap.put(i, u);\n\t\t}\n\n\t\treturn new SparseMatrix(dimensions[userDimension], dimensions[itemDimension], dataTable, colMap);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 494,
    "type": "Param",
    "comment": "@param mavenMetaDataUrl",
    "code": "    public static String readMavenReleaseVersion(String mavenMetaData) {\n        try {\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(mavenMetaData.getBytes(\"UTF-8\"));\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document document = dBuilder.parse(inputStream);\n\n            NodeList nodeList = document.getDocumentElement().getElementsByTagName(\"release\");\n\n            return nodeList.item(0).getTextContent();\n        } catch (Exception e) {\n            // ignore\n        }\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param mavenMetaData"
  },
  {
    "id": 495,
    "type": "Param",
    "comment": "@param ccfg Cache configuration.",
    "code": "    public static VisorCacheConfiguration from(IgniteEx ignite, CacheConfiguration ccfg) {\n        VisorCacheConfiguration cfg = new VisorCacheConfiguration();\n\n        cfg.name = ccfg.getName();\n        cfg.mode = ccfg.getCacheMode();\n        cfg.atomicityMode = ccfg.getAtomicityMode();\n        cfg.atomicWriteOrderMode = ccfg.getAtomicWriteOrderMode();\n        cfg.eagerTtl = ccfg.isEagerTtl();\n        cfg.writeSynchronizationMode = ccfg.getWriteSynchronizationMode();\n        cfg.swapEnabled = ccfg.isSwapEnabled();\n        cfg.invalidate = ccfg.isInvalidate();\n        cfg.startSize = ccfg.getStartSize();\n        cfg.tmLookupClsName = ccfg.getTransactionManagerLookupClassName();\n        cfg.offHeapMaxMemory = ccfg.getOffHeapMaxMemory();\n        cfg.maxConcurrentAsyncOps = ccfg.getMaxConcurrentAsyncOperations();\n        cfg.memoryMode = ccfg.getMemoryMode();\n        cfg.interceptor = compactClass(ccfg.getInterceptor());\n        cfg.typeMeta = VisorCacheTypeMetadata.list(ccfg.getTypeMetadata());\n        cfg.statisticsEnabled = ccfg.isStatisticsEnabled();\n        cfg.mgmtEnabled = ccfg.isManagementEnabled();\n        cfg.ldrFactory = compactClass(ccfg.getCacheLoaderFactory());\n        cfg.writerFactory = compactClass(ccfg.getCacheWriterFactory());\n        cfg.expiryPlcFactory = compactClass(ccfg.getExpiryPolicyFactory());\n        cfg.system = ignite.systemCache(ccfg.getName());\n\n        cfg.affinityCfg = VisorCacheAffinityConfiguration.from(ccfg);\n        cfg.rebalanceCfg = VisorCacheRebalanceConfiguration.from(ccfg);\n        cfg.evictCfg = VisorCacheEvictionConfiguration.from(ccfg);\n        cfg.nearCfg = VisorCacheNearConfiguration.from(ccfg);\n        cfg.dfltCfg = VisorCacheDefaultConfiguration.from(ccfg);\n        cfg.storeCfg = VisorCacheStoreConfiguration.from(ignite, ccfg);\n        cfg.qryCfg = VisorCacheQueryConfiguration.from(ccfg);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 496,
    "type": "Param",
    "comment": "@param groupName Name of the group.",
    "code": "    public int groupSize(String grpName) {\n        int res = 0;\n\n        for (GridHadoopCounter counter : cntrs.values()) {\n            if (grpName.equals(counter.group()))\n                res++;\n        }\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param grpName Name of the group."
  },
  {
    "id": 497,
    "type": "Param",
    "comment": "@param weighting specify e.g. fastest or shortest (or empty for default)",
    "code": "    public Weighting createWeighting( String weightingStr, FlagEncoder encoder )\n    {\n        // ignore case\n        Weighting weighting;\n        weightingStr = weightingStr.toLowerCase();\n        if (\"fastest\".equals(weightingStr))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                weighting = new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                weighting = new FastestWeighting(encoder);\n        } else\n            weighting = new ShortestWeighting();\n\n        if (hasTurnCosts())\n            weighting = new TurnWeighting(weighting, encoder);\n\n        return weighting;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 498,
    "type": "Param",
    "comment": "@param g Grid instance.",
    "code": "    public static boolean checkExplicitTaskMonitoring(Ignite ignite) {\n        int[] evts = ignite.configuration().getIncludeEventTypes();\n\n        if (F.isEmpty(evts))\n            return false;\n\n        for (int evt : VISOR_TASK_EVTS) {\n            if (!F.contains(evts, evt))\n                return false;\n        }\n\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid instance."
  },
  {
    "id": 499,
    "type": "Param",
    "comment": "@param spaceName Space name.",
    "code": "    @Nullable public byte[] get(@Nullable String spaceName, int part, KeyCacheObject key, byte[] keyBytes)\n        throws IgniteCheckedException {\n        GridOffHeapPartitionedMap m = offheap(spaceName);\n\n        return m == null ? null : m.get(part, U.hash(key), keyBytes(key, keyBytes));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 500,
    "type": "Param",
    "comment": "@param metaDataSet",
    "code": "    public static AbstractReportDataSet getDataSet(final Queryer queryer, final ReportParameter parameter) {\n        return new DataExecutor(queryer, parameter).execute();\n    }\n",
    "label": 1,
    "rec": "@param queryer"
  },
  {
    "id": 501,
    "type": "Param",
    "comment": "@param ver Version.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, K key, V val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = (K)cctx.unwrapPortableIfNeeded(key, false);\n                val = (V)cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(key, locStore ? F.t(val, ver) : val));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 502,
    "type": "Param",
    "comment": "@param type The type of the class where the method is located.",
    "code": "\tpublic static Field field(Class<?> declaringClass, String fieldName) {\n\t\treturn Whitebox.getField(declaringClass, fieldName);\n\t}\n",
    "label": 1,
    "rec": "@param declaringClass The declaringClass of the class where the method is located."
  },
  {
    "id": 503,
    "type": "Param",
    "comment": "@param startI row where a finder pattern was detected",
    "code": "  private float crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal) {\n    MonochromeBitmapSource image = this.image;\n\n    int maxI = image.getHeight();\n    int[] stateCount = new int[5];\n\n    // Start counting up from center\n    int i = startI;\n    while (i >= 0 && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i--;\n    }\n    if (i < 0) {\n      return Float.NaN;\n    }\n    while (i >= 0 && !image.isBlack(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return Float.NaN;\n    }\n    while (i >= 0 && image.isBlack(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return Float.NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i++;\n    }\n    if (i == maxI) {\n      return Float.NaN;\n    }\n    while (i < maxI && !image.isBlack(centerJ, i) && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      i++;\n    }\n    if (i == maxI || stateCount[3] >= maxCount) {\n      return Float.NaN;\n    }\n    while (i < maxI && image.isBlack(centerJ, i) && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      i++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return Float.NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is more than 20% different than\n    // the original, assume it's a false positive\n    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n      return Float.NaN;\n    }\n\n    return foundPatternCross(stateCount) ? centerFromEnd(stateCount, i) : Float.NaN;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 504,
    "type": "Param",
    "comment": "@param fwdId Expected forward page ID.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long expFwdId, final int lvl)\n        throws IgniteCheckedException {\n        try (Page page = page(pageId)) {\n            int res;\n\n            for (;;) {\n                // Init args.\n                g.pageId = pageId;\n                g.expFwdId = expFwdId;\n\n                res = readPage(page, search, g, lvl);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.expFwdId != expFwdId || expFwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.expFwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false;\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        throw new IllegalStateException(\"Invalid result: \" + res);\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param expFwdId Expected forward page ID."
  },
  {
    "id": 505,
    "type": "Param",
    "comment": "@param in Stream.",
    "code": "    private static AffinityFunction readAffinityFunction(BinaryRawReaderEx in) {\n        byte plcTyp = in.readByte();\n\n        switch (plcTyp) {\n            case 0:\n                break;\n            case 1: {\n                FairAffinityFunction f = new FairAffinityFunction();\n                f.setPartitions(in.readInt());\n                f.setExcludeNeighbors(in.readBoolean());\n                return f;\n            }\n            case 2: {\n                RendezvousAffinityFunction f = new RendezvousAffinityFunction();\n                f.setPartitions(in.readInt());\n                f.setExcludeNeighbors(in.readBoolean());\n                return f;\n            }\n            case 3: {\n                return new PlatformAffinityFunction(in.readObjectDetached(), in.readInt());\n            }\n            default:\n                assert false;\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 506,
    "type": "Param",
    "comment": "@param binding the field or local to check",
    "code": "public boolean canOnlyBeNull(LocalVariableBinding local) {\n\treturn isDefinitelyNull(local) || isProtectedNull(local);\n}\n\n",
    "label": 1,
    "rec": "@param local the variable to ckeck"
  },
  {
    "id": 507,
    "type": "Param",
    "comment": "@param projectId the project's unique identifier",
    "code": "  public static int pubSub(String subId, int timeout, String projectId) throws Exception {\n    Subscriber subscriber = null;\n    MessageReceiverExample receiver = new MessageReceiverExample();\n\n    try {\n      // subscribe to the requested pubsub channel\n      ProjectSubscriptionName subName = ProjectSubscriptionName.of(projectId, subId);\n      subscriber = Subscriber.newBuilder(subName, receiver).build();\n      subscriber.startAsync().awaitRunning();\n      // listen to messages for 'timeout' seconds\n      for (int i = 0; i < timeout; i++) {\n        sleep(1000);\n      }\n    } finally {\n      // stop listening to the channel\n      if (subscriber != null) {\n        subscriber.stopAsync();\n      }\n    }\n    //print and return the number of pubsub messages received\n    System.out.println(receiver.messageCount);\n    return receiver.messageCount;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 508,
    "type": "Param",
    "comment": "@param filters the filters to test",
    "code": "    public static <E> Predicates.AllPredicate<E> all(Predicate<E>... predicates) {\r\n        return new Predicates.AllPredicate<E>(predicates);\r\n    }\r\n\n",
    "label": 1,
    "rec": "@param predicates the predicates to test"
  },
  {
    "id": 509,
    "type": "Param",
    "comment": "@param p Partition.",
    "code": "    private List<ClusterNode> nodes(int p, long topVer, GridDhtPartitionState state, GridDhtPartitionState... states) {\n        Collection<UUID> allIds = topVer > 0 ? F.nodeIds(CU.allNodes(cctx, topVer)) : null;\n\n        lock.readLock().lock();\n\n        try {\n            assert node2part != null && node2part.valid() : \"Invalid node-to-partitions map [topVer=\" + topVer +\n                \", allIds=\" + allIds + \", node2part=\" + node2part + ']';\n\n            Collection<UUID> nodeIds = part2node.get(p);\n\n            // Node IDs can be null if both, primary and backup, nodes disappear.\n            int size = nodeIds == null ? 0 : nodeIds.size();\n\n            if (size == 0)\n                return Collections.emptyList();\n\n            List<ClusterNode> nodes = new ArrayList<>(size);\n\n            for (UUID id : nodeIds) {\n                if (topVer > 0 && !allIds.contains(id))\n                    continue;\n\n                if (hasState(p, id, state, states)) {\n                    ClusterNode n = cctx.discovery().node(id);\n\n                    if (n != null && (topVer < 0 || n.order() <= topVer))\n                        nodes.add(n);\n                }\n            }\n\n            return nodes;\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 510,
    "type": "Param",
    "comment": "@param milis",
    "code": "    public static XMLGregorianCalendar add(XMLGregorianCalendar value, long millis) {\n        if (value == null) {\n            return null;\n        }\n\n        XMLGregorianCalendar newVal = (XMLGregorianCalendar) value.clone();\n\n        if (millis == 0) {\n            return newVal;\n        }\n\n        Duration duration;\n        duration = DATATYPE_FACTORY.get().newDuration(millis);\n        newVal.add(duration);\n        return newVal;\n    }\n",
    "label": 1,
    "rec": "@param millis"
  },
  {
    "id": 511,
    "type": "Param",
    "comment": "@param transactions Map of txhash->transaction.",
    "code": "    ConnectionResult connect(Map<Sha256Hash, Transaction> transactions, ConnectMode mode) {\n        Transaction tx = transactions.get(outpoint.getHash());\n        if (tx == null) {\n            return TransactionInput.ConnectionResult.NO_SUCH_TX;\n        }\n        TransactionOutput out = tx.getOutputs().get((int) outpoint.getIndex());\n        if (!out.isAvailableForSpending()) {\n            if (mode == ConnectMode.DISCONNECT_ON_CONFLICT) {\n                out.markAsUnspent();\n            } else if (mode == ConnectMode.ABORT_ON_CONFLICT) {\n                outpoint.fromTx = checkNotNull(out.parentTransaction);\n                return TransactionInput.ConnectionResult.ALREADY_SPENT;\n            }\n        }\n        connect(out);\n        return TransactionInput.ConnectionResult.SUCCESS;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 512,
    "type": "Param",
    "comment": "@param joinEventCount Expected events number.",
    "code": "    private CountDownLatch expectJoinEvents(Ignite ignite, int joinEvtCnt) {\n        final CountDownLatch latch = new CountDownLatch(joinEvtCnt);\n\n        ignite.events().remoteListen(new IgniteBiPredicate<UUID, Event>() {\n            @Override public boolean apply(UUID uuid, Event evt) {\n                latch.countDown();\n                return true;\n            }\n        }, null, EventType.EVT_NODE_JOINED);\n\n        return latch;\n    }\n",
    "label": 1,
    "rec": "@param joinEvtCnt Expected events number."
  },
  {
    "id": 513,
    "type": "Param",
    "comment": "@param failFast Fail fast flag.",
    "code": "    @Nullable private CacheObject peekDb(boolean failFast, CacheEntryPredicate[] filter)\n        throws IgniteCheckedException, GridCacheFilterFailedException {\n        if (!cctx.isAll(this, filter))\n            return CU.failed(failFast);\n\n        synchronized (this) {\n            if (checkExpired())\n                return null;\n        }\n\n        // TODO IGNITE-51.\n        return cctx.toCacheObject(cctx.store().loadFromStore(cctx.tm().localTxx(), key));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 514,
    "type": "Param",
    "comment": "@param activityUsedToStartLoginProcess",
    "code": "    public static Account getAccount(final AccountManager manager, final Activity activity) {\n        final boolean loggable = Log.isLoggable(TAG, DEBUG);\n        if (loggable)\n            Log.d(TAG, \"Getting account\");\n\n        if (activity == null)\n            throw new RuntimeException(\"Can't create new GitHub account - no activity available\");\n\n        Account[] accounts;\n        try {\n            while ((accounts = getAccounts(manager)).length == 0) {\n                if (loggable)\n                    Log.d(TAG, \"No GitHub accounts for activity=\" + activity);\n\n                Bundle result = manager.addAccount(GITHUB_ACCOUNT_TYPE, null, null, null, activity, null, null)\n                        .getResult();\n\n                if (loggable)\n                    Log.d(TAG, \"Added account \" + result.getString(KEY_ACCOUNT_NAME));\n            }\n        } catch (AuthenticatorException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        } catch (OperationCanceledException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        }\n\n        if (loggable)\n            Log.d(TAG, \"Returning account \" + accounts[0].name);\n\n        return accounts[0];\n    }\n",
    "label": 1,
    "rec": "@param activity"
  },
  {
    "id": 515,
    "type": "Param",
    "comment": "@param val Value object.",
    "code": "    protected int fillValueParameters(PreparedStatement stmt, int idx, EntryMapping em, Object val)\n        throws CacheWriterException {\n        for (CacheTypeFieldMetadata field : em.uniqValFields) {\n            Object fieldVal = extractField(em.cacheName, em.valueType(), field.getJavaName(), val);\n\n            try {\n                if (fieldVal != null)\n                    stmt.setObject(idx++, fieldVal);\n                else\n                    stmt.setNull(idx++, field.getDatabaseType());\n            }\n            catch (SQLException e) {\n                throw new CacheWriterException(\"Failed to set statement parameter name: \" + field.getDatabaseName(), e);\n            }\n        }\n\n        return idx;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 516,
    "type": "Param",
    "comment": "@param ref",
    "code": "    public static String getName(final String name) {\n        if (TextUtils.isEmpty(name))\n            return name;\n        if (name.startsWith(PREFIX_HEADS))\n            return name.substring(PREFIX_HEADS.length());\n        else if (name.startsWith(PREFIX_TAG))\n            return name.substring(PREFIX_TAG.length());\n        else if (name.startsWith(PREFIX_REFS))\n            return name.substring(PREFIX_REFS.length());\n        else\n            return name;\n    }\n",
    "label": 1,
    "rec": "@param name"
  },
  {
    "id": 517,
    "type": "Param",
    "comment": "@param stealInfo",
    "code": "    public int rebalanceNode(String storeName, RebalancePartitionsInfo stealInfo) {\n        VAdminProto.InitiateRebalanceNodeRequest rebalanceNodeRequest = VAdminProto.InitiateRebalanceNodeRequest.newBuilder()\n                                                                                                                .setAttempt(stealInfo.getAttempt())\n                                                                                                                .setDonorId(stealInfo.getDonorId())\n                                                                                                                .setStealerId(stealInfo.getStealerId())\n                                                                                                                .setCurrentStore(storeName)\n                                                                                                                .addAllPartitions(stealInfo.getPartitionList())\n                                                                                                                .addAllUnbalancedStore(stealInfo.getUnbalancedStoreList())\n                                                                                                                .build();\n        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()\n                                                                                          .setType(VAdminProto.AdminRequestType.INITIATE_REBALANCE_NODE)\n                                                                                          .setInitiateRebalanceNode(rebalanceNodeRequest)\n                                                                                          .build();\n        VAdminProto.AsyncOperationStatusResponse.Builder response = sendAndReceive(stealInfo.getStealerId(),\n                                                                                   adminRequest,\n                                                                                   VAdminProto.AsyncOperationStatusResponse.newBuilder());\n\n        if(response.hasError())\n            throwException(response.getError());\n\n        return response.getRequestId();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 518,
    "type": "Param",
    "comment": "@param image the scanned barcode image.",
    "code": "  private static ResultPoint[] findVertices(BitMatrix matrix) throws ReaderException {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    int[] loc = null;\n    // Top Left\n    for (int i = 0; i < height; i++) {\n      loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[0], i);\n        result[4] = new ResultPoint(loc[1], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[0], i);\n          result[5] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Top right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[1], i);\n          result[6] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom right\n    if (found) { // Found the Top right vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[1], i);\n          result[7] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n",
    "label": 1,
    "rec": "@param matrix the scanned barcode image."
  },
  {
    "id": 519,
    "type": "Param",
    "comment": "@param taskSes Task session.",
    "code": "    public ClusterNode failover(GridTaskSessionImpl taskSes, ComputeJobResult jobRes, List<ClusterNode> top) {\n        return getSpi(taskSes.getFailoverSpi()).failover(new GridFailoverContextImpl(taskSes, jobRes,\n            ctx.loadBalancing()), top);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 520,
    "type": "Param",
    "comment": "@param exact",
    "code": "  public static int[][] getDomainMapping(String colName, String[] modelDom, String[] colDom, boolean logNonExactMapping) {\n    int emap[] = new int[modelDom.length];\n    boolean bmap[] = new boolean[modelDom.length];\n    HashMap<String,Integer> md = new HashMap<String, Integer>();\n    for( int i = 0; i < colDom.length; i++) md.put(colDom[i], i);\n    for( int i = 0; i < modelDom.length; i++) {\n      Integer I = md.get(modelDom[i]);\n      if (I == null && logNonExactMapping)\n        Log.warn(Sys.SCORM, \"Column \"+colName+\" was trained with factor '\"+modelDom[i]+\"' which DOES NOT appear in column data\");\n      if (I!=null) {\n        emap[i] = I;\n        bmap[i] = true;\n      }\n    }\n    if (logNonExactMapping) { // Inform about additional values in column domain which do not appear in model domain\n      for (int i=0; i<colDom.length; i++) {\n        boolean found = false;\n        for (int j=0; j<emap.length; j++)\n          if (emap[j]==i) { found=true; break; }\n        if (!found)\n          Log.warn(Sys.SCORM, \"Column \"+colName+\" WAS NOT trained with factor '\"+colDom[i]+\"' which appears in column data\");\n      }\n    }\n\n    // produce packed values\n    return Utils.pack(emap, bmap);\n  }\n",
    "label": 1,
    "rec": "@param logNonExactMapping"
  },
  {
    "id": 521,
    "type": "Param",
    "comment": "@param serviceUrl",
    "code": "    public static SharedPulsarClient get(String componentId, ClientConfigurationData clientConf)\n            throws PulsarClientException {\n        AtomicReference<PulsarClientException> exception = new AtomicReference<PulsarClientException>();\n        instances.computeIfAbsent(componentId, pulsarClient -> {\n            SharedPulsarClient sharedPulsarClient = null;\n            try {\n                sharedPulsarClient = new SharedPulsarClient(componentId, clientConf);\n                LOG.info(\"[{}] Created a new Pulsar Client.\", componentId);\n            } catch (PulsarClientException e) {\n                exception.set(e);\n            }\n            return sharedPulsarClient;\n        });\n        if (exception.get() != null) {\n            throw exception.get();\n        }\n        return instances.get(componentId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 522,
    "type": "Param",
    "comment": "@param taskInfo Task info.",
    "code": "    public GridHadoopTaskInput input(GridHadoopTaskContext taskCtx) throws GridException {\n        switch (taskCtx.taskInfo().type()) {\n            case REDUCE:\n                int reducer = taskCtx.taskInfo().taskNumber();\n\n                GridHadoopMultimap m = maps.get(reducer);\n\n                if (m != null)\n                    return m.input(taskCtx);\n\n                return new GridHadoopTaskInput() { // Empty input.\n                    @Override public boolean next() {\n                        return false;\n                    }\n\n                    @Override public Object key() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public Iterator<?> values() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public void close() {\n                        // No-op.\n                    }\n                };\n\n            default:\n                throw new IllegalStateException(\"Illegal type: \" + taskCtx.taskInfo().type());\n        }\n    }\n",
    "label": 1,
    "rec": "@param taskCtx Task context."
  },
  {
    "id": 523,
    "type": "Param",
    "comment": "@param timedOut Timeout flag.",
    "code": "    private boolean state(IgniteTxState state, boolean timedOut) {\n        boolean valid = false;\n\n        IgniteTxState prev;\n\n        boolean notify = false;\n\n        lock();\n\n        try {\n            prev = this.state;\n\n            switch (state) {\n                case ACTIVE: {\n                    valid = false;\n\n                    break;\n                } // Active is initial state and cannot be transitioned to.\n                case PREPARING: {\n                    valid = prev == ACTIVE;\n\n                    break;\n                }\n                case PREPARED: {\n                    valid = prev == PREPARING;\n\n                    break;\n                }\n                case COMMITTING: {\n                    valid = prev == PREPARED;\n\n                    break;\n                }\n\n                case UNKNOWN: {\n                    if (isDone.compareAndSet(false, true))\n                        notify = true;\n\n                    valid = prev == ROLLING_BACK || prev == COMMITTING;\n\n                    break;\n                }\n\n                case COMMITTED: {\n                    if (isDone.compareAndSet(false, true))\n                        notify = true;\n\n                    valid = prev == COMMITTING;\n\n                    break;\n                }\n\n                case ROLLED_BACK: {\n                    if (isDone.compareAndSet(false, true))\n                        notify = true;\n\n                    valid = prev == ROLLING_BACK;\n\n                    break;\n                }\n\n                case MARKED_ROLLBACK: {\n                    valid = prev == ACTIVE || prev == PREPARING || prev == PREPARED || prev == COMMITTING;\n\n                    break;\n                }\n\n                case ROLLING_BACK: {\n                    valid =\n                        prev == ACTIVE || prev == MARKED_ROLLBACK || prev == PREPARING ||\n                            prev == PREPARED || (prev == COMMITTING && local() && !dht());\n\n                    break;\n                }\n            }\n\n            if (valid) {\n                this.state = state;\n                this.timedOut = timedOut;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Changed transaction state [prev=\" + prev + \", new=\" + this.state + \", tx=\" + this + ']');\n\n                // Notify of state change.\n                signalAll();\n            }\n            else {\n                if (log.isDebugEnabled())\n                    log.debug(\"Invalid transaction state transition [invalid=\" + state + \", cur=\" + this.state +\n                        \", tx=\" + this + ']');\n            }\n        }\n        finally {\n            unlock();\n        }\n\n        if (notify) {\n            GridFutureAdapter<IgniteTx> fut = finFut.get();\n\n            if (fut != null)\n                fut.onDone(this);\n        }\n\n        if (valid) {\n            // Seal transactions maps.\n            if (state != ACTIVE)\n                seal();\n\n            cctx.tm().onTxStateChange(prev, state, this);\n        }\n\n        return valid;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 524,
    "type": "Param",
    "comment": "@param start",
    "code": "  public Long zremrangeByScore(final String key, final double min, final double max) {\n    checkIsInMultiOrPipeline();\n    client.zremrangeByScore(key, min, max);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param min"
  },
  {
    "id": 525,
    "type": "Param",
    "comment": "@param id",
    "code": "    public Commit getCommit(final Repository repo, final String id) {\n        final ItemReferences<Commit> repoCommits = commits.get(InfoUtils.createRepoId(repo));\n        return repoCommits != null ? repoCommits.get(id) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 526,
    "type": "Param",
    "comment": "@param user",
    "code": "    public AvatarLoader bind(final ActionBar actionBar, final AtomicReference<User> userReference) {\n        if (userReference == null)\n            return this;\n\n        final User user = userReference.get();\n        if (user == null)\n            return this;\n\n        final String avatarUrl = user.getAvatarUrl();\n        if (TextUtils.isEmpty(avatarUrl))\n            return this;\n\n        final Integer userId = Integer.valueOf(user.getId());\n\n        BitmapDrawable loadedImage = loaded.get(userId);\n        if (loadedImage != null) {\n            actionBar.setLogo(loadedImage);\n            return this;\n        }\n\n        new FetchAvatarTask(context) {\n\n            @Override\n            public BitmapDrawable call() throws Exception {\n                final BitmapDrawable image = getImage(user);\n                if (image != null)\n                    return image;\n                else\n                    return fetchAvatar(avatarUrl, userId);\n            }\n\n            @Override\n            protected void onSuccess(BitmapDrawable image) throws Exception {\n                final User current = userReference.get();\n                if (current != null && userId.equals(current.getId()))\n                    actionBar.setLogo(image);\n            }\n        }.execute();\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param userReference"
  },
  {
    "id": 527,
    "type": "Param",
    "comment": "@param topOrder Maximum allowed node order.",
    "code": "    public static Collection<ClusterNode> aliveCacheNodes(final GridCacheSharedContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().aliveNodesWithCaches(topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 528,
    "type": "Param",
    "comment": "@param string the task name. Choose something unique.",
    "code": "\tpublic static TimedTask createTask(String taskName, boolean accumulativity) {\n\t\tpreviousTask = new TimedTask(taskName, previousTask, globalPerformanceMetrics,\n\t\t\t\taccumulativity);\n\t\treturn previousTask;\n\t}\n\n",
    "label": 1,
    "rec": "@param taskName the task name. Choose something unique."
  },
  {
    "id": 529,
    "type": "Param",
    "comment": "@param pageIdx Page index.",
    "code": "    public static long pageId(int fileId, long pageIdx) {\n        assert (pageIdx & ~PAGE_IDX_MASK) == 0;\n\n        long pageId = 0;\n\n        pageId = (pageId << FILE_ID_SIZE) | (fileId & FILE_ID_MASK);\n        pageId = (pageId << PAGE_IDX_SIZE) | (pageIdx & PAGE_IDX_MASK);\n\n        return pageId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 530,
    "type": "Param",
    "comment": "@param length Length.",
    "code": "    static byte[] createChunk(int len) {\n        byte[] chunk = new byte[len];\n\n        for (int i = 0; i < chunk.length; i++)\n            chunk[i] = (byte)i;\n\n        return chunk;\n    }\n",
    "label": 1,
    "rec": "@param len Length."
  },
  {
    "id": 531,
    "type": "Param",
    "comment": "@param cacheName Cache name.",
    "code": "    public static VisorCache from(IgniteEx ignite, String cacheName, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        // Cache was not started.\n        if (ca == null || !ca.context().started())\n            return null;\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && ca.context().affinityNode();\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(AffinityTopologyVersion.NONE)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ignite, ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 532,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer, final int cnt) {\n        TimerTask task = new TimerTask() {\n            private CacheQuery<List<?>> qry;\n\n            @Override public void run() {\n                // Get reference to cache.\n                GridCache<Integer, Long> cache = ignite.cache(CACHE_NAME);\n\n                if (qry == null)\n                    qry = cache.queries().\n                        createSqlFieldsQuery(\"select _key, _val from Long order by _val desc limit \" + cnt);\n\n                try {\n                    List<List<?>> results = new ArrayList<>(qry.execute().get());\n\n                    Collections.sort(results, new Comparator<List<?>>() {\n                        @Override public int compare(List<?> r1, List<?> r2) {\n                            long cnt1 = (Long)r1.get(1);\n                            long cnt2 = (Long)r2.get(1);\n\n                            return cnt1 < cnt2 ? 1 : cnt1 > cnt2 ? -1 : 0;\n                        }\n                    });\n\n                    for (int i = 0; i < cnt && i < results.size(); i++) {\n                        List<?> res = results.get(i);\n\n                        System.out.println(res.get(0) + \"=\" + res.get(1));\n                    }\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 533,
    "type": "Param",
    "comment": "@param runnable",
    "code": "    public static int execute(Runnable runnable, int attemptsCount, long intervalMillis) {\n        int executionIndex = 0;\n        while (true) {\n            try {\n                runnable.run();\n                return executionIndex;\n            } catch (RuntimeException | AssertionError e) {\n                attemptsCount--;\n                executionIndex++;\n                if (attemptsCount > 0) {\n                    try {\n                        Thread.sleep(intervalMillis);\n                    } catch (InterruptedException ie) {\n                        ie.addSuppressed(e);\n                        throw new RuntimeException(ie);\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 534,
    "type": "Param",
    "comment": "@param member",
    "code": "    public Long sadd(final String key, final String... members) {\n        checkIsInMulti();\n        client.sadd(key, members);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param members"
  },
  {
    "id": 535,
    "type": "Param",
    "comment": "@param obj Response object.",
    "code": "    private static Object interceptSendObject(Object obj, ConnectorMessageInterceptor interceptor) {\n        if (obj instanceof Map) {\n            Map<Object, Object> original = (Map<Object, Object>)obj;\n\n            Map<Object, Object> m = new HashMap<>();\n\n            for (Map.Entry e : original.entrySet())\n                m.put(interceptor.onSend(e.getKey()), interceptor.onSend(e.getValue()));\n\n            return m;\n        }\n        else if (obj instanceof Collection) {\n            Collection<Object> original = (Collection<Object>)obj;\n\n            Collection<Object> c = new ArrayList<>(original.size());\n\n            for (Object e : original)\n                c.add(interceptor.onSend(e));\n\n            return c;\n        }\n        else\n            return interceptor.onSend(obj);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 536,
    "type": "Param",
    "comment": "@param plain Whether provided bytes is not some marshaled value, but rather real value.",
    "code": "    public long putOffHeap(long ptr, byte[] val, byte type) {\n        int size = val.length;\n\n        assert size != 0;\n\n        int allocated = ptr == 0 ? 0 : readInt(ptr);\n\n        if (allocated != size) {\n            if (ptr != 0)\n                release(ptr, allocated + 5);\n\n            ptr = allocate(size + 5);\n\n            writeInt(ptr, size);\n        }\n\n        writeByte(ptr + 4, type);\n        writeBytes(ptr + 5, val);\n\n        return ptr;\n    }\n",
    "label": 1,
    "rec": "@param type Value type."
  },
  {
    "id": 537,
    "type": "Param",
    "comment": "@param nodes Topology nodes.",
    "code": "    private Collection<ClusterNode> nodes(AffinityFunction aff, int part, Collection<ClusterNode> nodes) {\n        List<List<ClusterNode>> assignment = aff.assignPartitions(\n            new GridAffinityFunctionContextImpl(new ArrayList<>(nodes), null, null, new AffinityTopologyVersion(1),\n                BACKUP_CNT));\n\n        return assignment.get(part);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 538,
    "type": "Param",
    "comment": "@param groupName Name of the group.",
    "code": "    public int groupSize(String grpName) {\n        int res = 0;\n\n        for (GridHadoopCounter counter : userCounters) {\n            if (grpName.equals(counter.group()))\n                res++;\n        }\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param grpName Name of the group."
  },
  {
    "id": 539,
    "type": "Param",
    "comment": "@param size the population size of Genetic Algorithm.",
    "code": "    public BitString[] learn(int size, int generation, double[][] x, double[] y, double[][] testx, double[] testy, RegressionMeasure measure, BiFunction<double[][], double[], Regression<double[]>> trainer) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (generation <= 0) {\n            throw new IllegalArgumentException(\"Invalid number of generations to go: \" + generation);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        if (testx.length != testy.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of test X and Y don't match: %d != %d\", testx.length, testy.length));\n        }\n\n        int p = x[0].length;\n        RegressionFitness fitness = new RegressionFitness(trainer, measure, x, y, testx, testy);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;        \n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 540,
    "type": "Param",
    "comment": "@param dest the file containing the new name.",
    "code": "    public boolean renameTo(File newPath) {\n        if (path.isEmpty() || newPath.path.isEmpty()) {\n            return false;\n        }\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkWrite(path);\n            security.checkWrite(newPath.path);\n        }\n        return renameToImpl(pathBytes, newPath.pathBytes);\n    }\n\n",
    "label": 1,
    "rec": "@param newPath the new path."
  },
  {
    "id": 541,
    "type": "Param",
    "comment": "@param setName Name of set.",
    "code": "    private static CacheSet<String> initializeSet(Ignite ignite, String setName) throws IgniteCheckedException {\n        // Initialize new set.\n        CacheSet<String> set = ignite.cache(CACHE_NAME).dataStructures().set(setName, false, true);\n\n        // Initialize set items.\n        for (int i = 0; i < 10; i++)\n            set.add(Integer.toString(i));\n\n        System.out.println(\"Set size after initializing: \" + set.size());\n\n        return set;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 542,
    "type": "Param",
    "comment": "@param t1 the first type",
    "code": "\tpublic boolean isSubtype(TypeMirror potentialSubtype, TypeMirror potentialSupertype) {\n\n\t\tif (processingEnv.getTypeUtils().isSubtype(potentialSubtype, potentialSupertype)) {\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tif (potentialSubtype instanceof DeclaredType) {\n\n\t\t\t\tDeclaredType potentialDeclaredSubtype = (DeclaredType) potentialSubtype;\n\n\t\t\t\tElement potentialSubElement = potentialDeclaredSubtype.asElement();\n\t\t\t\tif (potentialSubElement instanceof TypeElement) {\n\t\t\t\t\tTypeElement potentialSubDeclaredElement = (TypeElement) potentialSubElement;\n\n\t\t\t\t\tTypeMirror superclassTypeMirror = potentialSubDeclaredElement.getSuperclass();\n\n\t\t\t\t\tif (isRootObjectClass(superclassTypeMirror)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (superclassTypeMirror instanceof ErrorType) {\n\n\t\t\t\t\t\t\tErrorType errorType = (ErrorType) superclassTypeMirror;\n\n\t\t\t\t\t\t\tElement errorElement = errorType.asElement();\n\n\t\t\t\t\t\t\tString errorElementSimpleName = errorElement.getSimpleName().toString();\n\t\t\t\t\t\t\tif (errorElementSimpleName.endsWith(GENERATION_SUFFIX)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The supertype %s of the potential subElement %s of potential supertype %s is an ErrorType that doesn't end with %s\", errorElement, potentialSubElement, potentialSupertype, GENERATION_SUFFIX));\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn isSubtype(superclassTypeMirror, potentialSupertype);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The potential subElement %s of potential supertype %s is not a TypeElement but a %s\", potentialSubElement, potentialSupertype, potentialSubElement.getClass()));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tprocessingEnv.getMessager().printMessage(Kind.NOTE, String.format(\"The potential subtype %s of potential supertype %s is not a DeclaredType but a %s\", potentialSubtype, potentialSupertype, potentialSubtype.getClass()));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param potentialSubtype the first type"
  },
  {
    "id": 543,
    "type": "Param",
    "comment": "@param sample Sample size.",
    "code": "    public static VisorCache from(Ignite ignite, GridCache c, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 544,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 545,
    "type": "Param",
    "comment": "@param gridName Grid name.",
    "code": "    protected Ignite startGrid(String gridName, IgniteConfiguration cfg, GridSpringResourceContext ctx)\n        throws Exception {\n        if (!isRemoteJvm(gridName)) {\n            startingGrid.set(gridName);\n\n            try {\n                Ignite node = IgnitionEx.start(cfg, ctx);\n\n                IgniteConfiguration nodeCfg = node.configuration();\n\n                log.info(\"Node started with the following configuration [id=\" + node.cluster().localNode().id()\n                    + \", marshaller=\" + nodeCfg.getMarshaller()\n                    + \", binaryCfg=\" + nodeCfg.getBinaryConfiguration() + \"]\");\n\n                return node;\n            }\n            finally {\n                startingGrid.set(null);\n            }\n        }\n        else\n            return startRemoteGrid(gridName, null, ctx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 546,
    "type": "Param",
    "comment": "@param integer",
    "code": "  public Long incrBy(final String key, final long increment) {\n    checkIsInMultiOrPipeline();\n    client.incrBy(key, increment);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param increment"
  },
  {
    "id": 547,
    "type": "Param",
    "comment": "@param sourceGraph the directed graph",
    "code": "    public GraphImpl createPreviewGraph(PreviewModel model, HierarchicalDirectedGraph sourceGraph) {\n        // creates graph\n        GraphImpl previewGraph = new GraphImpl(model);\n\n        // creates nodes\n        for (org.gephi.graph.api.Node sourceNode : sourceGraph.getNodes()) {\n            createPreviewNode(previewGraph, sourceNode);\n        }\n\n        // creates edges\n        for (org.gephi.graph.api.Edge sourceEdge : sourceGraph.getEdgesAndMetaEdges()) {\n\n            if (sourceEdge.getWeight() <= 0) {\n                continue;\n            }\n\n            if (sourceEdge.isSelfLoop()) {\n                createPreviewSelfLoop(previewGraph, sourceEdge);\n                continue;\n            }\n\n            if (isBidirectional(sourceGraph, sourceEdge)) {\n                createPreviewBidirectionalEdge(previewGraph, sourceEdge);\n            } else {\n                createPreviewUnidirectionalEdge(previewGraph, sourceEdge);\n            }\n        }\n\n        // clears the node map\n        nodeMap.clear();\n\n        return previewGraph;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 548,
    "type": "Param",
    "comment": "@param string",
    "code": "    public Long lpush(final String key, final String... strings) {\n        checkIsInMulti();\n        client.lpush(key, strings);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param strings"
  },
  {
    "id": 549,
    "type": "Param",
    "comment": "@param aesKey The AES key to use for decryption",
    "code": "    public byte[] decrypt(EncryptedData dataToDecrypt, KeyParameter aesKey) throws KeyCrypterException {\n        checkNotNull(dataToDecrypt);\n        checkNotNull(aesKey);\n\n        try {\n            ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), dataToDecrypt.initialisationVector);\n\n            // Decrypt the message.\n            BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));\n            cipher.init(false, keyWithIv);\n\n            byte[] cipherBytes = dataToDecrypt.encryptedBytes;\n            byte[] decryptedBytes = new byte[cipher.getOutputSize(cipherBytes.length)];\n            final int length1 = cipher.processBytes(cipherBytes, 0, cipherBytes.length, decryptedBytes, 0);\n            final int length2 = cipher.doFinal(decryptedBytes, length1);\n\n            return Arrays.copyOf(decryptedBytes, length1 + length2);\n        } catch (Exception e) {\n            throw new KeyCrypterException(\"Could not decrypt bytes\", e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 550,
    "type": "Param",
    "comment": "@param fileUri the URI of a resource.",
    "code": "  public IProject project(Resource resource) {\n    return file(resource.getURI()).getProject();\n  }\n\n",
    "label": 1,
    "rec": "@param resource the given resource."
  },
  {
    "id": 551,
    "type": "Param",
    "comment": "@param subjId Subject ID.",
    "code": "    @Override protected void clearIndex(CacheObject val) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 552,
    "type": "Param",
    "comment": "@param bits",
    "code": "  public static PSetupGuess guessSetup(byte [] bytes){\n    // find the last eof\n    int i = bytes.length-1;\n    while(i > 0 && bytes[i] != '\\n')--i;\n    assert i >= 0;\n    InputStream is = new ByteArrayInputStream(Arrays.copyOf(bytes,i));\n    SVMLightParser p = new SVMLightParser(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, false));\n    InspectDataOut dout = new InspectDataOut();\n    try{p.streamParse(is, dout);}catch(Exception e){throw new RuntimeException(e);}\n    return new PSetupGuess(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, dout._ncols,false,null,false),dout._nlines,dout._invalidLines,dout.data(),dout._ncols > 0 && dout._nlines > 0 && dout._nlines > dout._invalidLines,dout.errors());\n  }\n",
    "label": 1,
    "rec": "@param bytes"
  },
  {
    "id": 553,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean update(CacheObject key, CacheObject val, long expirationTime, boolean rmv)\n        throws IgniteCheckedException {\n        assert desc != null;\n\n        GridH2Row row = desc.createRow(key, val, expirationTime);\n\n        return doUpdate(row, rmv);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 554,
    "type": "Param",
    "comment": "@param obj Object.",
    "code": "    public static boolean overridesEqualsAndHashCode(Class<?> cls) {\n        try {\n            return !Object.class.equals(cls.getMethod(\"equals\", Object.class).getDeclaringClass()) &&\n                !Object.class.equals(cls.getMethod(\"hashCode\").getDeclaringClass());\n        }\n        catch (NoSuchMethodException | SecurityException ignore) {\n            return true; // Ignore.\n        }\n    }\n",
    "label": 1,
    "rec": "@param cls Class."
  },
  {
    "id": 555,
    "type": "Param",
    "comment": "@param rec A raw data record.",
    "code": "    @Override public void loadCache(IgniteBiInClosure<K, V> c, @Nullable Object... args)\n        throws GridException {\n        ExecutorService exec = new ThreadPoolExecutor(\n            threadsCnt,\n            threadsCnt,\n            0L,\n            MILLISECONDS,\n            new ArrayBlockingQueue<Runnable>(batchQueueSize),\n            new BlockingRejectedExecutionHandler());\n\n        Iterator<I> iter = inputIterator(args);\n\n        Collection<I> buf = new ArrayList<>(batchSize);\n\n        try {\n            while (iter.hasNext()) {\n                if (Thread.currentThread().isInterrupted()) {\n                    U.warn(log, \"Working thread was interrupted while loading data.\");\n\n                    break;\n                }\n\n                buf.add(iter.next());\n\n                if (buf.size() == batchSize) {\n                    exec.submit(new Worker(c, buf, args));\n\n                    buf = new ArrayList<>(batchSize);\n                }\n            }\n\n            if (!buf.isEmpty())\n                exec.submit(new Worker(c, buf, args));\n        }\n        catch (RejectedExecutionException ignored) {\n            // Because of custom RejectedExecutionHandler.\n            assert false : \"RejectedExecutionException was thrown while it shouldn't.\";\n        }\n        finally {\n            exec.shutdown();\n\n            try {\n                exec.awaitTermination(Long.MAX_VALUE, MILLISECONDS);\n            }\n            catch (InterruptedException ignored) {\n                U.warn(log, \"Working thread was interrupted while waiting for put operations to complete.\");\n\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 556,
    "type": "Param",
    "comment": "@param end",
    "code": "  public Long zremrangeByScore(final String key, final double min, final double max) {\n    checkIsInMultiOrPipeline();\n    client.zremrangeByScore(key, min, max);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param max"
  },
  {
    "id": 557,
    "type": "Param",
    "comment": "@param b the right hand side of linear equations.",
    "code": "    public static double solve(Matrix A, double[] b, double[] x, double tol, int itol) {\n        return solve(A, diagonalPreconditioner(A), b, x, tol, itol);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 558,
    "type": "Param",
    "comment": "@param name Field name.",
    "code": "    private int fieldOffset(int id) {\n        if (fieldsOffs == null) {\n            fieldsOffs = new HashMap<>();\n\n            int off = start + HDR_LEN;\n\n            while (true) {\n                if (off >= arr.length)\n                    break;\n\n                int id0 = PRIM.readInt(arr, off);\n\n                off += 4;\n\n                int len = PRIM.readInt(arr, off);\n\n                off += 4;\n\n                fieldsOffs.put(id0, off);\n\n                off += len;\n            }\n        }\n\n        Integer fieldOff = fieldsOffs.get(id);\n\n        return fieldOff != null ? fieldOff : -1;\n    }\n",
    "label": 1,
    "rec": "@param id Field ID."
  },
  {
    "id": 559,
    "type": "Param",
    "comment": "@param maxIndividualVariance The most any counter can differ before we give up",
    "code": "  private static float patternMatchVariance(int[] counters, int[] pattern, float maxIndividualVariance) {\n    int numCounters = counters.length;\n    int total = 0;\n    int patternLength = 0;\n    for (int i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this\n      // is too small to reliably match, so fail:\n      return Float.POSITIVE_INFINITY;\n    }\n    // We're going to fake floating-point math in integers. We just need to use more bits.\n    // Scale up patternLength so that intermediate values below like scaledCounter will have\n    // more \"significant digits\".\n    float unitBarWidth = (float) total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n\n    float totalVariance = 0.0f;\n    for (int x = 0; x < numCounters; x++) {\n      int counter = counters[x];\n      float scaledPattern = pattern[x] * unitBarWidth;\n      float variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n      if (variance > maxIndividualVariance) {\n        return Float.POSITIVE_INFINITY;\n      }\n      totalVariance += variance;\n    }\n    return totalVariance / total;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 560,
    "type": "Param",
    "comment": "@param s string to escape",
    "code": "    public static String removeFormattingCharacters(final String toBeEscaped) {\n        StringBuffer escapedBuffer = new StringBuffer();\n        for (int i = 0; i < toBeEscaped.length(); i++) {\n            if ((toBeEscaped.charAt(i) != '\\n') && (toBeEscaped.charAt(i) != '\\r') && (toBeEscaped.charAt(i) != '\\t')) {\n                escapedBuffer.append(toBeEscaped.charAt(i));\n            }\n        }\n        return escapedBuffer.toString();\n    }\n\n",
    "label": 1,
    "rec": "@param toBeEscaped string to escape"
  },
  {
    "id": 561,
    "type": "Param",
    "comment": "@param nodeId Node ID to get primary partitions for.",
    "code": "    public Set<Integer> primaryPartitions(UUID nodeId, AffinityTopologyVersion topVer) {\n        return cachedAffinity(topVer).primaryPartitions(nodeId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 562,
    "type": "Param",
    "comment": "@param publicKey",
    "code": "    public boolean validate(Document signedDocument, KeyLocator keyLocator) throws ProcessingException {\n        try {\n            configureIdAttribute(signedDocument);\n            return XMLSignatureUtil.validate(signedDocument, keyLocator);\n        } catch (MarshalException | XMLSignatureException me) {\n            throw new ProcessingException(logger.signatureError(me));\n        }\n    }\n",
    "label": 1,
    "rec": "@param keyLocator"
  },
  {
    "id": 563,
    "type": "Param",
    "comment": "@param newKey key to insert",
    "code": "    static PreparedStatement createUpsertStatement(Connection conn, int newKey, int newVal) throws SQLException {\n        PreparedStatement stmt;\n        switch (conn.getMetaData().getDatabaseProductName()) {\n            case \"H2\":\n                stmt = conn.prepareStatement(\"merge into SAMPLE(id, val) values(?, ?)\");\n\n                break;\n\n            case \"MySQL\":\n                stmt = conn.prepareStatement(\"insert into SAMPLE(id, val) values(?, ?) on duplicate key update val = ?\");\n\n                stmt.setInt(3, newVal);\n\n                break;\n\n            case \"PostgreSQL\":\n                stmt = conn.prepareStatement(\"insert into SAMPLE(id, val) values(?, ?) on conflict(id) do \" +\n                    \"update set val = ?\");\n\n                stmt.setInt(3, newVal);\n\n                break;\n\n            default:\n                throw new IgniteException(\"Unexpected database type [databaseProductName=\" +\n                    conn.getMetaData().getDatabaseProductName() + ']');\n        }\n\n        stmt.setInt(1, newKey);\n        stmt.setInt(2, newVal);\n\n        return stmt;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 564,
    "type": "Param",
    "comment": "@param add indicate whether the target should be added to the manager if it is not managed.",
    "code": "\tpublic File lookup(String managedFile, boolean add) throws IOException {\n\t\tif (!open)\n\t\t\tthrow new IOException(EclipseAdaptorMsg.fileManager_notOpen);\n\t\tEntry entry = (Entry) table.get(managedFile);\n\t\tif (entry == null) {\n\t\t\tif (add) {\n\t\t\t\tadd(managedFile);\n\t\t\t\tentry = (Entry) table.get(managedFile);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn new File(getAbsolutePath(managedFile + '.' + entry.getReadId()));\n\t}\n\n",
    "label": 1,
    "rec": "@param add indicate whether the managed file name should be added to the manager if it is not already managed."
  },
  {
    "id": 565,
    "type": "Param",
    "comment": "@param fileName File name in the parent's listing.",
    "code": "    private IgniteUuid putIfAbsentNonTx(IgniteUuid parentId, String fileName, IgfsEntryInfo newFileInfo)\n        throws IgniteCheckedException {\n        if (log.isDebugEnabled())\n            log.debug(\"Locking parent id [parentId=\" + parentId + \", fileName=\" + fileName + \", newFileInfo=\" +\n                newFileInfo + ']');\n\n        validTxState(true);\n\n        // Lock only parent file ID.\n        IgfsEntryInfo parentInfo = info(parentId);\n\n        if (parentInfo == null)\n            throw fsException(new IgfsPathNotFoundException(\"Failed to lock parent directory (not found): \" +\n                parentId));\n\n        if (!parentInfo.isDirectory())\n            throw fsException(new IgfsPathIsNotDirectoryException(\"Parent file is not a directory: \" + parentInfo));\n\n        IgfsListingEntry childEntry = parentInfo.listing().get(fileName);\n\n        if (childEntry != null)\n            return childEntry.fileId();\n\n        createNewEntry(newFileInfo, parentId, fileName);\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 566,
    "type": "Param",
    "comment": "@param abbreviatedResponse",
    "code": "\tprivate State createState(Item item, String transformedResponse) {\n\t\t\n\t\tif (item != null) {\n\t\t\treturn TypeParser.parseState(item.getAcceptedDataTypes(), transformedResponse);\n\t\t}\n\t\telse {\n\t\t\treturn StringType.valueOf(transformedResponse);\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param transformedResponse"
  },
  {
    "id": 567,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, K key, V val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = (K)cctx.unwrapPortableIfNeeded(key, false);\n                val = (V)cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(key, locStore ? F.t(val, ver) : val));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 568,
    "type": "Param",
    "comment": "@param cls Input split class.",
    "code": "    public static GridHadoopFileBlock readFileBlock(String clsName, DataInput in, @Nullable String[] hosts)\n        throws GridException {\n        if (!FileSplit.class.getName().equals(clsName))\n            return null;\n\n        FileSplit split = new FileSplit();\n\n        try {\n            split.readFields(in);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n\n        if (hosts == null)\n            hosts = EMPTY_HOSTS;\n\n        return new GridHadoopFileBlock(hosts, split.getPath().toUri(), split.getStart(), split.getLength());\n    }\n",
    "label": 1,
    "rec": "@param clsName Input split class name."
  },
  {
    "id": 569,
    "type": "Param",
    "comment": "@param cand Cache lock candidate to add.",
    "code": "    public boolean addNext(GridCacheContext<K, V> cacheCtx, GridCacheMvccCandidate<K> cand) {\n        assert cand != null;\n        assert !cand.reentry() : \"Lock reentries should not be linked: \" + cand;\n\n        // Don't order near candidates by thread as they will be ordered on\n        // DHT node. Also, if candidate is implicit, no point to order him.\n        if (cacheCtx.isNear() || cand.singleImplicit())\n            return true;\n\n        Queue<GridCacheMvccCandidate<K>> queue = pending.get();\n\n        boolean add = true;\n\n        GridCacheMvccCandidate<K> prev = null;\n\n        for (Iterator<GridCacheMvccCandidate<K>> it = queue.iterator(); it.hasNext(); ) {\n            GridCacheMvccCandidate<K> c = it.next();\n\n            if (c.equals(cand))\n                add = false;\n\n            if (c.used()) {\n                it.remove();\n\n                unlink(c);\n\n                continue;\n            }\n\n            prev = c;\n        }\n\n        if (add) {\n            queue.add(cand);\n\n            if (prev != null) {\n                prev.next(cand);\n\n                cand.previous(prev);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Linked new candidate: \" + cand);\n        }\n\n        return add;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 570,
    "type": "Param",
    "comment": "@param model_size Size of the model in #weights and #biases",
    "code": "  private static long computeTrainSamplesPerIteration(final DeepLearning mp, final long numRows, DeepLearningModel model) {\n    long tspi = mp.train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi == -2 || tspi >= 1);\n    if (tspi == 0 || (!mp.replicate_training_data && tspi == -1) ) {\n      tspi = numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n    }\n    else if (tspi == -1) {\n      tspi = (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n    } else if (tspi == -2) {\n      // automatic tuning based on CPU speed, network speed and model size\n\n      // measure cpu speed\n      double total_gflops = 0;\n      for (H2ONode h2o : H2O.CLOUD._memary) {\n        HeartBeat hb = h2o._heartbeat;\n        total_gflops += hb._gflops;\n      }\n      if (mp.single_node_mode) total_gflops /= H2O.CLOUD.size();\n      if (total_gflops == 0) {\n        total_gflops = Linpack.run(H2O.SELF._heartbeat._cpus_allowed) * (mp.single_node_mode ? 1 : H2O.CLOUD.size());\n      }\n\n      final long model_size = model.model_info().size();\n      int[] msg_sizes = new int[]{ (int)(model_size*4) == (model_size*4) ? (int)(model_size*4) : Integer.MAX_VALUE };\n      double[] microseconds_collective = new double[msg_sizes.length];\n      NetworkTest.NetworkTester nt = new NetworkTest.NetworkTester(msg_sizes,null,microseconds_collective,model_size>1e6 ? 1 : 5 /*repeats*/,false,true /*only collectives*/);\n      nt.compute2();\n\n      //length of the network traffic queue based on log-tree rollup (2 log(nodes))\n      int network_queue_length = mp.single_node_mode || H2O.CLOUD.size() == 1? 1 : 2*(int)Math.floor(Math.log(H2O.CLOUD.size())/Math.log(2));\n\n      // heuristics\n      double flops_overhead_per_row = 30;\n      if (mp.activation == Activation.Maxout || mp.activation == Activation.MaxoutWithDropout) {\n        flops_overhead_per_row *= 8;\n      } else if (mp.activation == Activation.Tanh || mp.activation == Activation.TanhWithDropout) {\n        flops_overhead_per_row *= 5;\n      }\n\n      // target fraction of comm vs cpu time: 5%\n      double fraction = mp.single_node_mode || H2O.CLOUD.size() == 1 ? 1e-3 : 0.05; //one single node mode, there's no model averaging effect, so less need to shorten the M/R iteration\n\n      // estimate the time for communication (network) and training (compute)\n      model.time_for_communication_us = (H2O.CLOUD.size() == 1 ? 1e4 /* add 10ms for single-node */ : 0) + network_queue_length * microseconds_collective[0];\n      double time_per_row_us  = flops_overhead_per_row * model_size / (total_gflops * 1e9) / H2O.SELF._heartbeat._cpus_allowed * 1e6;\n\n      // compute the optimal number of training rows per iteration\n      // fraction := time_comm_us / (time_comm_us + tspi * time_per_row_us)  ==>  tspi = (time_comm_us/fraction - time_comm_us)/time_per_row_us\n      tspi = (long)((model.time_for_communication_us / fraction - model.time_for_communication_us)/ time_per_row_us);\n\n      tspi = Math.min(tspi, (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows * 10); //not more than 10x of what train_samples_per_iteration=-1 would do\n\n      // If the number is close to a multiple of epochs, use that -> prettier scoring\n      if (tspi > numRows && Math.abs(tspi % numRows)/(double)numRows < 0.2)  tspi = tspi - tspi % numRows;\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows / 10)); //limit to number of epochs desired, but at least 10 iterations total\n      tspi = Math.max(1, tspi); //at least 1 point\n\n      if (!mp.quiet_mode) {\n        Log.info(\"Auto-tuning parameter 'train_samples_per_iteration':\");\n        Log.info(\"Estimated compute power : \" + (int)total_gflops + \" GFlops\");\n        Log.info(\"Estimated time for comm : \" + PrettyPrint.usecs((long)model.time_for_communication_us));\n        Log.info(\"Estimated time per row  : \" + ((long)time_per_row_us > 0 ? PrettyPrint.usecs((long)time_per_row_us) : time_per_row_us + \" usecs\"));\n        Log.info(\"Estimated training speed: \" + (int)(1e6/time_per_row_us) + \" rows/sec\");\n        Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to auto-tuned value: \" + tspi);\n      }\n\n    } else {\n      // limit user-given value to number of epochs desired\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows));\n    }\n    assert(tspi != 0 && tspi != -1 && tspi != -2 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 1,
    "rec": "@param model DL Model"
  },
  {
    "id": 571,
    "type": "Param",
    "comment": "@param context the current context",
    "code": "    public static Typeface getTypeface(Context context, IconSet iconSet) {\n        String path = iconSet.fontPath().toString();\n\n        if (TYPEFACE_MAP.get(path) == null) {\n            final Typeface font = Typeface.createFromAsset(context.getAssets(), path);\n            TYPEFACE_MAP.put(path, font);\n        }\n        return TYPEFACE_MAP.get(path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 572,
    "type": "Param",
    "comment": "@param barCode",
    "code": "    public Observable<Parsed> disk(@Nonnull final Key key) {\n        if (shouldReturnNetworkBeforeStale(persister, stalePolicy, key)) {\n            return Observable.empty();\n        }\n\n        return readDisk(key);\n    }\n",
    "label": 1,
    "rec": "@param key"
  },
  {
    "id": 573,
    "type": "Param",
    "comment": "@param exDir",
    "code": "\tpublic static boolean updateFlowStatusFromFile(File exDir, ExecutableFlow flow, boolean cleanOldUpdates) throws ExecutorManagerException {\n\t\tFile file = getLatestExecutableFlowDir(exDir, cleanOldUpdates);\n\t\tint number =  getFlowUpdateNumber(file);\n\t\tif (flow.getUpdateNumber() >= number) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Loading from: \" + file);\n\t\tObject exFlowObj = getFlowObjectFromFile(file);\n\t\tflow.updateExecutableFlowFromObject(exFlowObj);\n\t\tflow.setUpdateNumber(number);\n\t\t\n\t\treturn true;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 574,
    "type": "Param",
    "comment": "@param jsonProvider the json provider that is used to create the result list",
    "code": "    public Object doFilter(Iterable<T> filterItems, Configuration configuration) {\n        JsonProvider provider = configuration.getProvider();\n        Object result = provider.createArray();\n        for (T filterItem : filterItems) {\n            if (accept(filterItem, configuration)) {\n                provider.setProperty(result, provider.length(result), filterItem);\n            }\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param configuration the json provider configuration that is used to create the result list"
  },
  {
    "id": 575,
    "type": "Param",
    "comment": "@param tx Started transaction.",
    "code": "    public boolean onStarted(IgniteInternalTx<K, V> tx) {\n        assert tx.state() == ACTIVE || tx.isRollbackOnly() : \"Invalid transaction state [locId=\" + cctx.localNodeId() +\n            \", tx=\" + tx + ']';\n\n        if (isCompleted(tx)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Attempt to start a completed transaction (will ignore): \" + tx);\n\n            return false;\n        }\n\n        onTxStateChange(null, ACTIVE, tx);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Transaction started: \" + tx);\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 576,
    "type": "Param",
    "comment": "@param ggfs GGFS instance to resolve logs dir for.",
    "code": "    public static Path resolveGgfsProfilerLogsDir(IgniteFs igfs) throws IgniteCheckedException {\n        String logsDir;\n\n        if (igfs instanceof IgfsEx)\n            logsDir = ((IgfsEx)igfs).clientLogDirectory();\n        else if (igfs == null)\n            throw new IgniteCheckedException(\"Failed to get profiler log folder (GGFS instance not found)\");\n        else\n            throw new IgniteCheckedException(\"Failed to get profiler log folder (unexpected GGFS instance type)\");\n\n        URL logsDirUrl = U.resolveIgniteUrl(logsDir != null ? logsDir : DFLT_GGFS_LOG_DIR);\n\n        return logsDirUrl != null ? new File(logsDirUrl.getPath()).toPath() : null;\n    }\n",
    "label": 1,
    "rec": "@param igfs GGFS instance to resolve logs dir for."
  },
  {
    "id": 577,
    "type": "Param",
    "comment": "@param jdkMarshaller JDK marshaller.",
    "code": "    private byte[] encodeMemcache(GridMemcachedMessage msg, IgniteMarshaller jdkMarshaller) throws GridException {\n        GridByteArrayList res = new GridByteArrayList(HDR_LEN - 1);\n\n        int keyLen = 0;\n\n        int keyFlags = 0;\n\n        if (msg.key() != null) {\n            ByteArrayOutputStream rawKey = new ByteArrayOutputStream();\n\n            keyFlags = encodeObj(msg.key(), rawKey, jdkMarshaller);\n\n            msg.key(rawKey.toByteArray());\n\n            keyLen = rawKey.size();\n        }\n\n        int dataLen = 0;\n\n        int valFlags = 0;\n\n        if (msg.value() != null) {\n            ByteArrayOutputStream rawVal = new ByteArrayOutputStream();\n\n            valFlags = encodeObj(msg.value(), rawVal, jdkMarshaller);\n\n            msg.value(rawVal.toByteArray());\n\n            dataLen = rawVal.size();\n        }\n\n        int flagsLen = 0;\n\n        if (msg.addFlags())\n            flagsLen = FLAGS_LENGTH;\n\n        res.add(msg.operationCode());\n\n        // Cast is required due to packet layout.\n        res.add((short)keyLen);\n\n        // Cast is required due to packet layout.\n        res.add((byte)flagsLen);\n\n        // Data type is always 0x00.\n        res.add((byte)0x00);\n\n        res.add((short)msg.status());\n\n        res.add(keyLen + flagsLen + dataLen);\n\n        res.add(msg.opaque(), 0, msg.opaque().length);\n\n        // CAS, unused.\n        res.add(0L);\n\n        assert res.size() == HDR_LEN - 1;\n\n        if (flagsLen > 0) {\n            res.add((short) keyFlags);\n            res.add((short) valFlags);\n        }\n\n        assert msg.key() == null || msg.key() instanceof byte[];\n        assert msg.value() == null || msg.value() instanceof byte[];\n\n        if (keyLen > 0)\n            res.add((byte[])msg.key(), 0, ((byte[])msg.key()).length);\n\n        if (dataLen > 0)\n            res.add((byte[])msg.value(), 0, ((byte[])msg.value()).length);\n\n        return res.entireArray();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 578,
    "type": "Param",
    "comment": "@param meta Job metadata.",
    "code": "    private JobLocalState initState(GridHadoopJobId jobId) {\n        return F.addIfAbsent(activeJobs, jobId, new JobLocalState());\n    }\n",
    "label": 1,
    "rec": "@param jobId Job ID."
  },
  {
    "id": 579,
    "type": "Param",
    "comment": "@param listener the listener",
    "code": "    public boolean nextRow(ResultSet results, KeyValueStreamListener listener)\n            throws SQLException, IOException, ParseException {\n        if (results.next()) {\n            processRow(results, listener);\n            return true;\n        }\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 580,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static IgniteQueue<String> initializeQueue(Ignite g, String queueName) throws IgniteCheckedException {\n        IgniteCollectionConfiguration colCfg = new IgniteCollectionConfiguration();\n\n        // Initialize new FIFO queue.\n        IgniteQueue<String> queue = g.queue(queueName, colCfg, 0, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < g.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 581,
    "type": "Param",
    "comment": "@param idTask",
    "code": "    public JSONArray tasksSetTitle(long idTask, String title) throws ApiServiceException, IOException {\n        return getResponse(invokeGet(\"tasks/set_title.json\",\n                \"token\", token,\n                \"id_task\", idTask,\n                \"title\", title), \"tasks\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 582,
    "type": "Param",
    "comment": "@param lines Lines to sum.",
    "code": "    public static VisorGgfsProfilerEntry aggregateGgfsProfilerEntries(List<VisorGgfsProfilerEntry> entries) {\n        assert !F.isEmpty(entries);\n\n        if (entries.size() == 1) {\n            return entries.get(0); // No need to aggregate.\n        }\n        else {\n            String path = entries.get(0).path();\n\n            long timestamp = 0;\n            long size = 0;\n            long bytesRead = 0;\n            long readTime = 0;\n            long userReadTime = 0;\n            long bytesWritten = 0;\n            long writeTime = 0;\n            long userWriteTime = 0;\n            GridGgfsMode mode = null;\n            VisorGgfsProfilerUniformityCounters counters = new VisorGgfsProfilerUniformityCounters();\n\n            Collections.sort(entries, VisorGgfsProfilerEntry.ENTRY_TIMESTAMP_COMPARATOR);\n\n            for (VisorGgfsProfilerEntry entry : entries) {\n                // Take last timestamp.\n                timestamp = entry.timestamp();\n\n                // Take last size.\n                size = entry.size();\n\n                // Take last size.\n                mode = entry.mode();\n\n                // Aggregate metrics.\n                bytesRead += entry.bytesRead();\n                readTime += entry.readTime();\n                userReadTime += entry.userReadTime();\n                bytesWritten += entry.bytesWritten();\n                writeTime += entry.writeTime();\n                userWriteTime += entry.userWriteTime();\n\n                counters.aggregate(entry.counters());\n            }\n\n            return new VisorGgfsProfilerEntry(path, timestamp, mode, size, bytesRead, readTime, userReadTime,\n                bytesWritten, writeTime, userWriteTime, counters);\n        }\n    }\n",
    "label": 1,
    "rec": "@param entries Entries to sum."
  },
  {
    "id": 583,
    "type": "Param",
    "comment": "@param excl Excludes.",
    "code": "            @Override public void apply(IgniteFuture<?> f) {\n                try {\n                    f.get();\n                }\n                catch (GridException e) {\n                    if (!F.isEmpty(excl))\n                        for (Class cls : excl)\n                            if (e.hasCause(cls))\n                                return;\n\n                    U.error(log, \"Future execution resulted in error: \" + f, e);\n                }\n            }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 584,
    "type": "Param",
    "comment": "@param position",
    "code": "    public Group getGroup(Item contentItem) {\n        for (Group group : groups) {\n            if (group.getPosition(contentItem) >= 0) {\n                return group;\n            }\n        }\n        throw new IndexOutOfBoundsException(\"Item is not present in adapter or in any group\");\n    }\n",
    "label": 1,
    "rec": "@param contentItem Item to find the parent group for."
  },
  {
    "id": 585,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, AffinityTopologyVersion topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!cctx.discovery().cacheNearNode(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listenAsync(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        synchronized (this) {\n                            // Release memory.\n                            reader0.resetTxFuture();\n                        }\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 586,
    "type": "Param",
    "comment": "@param zooKeeper Zookeeper address .",
    "code": "    private ConsumerConfig createDefaultConsumerConfig(String zooKeeper, String grpId) {\n        A.notNull(zooKeeper, \"zookeeper\");\n        A.notNull(grpId, \"groupId\");\n\n        Properties props = new Properties();\n\n        props.put(\"zookeeper.connect\", zooKeeper);\n        props.put(\"group.id\", grpId);\n        props.put(\"zookeeper.session.timeout.ms\", \"400\");\n        props.put(\"zookeeper.sync.time.ms\", \"200\");\n        props.put(\"auto.commit.interval.ms\", \"1000\");\n        props.put(\"auto.offset.reset\", \"smallest\");\n\n        return new ConsumerConfig(props);\n    }\n",
    "label": 1,
    "rec": "@param zooKeeper ZooKeeper address &lt;server:port&gt;."
  },
  {
    "id": 587,
    "type": "Param",
    "comment": "@param startpos the start position within the message",
    "code": "  private static int determineConsecutiveTextCount(CharSequence msg, int startpos) {\n    int len = msg.length();\n    int idx = startpos;\n    while (idx < len) {\n      char ch = msg.charAt(idx);\n      int numericCount = 0;\n      while (numericCount < 13 && isDigit(ch) && idx < len) {\n        numericCount++;\n        idx++;\n        if (idx < len) {\n          ch = msg.charAt(idx);\n        }\n      }\n      if (numericCount >= 13) {\n        return idx - startpos - numericCount;\n      }\n      if (numericCount > 0) {\n        //Heuristic: All text-encodable chars or digits are binary encodable\n        continue;\n      }\n      ch = msg.charAt(idx);\n\n      //Check if character is encodable\n      if (!isText(ch)) {\n        break;\n      }\n      idx++;\n    }\n    return idx - startpos;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 588,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static CacheSet<String> initializeSet(Ignite ignite, String setName) throws IgniteCheckedException {\n        // Initialize new set.\n        CacheSet<String> set = ignite.cache(CACHE_NAME).dataStructures().set(setName, false, true);\n\n        // Initialize set items.\n        for (int i = 0; i < 10; i++)\n            set.add(Integer.toString(i));\n\n        System.out.println(\"Set size after initializing: \" + set.size());\n\n        return set;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 589,
    "type": "Param",
    "comment": "@param moduleIds",
    "code": "    public List<SysRoleModule> getEntitys(Integer[] roleIds, String[] moduleIds) {\n        return dao.getEntitys(roleIds, moduleIds);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 590,
    "type": "Param",
    "comment": "@param info Task info.",
    "code": "    private GridHadoopTaskOutput createOutput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case REDUCE:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case MAP:\n                if (locCombiner) {\n                    assert local == null;\n\n                    local = get(job.info(), SHUFFLE_COMBINER_NO_SORTING, false) ?\n                        new GridHadoopHashMultimap(job, mem, get(job.info(), COMBINER_HASHMAP_SIZE, 8 * 1024)):\n                        new GridHadoopSkipList(job, mem, job.sortComparator()); // TODO replace with red-black tree\n\n                    return local.startAdding();\n                }\n\n            default:\n                return createOutput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param ctx Task info."
  },
  {
    "id": 591,
    "type": "Param",
    "comment": "@param centerJ center of the section that appears to cross a finder pattern",
    "code": "  private float crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal) {\n    MonochromeBitmapSource image = this.image;\n\n    int maxI = image.getHeight();\n    int[] stateCount = new int[5];\n\n    // Start counting up from center\n    int i = startI;\n    while (i >= 0 && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i--;\n    }\n    if (i < 0) {\n      return Float.NaN;\n    }\n    while (i >= 0 && !image.isBlack(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return Float.NaN;\n    }\n    while (i >= 0 && image.isBlack(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return Float.NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i++;\n    }\n    if (i == maxI) {\n      return Float.NaN;\n    }\n    while (i < maxI && !image.isBlack(centerJ, i) && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      i++;\n    }\n    if (i == maxI || stateCount[3] >= maxCount) {\n      return Float.NaN;\n    }\n    while (i < maxI && image.isBlack(centerJ, i) && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      i++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return Float.NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is more than 20% different than\n    // the original, assume it's a false positive\n    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n      return Float.NaN;\n    }\n\n    return foundPatternCross(stateCount) ? centerFromEnd(stateCount, i) : Float.NaN;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 592,
    "type": "Param",
    "comment": "@param info Task info.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input(ctx, (Comparator<Object>) ctx.combineGroupComparator());\n                }\n\n            default:\n                return createInput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param ctx Task info."
  },
  {
    "id": 593,
    "type": "Param",
    "comment": "@param path Path.",
    "code": "    private List<IgniteUuid> fileIds(IgniteFsPath path, boolean skipTx) throws GridException {\n        assert path != null;\n\n        // Path components.\n        Collection<String> components = path.components();\n\n        // Collection of file IDs for components of specified path.\n        List<IgniteUuid> ids = new ArrayList<>(components.size() + 1);\n\n        ids.add(ROOT_ID); // Always add root ID.\n\n        IgniteUuid fileId = ROOT_ID;\n\n        for (String s : components) {\n            assert !s.isEmpty();\n\n            if (fileId != null)\n                fileId = fileId(fileId, s, skipTx);\n\n            ids.add(fileId);\n        }\n\n        return ids;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 594,
    "type": "Param",
    "comment": "@param spaces Space names.",
    "code": "    private static GridSqlQuery collectAllSpaces(GridSqlQuery qry, Set<String> schemas) {\n        if (qry instanceof GridSqlUnion) {\n            GridSqlUnion union = (GridSqlUnion)qry;\n\n            collectAllSpaces(union.left(), schemas);\n            collectAllSpaces(union.right(), schemas);\n        }\n        else {\n            GridSqlSelect select = (GridSqlSelect)qry;\n\n            collectAllSpacesInFrom(select.from(), schemas);\n\n            for (GridSqlElement el : select.columns(false))\n                collectAllSpacesInSubqueries(el, schemas);\n\n            collectAllSpacesInSubqueries(select.where(), schemas);\n        }\n\n        return qry;\n    }\n",
    "label": 1,
    "rec": "@param schemas Shemas' names."
  },
  {
    "id": 595,
    "type": "Param",
    "comment": "@param cacheId Cache ID.",
    "code": "    public GridDhtPartitionTopology clientTopology(int cacheId, GridDhtPartitionsExchangeFuture exchFut) {\n        GridClientPartitionTopology top = clientTops.get(cacheId);\n\n        if (top != null)\n            return top;\n\n        GridClientPartitionTopology old = clientTops.putIfAbsent(cacheId,\n            top = new GridClientPartitionTopology(cctx, cacheId, exchFut));\n\n        return old != null ? old : top;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 596,
    "type": "Param",
    "comment": "@param expFwdId Expected forward page ID.",
    "code": "    private boolean putDown(final Put p, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        assert lvl >= 0 : lvl;\n\n        for (;;) {\n            final Page page = page(pageId);\n\n            if (page == null)\n                return true; // Page was removed, retry.\n\n            try {\n                // Init args.\n                p.pageId = pageId;\n                p.fwdId = fwdId;\n\n                int res = readPage(page, search, p, lvl);\n\n                switch (res) {\n                    case Put.RETRY:\n                        return true; // Our page was splitted or merged, retry.\n\n                    case Put.GO_DOWN:\n                        assert lvl > 0 : lvl;\n                        assert p.pageId != pageId;\n                        assert p.fwdId != fwdId || fwdId == 0;\n\n                        if (p.foundInner) { // Need to replace ref in inner page.\n                            p.foundInner = false;\n\n                            int res0 = writePage(page, replace, p, lvl);\n\n                            switch (res0) {\n                                case Put.NOT_FOUND:\n                                    return true; // Our page was splitted or merged, retry.\n\n                                case Put.FOUND:\n                                    break; // Successfully replaced in inner page.\n\n                                default:\n                                    assert false : res0;\n                            }\n                        }\n\n                        // Go down recursively.\n                        if (putDown(p, p.pageId, p.fwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        if (p.isFinished()) {\n                            assert p.tailLock == null;\n\n                            return false; // Successfully inserted or replaced down the stack.\n                        }\n\n                        assert p.btmLvl == lvl : \"it must be a split: \" + p.btmLvl + \" == \" + lvl;\n\n                        checkInterrupted();\n\n                        continue; // We have to insert split row to the upper level.\n\n                    case Put.FOUND: // Do replace.\n                        assert lvl == 0 : \"This replace can happen only at the bottom level.\";\n\n                        // Init args.\n                        p.pageId = pageId;\n                        p.fwdId = fwdId;\n\n                        res = writePage(page, replace, p, lvl);\n\n                        switch (res) {\n                            case Put.NOT_FOUND:\n                                return true; // Retry.\n\n                            case Put.FOUND:\n                                assert p.isFinished();\n\n                                return false;\n\n                            default:\n                                assert false : res;\n                        }\n\n                        break;\n\n                    case Put.NOT_FOUND: // Do insert.\n                        assert lvl == p.btmLvl : \"must insert at the bottom level\";\n\n                        // Init args.\n                        p.pageId = pageId;\n                        p.fwdId = fwdId;\n\n                        res = writePage(page, insert, p, lvl);\n\n                        switch (res) {\n                            case Put.RETRY:\n                                return true; // Our page was splitted or merged, retry.\n\n                            case Put.FOUND:\n                                if (p.isFinished())\n                                    return false;\n\n                                assert p.btmLvl > lvl;\n\n                                return true; // Go insert to the upper level.\n\n                            default:\n                                assert false: res;\n                        }\n\n                        break;\n\n                    default:\n                        assert false : res;\n                }\n            }\n            finally{\n                if (p.tailLock != page)\n                    page.close();\n            }\n\n            checkInterrupted();\n        }\n    }\n",
    "label": 1,
    "rec": "@param fwdId Expected forward page ID."
  },
  {
    "id": 597,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorCache from(Ignite ignite, GridCache c, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 598,
    "type": "Param",
    "comment": "@param grid Node;",
    "code": "    private GridGgfsImpl ggfs(Ignite ignite) throws Exception {\n        return (GridGgfsImpl) ignite.ggfs(GGFS_NAME);\n    }\n",
    "label": 1,
    "rec": "@param ignite Node;"
  },
  {
    "id": 599,
    "type": "Param",
    "comment": "@param lvl Level.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        Page page = page(pageId);\n\n        if (page == null)\n            return true; // Page was removed, retry.\n\n        try {\n            for (;;) {\n                // Init args.\n                g.pageId = pageId;\n                g.fwdId = fwdId;\n\n                int res = readPage(page, search, g, lvl, Get.RETRY);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.fwdId != fwdId || fwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.fwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false; // We are done.\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        assert false: res;\n                }\n            }\n        }\n        finally {\n            if (g.canRelease(page, lvl))\n                page.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 600,
    "type": "Param",
    "comment": "@param tag",
    "code": "        public static QueryTemplate queryTemplate(Criterion criterion, TagData tagData) {\n            return new QueryTemplate().join(Join.inner(Metadata.TABLE,\n                    Task.ID.eq(Metadata.TASK))).where(tagEqIgnoreCase(tagData.getValue(TagData.NAME), criterion));\n        }\n",
    "label": 1,
    "rec": "@param tagData"
  },
  {
    "id": 601,
    "type": "Param",
    "comment": "@param e Event",
    "code": "        private boolean filterByTaskSessionId(Event e, IgniteUuid taskSesId) {\n            if (e.getClass().equals(TaskEvent.class)) {\n                TaskEvent te = (TaskEvent)e;\n\n                return te.taskSessionId().equals(taskSesId);\n            }\n\n            if (e.getClass().equals(JobEvent.class)) {\n                JobEvent je = (JobEvent)e;\n\n                return je.taskSessionId().equals(taskSesId);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 602,
    "type": "Param",
    "comment": "@param exchId Exchange ID.",
    "code": "    public GridDhtPartitionTopology clientTopology(int cacheId, GridDhtPartitionsExchangeFuture exchFut) {\n        GridClientPartitionTopology top = clientTops.get(cacheId);\n\n        if (top != null)\n            return top;\n\n        GridClientPartitionTopology old = clientTops.putIfAbsent(cacheId,\n            top = new GridClientPartitionTopology(cctx, cacheId, exchFut));\n\n        return old != null ? old : top;\n    }\n",
    "label": 1,
    "rec": "@param exchFut Exchange future."
  },
  {
    "id": 603,
    "type": "Param",
    "comment": "@param partId Partition ID.",
    "code": "    public static long pageId(int partId, byte flag, long pageIdx) {\n        long fileId = 0;\n\n        fileId = (fileId << FLAG_SIZE) | (flag & FLAG_MASK);\n        fileId = (fileId << PART_ID_SIZE) | (partId & PART_ID_MASK);\n\n        return pageId((int)fileId, pageIdx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 604,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static TimerTask scheduleQuery(final Ignite g, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = g.streamer(\"popular-numbers\");\n\n                try {\n                    // Send reduce query to all 'popular-numbers' streamers\n                    // running on local and remote nodes.\n                    Collection<StreamerIndexEntry<Integer, Integer, Long>> col = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext,\n                                                                            Collection<StreamerIndexEntry<Integer, Integer, Long>>>() {\n                            @Override public Collection<StreamerIndexEntry<Integer, Integer, Long>> apply(\n                                StreamerContext ctx) {\n                                StreamerIndex<Integer, Integer, Long> view = ctx.<Integer>window().index();\n\n                                return view.entries(-1 * POPULAR_NUMBERS_CNT);\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new PopularNumbersReducer());\n\n                    for (StreamerIndexEntry<Integer, Integer, Long> cntr : col)\n                        System.out.printf(\"%3d=%d\\n\", cntr.key(), cntr.value());\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 605,
    "type": "Param",
    "comment": "@param delimiter",
    "code": "\tpublic static String join(Collection<String> list, String delimiter) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tfor (String str: list) {\n\t\t\tbuffer.append(str);\n\t\t\tbuffer.append(delimiter);\n\t\t}\n\t\t\n\t\treturn buffer.toString();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 606,
    "type": "Param",
    "comment": "@param cacheVal Value.",
    "code": "    public V applyEntryProcessors(V val) {\n        for (T2<EntryProcessor<K, V, ?>, Object[]> t : entryProcessors()) {\n            try {\n                CacheInvokeEntry<K, V> invokeEntry = new CacheInvokeEntry<>(ctx, key, val);\n\n                EntryProcessor processor = t.get1();\n\n                processor.process(invokeEntry, t.get2());\n\n                val = invokeEntry.getValue();\n            }\n            catch (Exception ignore) {\n                // No-op.\n            }\n        }\n\n        if (ctx.portableEnabled())\n            val = (V)ctx.marshalToPortable(val);\n\n        return val;\n    }\n",
    "label": 1,
    "rec": "@param val Value."
  },
  {
    "id": 607,
    "type": "Param",
    "comment": "@param fs Secondary file system.",
    "code": "    public boolean renameDual(final IgniteFsFileSystem fs, final IgniteFsPath src, final IgniteFsPath dest) throws\n        GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert src != null;\n                assert dest != null;\n\n                if (src.parent() == null)\n                    return false; // Root directory cannot be renamed.\n\n                // Events to fire (can be done outside of a transaction).\n                final Collection<IgniteFsEvent> pendingEvts = new LinkedList<>();\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgniteFsPath, GridGgfsFileInfo> infos) throws Exception {\n                        GridGgfsFileInfo srcInfo = infos.get(src);\n                        GridGgfsFileInfo srcParentInfo = infos.get(src.parent());\n                        GridGgfsFileInfo destInfo = infos.get(dest);\n                        GridGgfsFileInfo destParentInfo = dest.parent() != null ? infos.get(dest.parent()) : null;\n\n                        // Source path and destination (or destination parent) must exist.\n                        if (srcInfo == null)\n                            throw new IgniteFsFileNotFoundException(\"Failed to rename (source path not found): \" + src);\n\n                        if (destInfo == null && destParentInfo == null)\n                            throw new IgniteFsFileNotFoundException(\"Failed to rename (destination path not found): \" +\n                                dest);\n\n                        // Delegate to the secondary file system.\n                        fs.rename(src, dest);\n\n                        // Rename was successful, perform compensation in the local file system.\n                        if (destInfo == null) {\n                            // Move and rename.\n                            assert destParentInfo != null;\n\n                            moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), dest.name(), destParentInfo.id());\n                        }\n                        else {\n                            // Move.\n                            if (destInfo.isFile())\n                                throw new IgniteFsException(\"Failed to rename the path in the local file system \" +\n                                    \"because destination path already exists and it is a file: \" + dest);\n                            else\n                                moveNonTx(srcInfo.id(), src.name(), srcParentInfo.id(), src.name(), destInfo.id());\n                        }\n\n                        // Record event if needed.\n                        if (srcInfo.isFile()) {\n                            if (evts.isRecordable(EVT_GGFS_FILE_RENAMED))\n                                pendingEvts.add(new IgniteFsEvent(\n                                    src,\n                                    destInfo == null ? dest : new IgniteFsPath(dest, src.name()),\n                                    locNode,\n                                    EVT_GGFS_FILE_RENAMED));\n                        }\n                        else if (evts.isRecordable(EVT_GGFS_DIR_RENAMED))\n                            pendingEvts.add(new IgniteFsEvent(src, dest, locNode, EVT_GGFS_DIR_RENAMED));\n\n                        return true;\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws GridException {\n                        U.error(log, \"Path rename in DUAL mode failed [source=\" + src + \", destination=\" + dest + ']',\n                            err);\n\n                        if (err instanceof IgniteFsException)\n                            throw (GridException)err;\n                        else\n                            throw new GridException(\"Failed to rename the path due to secondary file system \" +\n                                \"exception: \" + src, err);\n                    }\n                };\n\n                try {\n                    return synchronizeAndExecute(task, fs, false, src, dest);\n                }\n                finally {\n                    for (IgniteFsEvent evt : pendingEvts)\n                        evts.record(evt);\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to rename in DUAL mode because Grid is stopping [src=\" + src +\n                \", dest=\" + dest + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 608,
    "type": "Param",
    "comment": "@param deviceNumber The bulb number the bridge has filed the bulb under.",
    "code": "\tpublic int getBrightness(String deviceId) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(deviceId).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 1,
    "rec": "@param deviceId The bulb id the bridge has filed the bulb under."
  },
  {
    "id": 609,
    "type": "Param",
    "comment": "@param label A label",
    "code": "    public static String convertToBitcoinURI(String address, BigInteger amount, String label, String message) {\n        Preconditions.checkNotNull(address);\n        if (amount != null && amount.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Amount must be positive\");\n        }\n        \n        StringBuilder builder = new StringBuilder();\n        builder.append(BITCOIN_SCHEME).append(COLON_SEPARATOR).append(address);\n        \n        boolean questionMarkHasBeenOutput = false;\n        \n        if (amount != null) {\n            builder.append(QUESTION_MARK_SEPARATOR).append(FIELD_AMOUNT).append(\"=\");\n            builder.append(Utils.bitcoinValueToPlainString(amount));\n            questionMarkHasBeenOutput = true;\n        }\n        \n        if (label != null && !\"\".equals(label)) {\n            if (questionMarkHasBeenOutput) {\n                builder.append(AMPERSAND_SEPARATOR);\n            } else {\n                builder.append(QUESTION_MARK_SEPARATOR);                \n                questionMarkHasBeenOutput = true;\n            }\n            builder.append(FIELD_LABEL).append(\"=\").append(encodeURLString(label));\n        }\n        \n        if (message != null && !\"\".equals(message)) {\n            if (questionMarkHasBeenOutput) {\n                builder.append(AMPERSAND_SEPARATOR);\n            } else {\n                builder.append(QUESTION_MARK_SEPARATOR);                \n                questionMarkHasBeenOutput = true;\n            }\n            builder.append(FIELD_MESSAGE).append(\"=\").append(encodeURLString(message));\n        }\n        \n        return builder.toString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 610,
    "type": "Param",
    "comment": "@param remove Remove the dragged item from the list. Calls a registered DropListener, if one exists.",
    "code": "    public boolean stopDrag(boolean remove) {\n        if (mFloatView != null) {\n            mDragScroller.stopScrolling(true);\n            \n            if (remove) {\n                removeItem(mSrcPos - getHeaderViewsCount());\n            } else {\n                if (mDropAnimator != null) {\n                    mDropAnimator.start();\n                } else {\n                    dropFloatView();\n                }\n            }\n\n            if (mTrackDragSort) {\n                mDragSortTracker.stopTracking();\n            }\n\n            return true;\n        } else {\n            // stop failed\n            return false;\n        }\n    }\n",
    "label": 1,
    "rec": "@param remove Remove the dragged item from the list. Calls a registered RemoveListener, if one exists. Otherwise, calls the DropListener, if one exists."
  },
  {
    "id": 611,
    "type": "Param",
    "comment": "@param tx Cache transaction.",
    "code": "    public boolean putAllToStore(@Nullable IgniteTxEx tx, Map<K, IgniteBiTuple<V, GridCacheVersion>> map)\n        throws IgniteCheckedException {\n        if (F.isEmpty(map))\n            return true;\n\n        if (map.size() == 1) {\n            Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e = map.entrySet().iterator().next();\n\n            return putToStore(tx, e.getKey(), e.getValue().get1(), e.getValue().get2());\n        }\n        else {\n            if (store != null) {\n                EntriesView entries = new EntriesView(map);\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Storing values in cache store [entries=\" + entries + ']');\n\n                initSession(tx);\n\n                try {\n                    store.writeAll(entries);\n                }\n                catch (ClassCastException e) {\n                    handleClassCastException(e);\n                }\n                catch (Exception e) {\n                    if (!entries.isEmpty()) {\n                        List<Object> keys = new ArrayList<>(entries.size());\n\n                        for (Cache.Entry<?, ?> entry : entries)\n                            keys.add(entry.getKey());\n\n                        throw new CacheStorePartialUpdateException(keys, e);\n                    }\n\n                    if (!(e instanceof CacheWriterException))\n                        e = new CacheWriterException(e);\n\n                    throw new IgniteCheckedException(e);\n                }\n                finally {\n                    sesHolder.set(null);\n                }\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Stored value in cache store [entries=\" + entries + ']');\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 612,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = ignite.streamer(\"popular-numbers\");\n\n                try {\n                    // Send reduce query to all 'popular-numbers' streamers\n                    // running on local and remote nodes.\n                    Collection<StreamerIndexEntry<Integer, Integer, Long>> col = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext,\n                                                                            Collection<StreamerIndexEntry<Integer, Integer, Long>>>() {\n                            @Override public Collection<StreamerIndexEntry<Integer, Integer, Long>> apply(\n                                StreamerContext ctx) {\n                                StreamerIndex<Integer, Integer, Long> view = ctx.<Integer>window().index();\n\n                                return view.entries(-1 * POPULAR_NUMBERS_CNT);\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new PopularNumbersReducer());\n\n                    for (StreamerIndexEntry<Integer, Integer, Long> cntr : col)\n                        System.out.printf(\"%3d=%d\\n\", cntr.key(), cntr.value());\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 613,
    "type": "Param",
    "comment": "@param tier Tier number to assign.",
    "code": "        boolean assign(int part, int tier, ClusterNode node, boolean force, Map<Integer, Queue<Integer>> pendingParts) {\n            UUID nodeId = node.id();\n\n            if (!fullMap.get(nodeId).contains(part)) {\n                tierMaps[tier].get(nodeId).add(part);\n\n                fullMap.get(nodeId).add(part);\n\n                List<ClusterNode> assignment = assignments.get(part);\n\n                if (assignment.size() <= tier)\n                    assignment.add(node);\n                else {\n                    ClusterNode oldNode = assignment.set(tier, node);\n\n                    if (oldNode != null) {\n                        UUID oldNodeId = oldNode.id();\n\n                        tierMaps[tier].get(oldNodeId).remove(part);\n                        fullMap.get(oldNodeId).remove(part);\n                    }\n                }\n\n                return true;\n            }\n            else if (force) {\n                assert !tierMaps[tier].get(nodeId).contains(part);\n\n                // Check previous tiers first.\n                for (int t = 0; t < tier; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part))\n                        return false;\n                }\n\n                // Partition is on some lower tier, switch it.\n                for (int t = tier + 1; t < tierMaps.length; t++) {\n                    if (tierMaps[t].get(nodeId).contains(part)) {\n                        ClusterNode oldNode = assignments.get(part).get(tier);\n\n                        // Move partition from level t to tier.\n                        assignments.get(part).set(tier, node);\n                        assignments.get(part).set(t, null);\n\n                        if (oldNode != null) {\n                            tierMaps[tier].get(oldNode.id()).remove(part);\n                            fullMap.get(oldNode.id()).remove(part);\n                        }\n\n                        tierMaps[tier].get(nodeId).add(part);\n                        tierMaps[t].get(nodeId).remove(part);\n\n                        Queue<Integer> pending = pendingParts.get(t);\n\n                        if (pending == null) {\n                            pending = new LinkedList<>();\n\n                            pendingParts.put(t, pending);\n                        }\n\n                        pending.add(part);\n\n                        return true;\n                    }\n                }\n\n                throw new IllegalStateException(\"Unable to assign partition to node while force is true.\");\n            }\n\n            // !force.\n            return false;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 614,
    "type": "Param",
    "comment": "@param kafkaPorts the ports.",
    "code": "\tpublic EmbeddedKafkaBroker kafkaPorts(int... ports) {\n\t\tAssert.isTrue(ports.length == this.count, \"A port must be provided for each instance [\"\n\t\t\t\t+ this.count + \"], provided: \" + Arrays.toString(ports) + \", use 0 for a random port\");\n\t\tthis.kafkaPorts = ports;\n\t\treturn this;\n\t}\n",
    "label": 1,
    "rec": "@param ports the ports."
  },
  {
    "id": 615,
    "type": "Param",
    "comment": "@param tx Transaction to commit.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitTxAsync(IgniteInternalTx<K, V> tx) {\n        Collection<Integer> cacheIds = tx.activeCacheIds();\n\n        if (cacheIds.isEmpty())\n            return tx.commitAsync();\n        else if (cacheIds.size() == 1) {\n            int cacheId = F.first(cacheIds);\n\n            return cacheContext(cacheId).cache().commitTxAsync(tx);\n        }\n        else {\n            for (Integer cacheId : cacheIds)\n                cacheContext(cacheId).cache().awaitLastFut();\n\n            return tx.commitAsync();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 616,
    "type": "Param",
    "comment": "@param end",
    "code": "  public String ltrim(final byte[] key, final long start, final long stop) {\n    checkIsInMultiOrPipeline();\n    client.ltrim(key, start, stop);\n    return client.getStatusCodeReply();\n  }\n",
    "label": 1,
    "rec": "@param stop"
  },
  {
    "id": 617,
    "type": "Param",
    "comment": "@param keys Keys to lock.",
    "code": "    private boolean mapAsPrimary(Collection<KeyCacheObject> keys, AffinityTopologyVersion topVer) throws IgniteCheckedException {\n        // Assign keys to primary nodes.\n        Collection<KeyCacheObject> distributedKeys = new ArrayList<>(keys.size());\n\n        for (KeyCacheObject key : keys) {\n            if (!cctx.affinity().primary(cctx.localNode(), key, topVer)) {\n                // Remove explicit locks added so far.\n                for (KeyCacheObject k : keys)\n                    cctx.mvcc().removeExplicitLock(threadId, k, lockVer);\n\n                return false;\n            }\n\n            addLocalKey(key, topVer, distributedKeys);\n\n            if (isDone())\n                return true;\n        }\n\n        trackable = false;\n\n        if (tx != null)\n            tx.colocatedLocallyMapped(true);\n\n        if (!distributedKeys.isEmpty()) {\n            if (tx != null) {\n                for (KeyCacheObject key : distributedKeys)\n                    tx.addKeyMapping(cctx.txKey(key), cctx.localNode());\n            }\n\n            lockLocally(distributedKeys, topVer, null);\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 618,
    "type": "Param",
    "comment": "@param srvNodesNum Server nodes number.",
    "code": "    private String topologySnapshotMessage(int serverNodesNum, int clientNodesNum, int totalCpus, double heap) {\n        return PREFIX + \" [\" +\n            (discoOrdered ? \"ver=\" + topSnap.get().topVer.topologyVersion() + \", \" : \"\") +\n            \"servers=\" + serverNodesNum +\n            \", clients=\" + clientNodesNum +\n            \", CPUs=\" + totalCpus +\n            \", heap=\" + heap + \"GB]\";\n    }\n",
    "label": 1,
    "rec": "@param serverNodesNum Server nodes number."
  },
  {
    "id": 619,
    "type": "Param",
    "comment": "@param repository",
    "code": "    public static Intent createIntent(Repo repository) {\n        return new Builder(\"repo.VIEW\").repo(repository).toIntent();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 620,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    private Collection<Integer> nearKeys(Ignite ignite) {\n        final Collection<Integer> keys = new ArrayList<>(KEY_CNT);\n\n        GridKernal kernal = (GridKernal) ignite;\n\n        GridCacheAffinityManager<Object, Object> affMgr = kernal.internalCache().context().affinity();\n\n        for (int i = 0; i < KEY_CNT * GRID_CNT * 1.5; i++) {\n            if (!affMgr.localNode((Object)i, kernal.context().discovery().topologyVersion())) {\n                keys.add(i);\n\n                if (keys.size() == KEY_CNT)\n                    break;\n            }\n        }\n\n        return keys;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 621,
    "type": "Param",
    "comment": "@param g Grid instance.",
    "code": "    public static boolean checkExplicitTaskMonitoring(Ignite g) {\n        int[] evts = g.configuration().getIncludeEventTypes();\n\n        if (F.isEmpty(evts))\n            return false;\n\n        for (int evt : VISOR_TASK_EVTS) {\n            if (!F.contains(evts, evt))\n                return false;\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 622,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorBasicConfiguration from(IgniteEx g, IgniteConfiguration c) {\n        VisorBasicConfiguration cfg = new VisorBasicConfiguration();\n\n        cfg.gridName(c.getGridName());\n        cfg.ggHome(getProperty(IGNITE_HOME, c.getIgniteHome()));\n        cfg.localHost(getProperty(IGNITE_LOCAL_HOST, c.getLocalHost()));\n        cfg.nodeId(g.localNode().id());\n        cfg.marshaller(compactClass(c.getMarshaller()));\n        cfg.deploymentMode(compactObject(c.getDeploymentMode()));\n        cfg.daemon(boolValue(IGNITE_DAEMON, c.isDaemon()));\n        cfg.jmxRemote(g.isJmxRemoteEnabled());\n        cfg.restart(g.isRestartEnabled());\n        cfg.networkTimeout(c.getNetworkTimeout());\n        cfg.logger(compactClass(c.getGridLogger()));\n        cfg.discoStartupDelay(c.getDiscoveryStartupDelay());\n        cfg.mBeanServer(compactClass(c.getMBeanServer()));\n        cfg.noAscii(boolValue(IGNITE_NO_ASCII, false));\n        cfg.noDiscoOrder(boolValue(IGNITE_NO_DISCO_ORDER, false));\n        cfg.noShutdownHook(boolValue(IGNITE_NO_SHUTDOWN_HOOK, false));\n        cfg.programName(getProperty(IGNITE_PROG_NAME));\n        cfg.quiet(boolValue(IGNITE_QUIET, true));\n        cfg.successFile(getProperty(IGNITE_SUCCESS_FILE));\n        cfg.updateNotifier(boolValue(IGNITE_UPDATE_NOTIFIER, true));\n        cfg.securityCredentialsProvider(compactClass(c.getSecurityCredentialsProvider()));\n\n        return cfg;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 623,
    "type": "Param",
    "comment": "@param c Actual cache.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 624,
    "type": "Param",
    "comment": "@param in Input character stream.",
    "code": "    public static int copy(InputStream in, OutputStream out) throws IOException {\n        assert in != null;\n        assert out != null;\n\n        byte[] buf = new byte[BUF_SIZE];\n\n        int cnt = 0;\n\n        for (int n; (n = in.read(buf)) > 0;) {\n            out.write(buf, 0, n);\n\n            cnt += n;\n        }\n\n        return cnt;\n    }\n",
    "label": 1,
    "rec": "@param in Input byte stream."
  },
  {
    "id": 625,
    "type": "Param",
    "comment": "@param content the set of commands to be executed by the  ExecuteCommandJob later on",
    "code": "    protected JobDetail createJob(String content, Event event, boolean isStartEvent) {\n        String jobIdentity = event.getICalUID() + (isStartEvent ? \"_start\" : \"_end\");\n\n        if (StringUtils.isBlank(content)) {\n            logger.debug(\"content of job '{}' is empty -> no task will be created!\", jobIdentity);\n            return null;\n        }\n\n        JobDetail job = newJob(ExecuteCommandJob.class).usingJobData(ExecuteCommandJob.JOB_DATA_CONTENT_KEY, content)\n                .withIdentity(jobIdentity, GCAL_SCHEDULER_GROUP).build();\n\n        return job;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 626,
    "type": "Param",
    "comment": "@param criteria criteria",
    "code": "    public static Filter filter(Collection<Predicate> predicates) {\n        return new AndFilter(predicates);\n    }\n",
    "label": 1,
    "rec": "@param predicates list of criteria all needs to evaluate to true"
  },
  {
    "id": 627,
    "type": "Param",
    "comment": "@param addr Address to send message to.",
    "code": "    @Nullable private Integer sendMessageDirectly(TcpDiscoveryAbstractMessage msg, InetSocketAddress addr, Socket sock)\n        throws IgniteSpiException {\n        assert msg != null;\n        assert addr != null;\n\n        Collection<Throwable> errs = null;\n\n        long ackTimeout0 = ackTimeout;\n\n        int connectAttempts = 1;\n\n        boolean joinReqSent = false;\n\n        UUID locNodeId = ignite.configuration().getNodeId();\n\n        for (int i = 0; i < reconCnt; i++) {\n            // Need to set to false on each new iteration,\n            // since remote node may leave in the middle of the first iteration.\n            joinReqSent = false;\n\n            boolean openSock = false;\n\n            try {\n                long tstamp = U.currentTimeMillis();\n\n                if (sock == null)\n                    sock = openSocket(addr);\n\n                openSock = true;\n\n                // Handshake.\n                writeToSocket(sock, new TcpDiscoveryHandshakeRequest(locNodeId));\n\n                TcpDiscoveryHandshakeResponse res = readMessage(sock, null, ackTimeout0);\n\n                if (locNodeId.equals(res.creatorNodeId())) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Handshake response from local node: \" + res);\n\n                    break;\n                }\n\n                stats.onClientSocketInitialized(U.currentTimeMillis() - tstamp);\n\n                // Send message.\n                tstamp = U.currentTimeMillis();\n\n                writeToSocket(sock, msg);\n\n                stats.onMessageSent(msg, U.currentTimeMillis() - tstamp);\n\n                if (debugMode)\n                    debugLog(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                // Connection has been established, but\n                // join request may not be unmarshalled on remote host.\n                // E.g. due to class not found issue.\n                joinReqSent = msg instanceof TcpDiscoveryJoinRequestMessage;\n\n                return readReceipt(sock, ackTimeout0);\n            }\n            catch (ClassCastException e) {\n                // This issue is rarely reproducible on AmazonEC2, but never\n                // on dedicated machines.\n                if (log.isDebugEnabled())\n                    U.error(log, \"Class cast exception on direct send: \" + addr, e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n            }\n            catch (IOException | IgniteCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.error(\"Exception on direct send: \" + e.getMessage(), e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n\n                if (!openSock) {\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break; // Don't retry if we can not establish connection.\n                }\n\n                if (e instanceof SocketTimeoutException || X.hasCause(e, SocketTimeoutException.class)) {\n                    ackTimeout0 *= 2;\n\n                    if (!checkAckTimeout(ackTimeout0))\n                        break;\n                }\n            }\n            finally {\n                U.closeQuiet(sock);\n\n                sock = null;\n            }\n        }\n\n        if (joinReqSent) {\n            if (log.isDebugEnabled())\n                log.debug(\"Join request has been sent, but receipt has not been read (returning RES_WAIT).\");\n\n            // Topology will not include this node,\n            // however, warning on timed out join will be output.\n            return RES_OK;\n        }\n\n        throw new IgniteSpiException(\n            \"Failed to send message to address [addr=\" + addr + \", msg=\" + msg + ']',\n            U.exceptionWithSuppressed(\"Failed to send message to address \" +\n                \"[addr=\" + addr + \", msg=\" + msg + ']', errs));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 628,
    "type": "Param",
    "comment": "@param type The type of the class where the method is located.",
    "code": "\tpublic static Method method(Class<?> declaringClass, String methodName, Class<?>... parameterTypes) {\n\t\tfinal Method method = WhiteboxImpl.findMethod(declaringClass, methodName, parameterTypes);\n\t\tWhiteboxImpl.throwExceptionIfMethodWasNotFound(declaringClass, methodName, method, (Object[]) parameterTypes);\n\t\treturn method;\n\t}\n",
    "label": 1,
    "rec": "@param declaringClass The declaringClass of the class where the method is located."
  },
  {
    "id": 629,
    "type": "Param",
    "comment": "@param ids",
    "code": "    public String delete(Long[] ids, HttpServletRequest request, HttpSession session) {\n        if (notEmpty(ids)) {\n            SysSite site = getSite(request);\n            service.delete(site.getId(), ids);\n            logOperateService.save(new LogOperate(site.getId(), getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.place\", getIpAddress(request), getDate(), join(ids, ',')));\n        }\n        return TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 630,
    "type": "Param",
    "comment": "@param filesStr File path(s) delimited by delimiter",
    "code": "  public static Collection<String> listFiles(String filesString, String delimiter) {\n    ValidationUtils.validateNotEmpty(filesString, \"fileStr\");\n\n    List<String> files = new ArrayList<String>();\n    for (String fileString : filesString.split(delimiter)) {\n      File file = new File(fileString);\n      if (!file.getName().contains(\"*\") && !file.getName().contains(\"?\")) {\n        files.add(file.getAbsolutePath());\n        continue;\n      }\n\n      FileFilter fileFilter = new AndFileFilter(new WildcardFileFilter(file.getName()),\n          FileFileFilter.FILE);\n      File parent = file.getParentFile() == null ? file : file.getParentFile();\n      File[] filteredFiles = parent.listFiles(fileFilter);\n      if (filteredFiles == null) {\n        continue;\n      }\n\n      for (File filteredFile : filteredFiles) {\n        files.add(filteredFile.getAbsolutePath());\n      }\n    }\n    return files;\n  }\n",
    "label": 1,
    "rec": "@param filesString File path(s) delimited by delimiter"
  },
  {
    "id": 631,
    "type": "Param",
    "comment": "@param fromTouch - Whether this is being invoked from a touch event",
    "code": "    private boolean canRefresh(boolean fromTouch, OnRefreshListener listener) {\n        return !mIsRefreshing && (!fromTouch || listener != null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 632,
    "type": "Param",
    "comment": "@param way: needed to retrieve OSM tags",
    "code": "    protected double applyMaxSpeed( ReaderWay way, double speed )\n    {\n        double maxSpeed = getMaxSpeed(way);\n        if (maxSpeed >= 0)\n        {\n            // We strictly obay speed limits, see #600\n            if (maxSpeed < speed)\n            {\n                return maxSpeed;\n            }\n        }\n        return speed;\n    }\n",
    "label": 1,
    "rec": "@param way: needed to retrieve tags"
  },
  {
    "id": 633,
    "type": "Param",
    "comment": "@param repository",
    "code": "    public static Intent createIntent(Repo repository) {\n        return new Intents.Builder(\"repo.contributors.VIEW\").repo(repository).toIntent();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 634,
    "type": "Param",
    "comment": "@param delete Whether lock is taken for delete.",
    "code": "    private IgfsEntryInfo invokeLock(IgniteUuid id, boolean del) throws IgniteCheckedException {\n        return invokeAndGet(id, new IgfsMetaFileLockProcessor(createFileLockId(del)));\n    }\n",
    "label": 1,
    "rec": "@param del Whether lock is taken for delete."
  },
  {
    "id": 635,
    "type": "Param",
    "comment": "@param key Key to look up.",
    "code": "    @Nullable public GridCacheMvccCandidate explicitLock(long threadId, KeyCacheObject key) {\n        if (threadId < 0)\n            return explicitLock(key, null);\n        else {\n            GridCacheExplicitLockSpan span = pendingExplicit.get(threadId);\n\n            return span == null ? null : span.candidate(key, null);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 636,
    "type": "Param",
    "comment": "@param start",
    "code": "  public Long zremrangeByScore(final byte[] key, final double min, final double max) {\n    return zremrangeByScore(key, toByteArray(min), toByteArray(max));\n  }\n",
    "label": 1,
    "rec": "@param min"
  },
  {
    "id": 637,
    "type": "Param",
    "comment": "@param c",
    "code": "\tpublic static JsonObject serialize(RegisteredClient c) {\n\t\tJsonObject o = new JsonObject();\n\n\t\to.addProperty(\"client_id\", c.getClientId());\n\t\tif (c.getClientSecret() != null) {\n\t\t\to.addProperty(\"client_secret\", c.getClientSecret());\n\t\t\to.addProperty(\"expires_at\", 0); // TODO: do we want to let secrets expire?\n\t\t}\n\n\t\tif (c.getIssuedAt() != null) {\n\t\t\to.addProperty(\"issued_at\", c.getIssuedAt().getTime() / 1000L);\n\t\t} else if (c.getCreatedAt() != null) {\n\t\t\to.addProperty(\"issued_at\", c.getCreatedAt().getTime() / 1000L);\n\t\t}\n\t\tif (c.getRegistrationAccessToken() != null) {\n\t\t\to.addProperty(\"registration_access_token\", c.getRegistrationAccessToken());\n\t\t}\n\n\t\tif (c.getRegistrationClientUri() != null) {\n\t\t\to.addProperty(\"registration_client_uri\", c.getRegistrationClientUri());\n\t\t}\n\n\n\t\t// add in all other client properties\n\n\t\t// OAuth DynReg\n\t\to.add(\"redirect_uris\", getAsArray(c.getRedirectUris()));\n\t\to.addProperty(\"client_name\", c.getClientName());\n\t\to.addProperty(\"client_uri\", c.getClientUri());\n\t\to.addProperty(\"logo_uri\", c.getLogoUri());\n\t\to.add(\"contacts\", getAsArray(c.getContacts()));\n\t\to.addProperty(\"tos_uri\", c.getTosUri());\n\t\to.addProperty(\"token_endpoint_auth_method\", c.getTokenEndpointAuthMethod() != null ? c.getTokenEndpointAuthMethod().getValue() : null);\n\t\to.addProperty(\"scope\", c.getScope() != null ? Joiner.on(\" \").join(c.getScope()) : null);\n\t\to.add(\"grant_types\", getAsArray(c.getGrantTypes()));\n\t\to.addProperty(\"policy_uri\", c.getPolicyUri());\n\t\to.addProperty(\"jwks_uri\", c.getJwksUri());\n\n\t\t// OIDC Registration\n\t\to.addProperty(\"application_type\", c.getApplicationType() != null ? c.getApplicationType().getValue() : null);\n\t\to.addProperty(\"sector_identifier_uri\", c.getSectorIdentifierUri());\n\t\to.addProperty(\"subject_type\", c.getSubjectType() != null ? c.getSubjectType().getValue() : null);\n\t\to.addProperty(\"request_object_signing_alg\", c.getRequestObjectSigningAlg() != null ? c.getRequestObjectSigningAlg().getAlgorithmName() : null);\n\t\to.addProperty(\"userinfo_signed_response_alg\", c.getUserInfoSignedResponseAlg() != null ? c.getUserInfoSignedResponseAlg().getAlgorithmName() : null);\n\t\to.addProperty(\"userinfo_encrypted_response_alg\", c.getUserInfoEncryptedResponseAlg() != null ? c.getUserInfoEncryptedResponseAlg().getAlgorithmName() : null);\n\t\to.addProperty(\"userinfo_encrypted_response_enc\", c.getUserInfoEncryptedResponseEnc() != null ? c.getUserInfoEncryptedResponseEnc().getAlgorithmName() : null);\n\t\to.addProperty(\"id_token_signed_response_alg\", c.getIdTokenSignedResponseAlg() != null ? c.getIdTokenSignedResponseAlg().getAlgorithmName() : null);\n\t\to.addProperty(\"id_token_encrypted_response_alg\", c.getIdTokenEncryptedResponseAlg() != null ? c.getIdTokenEncryptedResponseAlg().getAlgorithmName() : null);\n\t\to.addProperty(\"id_token_encrypted_response_enc\", c.getIdTokenEncryptedResponseEnc() != null ? c.getIdTokenEncryptedResponseEnc().getAlgorithmName() : null);\n\t\to.addProperty(\"default_max_age\", c.getDefaultMaxAge());\n\t\to.addProperty(\"require_auth_time\", c.getRequireAuthTime());\n\t\to.add(\"default_acr_values\", getAsArray(c.getDefaultACRvalues()));\n\t\to.addProperty(\"initiate_login_uri\", c.getInitiateLoginUri());\n\t\to.addProperty(\"post_logout_redirect_uri\", c.getPostLogoutRedirectUri());\n\t\to.add(\"request_uris\", getAsArray(c.getRequestUris()));\n\t\treturn o;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 638,
    "type": "Param",
    "comment": "@param score",
    "code": "  public Double zincrby(final String key, final double increment, final String member) {\n    checkIsInMultiOrPipeline();\n    client.zincrby(key, increment, member);\n    String newscore = client.getBulkReply();\n    return Double.valueOf(newscore);\n  }\n",
    "label": 1,
    "rec": "@param increment"
  },
  {
    "id": 639,
    "type": "Param",
    "comment": "@param commit Commit flag (rollback if  false).",
    "code": "    public GridFuture<GridCacheTx> finishLocal(boolean commit, boolean explicitLock, GridNearTxLocal<K, V> tx) {\n        try {\n            if (commit) {\n                if (!tx.markFinalizing(USER_FINISH)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Will not finish transaction (it is handled by another thread): \" + tx);\n\n                    return null;\n                }\n\n                return tx.commitAsyncLocal();\n            }\n            else\n                return tx.rollbackAsyncLocal();\n        }\n        catch (Throwable e) {\n            U.error(log, \"Failed completing transaction [commit=\" + commit + \", tx=\" + tx + ']', e);\n\n            if (tx != null)\n                return tx.rollbackAsync();\n\n            return new GridFinishedFuture<>(ctx.kernalContext(), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 640,
    "type": "Param",
    "comment": "@param loginSession for current request",
    "code": "    protected Response handleBrowserAuthenticationRequest(AuthenticationSessionModel authSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(authSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, authSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    // processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                AuthenticationManager.setRolesAndMappersInSession(authSession);\n\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                // Attach session once no requiredActions or other things are required\n                processor.attachSession();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, authSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow(null);\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param authSession for current request"
  },
  {
    "id": 641,
    "type": "Param",
    "comment": "@param matcher decides whether argument matches",
    "code": "    public static int intThat(MockitoMatcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 642,
    "type": "Param",
    "comment": "@param pGraph",
    "code": "    public double finalQ(int[] struct, double[] degrees, HierarchicalUndirectedGraph graph, AttributeModel attributeModel) {\n        AttributeTable nodeTable = attributeModel.getNodeTable();\n        AttributeColumn modCol = nodeTable.getColumn(MODULARITY_CLASS);\n        if (modCol == null) {\n            modCol = nodeTable.addColumn(MODULARITY_CLASS, \"Modularity Class\", AttributeType.INT, AttributeOrigin.COMPUTED, new Integer(0));\n        }\n\n        double res = 0;\n        double[] internal = new double[degrees.length];\n        for (Node n : graph.getNodes()) {\n            int n_index = structure.map.get(n);\n            AttributeRow row = (AttributeRow) n.getNodeData().getAttributes();\n            row.setValue(modCol, struct[n_index]);\n            for (Node neighbor : graph.getNeighbors(n)) {\n                if (n == neighbor) {\n                    continue;\n                }\n                int neigh_index = structure.map.get(neighbor);\n                if (struct[neigh_index] == struct[n_index]) {\n                    internal[struct[neigh_index]]++;\n                }\n            }\n        }\n        for (int i = 0; i < degrees.length; i++) {\n            internal[i] /= 2.0;\n            res += (internal[i] / graph.getEdgeCount()) - Math.pow(degrees[i] / (2 * graph.getEdgeCount()), 2);\n        }\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param graph"
  },
  {
    "id": 643,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, AffinityTopologyVersion topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!cctx.discovery().cacheNearNode(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture txFut = null;\n\n        Collection<GridCacheMvccCandidate> cands = null;\n\n        ReaderId reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId(nodeId, msgId);\n\n                ReaderId[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate c : cands) {\n                    IgniteInternalTx tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId reader0 = reader;\n\n                txFut.listen(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        cctx.kernalContext().closure().runLocalSafe(new GridPlainRunnable() {\n                            @Override public void run() {\n                                synchronized (this) {\n                                    // Release memory.\n                                    reader0.resetTxFuture();\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 644,
    "type": "Param",
    "comment": "@param pathFragment The path fragment that is currently being processed which is believed to be the name of a function",
    "code": "    public static Function newFunction(String name) throws InvalidPathException {\n        Function result = new PassthruFunction();\n\n        if (null != name && FUNCTIONS.containsKey(name) && Function.class.isAssignableFrom(FUNCTIONS.get(name))) {\n            try {\n                result = (Function)FUNCTIONS.get(name).newInstance();\n            } catch (InstantiationException e) {\n                throw new InvalidPathException(\"Function of name: \" + name + \" cannot be created\", e);\n            } catch (IllegalAccessException e) {\n                throw new InvalidPathException(\"Function of name: \" + name + \" cannot be created\", e);\n            }\n        }\n        return result;\n\n    }\n",
    "label": 1,
    "rec": "@param name The name of the function"
  },
  {
    "id": 645,
    "type": "Param",
    "comment": "@param byteBuffer",
    "code": "\tprivate Object getValue(ByteBuffer byteBuffer, TelegramValue telegramValue) {\n\n\t\tString type = telegramValue.getType().toLowerCase();\n\t\tint pos = telegramValue.getPos() != null ? telegramValue.getPos() : -1;\n\n\t\tObject value = null;\n\n\t\t// requested pos is greater as whole buffer\n\t\tif(pos > byteBuffer.position()) {\n\t\t\tlogger.warn(\"eBus buffer pos error! Can happen ...\");\n\t\t}\n\n\t\t// replace similar data types\n\t\tif(type.equals(\"uint\"))\n\t\t\ttype = \"word\";\n\t\tif(type.equals(\"byte\"))\n\t\t\ttype = \"uchar\";\n\n\t\tbyte[] bytes = null;\n\t\tif(type.equals(\"data2b\") || type.equals(\"data2c\") || type.equals(\"word\")) {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos), byteBuffer.get(pos-1)};\n\t\t} else {\n\t\t\tbytes = new byte[] {byteBuffer.get(pos-1)};\n\t\t}\n\n\t\tif(type.equals(\"bit\")) {\n\t\t\tint bit = telegramValue.getBit();\n\t\t\tvalue = bytes[0];\n\n\t\t\tboolean isSet = ((Byte)value >> bit& 0x1) == 1;\n\t\t\tvalue = isSet;\n\n\t\t} else {\n\t\t\tvalue = NumberUtils.toBigDecimal(EBusCodecUtils.decode(type, bytes, telegramValue.getReplaceValue()));\n\t\t}\n\n\t\t// if BigDecimal check for min, max and replace value\n\t\tif(value instanceof BigDecimal) {\n\t\t\tBigDecimal b = (BigDecimal)value;\n\n\t\t\t// multiply before check min and max\n\t\t\tif(b != null && telegramValue.getFactor() != null) {\n\t\t\t\tlogger.trace(\"Value multiplied ...\");\n\t\t\t\tvalue = b = b.multiply(telegramValue.getFactor());\n\t\t\t}\n\n\t\t\t// value is below min value, return null\n\t\t\tif(telegramValue.getMin() != null && b != null && b.compareTo(telegramValue.getMin()) == -1) {\n\t\t\t\tlogger.trace(\"Minimal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\n\t\t\t\t// value is above max value, return null\n\t\t\t} else if (telegramValue.getMax() != null && b != null && b.compareTo(telegramValue.getMax()) == 1) {\n\t\t\t\tlogger.trace(\"Maximal value reached, skip value ...\");\n\t\t\t\tvalue = b = null;\n\t\t\t}\n\n\t\t}\n\n\t\treturn value;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 646,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static TimerTask scheduleQuery(final Ignite g, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = g.streamer(\"priceBars\");\n\n                try {\n                    Collection<Bar> bars = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext, Collection<Bar>>() {\n                            @Override public Collection<Bar> apply(StreamerContext ctx) {\n                                Collection<Bar> values = ctx.<String, Bar>localSpace().values();\n\n                                Collection<Bar> res = new ArrayList<>(values.size());\n\n                                for (Bar bar : values)\n                                    res.add(bar.copy());\n\n                                return res;\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new IgniteReducer<Collection<Bar>, Collection<Bar>>() {\n                            private final Collection<Bar> res = new ArrayList<>();\n\n                            @Override public boolean collect(@Nullable Collection<Bar> col) {\n                                res.addAll(col);\n\n                                return true;\n                            }\n\n                            @Override public Collection<Bar> reduce() {\n                                return res;\n                            }\n                        }\n                    );\n\n                    for (Bar bar : bars)\n                        System.out.println(bar.toString());\n\n                    System.out.println(\"-----------------\");\n                }\n                catch (IgniteException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 2000, 2000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 647,
    "type": "Param",
    "comment": "@param gridName Grid name.",
    "code": "    protected CacheConfiguration cacheConfiguration(String gridName) {\n        CacheConfiguration cacheCfg = defaultCacheConfiguration();\n\n        cacheCfg.setName(\"partitioned\");\n        cacheCfg.setCacheMode(PARTITIONED);\n        cacheCfg.setDistributionMode(cnt == 0 ? NEAR_ONLY : PARTITIONED_ONLY);\n        cacheCfg.setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC);\n        cacheCfg.setAffinityMapper(new IgfsGroupDataBlocksKeyMapper(GRP_SIZE));\n        cacheCfg.setBackups(0);\n        cacheCfg.setQueryIndexEnabled(false);\n        cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n        return cacheCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 648,
    "type": "Param",
    "comment": "@param m IGFS metrics.",
    "code": "    public static VisorIgfsMetrics from(IgniteFileSystem igfs) {\n        assert igfs != null;\n\n        IgfsMetrics m = igfs.metrics();\n\n        VisorIgfsMetrics metrics = new VisorIgfsMetrics();\n\n        metrics.totalSpaceSz = igfs.configuration().getMaxSpaceSize();\n        metrics.usedSpaceSz = m.localSpaceSize();\n        metrics.foldersCnt = m.directoriesCount();\n        metrics.filesCnt = m.filesCount();\n        metrics.filesOpenedForRd = m.filesOpenedForRead();\n        metrics.filesOpenedForWrt = m.filesOpenedForWrite();\n        metrics.blocksRd = m.blocksReadTotal();\n        metrics.blocksRdRmt = m.blocksReadRemote();\n        metrics.blocksWrt = m.blocksWrittenTotal();\n        metrics.blocksWrtRmt = m.blocksWrittenRemote();\n        metrics.bytesRd = m.bytesRead();\n        metrics.bytesRdTm = m.bytesReadTime();\n        metrics.bytesWrt = m.bytesWritten();\n        metrics.bytesWrtTm = m.bytesWriteTime();\n\n        return metrics;\n    }\n",
    "label": 1,
    "rec": "@param igfs Source IGFS."
  },
  {
    "id": 649,
    "type": "Param",
    "comment": "@param directory",
    "code": "    private String setupFile(File directory, boolean isService) throws IOException {\n        File astridDir = directory;\n        if (astridDir != null) {\n            // Check for /sdcard/astrid directory. If it doesn't exist, make it.\n            if (astridDir.exists() || astridDir.mkdir()) {\n                String fileName;\n                if (isService) {\n                    fileName = BackupConstants.BACKUP_FILE_NAME;\n                } else {\n                    fileName = BackupConstants.EXPORT_FILE_NAME;\n                }\n                fileName = String.format(fileName, BackupDateUtilities.getDateForExport());\n                return astridDir.getAbsolutePath() + File.separator + fileName;\n            } else {\n                // Unable to make the /sdcard/astrid directory.\n                throw new IOException(context.getString(R.string.DLG_error_sdcard,\n                        astridDir.getAbsolutePath()));\n            }\n        } else {\n            // Unable to access the sdcard because it's not in the mounted state.\n            throw new IOException(context.getString(R.string.DLG_error_sdcard_general));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 650,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public boolean isNativeMethod(String methodSignature) {\n        BuilderMethod method = getMethod(methodSignature);\n\n        return Modifier.isNative(method.getAccessFlags());\n    }\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 651,
    "type": "Param",
    "comment": "@param spi SPI.",
    "code": "    private GridNioSession communicationSession(TcpCommunicationSpi spi, boolean in) throws Exception {\n        final GridNioServer srv = U.field(spi, \"nioSrvr\");\n\n        GridTestUtils.waitForCondition(new GridAbsPredicate() {\n            @Override public boolean apply() {\n                Collection<? extends GridNioSession> sessions = GridTestUtils.getFieldValue(srv, \"sessions\");\n\n                return !sessions.isEmpty();\n            }\n        }, awaitForSocketWriteTimeout());\n\n        Collection<? extends GridNioSession> sessions = GridTestUtils.getFieldValue(srv, \"sessions\");\n\n        for (GridNioSession ses : sessions) {\n            if (in == ses.accepted())\n                return ses;\n        }\n\n        fail(\"Failed to find session\");\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 652,
    "type": "Param",
    "comment": "@param strings",
    "code": "    public Long rpush(final byte[] key, final byte[]... string) {\n        checkIsInMulti();\n        client.rpush(key, string);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param string"
  },
  {
    "id": 653,
    "type": "Param",
    "comment": "@param name Property name.",
    "code": "    private static String getStringProperty(String name, Properties fileProps, String dfltVal) {\n        if (fileProps != null && fileProps.containsKey(name))\n            return fileProps.getProperty(name);\n\n        String prop = System.getProperty(name);\n\n        if (prop == null)\n            prop = System.getenv(name);\n\n        return prop == null ? dfltVal : prop;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 654,
    "type": "Param",
    "comment": "@param drawableResource",
    "code": "\tpublic static Drawable getTintDrawable(Context context, Drawable drawable, int color) {\n\t\tDrawable wrapDrawable = DrawableCompat.wrap(drawable);\n\t\tDrawableCompat.setTint(wrapDrawable, color);\n\t\treturn wrapDrawable;\n\t}\n",
    "label": 1,
    "rec": "@param drawable"
  },
  {
    "id": 655,
    "type": "Param",
    "comment": "@param in Input stream.",
    "code": "    Object read(IgniteOptimizedObjectInputStream in) throws ClassNotFoundException, IOException {\n        switch (type) {\n            case TYPE_BYTE:\n                return in.readByte();\n\n            case TYPE_SHORT:\n                return in.readShort();\n\n            case TYPE_INT:\n                return in.readInt();\n\n            case TYPE_LONG:\n                return in.readLong();\n\n            case TYPE_FLOAT:\n                return in.readFloat();\n\n            case TYPE_DOUBLE:\n                return in.readDouble();\n\n            case TYPE_CHAR:\n                return in.readChar();\n\n            case TYPE_BOOLEAN:\n                return in.readBoolean();\n\n            case TYPE_BYTE_ARR:\n                return in.readByteArray();\n\n            case TYPE_SHORT_ARR:\n                return in.readShortArray();\n\n            case TYPE_INT_ARR:\n                return in.readIntArray();\n\n            case TYPE_LONG_ARR:\n                return in.readLongArray();\n\n            case TYPE_FLOAT_ARR:\n                return in.readFloatArray();\n\n            case TYPE_DOUBLE_ARR:\n                return in.readDoubleArray();\n\n            case TYPE_CHAR_ARR:\n                return in.readCharArray();\n\n            case TYPE_BOOLEAN_ARR:\n                return in.readBooleanArray();\n\n            case TYPE_OBJ_ARR:\n                return in.readArray(arrCompType);\n\n            case TYPE_STR:\n                return in.readString();\n\n            case TYPE_ENUM:\n                return enumVals[in.readInt()];\n\n            case TYPE_UUID:\n                return in.readUuid();\n\n            case TYPE_PROPS:\n                return in.readProperties();\n\n            case TYPE_ARRAY_LIST:\n                return in.readArrayList();\n\n            case TYPE_HASH_MAP:\n                return in.readHashMap(false);\n\n            case TYPE_HASH_SET:\n                return in.readHashSet(mapFieldOff);\n\n            case TYPE_LINKED_LIST:\n                return in.readLinkedList();\n\n            case TYPE_LINKED_HASH_MAP:\n                return in.readLinkedHashMap(false);\n\n            case TYPE_LINKED_HASH_SET:\n                return in.readLinkedHashSet(mapFieldOff);\n\n            case TYPE_DATE:\n                return in.readDate();\n\n            case TYPE_CLS:\n                return IgniteOptimizedClassResolver.readClass(in, in.classLoader()).describedClass();\n\n            case TYPE_EXTERNALIZABLE:\n                return in.readExternalizable(constructor, readResolveMtd);\n\n            case TYPE_SERIALIZABLE:\n                return in.readSerializable(cls, readObjMtds, readResolveMtd, fields);\n\n            default:\n                throw new IllegalStateException(\"Invalid class type: \" + type);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 656,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = ignite.streamer(\"priceBars\");\n\n                try {\n                    Collection<Bar> bars = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext, Collection<Bar>>() {\n                            @Override public Collection<Bar> apply(StreamerContext ctx) {\n                                Collection<Bar> values = ctx.<String, Bar>localSpace().values();\n\n                                Collection<Bar> res = new ArrayList<>(values.size());\n\n                                for (Bar bar : values)\n                                    res.add(bar.copy());\n\n                                return res;\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new IgniteReducer<Collection<Bar>, Collection<Bar>>() {\n                            private final Collection<Bar> res = new ArrayList<>();\n\n                            @Override public boolean collect(@Nullable Collection<Bar> col) {\n                                res.addAll(col);\n\n                                return true;\n                            }\n\n                            @Override public Collection<Bar> reduce() {\n                                return res;\n                            }\n                        }\n                    );\n\n                    for (Bar bar : bars)\n                        System.out.println(bar.toString());\n\n                    System.out.println(\"-----------------\");\n                }\n                catch (IgniteException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 2000, 2000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 657,
    "type": "Param",
    "comment": "@param parentId Parent file ID.",
    "code": "    private IgniteUuid putIfAbsentNonTx(IgniteUuid parentId, String fileName, IgfsFileInfo newFileInfo)\n        throws IgniteCheckedException {\n        if (log.isDebugEnabled())\n            log.debug(\"Locking parent id [parentId=\" + parentId + \", fileName=\" + fileName + \", newFileInfo=\" +\n                newFileInfo + ']');\n\n        assert validTxState(true);\n\n        // Lock only parent file ID.\n        IgfsFileInfo parentInfo = info(parentId);\n\n        if (parentInfo == null)\n            throw fsException(new IgfsPathNotFoundException(\"Failed to lock parent directory (not found): \" +\n                parentId));\n\n        if (!parentInfo.isDirectory())\n            throw fsException(new IgfsPathIsNotDirectoryException(\"Parent file is not a directory: \" + parentInfo));\n\n        Map<String, IgfsListingEntry> parentListing = parentInfo.listing();\n\n        assert parentListing != null;\n\n        IgfsListingEntry entry = parentListing.get(fileName);\n\n        if (entry != null)\n            return entry.fileId();\n\n        IgniteUuid fileId = newFileInfo.id();\n\n        if (!id2InfoPrj.putIfAbsent(fileId, newFileInfo))\n            throw fsException(\"Failed to add file details into cache: \" + newFileInfo);\n\n        assert metaCache.get(parentId) != null;\n\n        id2InfoPrj.invoke(parentId, new UpdateListing(fileName, new IgfsListingEntry(newFileInfo), false));\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 658,
    "type": "Param",
    "comment": "@param sUrl , input string",
    "code": "    public static String pamEncode(String stringToEncode) {\n        /* !'()*~ */\n\n        String encoded = urlEncode(stringToEncode);\n        if (encoded != null) {\n            encoded = encoded\n                    .replace(\"*\", \"%2A\")\n                    .replace(\"!\", \"%21\")\n                    .replace(\"'\", \"%27\")\n                    .replace(\"(\", \"%28\")\n                    .replace(\")\", \"%29\")\n                    .replace(\"[\", \"%5B\")\n                    .replace(\"]\", \"%5D\")\n                    .replace(\"~\", \"%7E\");\n        }\n        return encoded;\n    }\n",
    "label": 1,
    "rec": "@param stringToEncode , input string"
  },
  {
    "id": 659,
    "type": "Param",
    "comment": "@param offset offset for all units",
    "code": "    static double fromRelative(SVGLength length, double relative, double offset, double scale, double fontSize) {\n        /*\n            TODO list\n\n            unit  relative to\n            em    font size of the element\n            ex    x-height of the element\u00e2\u0080\u0099s font\n            ch    width of the \"0\" (ZERO, U+0030) glyph in the element\u00e2\u0080\u0099s font\n            rem   font size of the root element\n            vw    1% of viewport\u00e2\u0080\u0099s width\n            vh    1% of viewport\u00e2\u0080\u0099s height\n            vmin  1% of viewport\u00e2\u0080\u0099s smaller dimension\n            vmax  1% of viewport\u00e2\u0080\u0099s larger dimension\n\n            relative-size [ larger | smaller ]\n            absolute-size: [ xx-small | x-small | small | medium | large | x-large | xx-large ]\n\n            https://www.w3.org/TR/css3-values/#relative-lengths\n            https://www.w3.org/TR/css3-values/#absolute-lengths\n            https://drafts.csswg.org/css-cascade-4/#computed-value\n            https://drafts.csswg.org/css-fonts-3/#propdef-font-size\n            https://drafts.csswg.org/css2/fonts.html#propdef-font-size\n        */\n        SVGLengthUnitType unitType = length.unit;\n        double value = length.value;\n        double unit = 1;\n        switch (unitType) {\n            case SVG_LENGTHTYPE_NUMBER:\n            case SVG_LENGTHTYPE_PX:\n                break;\n\n            case SVG_LENGTHTYPE_PERCENTAGE:\n                return value / 100 * relative + offset;\n\n            case SVG_LENGTHTYPE_EMS:\n                unit = fontSize;\n                break;\n            case SVG_LENGTHTYPE_EXS:\n                unit = fontSize / 2;\n                break;\n\n            case SVG_LENGTHTYPE_CM:\n                unit = 35.43307;\n                break;\n            case SVG_LENGTHTYPE_MM:\n                unit = 3.543307;\n                break;\n            case SVG_LENGTHTYPE_IN:\n                unit = 90;\n                break;\n            case SVG_LENGTHTYPE_PT:\n                unit = 1.25;\n                break;\n            case SVG_LENGTHTYPE_PC:\n                unit = 15;\n                break;\n\n            default:\n            case SVG_LENGTHTYPE_UNKNOWN:\n                return value * scale + offset;\n        }\n        return value * unit * scale + offset;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 660,
    "type": "Param",
    "comment": "@param info the AuthenticationInfo of a newly authenticated subject/user.",
    "code": "    protected SecurityContext createSecurityContext(AuthenticationToken token, Account account) {\n        SecurityContextFactory factory = getSecurityContextFactory();\n        if (factory == null) {\n            throw new IllegalStateException(\n                \"No SecurityContextFactory class attribute has been set, so authentication cannot \" +\n                    \"be completed.  Make sure the init() method is being called on this \" +\n                    \"Authenticator before it is used.\");\n        }\n\n        return factory.createSecurityContext(token, account);\n    }\n",
    "label": 1,
    "rec": "@param account the Account of a newly authenticated subject/user."
  },
  {
    "id": 661,
    "type": "Param",
    "comment": "@param session",
    "code": "    public String delete(Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysSite site = siteComponent.getSite(request.getServerName());\n        if (CommonUtils.notEmpty(ids)) {\n            service.delete(ids);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.cmsDictionary\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), StringUtils.join(ids, CommonConstants.COMMA)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 662,
    "type": "Param",
    "comment": "@param strings",
    "code": "    public Long lpush(final String key, final String... string) {\n        checkIsInMulti();\n        client.lpush(key, string);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param string"
  },
  {
    "id": 663,
    "type": "Param",
    "comment": "@param getParameters",
    "code": "    private String createFetchUrl(String api, String method, Object... getParameters) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        ArrayList<Pair<String, Object>> params = new ArrayList<Pair<String, Object>>();\n        for(int i = 0; i < getParameters.length; i += 2) {\n            if(getParameters[i+1] instanceof ArrayList) {\n                ArrayList<?> list = (ArrayList<?>) getParameters[i+1];\n                for(int j = 0; j < list.size(); j++)\n                    params.add(new Pair<String, Object>(getParameters[i].toString() + \"[]\",\n                            list.get(j)));\n            } else\n                params.add(new Pair<String, Object>(getParameters[i].toString(), getParameters[i+1]));\n        }\n        params.add(new Pair<String, Object>(\"app_id\", APP_ID));\n        boolean syncMethod = \"synchronize\".equals(method);\n\n        if (!syncMethod)\n            params.add(new Pair<String, Object>(\"time\", System.currentTimeMillis() / 1000L));\n        if(token != null) {\n            boolean foundTokenKey = false;\n            for (Pair<String, Object> curr : params) {\n                if (curr.getLeft().equals(\"token\")) {\n                    foundTokenKey = true;\n                    break;\n                }\n            }\n            if (!foundTokenKey)\n                params.add(new Pair<String, Object>(\"token\", token));\n        }\n\n        Collections.sort(params, new Comparator<Pair<String, Object>>() {\n            @Override\n            public int compare(Pair<String, Object> object1,\n                    Pair<String, Object> object2) {\n                int result = object1.getLeft().compareTo(object2.getLeft());\n                if(result == 0)\n                    return object1.getRight().toString().compareTo(object2.getRight().toString());\n                return result;\n            }\n        });\n\n        String url = URL;\n        boolean customApi = false;\n        if (api != null) {\n            customApi = true;\n            url = url.replace(\"api\", api);\n        }\n        if (Preferences.getBoolean(R.string.actfm_https_key, false))\n            url = \"https:\" + url;\n        else\n            url = \"http:\" + url;\n\n        StringBuilder requestBuilder = new StringBuilder(url);\n        if (!customApi)\n            requestBuilder.append(API_VERSION).append(\"/\");\n        requestBuilder.append(method).append('?');\n        StringBuilder sigBuilder = new StringBuilder(method);\n        for(Pair<String, Object> entry : params) {\n            if(entry.getRight() == null)\n                continue;\n\n            String key = entry.getLeft();\n            String value = entry.getRight().toString();\n            String encoded = URLEncoder.encode(value, \"UTF-8\");\n\n            if (!syncMethod || \"app_id\".equals(key));\n                requestBuilder.append(key).append('=').append(encoded).append('&');\n\n            sigBuilder.append(key).append(value);\n        }\n\n        sigBuilder.append(APP_SECRET);\n        String signature = DigestUtils.md5Hex(sigBuilder.toString());\n        requestBuilder.append(\"sig\").append('=').append(signature);\n        return requestBuilder.toString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 664,
    "type": "Param",
    "comment": "@param gr The value $g^r$.",
    "code": "    public NaorPinkasShare getShare(BigInteger r, BigInteger gr) {\n        BigInteger x = schnorr.getFieldModP().pow(gr, pi);\n        return new NaorPinkasShare(t, r, i, x, schnorr);\n    }\n\n",
    "label": 1,
    "rec": "@param gr The $gr$ value."
  },
  {
    "id": 665,
    "type": "Param",
    "comment": "@param ver Version to use.",
    "code": "    @Override protected void clearIndex(CacheObject val, GridCacheVersion ver) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 666,
    "type": "Param",
    "comment": "@param padding the padding to adjust.",
    "code": "    public static Insets calculateRequiredNodeLabelSpace(final NodeAdapter<?> node,\n            final double labelSpacing, final Insets nodeLabelInsets,\n            final Map<LabelLocation, LabelGroup> labelGroupsBoundingBoxes, final Insets insets) {\n\n        // Check if there are any labels\n        if (!node.getLabels().iterator().hasNext()) {\n            return insets;\n        }\n        \n        // Retrieve the node's label placement policy\n        final Set<NodeLabelPlacement> nodeLabelPlacement = node.getProperty(CoreOptions.NODE_LABELS_PLACEMENT);\n        final LabelLocation nodeLabelLocation = LabelLocation.fromNodeLabelPlacement(nodeLabelPlacement);\n        \n        // Compute a bounding box for each location where labels should be placed.\n        // The size is calculated from the size of all labels stacked vertically at that location.\n        for (final LabelAdapter<?> label : node.getLabels()) {\n            LabelLocation labelPlacement =\n                    LabelLocation.fromNodeLabelPlacement(label.getProperty(CoreOptions.NODE_LABELS_PLACEMENT));\n            \n            // If no valid placement is set on the label, use the node's placement policy.\n            if (labelPlacement == LabelLocation.UNDEFINED) {\n                labelPlacement = nodeLabelLocation;\n            }\n            \n            // Save the location of this label in its id field for later use.\n            label.setVolatileId(labelPlacement.ordinal());\n            \n            // Create or retrieve the label group for the current label.\n            final Rectangle boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);\n            boundingBox.width = Math.max(boundingBox.width, label.getSize().x);\n            boundingBox.height += label.getSize().y + labelSpacing;\n        }\n        \n        // We need to count different label placement boxes towards different kinds of insets, depending on whether\n        // or not H_PRIORITY is set on the node itself (see H_PRIORITY documentation)\n        boolean hPrio = nodeLabelPlacement.contains(NodeLabelPlacement.H_PRIORITY);\n        \n        // Calculate the node label space required inside the node (only label groups on the inside\n        // are relevant here).\n        for (final Entry<LabelLocation, LabelGroup> entry : labelGroupsBoundingBoxes.entrySet()) {\n            final Rectangle boundingBox = entry.getValue();\n            \n            // From each existing label group, remove the last superfluous label spacing\n            // (the mere existence of a label group implies that it contains at least one label)\n            boundingBox.height -= labelSpacing;\n            switch (entry.getKey()) {\n            case IN_T_L:\n                if (hPrio) {\n                    insets.left = Math.max(\n                            insets.left,\n                            boundingBox.width + labelSpacing + nodeLabelInsets.left);\n                } else {\n                    insets.top = Math.max(\n                            insets.top,\n                            boundingBox.height + labelSpacing + nodeLabelInsets.top);\n                }\n                break;\n                \n            case IN_T_C:\n                insets.top = Math.max(\n                        insets.top,\n                        boundingBox.height + labelSpacing + nodeLabelInsets.top);\n                break;\n                \n            case IN_T_R:\n                if (hPrio) {\n                    insets.right = Math.max(\n                            insets.right,\n                            boundingBox.width + labelSpacing + nodeLabelInsets.right);\n                } else {\n                    insets.top = Math.max(\n                            insets.top,\n                            boundingBox.height + labelSpacing + nodeLabelInsets.top);\n                }\n                break;\n                \n            case IN_C_L:\n                insets.left = Math.max(\n                        insets.left,\n                        boundingBox.width + labelSpacing + nodeLabelInsets.left);\n                break;\n                \n            case IN_C_R:\n                insets.right = Math.max(\n                        insets.right,\n                        boundingBox.width + labelSpacing + nodeLabelInsets.right);\n                break;\n                \n            case IN_B_L:\n                if (hPrio) {\n                    insets.left = Math.max(\n                            insets.left,\n                            boundingBox.width + labelSpacing + nodeLabelInsets.left);\n                } else {\n                    insets.bottom = Math.max(\n                            insets.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelInsets.bottom);\n                }\n                break;\n                \n            case IN_B_C:\n                insets.bottom = Math.max(\n                        insets.bottom,\n                        boundingBox.height + labelSpacing + nodeLabelInsets.bottom);\n                break;\n                \n            case IN_B_R:\n                if (hPrio) {\n                    insets.right = Math.max(\n                            insets.right,\n                            boundingBox.width + labelSpacing + nodeLabelInsets.right);\n                } else {\n                    insets.bottom = Math.max(\n                            insets.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelInsets.bottom);\n                }\n                break;\n                \n            default:\n                // In all other cases, no specific action is required\n            }\n        }\n\n        // Add node label insets that aren't set yet\n        // This happens if e.g. a top inset is set but no top label is present\n        insets.top    = Math.max(insets.top, nodeLabelInsets.top);\n        insets.left   = Math.max(insets.left, nodeLabelInsets.left);\n        insets.right  = Math.max(insets.right, nodeLabelInsets.right);\n        insets.bottom = Math.max(insets.bottom, nodeLabelInsets.bottom);\n\n        return insets;\n    }\n\n",
    "label": 1,
    "rec": "@param insets the insets to adjust."
  },
  {
    "id": 667,
    "type": "Param",
    "comment": "@param expVer Optional version to match.",
    "code": "    @Override protected void clearIndex(CacheObject val) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 668,
    "type": "Param",
    "comment": "@param m Cache query metrics.",
    "code": "    public static VisorCacheQueryMetrics from(QueryMetrics m) {\n        VisorCacheQueryMetrics qm = new VisorCacheQueryMetrics();\n\n        qm.minTime = m.minimumTime();\n        qm.maxTime = m.maximumTime();\n        qm.avgTime = m.averageTime();\n        qm.execs = m.executions();\n        qm.fails = m.fails();\n\n        return qm;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 669,
    "type": "Param",
    "comment": "@param select",
    "code": "\tpublic List<String> getTableList(Update update) {\n\t\tinit();\n\t\ttables.add(update.getTable().getName());\n\t\tif (update.getExpressions() != null) {\n\t\t\tfor (Expression expression : update.getExpressions()) {\n\t\t\t\texpression.accept(this);\n\t\t\t}\n\t\t}\n\t\tif (update.getWhere() != null) {\n\t\t\tupdate.getWhere().accept(this);\n\t\t}\n\n\t\treturn tables;\n\t}\n",
    "label": 1,
    "rec": "@param update"
  },
  {
    "id": 670,
    "type": "Param",
    "comment": "@param path Path to update.",
    "code": "    public IgfsFileInfo updateDual(final IgfsSecondaryFileSystem fs, final IgfsPath path, final Map<String, String> props)\n        throws IgniteCheckedException {\n        assert fs != null;\n        assert path != null;\n        assert props != null && !props.isEmpty();\n\n        if (busyLock.enterBusy()) {\n            try {\n                SynchronizationTask<IgfsFileInfo> task = new SynchronizationTask<IgfsFileInfo>() {\n                    @Override public IgfsFileInfo onSuccess(Map<IgfsPath, IgfsFileInfo> infos)\n                        throws Exception {\n                        if (infos.get(path) == null)\n                            return null;\n\n                        fs.update(path, props);\n\n                        assert path.parent() == null || infos.get(path.parent()) != null;\n\n                        return updatePropertiesNonTx(infos.get(path.parent()).id(), infos.get(path).id(), path.name(),\n                            props);\n                    }\n\n                    @Override public IgfsFileInfo onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path update in DUAL mode failed [path=\" + path + \", properties=\" + props + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to update the path due to secondary file system exception: \" +\n                            path, err);\n                    }\n                };\n\n                return synchronizeAndExecute(task, fs, false, path);\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to update in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 671,
    "type": "Param",
    "comment": "@param subscriptionId the user-specified identifier for the pubsub subscription",
    "code": "  public static int pubSub(String subId, int timeout, String projectId) throws Exception {\n    Subscriber subscriber = null;\n    MessageReceiverExample receiver = new MessageReceiverExample();\n\n    try {\n      // subscribe to the requested pubsub channel\n      ProjectSubscriptionName subName = ProjectSubscriptionName.of(projectId, subId);\n      subscriber = Subscriber.newBuilder(subName, receiver).build();\n      subscriber.startAsync().awaitRunning();\n      // listen to messages for 'timeout' seconds\n      for (int i = 0; i < timeout; i++) {\n        sleep(1000);\n      }\n    } finally {\n      // stop listening to the channel\n      if (subscriber != null) {\n        subscriber.stopAsync();\n      }\n    }\n    //print and return the number of pubsub messages received\n    System.out.println(receiver.messageCount);\n    return receiver.messageCount;\n  }\n",
    "label": 1,
    "rec": "@param subId the user-specified identifier for the pubsub subscription"
  },
  {
    "id": 672,
    "type": "Param",
    "comment": "@param sample Sample size.",
    "code": "    public static VisorCache from(Ignite ignite, String cacheName, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && ca.context().affinityNode();\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(AffinityTopologyVersion.NONE)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 673,
    "type": "Param",
    "comment": "@param accountManager",
    "code": "    public static Account getAccount(final AccountManager manager, final Activity activity) {\n        final boolean loggable = Log.isLoggable(TAG, DEBUG);\n        if (loggable)\n            Log.d(TAG, \"Getting account\");\n\n        if (activity == null)\n            throw new RuntimeException(\"Can't create new GitHub account - no activity available\");\n\n        Account[] accounts;\n        try {\n            while ((accounts = getAccounts(manager)).length == 0) {\n                if (loggable)\n                    Log.d(TAG, \"No GitHub accounts for activity=\" + activity);\n\n                Bundle result = manager.addAccount(GITHUB_ACCOUNT_TYPE, null, null, null, activity, null, null)\n                        .getResult();\n\n                if (loggable)\n                    Log.d(TAG, \"Added account \" + result.getString(KEY_ACCOUNT_NAME));\n            }\n        } catch (AuthenticatorException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        } catch (OperationCanceledException e) {\n            Log.d(TAG, \"Excepting retrieving account\", e);\n            throw new RuntimeException(e);\n        }\n\n        if (loggable)\n            Log.d(TAG, \"Returning account \" + accounts[0].name);\n\n        return accounts[0];\n    }\n",
    "label": 1,
    "rec": "@param manager"
  },
  {
    "id": 674,
    "type": "Param",
    "comment": "@param log Grid logger.",
    "code": "    private IgniteConfiguration getConfiguration(IgniteLogger log) {\n        // We can't use U.getGridGainHome() here because\n        // it will initialize cached value which is forbidden to override.\n        String ggHome = GridSystemProperties.getString(GG_HOME);\n\n        assert ggHome != null;\n\n        U.setGridGainHome(null);\n\n        String ggHome0 = U.getGridGainHome();\n\n        assert ggHome0 == null;\n\n        GridTcpDiscoverySpi disc = new GridTcpDiscoverySpi();\n\n        disc.setIpFinder(IP_FINDER);\n\n        IgniteConfiguration cfg = new IgniteConfiguration();\n\n        cfg.setGridLogger(log);\n        cfg.setDiscoverySpi(disc);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 675,
    "type": "Param",
    "comment": "@param item the item associated with the thermostat(s) against which to perform the function.",
    "code": "    private static boolean callEcobeeInternal(String selection, AbstractFunction function) {\n        try {\n            logger.debug(\"Attempting to call Ecobee function '{}' against selection '{}'\", function, selection);\n\n            EcobeeActionProvider actionProvider = getActionProvider(selection);\n\n            return actionProvider.callEcobee(selection, function);\n        } catch (Exception ex) {\n            logger.error(ex.getMessage(), ex);\n            return false;\n        }\n    }\n",
    "label": 1,
    "rec": "@param selection the selection of thermostat(s) against which to perform the function."
  },
  {
    "id": 676,
    "type": "Param",
    "comment": "@param sourceFilename the C++ source filename",
    "code": "    int compile(String[] sourceFilenames, String outputFilename, ClassProperties properties, File workingDirectory)\n            throws IOException, InterruptedException {\n        ArrayList<String> command = new ArrayList<String>();\n\n        includeJavaPaths(properties, header);\n\n        String platform  = Loader.getPlatform();\n        String compilerPath = properties.getProperty(\"platform.compiler\");\n        command.add(compilerPath);\n\n        {\n            String p = properties.getProperty(\"platform.sysroot.prefix\", \"\");\n            for (String s : properties.get(\"platform.sysroot\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.includepath.prefix\", \"\");\n            for (String s : properties.get(\"platform.includepath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n            for (String s : properties.get(\"platform.includeresource\")) {\n                for (File f : Loader.cacheResources(s)) {\n                    if (f.isDirectory()) {\n                        if (p.endsWith(\" \")) {\n                            command.add(p.trim()); command.add(f.getCanonicalPath());\n                        } else {\n                            command.add(p + f.getCanonicalPath());\n                        }\n                    }\n                }\n            }\n        }\n\n        for (String sourceFilename : sourceFilenames) {\n            command.add(sourceFilename);\n        }\n\n        List<String> allOptions = properties.get(\"platform.compiler.*\");\n        if (!allOptions.contains(\"!default\") && !allOptions.contains(\"default\")) {\n            allOptions.add(0, \"default\");\n        }\n        for (String s : allOptions) {\n            if (s == null || s.length() == 0) {\n                continue;\n            }\n            String p = \"platform.compiler.\" + s;\n            String options = properties.getProperty(p);\n            if (options != null && options.length() > 0) {\n                command.addAll(Arrays.asList(options.split(\" \")));\n            } else if (!\"!default\".equals(s) && !\"default\".equals(s)) {\n                logger.warn(\"Could not get the property named \\\"\" + p + \"\\\"\");\n            }\n        }\n\n        command.addAll(compilerOptions);\n\n        String output = properties.getProperty(\"platform.compiler.output\");\n        for (int i = 1; i < 2 || output != null; i++,\n                output = properties.getProperty(\"platform.compiler.output\" + i)) {\n            if (output != null && output.length() > 0) {\n                command.addAll(Arrays.asList(output.split(\" \")));\n            }\n\n            if (output == null || output.length() == 0 || output.endsWith(\" \")) {\n                command.add(outputFilename);\n            } else {\n                command.add(command.remove(command.size() - 1) + outputFilename);\n            }\n        }\n\n        {\n            String p  = properties.getProperty(\"platform.linkpath.prefix\", \"\");\n            String p2 = properties.getProperty(\"platform.linkpath.prefix2\");\n            for (String s : properties.get(\"platform.linkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                    if (p2 != null) {\n                        if (p2.endsWith(\" \")) {\n                            command.add(p2.trim()); command.add(s);\n                        } else {\n                            command.add(p2 + s);\n                        }\n                    }\n                }\n            }\n            for (String s : properties.get(\"platform.linkresource\")) {\n                for (File f : Loader.cacheResources(s)) {\n                    if (f.isDirectory()) {\n                        if (p.endsWith(\" \")) {\n                            command.add(p.trim()); command.add(f.getCanonicalPath());\n                        } else {\n                            command.add(p + f.getCanonicalPath());\n                        }\n                        if (p2 != null) {\n                            if (p2.endsWith(\" \")) {\n                                command.add(p2.trim()); command.add(f.getCanonicalPath());\n                            } else {\n                                command.add(p2 + f.getCanonicalPath());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.link.prefix\", \"\");\n            String x = properties.getProperty(\"platform.link.suffix\", \"\");\n            int i = command.size(); // to inverse order and satisfy typical compilers\n            for (String s : properties.get(\"platform.link\")) {\n                String[] libnameversion = s.split(\"#\")[0].split(\"@\");\n                if (libnameversion.length == 3 && libnameversion[1].length() == 0) {\n                    // Only use the version number when the user gave us a double @\n                    s = libnameversion[0] + libnameversion[2];\n                } else {\n                    s = libnameversion[0];\n                }\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s); command.add(i + 2, x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(i, p + s); command.add(i + 1, x.trim());\n                } else {\n                    command.add(i, p + s + x);\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.frameworkpath.prefix\", \"\");\n            for (String s : properties.get(\"platform.frameworkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.framework.prefix\", \"\");\n            String x = properties.getProperty(\"platform.framework.suffix\", \"\");\n            for (String s : properties.get(\"platform.framework\")) {\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(p.trim()); command.add(s); command.add(x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(p.trim()); command.add(s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(p + s); command.add(x.trim());\n                } else {\n                    command.add(p + s + x);\n                }\n            }\n        }\n\n        String text = \"\";\n        boolean windows = platform.startsWith(\"windows\");\n        for (String s : command) {\n            boolean hasSpaces = s.indexOf(\" \") > 0;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += s;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += \" \";\n        }\n        logger.info(text);\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        // Use the library output path as the working directory so that all\n        // build files, including intermediate ones from MSVC, are dumped there\n        pb.directory(workingDirectory);\n        if (environmentVariables != null) {\n            pb.environment().putAll(environmentVariables);\n        }\n        return pb.inheritIO().start().waitFor();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 677,
    "type": "Param",
    "comment": "@param userVersion Version to create.",
    "code": "    private String makeUserVersion(String userVer) {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \" +\n            \"<beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" \" +\n            \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" +\n            \"xmlns:util=\\\"http://www.springframework.org/schema/util\\\" \" +\n            \"xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd \" +\n            \"http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> \" +\n            \"<bean id=\\\"userVersion\\\" class=\\\"java.lang.String\\\"><constructor-arg value=\\\"\" + userVer + \"\\\"/></bean> \" +\n            \"</beans>\";\n    }\n",
    "label": 1,
    "rec": "@param userVer Version to create."
  },
  {
    "id": 678,
    "type": "Param",
    "comment": "@param single_node_mode whether or not the single node mode is enabled",
    "code": "  private static long computeTrainSamplesPerIteration(final long train_samples_per_iteration, final long numRows, final boolean replicate_training_data, final boolean single_node_mode, final boolean quiet_mode) {\n    long tspi = train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi >= 1);\n    if (tspi == 0 || (!replicate_training_data && tspi == -1) ) {\n      tspi = numRows;\n      if (!quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n    }\n    else if (tspi == -1) {\n      tspi = H2O.CLOUD.size() * numRows;\n      if (!quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n    }\n    assert(tspi != 0 && tspi != -1 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 679,
    "type": "Param",
    "comment": "@param matchedHashes A list which will contain the matched txn (will be cleared)",
    "code": "    public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashes) throws VerificationException {\n        matchedHashes.clear();\n        \n        // An empty set will not work\n        if (transactionCount == 0)\n            throw new VerificationException(\"Got a CPartialMerkleTree with 0 transactions\");\n        // check for excessively high numbers of transactions\n        if (transactionCount > Block.MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n            throw new VerificationException(\"Got a CPartialMerkleTree with more transactions than is possible\");\n        // there can never be more hashes provided than one for every txid\n        if (hashes.size() > transactionCount)\n            throw new VerificationException(\"Got a CPartialMerkleTree with more hashes than transactions\");\n        // there must be at least one bit per node in the partial tree, and at least one node per hash\n        if (matchedChildBits.length*8 < hashes.size())\n            throw new VerificationException(\"Got a CPartialMerkleTree with fewer matched bits than hashes\");\n        // calculate height of tree\n        int height = 0;\n        while (getTreeWidth(height) > 1)\n            height++;\n        // traverse the partial tree\n        ValuesUsed used = new ValuesUsed();\n        Sha256Hash merkleRoot = recursiveExtractHashes(height, 0, used, matchedHashes);\n        // verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)\n        if ((used.bitsUsed+7)/8 != matchedChildBits.length ||\n                // verify that all hashes were consumed\n                used.hashesUsed != hashes.size())\n            throw new VerificationException(\"Got a CPartialMerkleTree that didn't need all the data it provided\");\n        \n        return merkleRoot;\n    }\n",
    "label": 1,
    "rec": "@param matchedHashes A list which will contain the matched txn (will be cleared) Required to be a LinkedHashSet in order to retain order or transactions in the block"
  },
  {
    "id": 680,
    "type": "Param",
    "comment": "@param maxCount maximum reasonable number of modules that should be observed in any reading state, based on the results of the horizontal scan",
    "code": "  private float crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal) {\n    MonochromeBitmapSource image = this.image;\n\n    int maxI = image.getHeight();\n    int[] stateCount = new int[5];\n\n    // Start counting up from center\n    int i = startI;\n    while (i >= 0 && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i--;\n    }\n    if (i < 0) {\n      return Float.NaN;\n    }\n    while (i >= 0 && !image.isBlack(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return Float.NaN;\n    }\n    while (i >= 0 && image.isBlack(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return Float.NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i++;\n    }\n    if (i == maxI) {\n      return Float.NaN;\n    }\n    while (i < maxI && !image.isBlack(centerJ, i) && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      i++;\n    }\n    if (i == maxI || stateCount[3] >= maxCount) {\n      return Float.NaN;\n    }\n    while (i < maxI && image.isBlack(centerJ, i) && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      i++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return Float.NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is more than 20% different than\n    // the original, assume it's a false positive\n    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n      return Float.NaN;\n    }\n\n    return foundPatternCross(stateCount) ? centerFromEnd(stateCount, i) : Float.NaN;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 681,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public GridCacheEntryEx entryEx(KeyCacheObject key, boolean touch) {\n        GridCacheEntryEx e = entry0(key, ctx.affinity().affinityTopologyVersion(), true, touch);\n\n        assert e != null;\n\n        return e;\n    }\n",
    "label": 1,
    "rec": "@param key Entry key."
  },
  {
    "id": 682,
    "type": "Param",
    "comment": "@param p Filter for IDs.",
    "code": "    public Collection<ClusterNode> nodes(@Nullable Collection<UUID> ids, IgnitePredicate<UUID>... p) {\n        return F.isEmpty(ids) ? Collections.<ClusterNode>emptyList() :\n            F.view(\n                F.viewReadOnly(ids, U.id2Node(ctx), p),\n                F.notNull());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 683,
    "type": "Param",
    "comment": "@param timeout the timeout to set in milliseconds",
    "code": "\tprotected String sendQuery(String query)\n\t\t\tthrows IhcExecption {\n\t\t\n\t\tconn.setReadTimeout(timeout);\n\n\t\ttry {\n\t\t\tOutputStreamWriter writer = new OutputStreamWriter(\n\t\t\t\t\tconn.getOutputStream(), \"UTF-8\");\n\n\t\t\tlogger.trace(\"Send query: {}\", query);\n\t\t\twriter.write(query);\n\t\t\twriter.flush();\n\t\t\twriter.close();\n\t\n\t\t\tInputStreamReader reader = new InputStreamReader(conn.getInputStream(),\n\t\t\t\t\t\"UTF-8\");\n\t\t\tString response = readInputStreamAsString(reader);\n\t\t\tlogger.trace(\"Receive response: {}\", response);\n\t\t\treturn response;\n\t\t\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new IhcExecption(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new IhcExecption(e);\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param timeoutInMilliseconds Timeout in milliseconds to wait response."
  },
  {
    "id": 684,
    "type": "Param",
    "comment": "@param node",
    "code": "    private double q(int node, Community community) {\n\n        Integer edgesToInt = structure.nodeConnections[node].get(community);\n        double edgesTo = 0;\n        if (edgesToInt != null) {\n            edgesTo = edgesToInt.doubleValue();\n        }\n        double weightSum = community.weightSum;\n        double nodeWeight = structure.weights[node];\n        //double penalty = (nodeWeight * weightSum) / (2.0 * mStructure.graphWeightSum);\n        double qValue = edgesTo - (nodeWeight * weightSum) / (2.0 * structure.graphWeightSum);\n        if ((structure.nodeCommunities[node] == community) && (structure.nodeCommunities[node].size() > 1)) {\n            qValue = edgesTo - (nodeWeight * (weightSum - nodeWeight)) / (2.0 * structure.graphWeightSum);\n        }\n        return qValue;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 685,
    "type": "Param",
    "comment": "@param adaptedValidation a test frame or null",
    "code": "    public Score doIt(Model model, Frame fr, Frame adaptedValidation, Vec adaptedValidationResponse, int[][] modelTransf, String[] cmDomain, boolean oob, boolean build_tree_per_node) {\n      assert !oob || adaptedValidation==null : \"Validation frame cannot be specified if oob validation is demanded!\"; // oob => validation==null\n      assert _nclass == 1 || cmDomain != null ;\n\n      System.err.println(\"CM domain: \" + Arrays.toString(cmDomain));\n\n      _cmlen = _nclass > 1 ? cmDomain.length : 1;\n      _oob = oob;\n      // No validation frame is specified, so perform computation on training data\n      if( adaptedValidation == null ) return doAll(fr, build_tree_per_node);\n      _validation = true;\n      _cavr       = false;\n      // Validation: need to score the set, getting a probability distribution for each class\n      // Frame has nclass vectors (nclass, or 1 for regression), for classification it\n      Frame res = model.score(adaptedValidation, false); // For classification: predicted values (~ values in res[0]) are in interval 0..domain().length-1, for regression just single column.\n      Frame adapValidation = new Frame(adaptedValidation); // adapted validation dataset\n      // All columns including response of validation frame are already adapted to model\n      if (_nclass>1) { // Only for Classification\n        for( int i=0; i<_nclass; i++ ) // Distribution of response classes\n          adapValidation.add(\"ClassDist\"+i,res.vecs()[i+1]);\n        if (modelTransf!=null) {\n          Vec ar = res.vecs()[0].makeTransf(modelTransf); // perform transformation of model results to be consistent with expected confusion matrix domain\n          adapValidation.add(\"Prediction\", ar); // add as a prediction\n          adapValidation.add(\"ActualValidationResponse\", adaptedValidationResponse);\n          _cavr = true; // signal that we have two predictions vectors in the frame.\n          res.add(\"__dummyx__\", ar); // add the vector to clean up list\n        } else\n          adapValidation.add(\"Prediction\",res.vecs()[0]); // Predicted values\n      } else { // Regression\n        adapValidation.add(\"Prediction\",res.vecs()[0]);\n      }\n      // Compute a CM & MSE\n      try {\n        doAll(adapValidation, build_tree_per_node);\n      } finally {\n        // Perform clean-up: remove temporary result\n        res.delete();\n      }\n      return this;\n    }\n",
    "label": 1,
    "rec": "@param adaptedValidation a test frame or null, the test frame is already adapted to a model"
  },
  {
    "id": 686,
    "type": "Param",
    "comment": "@param idTask",
    "code": "    public JSONArray tasksLabels(long idTask) throws ApiServiceException, IOException {\n        return getResponse(invokeGet(\"tasks/labels.json\",\n                \"token\", token,\n                \"id_task\", idTask), \"labels\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 687,
    "type": "Param",
    "comment": "@param requestObj",
    "code": "\tprivate JsonObject toJsonFromRequestObj(UserInfo ui, Set<String> scope, JsonObject authorizedClaims, JsonObject requestedClaims) {\n\n\t\t// get the base object\n\t\tJsonObject obj = toJson(ui, scope);\n\n\t\tJsonObject userinfoAuthorized = authorizedClaims.getAsJsonObject().get(\"userinfo\").getAsJsonObject();\n\t\tJsonObject userinfoRequested = requestedClaims.getAsJsonObject().get(\"userinfo\").getAsJsonObject();\n\t\t\n\t\tif (userinfoAuthorized == null || !userinfoAuthorized.isJsonObject()) {\n\t\t\treturn obj;\n\t\t}\n\n\t\t\n\t\t// Filter claims from the request object with the claims from the claims request parameter, if it exists\n\t\t\n\t\t// Doing the set intersection manually because the claim entries may be referring to\n\t\t// the same claim but have different 'individual claim values', causing the Entry<> to be unequal, \n\t\t// which doesn't allow the use of the more compact Sets.intersection() type method.\n\t\tSet<Entry<String, JsonElement>> requestClaimsSet = Sets.newHashSet();\n\t\tif (requestedClaims != null) {\n\t\t\t\n\t\t\tfor (Entry<String, JsonElement> entry : userinfoAuthorized.getAsJsonObject().entrySet()) {\n\t\t\t\tif (userinfoRequested.has(entry.getKey())) {\n\t\t\t\t\trequestClaimsSet.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// TODO: this method is likely to be fragile if the data model changes at all\n\n\t\t//For each claim found, add it if not already present\n\t\tfor (Entry<String, JsonElement> i : requestClaimsSet) {\n\t\t\tString claimName = i.getKey();\n\t\t\tif (!obj.has(claimName)) {\n\t\t\t\tString value = \"\";\n\n\n\t\t\t\t//Process claim names to go from \"claim_name\" to \"ClaimName\"\n\t\t\t\tString camelClaimName = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, claimName);\n\t\t\t\t//Now we have \"getClaimName\"\n\t\t\t\tString methodName = \"get\" + camelClaimName;\n\t\t\t\tMethod getter = null;\n\t\t\t\ttry {\n\t\t\t\t\tgetter = ui.getClass().getMethod(methodName);\n\t\t\t\t\tvalue = (String) getter.invoke(ui);\n\t\t\t\t\tobj.addProperty(claimName, value);\n\t\t\t\t} catch (SecurityException e) {\n\t\t\t\t\tlogger.error(\"SecurityException in UserInfoView.java: \", e);\n\t\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t\tlogger.error(\"NoSuchMethodException in UserInfoView.java: \", e);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tlogger.error(\"IllegalArgumentException in UserInfoView.java: \", e);\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tlogger.error(\"IllegalAccessException in UserInfoView.java: \", e);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tlogger.error(\"InvocationTargetException in UserInfoView.java: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn obj;\n\n\t}\n",
    "label": 1,
    "rec": "@param authorizedClaims"
  },
  {
    "id": 688,
    "type": "Param",
    "comment": "@param entry Entry.",
    "code": "    private int extrasSize(CacheEntry entry) throws Exception {\n        Method mthd = GridCacheMapEntry.class.getDeclaredMethod(\"extrasSize\");\n\n        mthd.setAccessible(true);\n\n        GridCacheContext ctx = U.field(entry, \"ctx\");\n\n        GridCacheEntryEx entry0 = ((GridCacheEntryImpl)entry).entryEx(false, ctx.discovery().topologyVersion());\n\n        return (Integer)mthd.invoke(entry0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 689,
    "type": "Param",
    "comment": "@param nt1 a node type",
    "code": "    public float getHorizontalSpacing(final NodeType t1, final NodeType t2) {\n        return nodeTypeSpacings[t1.ordinal()][t2.ordinal()];\n    }\n\n",
    "label": 1,
    "rec": "@param t1 the type of one node"
  },
  {
    "id": 690,
    "type": "Param",
    "comment": "@param item item model",
    "code": "    public boolean saveExisting(TYPE item) {\n        ContentValues values = item.getSetValues();\n        if(values.size() == 0) // nothing changed\n            return true;\n        return database.getDatabase().update(table.name, values,\n                AbstractModel.ID_PROPERTY.eq(item.getId()).toString(), null) > 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 691,
    "type": "Param",
    "comment": "@param methodInvocation the method invocation that the remote invocation should be based on.",
    "code": "    public RemoteInvocation createRemoteInvocation(MethodInvocation mi) {\n\n        Serializable sessionId = null;\n        InetAddress inet = null;\n        boolean sessionManagerMethodInvocation = false;\n\n        //If the calling MI is for a remoting SessionManager proxy, we need to acquire the session ID from the method\n        //argument and NOT interact with SecurityUtils/subject.getSession to avoid a stack overflow\n        if (SessionManager.class.equals(mi.getMethod().getDeclaringClass())) {\n            sessionManagerMethodInvocation = true;\n            //for SessionManager calls, all method calls require the session id as the first argument, with\n            //the exception of 'start' that takes in an InetAddress.  So, ignore that one case:\n            Object firstArg = mi.getArguments()[0];\n            if (!(firstArg instanceof InetAddress)) {\n                sessionId = (Serializable) firstArg;\n            }\n        }\n\n        //tried the proxy.  If sessionId is still null, only then try the Subject:\n        if (sessionId == null && !sessionManagerMethodInvocation) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession(false);\n            if (session != null) {\n                inet = session.getHostAddress();                \n                sessionId = session.getId();\n            }\n        }\n\n        //No call to the sessionManager, and the Subject doesn't have a session.  Try a system property\n        //as a last result:\n        if (sessionId == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No Session found for the currently executing subject via subject.getSession(false).  \" +\n                    \"Attempting to revert back to the 'ki.session.id' system property...\");\n            }\n            sessionId = System.getProperty(SESSION_ID_SYSTEM_PROPERTY_NAME);\n            if (sessionId == null && log.isTraceEnabled()) {\n                log.trace(\"No 'ki.session.id' system property found.  Heuristics have been exhausted; \" +\n                    \"RemoteInvocation will not contain a sessionId.\");\n            }\n        }\n\n        if ( inet == null ) {\n            //try thread context:\n            inet = ThreadContext.getInetAddress();\n        }\n\n        RemoteInvocation ri = new RemoteInvocation(mi);\n        if (sessionId != null) {\n            ri.addAttribute(SESSION_ID_KEY, sessionId);\n        }\n        if ( inet != null ) {\n            ri.addAttribute(INET_ADDRESS_KEY, inet);\n        }\n\n        return ri;\n    }\n",
    "label": 1,
    "rec": "@param mi the method invocation that the remote invocation should be based on."
  },
  {
    "id": 692,
    "type": "Param",
    "comment": "@param measures the performance measures of classification.",
    "code": "    public double[][] test(DataFrame x, int[] y, ClassificationMeasure[] measures) {\n        int T = trees.length;\n        int m = measures.length;\n        double[][] results = new double[T][m];\n\n        int n = x.size();\n        int[] label = new int[n];\n\n        if (k == 2) {\n            double[] prediction = new double[n];\n            for (int i = 0; i < T; i++) {\n                for (int j = 0; j < n; j++) {\n                    prediction[j] += alpha[i] * trees[i].predict(x.get(j));\n                    label[j] = prediction[j] > 0 ? 1 : 0;\n                }\n\n                for (int j = 0; j < m; j++) {\n                    results[i][j] = measures[j].measure(y, label);\n                }\n            }\n        } else {\n            double[][] prediction = new double[n][k];\n            for (int i = 0; i < T; i++) {\n                for (int j = 0; j < n; j++) {\n                    prediction[j][trees[i].predict(x.get(j))] += alpha[i];\n                    label[j] = MathEx.whichMax(prediction[j]);\n                }\n\n                for (int j = 0; j < m; j++) {\n                    results[i][j] = measures[j].measure(y, label);\n                }\n            }\n\n        }\n        \n        return results;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 693,
    "type": "Param",
    "comment": "@param plainText The text to encrypt",
    "code": "\tpublic static String encrypt(@Nonnull final byte[] plainTextAsBytes, @Nonnull final char[] password) throws IOException\n\t{\n\t\tfinal byte[] encryptedBytes = encryptRaw(plainTextAsBytes, password);\n\n\t\t// OpenSSL prefixes the salt bytes + encryptedBytes with Salted___ and then base64 encodes it\n\t\tfinal byte[] encryptedBytesPlusSaltedText = concat(OPENSSL_SALTED_BYTES, encryptedBytes);\n\n\t\treturn BASE64.encode(encryptedBytesPlusSaltedText);\n\t}\n",
    "label": 1,
    "rec": "@param plainTextAsBytes The bytes to encrypt"
  },
  {
    "id": 694,
    "type": "Param",
    "comment": "@param tx Cache transaction.",
    "code": "    public boolean putAllToStore(@Nullable IgniteTx tx, Map<K, IgniteBiTuple<V, GridCacheVersion>> map)\n        throws IgniteCheckedException {\n        if (F.isEmpty(map))\n            return true;\n\n        if (map.size() == 1) {\n            Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e = map.entrySet().iterator().next();\n\n            return putToStore(tx, e.getKey(), e.getValue().get1(), e.getValue().get2());\n        }\n        else {\n            if (store != null) {\n                Map<K, IgniteBiTuple<V, GridCacheVersion>> map0;\n\n                if (convertPortable) {\n                    map0 = U.newHashMap(map.size());\n\n                    for (Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e : map.entrySet()) {\n                        IgniteBiTuple<V, GridCacheVersion> t = e.getValue();\n\n                        map0.put((K)cctx.unwrapPortableIfNeeded(e.getKey(), false),\n                            F.t((V)cctx.unwrapPortableIfNeeded(t.get1(), false), t.get2()));\n                    }\n                }\n                else\n                    map0 = map;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Storing values in cache store [map=\" + map0 + ']');\n\n                try {\n                    store.putAll(tx, locStore ? map0 : F.viewReadOnly(map0,\n                        new C1<IgniteBiTuple<V, GridCacheVersion>, Object>() {\n                            @Override public Object apply(IgniteBiTuple<V, GridCacheVersion> t) {\n                                return t.get1();\n                            }\n                    }));\n                }\n                catch (ClassCastException e) {\n                    handleClassCastException(e);\n                }\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Stored value in cache store [map=\" + map0 + ']');\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 695,
    "type": "Param",
    "comment": "@param principal the primary identifying principal of the Account that should be retrieved.",
    "code": "    protected Account getAccount(PrincipalCollection principals) {\n\n        if (principals == null) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving Account for principals [\" + principals + \"]\");\n        }\n\n        Cache accountCache = getAccountCache();\n        if (accountCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the Account from cache.\");\n            }\n            account = (Account) accountCache.get(principals);\n            if (log.isTraceEnabled()) {\n                if (account == null) {\n                    log.trace(\"No Account found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"Account found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principals);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principals + \"].\");\n                }\n                accountCache.put(principals, account);\n            }\n        }\n\n        return account;\n    }\n",
    "label": 1,
    "rec": "@param principals the primary identifying principals of the Account that should be retrieved."
  },
  {
    "id": 696,
    "type": "Param",
    "comment": "@param metrics Metrics.",
    "code": "    private static byte[] serializeMetrics(UUID nodeId, ClusterNodeMetrics metrics) {\n        assert nodeId != null;\n        assert metrics != null;\n\n        byte[] buf = new byte[16 + GridDiscoveryMetricsHelper.METRICS_SIZE];\n\n        U.longToBytes(nodeId.getMostSignificantBits(), buf, 0);\n        U.longToBytes(nodeId.getLeastSignificantBits(), buf, 8);\n\n        serialize(buf, 16, metrics);\n\n        return buf;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 697,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = ignite.streamer(\"popular-numbers\");\n\n                try {\n                    // Send reduce query to all 'popular-numbers' streamers\n                    // running on local and remote nodes.\n                    Collection<StreamerIndexEntry<Integer, Integer, Long>> col = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext,\n                                                                            Collection<StreamerIndexEntry<Integer, Integer, Long>>>() {\n                            @Override public Collection<StreamerIndexEntry<Integer, Integer, Long>> apply(\n                                StreamerContext ctx) {\n                                StreamerIndex<Integer, Integer, Long> view = ctx.<Integer>window().index();\n\n                                return view.entries(-1 * POPULAR_NUMBERS_CNT);\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new PopularNumbersReducer());\n\n                    for (StreamerIndexEntry<Integer, Integer, Long> cntr : col)\n                        System.out.printf(\"%3d=%d\\n\", cntr.key(), cntr.value());\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 698,
    "type": "Param",
    "comment": "@param chol",
    "code": "  public Cholesky cholesky(Cholesky chol, int parallelize) {\n    long start = System.currentTimeMillis();\n    if( chol == null ) {\n      double[][] xx = _xx.clone();\n      for( int i = 0; i < xx.length; ++i )\n        xx[i] = xx[i].clone();\n      chol = new Cholesky(xx, _diag.clone());\n    }\n    final Cholesky fchol = chol;\n    final int sparseN = _diag.length;\n    final int denseN = _fullN - sparseN;\n    boolean spd=true;\n    // compute the cholesky of the diagonal and diagonal*dense parts\n    if( _diag != null ) for( int i = 0; i < sparseN; ++i ) {\n      double d = 1.0 / (chol._diag[i] = Math.sqrt(_diag[i]));\n      for( int j = 0; j < denseN; ++j )\n        chol._xx[j][i] = d*_xx[j][i];\n    }\n    Futures fs = new Futures();\n    // compute the outer product of diagonal*dense\n    final int chk = Math.max(denseN/10, 1); \n    Log.info(\"SPARSEN = \" + sparseN + \"    DENSEN = \" + denseN);\n\n    for( int i = 0; i < denseN; ++i ) {\n      final int fi = i;\n      fs.add(new RecursiveAction() {\n          @Override protected void compute() {\n            for( int j = 0; j <= fi; ++j ) {\n              double s = 0;\n              for( int k = 0; k < sparseN; ++k )\n                s += fchol._xx[fi][k] * fchol._xx[j][k];\n                 fchol._xx[fi][j + sparseN] = _xx[fi][j + sparseN] - s;\n            }\n          }\n        }.fork());\n    }\n    fs.blockForPending();\n    // compute the cholesky of dense*dense-outer_product(diagonal*dense)\n    // TODO we still use Jama, which requires (among other things) copy and expansion of the matrix. Do it here without copy and faster.\n    double[][] arr = new double[denseN][];\n    for( int i = 0; i < arr.length; ++i )\n      arr[i] = Arrays.copyOfRange(fchol._xx[i], sparseN, sparseN + denseN);\n\n    Log.info (\"CHOLESKY PRECOMPUTE TIME \" + (System.currentTimeMillis()-start));\n    start = System.currentTimeMillis();\n    // parallelize cholesky\n    if (parallelize == 1) {\n      int p = Runtime.getRuntime().availableProcessors();\n      InPlaceCholesky d = InPlaceCholesky.decompose_2(arr, 10, p);\n      fchol.setSPD(d.isSPD());\n      arr = d.getL();\n      Log.info (\"H2O CHOLESKY DECOMPOSE ON DENSEN*DENSEN TAKES: \" + (System.currentTimeMillis()-start));\n    } else {\n      // make it symmetric\n      for( int i = 0; i < arr.length; ++i )\n        for( int j = 0; j < i; ++j )\n          arr[j][i] = arr[i][j];\n      CholeskyDecomposition c = new Matrix(arr).chol();\n      fchol.setSPD(c.isSPD());\n      arr = c.getL().getArray();\n      Log.info (\"JAMA CHOLESKY DECOMPOSE TAKES: \" + (System.currentTimeMillis()-start));\n    }\n    for( int i = 0; i < arr.length; ++i )\n      System.arraycopy(arr[i], 0, fchol._xx[i], sparseN, i + 1);\n    return chol;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 699,
    "type": "Param",
    "comment": "@param utcOffset The UTC offset in seconds.",
    "code": "    public static Date genToday(long utcOffset) {\n        // The result is not adjusted for timezone anymore, following libanki model\n        // Timezone adjustment happens explicitly in Deck.updateCutoff(), but not in Deck.checkDailyStats()\n\n        Date today = new Date(System.currentTimeMillis() - (long) utcOffset * 1000l);\n        return today;\n    }\n\n",
    "label": 1,
    "rec": "@param utcOffset The UTC offset in seconds we are going to use to determine today or yesterday."
  },
  {
    "id": 700,
    "type": "Param",
    "comment": "@param intervalMillis",
    "code": "    public static int execute(Runnable runnable, int attemptsCount, long intervalMillis) {\n        int executionIndex = 0;\n        while (true) {\n            try {\n                runnable.run();\n                return executionIndex;\n            } catch (RuntimeException | AssertionError e) {\n                attemptsCount--;\n                executionIndex++;\n                if (attemptsCount > 0) {\n                    try {\n                        Thread.sleep(intervalMillis);\n                    } catch (InterruptedException ie) {\n                        ie.addSuppressed(e);\n                        throw new RuntimeException(ie);\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 701,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public BuilderMethod getMethod(String methodSignature) {\n        dexifyClassIfNecessary(methodSignature);\n\n        return methodSignatureToMethod.get(methodSignature);\n    }\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 702,
    "type": "Param",
    "comment": "@param resKey",
    "code": "  public static Frame rebalanceDataset(final Key resKey, final Frame f, final int nchunks){\n    H2O.H2OCountedCompleter cmp = new H2O.H2OEmptyCompleter();\n    rebalanceDataset(cmp,resKey,f,nchunks);\n    cmp.join();\n    return UKV.get(resKey);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 703,
    "type": "Param",
    "comment": "@param string the input string",
    "code": "  private static String convertToQuotedString(String s) {\n    if (s == null || s.isEmpty()) {\n      return null;\n    }\n    // If already quoted, return as-is\n    if (s.charAt(0) == '\"' && s.charAt(s.length() - 1) == '\"') {\n      return s;\n    }\n    return '\\\"' + s + '\\\"';\n  }\n",
    "label": 1,
    "rec": "@param s the input string"
  },
  {
    "id": 704,
    "type": "Param",
    "comment": "@param subjectContext the contextual data, usually provided by a  Subject.Builder implementation, that is being used to construct a  Subject instance.",
    "code": "    public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) {\n        PrincipalCollection principals = null;\n        try {\n            byte[] bytes = getRememberedSerializedIdentity(subjectContext);\n            //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:\n            if (bytes != null && bytes.length > 0) {\n                principals = convertBytesToPrincipals(bytes, subjectContext);\n            }\n        } catch (RuntimeException re) {\n            principals = onRememberedPrincipalFailure(re, subjectContext);\n        }\n\n        return principals;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 705,
    "type": "Param",
    "comment": "@param repository",
    "code": "    public static Intent createIntent(IssueFilter filter) {\n        return new Builder(\"repo.issues.VIEW\").repo(filter.getRepository()).add(EXTRA_ISSUE_FILTER, filter).toIntent();\n    }\n",
    "label": 1,
    "rec": "@param filter"
  },
  {
    "id": 706,
    "type": "Param",
    "comment": "@param status File status.",
    "code": "    @Override public boolean exists(IgniteFsPath path) throws GridException {\n        try {\n            return fileSys.exists(convert(path));\n        }\n        catch (IOException e) {\n            throw handleSecondaryFsError(e, \"Failed to check file existence [path=\" + path + \"]\");\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 707,
    "type": "Param",
    "comment": "@param repository",
    "code": "        public Builder repo(Repository repository) {\n            return add(EXTRA_REPOSITORY, repository);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 708,
    "type": "Param",
    "comment": "@param idx",
    "code": "\tpublic E get(int index) {\n\t\treturn executables.get( index );\n\t}\n\n",
    "label": 1,
    "rec": "@param index The index of the element to retrieve"
  },
  {
    "id": 709,
    "type": "Param",
    "comment": "@param timeout Timeout.",
    "code": "    private boolean waitCacheSize(IgniteCache<Integer, String> cache, int expSize, long timeout)\n        throws InterruptedException {\n        assert cache != null;\n        assert expSize > 0;\n        assert timeout >= 0;\n\n        long end = System.currentTimeMillis() + timeout;\n\n        while (cache.localSize() < expSize) {\n            Thread.sleep(50);\n\n            if (end - System.currentTimeMillis() <= 0)\n                break;\n        }\n\n        return cache.localSize() >= expSize;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 710,
    "type": "Param",
    "comment": "@param interceptor interceptor used to handle implemented methods",
    "code": "    public static Factory enhance(Class cls, MethodInterceptor ih) {\n        return (Factory)enhanceHelper(cls.isInterface() ? null : cls,\n                                      cls.isInterface() ? new Class[]{ cls } : null,\n                                      ih, cls.getClassLoader(), null, null );\n    }\n\n",
    "label": 1,
    "rec": "@param ih interceptor used to handle implemented methods"
  },
  {
    "id": 711,
    "type": "Param",
    "comment": "@param local",
    "code": "    public boolean isValid(RealmModel realm, UserModel local) {\n        return properties.containsKey(local.getUsername());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 712,
    "type": "Param",
    "comment": "@param resource the given resource.",
    "code": "  public IProject project(URI resourceUri) {\n    return file(resourceUri).getProject();\n  }\n\n",
    "label": 1,
    "rec": "@param resourceUri the given URI."
  },
  {
    "id": 713,
    "type": "Param",
    "comment": "@param token the authentication token reprenting the subject (user)'s authentication attempt.",
    "code": "    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, Account account ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, account );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 714,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    public VisorGridConfiguration from(IgniteEx ignite) {\n        assert ignite != null;\n\n        IgniteConfiguration c = ignite.configuration();\n\n        basic(VisorBasicConfiguration.from(ignite, c));\n        metrics(VisorMetricsConfiguration.from(c));\n        spis(VisorSpisConfiguration.from(c));\n        p2p(VisorPeerToPeerConfiguration.from(c));\n        email(VisorEmailConfiguration.from(c));\n        lifecycle(VisorLifecycleConfiguration.from(c));\n        executeService(VisorExecutorServiceConfiguration.from(c));\n        segmentation(VisorSegmentationConfiguration.from(c));\n        includeProperties(compactArray(c.getIncludeProperties()));\n        includeEventTypes(c.getIncludeEventTypes());\n        rest(VisorRestConfiguration.from(c));\n        userAttributes(c.getUserAttributes());\n        caches(VisorCacheConfiguration.list(c.getCacheConfiguration()));\n        ggfss(VisorGgfsConfiguration.list(c.getGgfsConfiguration()));\n        streamers(VisorStreamerConfiguration.list(c.getStreamerConfiguration()));\n        env(new HashMap<>(getenv()));\n        systemProperties(getProperties());\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 715,
    "type": "Param",
    "comment": "@param key",
    "code": "  public String ltrim(final String key, final long start, final long stop) {\n    checkIsInMultiOrPipeline();\n    client.ltrim(key, start, stop);\n    return client.getStatusCodeReply();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 716,
    "type": "Param",
    "comment": "@param m",
    "code": "    public static boolean isEmpty(PrincipalCollection principals) {\n        return principals == null || principals.isEmpty();\n    }\n",
    "label": 1,
    "rec": "@param principals the principals to check."
  },
  {
    "id": 717,
    "type": "Param",
    "comment": "@param pageIndex",
    "code": "    public PageHandler getPage(String hql, Map<String, Object> parameters, Integer pageIndex, Integer pageSize) {\n        return dao.getPage(hql, parameters, pageIndex, pageSize);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 718,
    "type": "Param",
    "comment": "@param ciphertext binary ciphertext",
    "code": "  public byte[] decrypt(byte[] cipherData) {\n    if (cipherData.length < OVERHEAD_SIZE) {\n      throw new DoubleClickCryptoException(\"Invalid cipherData, \" + cipherData.length + \" bytes\");\n    }\n\n    // workBytes := initVector || E(payload) || I(signature)\n    byte[] workBytes = cipherData.clone();\n    ByteBuffer workBuffer = ByteBuffer.wrap(workBytes);\n\n    try {\n      // workBytes := initVector || payload || I(signature)\n      xorPayloadToHmacPad(workBytes);\n      // workBytes := initVector || payload || I'(signature)\n      int confirmationSignature = hmacSignature(workBytes);\n      int integritySignature = workBuffer.getInt(workBytes.length - SIGNATURE_SIZE);\n      workBuffer.putInt(workBytes.length - SIGNATURE_SIZE, confirmationSignature);\n\n      if (confirmationSignature != integritySignature) {\n        throw new DoubleClickCryptoException(\"Signature mismatch: \"\n            + Integer.toHexString(confirmationSignature)\n            + \" vs \" + Integer.toHexString(integritySignature));\n      }\n\n      if (logger.isDebugEnabled()) {\n        logger.debug(dump(\"Decrypted\", cipherData, workBytes));\n      }\n\n      return workBytes;\n    } catch (InvalidKeyException | NoSuchAlgorithmException | ShortBufferException e) {\n      if (logger.isWarnEnabled()) {\n        logger.warn(dump(\"Decrypted (failed)\", cipherData, workBytes));\n      }\n      throw new DoubleClickCryptoException(e);\n    }\n  }\n\n",
    "label": 1,
    "rec": "@param cipherData initVector || E(payload) || I(signature:4)"
  },
  {
    "id": 719,
    "type": "Param",
    "comment": "@param log Logger.",
    "code": "    public GridNodeCallable setLogger(IgniteLogger log) {\n        this.log = log;\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 720,
    "type": "Param",
    "comment": "@param claimsRequest the claims request parameter object.",
    "code": "\tprivate JsonObject toJsonFromRequestObj(UserInfo ui, Set<String> scope, JsonObject authorizedClaims, JsonObject requestedClaims) {\n\n\t\t// get the base object\n\t\tJsonObject obj = toJson(ui, scope);\n\n\t\tJsonObject userinfoAuthorized = authorizedClaims.getAsJsonObject().get(\"userinfo\").getAsJsonObject();\n\t\tJsonObject userinfoRequested = requestedClaims.getAsJsonObject().get(\"userinfo\").getAsJsonObject();\n\t\t\n\t\tif (userinfoAuthorized == null || !userinfoAuthorized.isJsonObject()) {\n\t\t\treturn obj;\n\t\t}\n\n\t\t\n\t\t// Filter claims from the request object with the claims from the claims request parameter, if it exists\n\t\t\n\t\t// Doing the set intersection manually because the claim entries may be referring to\n\t\t// the same claim but have different 'individual claim values', causing the Entry<> to be unequal, \n\t\t// which doesn't allow the use of the more compact Sets.intersection() type method.\n\t\tSet<Entry<String, JsonElement>> requestClaimsSet = Sets.newHashSet();\n\t\tif (requestedClaims != null) {\n\t\t\t\n\t\t\tfor (Entry<String, JsonElement> entry : userinfoAuthorized.getAsJsonObject().entrySet()) {\n\t\t\t\tif (userinfoRequested.has(entry.getKey())) {\n\t\t\t\t\trequestClaimsSet.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// TODO: this method is likely to be fragile if the data model changes at all\n\n\t\t//For each claim found, add it if not already present\n\t\tfor (Entry<String, JsonElement> i : requestClaimsSet) {\n\t\t\tString claimName = i.getKey();\n\t\t\tif (!obj.has(claimName)) {\n\t\t\t\tString value = \"\";\n\n\n\t\t\t\t//Process claim names to go from \"claim_name\" to \"ClaimName\"\n\t\t\t\tString camelClaimName = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, claimName);\n\t\t\t\t//Now we have \"getClaimName\"\n\t\t\t\tString methodName = \"get\" + camelClaimName;\n\t\t\t\tMethod getter = null;\n\t\t\t\ttry {\n\t\t\t\t\tgetter = ui.getClass().getMethod(methodName);\n\t\t\t\t\tvalue = (String) getter.invoke(ui);\n\t\t\t\t\tobj.addProperty(claimName, value);\n\t\t\t\t} catch (SecurityException e) {\n\t\t\t\t\tlogger.error(\"SecurityException in UserInfoView.java: \", e);\n\t\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t\tlogger.error(\"NoSuchMethodException in UserInfoView.java: \", e);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tlogger.error(\"IllegalArgumentException in UserInfoView.java: \", e);\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tlogger.error(\"IllegalAccessException in UserInfoView.java: \", e);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tlogger.error(\"InvocationTargetException in UserInfoView.java: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn obj;\n\n\t}\n",
    "label": 1,
    "rec": "@param requestedClaims the claims request parameter object."
  },
  {
    "id": 721,
    "type": "Param",
    "comment": "@param ids Event ids.",
    "code": "    public static IgnitePredicate<GridEvent> eventId(@Nullable final IgniteUuid... ids) {\n        return isEmpty(ids) ? F.<GridEvent>alwaysFalse() :\n            new IgnitePredicate<GridEvent>() {\n                // Don't set peer deploy aware as UUID is loaded by\n                // system class loader.\n\n                @Override public boolean apply(GridEvent e) {\n                    assert e != null;\n\n                    return F.isAll(e.id(), in(ids));\n                }\n            };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 722,
    "type": "Param",
    "comment": "@param ignoreMergeMore Ignore the attempt to merge more pages up.",
    "code": "        boolean finishTail(boolean skipMergeMore) throws IgniteCheckedException {\n            assert !isFinished();\n            assert needMerge != FALSE || needReplaceInner != FALSE;\n            assert tail != null;\n\n            if (needReplaceInner == READY) {\n                assert getTail(0, false) != null: \"we must keep lock on the leaf page\";\n\n                // We increment remove ID in write lock on leaf page, thus it is guaranteed that\n                // any successor will get greater value than he had read at the beginning of the operation.\n                // Thus it will be guaranteed to do a retry from root.\n                globalRmvId.incrementAndGet();\n\n                // Need to replace inner key with new max key for the left subtree.\n                doReplaceInner();\n\n                needReplaceInner = DONE;\n            }\n            else if (needMerge == READY) {\n                assert tail.down != null || tail.fwd.down != null;\n\n                boolean needMergeMore = merge(tail.lvl - 1, true, true);\n\n                if (needMergeMore && !skipMergeMore) {\n                    needMerge = TRUE;\n\n                    return false;\n                }\n\n                needMerge = DONE;\n            }\n            else\n                return false;\n\n            releaseTail();\n            finish();\n\n            return true;\n        }\n",
    "label": 1,
    "rec": "@param skipMergeMore Ignore the attempt to merge more pages up."
  },
  {
    "id": 723,
    "type": "Param",
    "comment": "@param userInfo",
    "code": "\tprotected Authentication createAuthenticationToken(PendingOIDCAuthenticationToken token, Collection<? extends GrantedAuthority> authorities, UserInfo userInfo) {\n\t\treturn new OIDCAuthenticationToken(token.getSub(),\n\t\t\t\ttoken.getIssuer(),\n\t\t\t\tuserInfo, authorities,\n\t\t\t\ttoken.getIdToken(), token.getAccessTokenValue(), token.getRefreshTokenValue());\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 724,
    "type": "Param",
    "comment": "@param gists",
    "code": "    public static Intent createIntent(List<Item> items, int position) {\n        String[] ids = new String[items.size()];\n        int index = 0;\n        for (Item item : items) {\n            Gist gist = ((GistItem) item).getData();\n            ids[index++] = gist.id();\n        }\n        return new Builder(\"gists.VIEW\")\n            .add(EXTRA_GIST_IDS, (Serializable) ids)\n            .add(EXTRA_POSITION, position).toIntent();\n    }\n",
    "label": 1,
    "rec": "@param items"
  },
  {
    "id": 725,
    "type": "Param",
    "comment": "@param activity The  Activity that the  Crouton should be attached to.",
    "code": "\tpublic static Crouton makeText(Activity activity, int textResourceId, Style style) {\n\t\treturn makeText(activity, activity.getString(textResourceId), style);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 726,
    "type": "Param",
    "comment": "@param address the memory address of the AllocationPointerOperations",
    "code": "\tpublic static final String dump(final long address[]) {\n\t\tif(address==null || address.length==0) throw new IllegalArgumentException(\"Address array was null or zero length\");\n\t\tfinal byte dim = getDimension(address[0]);\t\t\n\t\tStringBuilder b = new StringBuilder(print(address));\n//\t\tb.append(\"\\n\\tAddresses: [\");\n//\t\tfinal int size = getSize(address);\n//\t\tif(size>0) {\n//\t\t\tfor(int i = 0; i < size; i++) {\n//\t\t\t\tb.append(getAddress(address, i)).append(\", \");\n//\t\t\t}\t\t\t\n//\t\t\tb.deleteCharAt(b.length()-1);\n//\t\t\tb.deleteCharAt(b.length()-1);\n//\t\t}\n//\t\treturn b.append(\"]\").toString();\n\t\treturn b.toString();\n\t}\n\n",
    "label": 1,
    "rec": "@param address The address array of the allocation pointer memory block which could be a length of: Simple address management Address management with memory tracking Address management with memory tracking and cache-line alignment overhead "
  },
  {
    "id": 727,
    "type": "Param",
    "comment": "@param realm",
    "code": "    public AuthenticationSessionModel getCurrentAuthenticationSession(RealmModel realm, ClientModel client, String tabId) {\n        String authSessionId = getAuthSessionCookieDecoded(realm);\n\n        if (authSessionId == null) {\n            return null;\n        }\n\n        return getAuthenticationSessionByIdAndClient(realm, authSessionId, client, tabId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 728,
    "type": "Param",
    "comment": "@param result the result set",
    "code": "    public boolean nextRow(ResultSet results, KeyValueStreamListener listener)\n            throws SQLException, IOException, ParseException {\n        if (results.next()) {\n            processRow(results, listener);\n            return true;\n        }\n        return false;\n    }\n",
    "label": 1,
    "rec": "@param results the result set"
  },
  {
    "id": 729,
    "type": "Param",
    "comment": "@param maxIter the maximum number of allowed iterations.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol, int maxIter) {\n        if (tol <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid tolerance: \" + tol);\n        }\n\n        if (maxIter <= 0) {\n            throw new IllegalArgumentException(\"Invalid maximum number of iterations: \" + maxIter);\n        }\n\n        if (itol < 1 || itol > 4) {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        double err = 0.0;\n        double ak, akden, bk, bkden = 1.0, bknum, bnrm, dxnrm, xnrm, zm1nrm, znrm = 0.0;\n        int j, n = b.length;\n\n        double[] p = new double[n];\n        double[] pp = new double[n];\n        double[] r = new double[n];\n        double[] rr = new double[n];\n        double[] z = new double[n];\n        double[] zz = new double[n];\n\n        A.ax(x, r);\n        for (j = 0; j < n; j++) {\n            r[j] = b[j] - r[j];\n            rr[j] = r[j];\n        }\n\n        if (itol == 1) {\n            bnrm = snorm(b, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 2) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 3 || itol == 4) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n            znrm = snorm(z, itol);\n        } else {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        for (int iter = 1; iter <= maxIter; iter++) {\n            Ap.asolve(rr, zz);\n            for (bknum = 0.0, j = 0; j < n; j++) {\n                bknum += z[j] * rr[j];\n            }\n            if (iter == 1) {\n                for (j = 0; j < n; j++) {\n                    p[j] = z[j];\n                    pp[j] = zz[j];\n                }\n            } else {\n                bk = bknum / bkden;\n                for (j = 0; j < n; j++) {\n                    p[j] = bk * p[j] + z[j];\n                    pp[j] = bk * pp[j] + zz[j];\n                }\n            }\n            bkden = bknum;\n            A.ax(p, z);\n            for (akden = 0.0, j = 0; j < n; j++) {\n                akden += z[j] * pp[j];\n            }\n            ak = bknum / akden;\n            A.atx(pp, zz);\n            for (j = 0; j < n; j++) {\n                x[j] += ak * p[j];\n                r[j] -= ak * z[j];\n                rr[j] -= ak * zz[j];\n            }\n            Ap.asolve(r, z);\n            if (itol == 1) {\n                err = snorm(r, itol) / bnrm;\n            } else if (itol == 2) {\n                err = snorm(z, itol) / bnrm;\n            } else if (itol == 3 || itol == 4) {\n                zm1nrm = znrm;\n                znrm = snorm(z, itol);\n                if (Math.abs(zm1nrm - znrm) > Math.EPSILON * znrm) {\n                    dxnrm = Math.abs(ak) * snorm(p, itol);\n                    err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n                xnrm = snorm(x, itol);\n                if (err <= 0.5 * xnrm) {\n                    err /= xnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n            }\n\n            if (iter % 10 == 0) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n            }\n\n            if (err <= tol) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n                break;\n            }\n        }\n\n        return err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 730,
    "type": "Param",
    "comment": "@param eventRequest event request object",
    "code": "    BotApiResponse reply(List<String> to, List<Message> messages)\n            throws LineBotAPIException;\n\n    BotApiResponse push(List<String> to, List<Message> messages)\n            throws LineBotAPIException;\n\n    default BotApiResponse push(String to, Message messages)\n            throws LineBotAPIException {\n        return push(Collections.singletonList(to), Collections.singletonList(messages));\n    }\n",
    "label": 1,
    "rec": "@param messages List of messages"
  },
  {
    "id": 731,
    "type": "Param",
    "comment": "@param model",
    "code": "    public String delete(Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysSite site = getSite(request);\n        if (CommonUtils.notEmpty(ids)) {\n            service.delete(site.getId(), ids);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.cmsComment\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), StringUtils.join(ids, ',')));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 732,
    "type": "Param",
    "comment": "@param dir the directory to create.",
    "code": "    public static boolean mkdirs( File directory )\n    {\n        if ( directory == null )\n        {\n            return false;\n        }\n\n        if ( directory.exists() )\n        {\n            return false;\n        }\n        if ( directory.mkdir() )\n        {\n            return true;\n        }\n\n        File canonDir = null;\n        try\n        {\n            canonDir = directory.getCanonicalFile();\n        }\n        catch ( IOException e )\n        {\n            return false;\n        }\n\n        File parentDir = canonDir.getParentFile();\n        return ( parentDir != null && ( mkdirs( parentDir ) || parentDir.exists() ) && canonDir.mkdir() );\n    }\n\n",
    "label": 1,
    "rec": "@param directory The directory to create, may be  null."
  },
  {
    "id": 733,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public boolean initializeFromDht(long topVer) throws GridCacheEntryRemovedException {\n        while (true) {\n            GridDhtCacheEntry<K, V> entry = cctx.near().dht().peekExx(key);\n\n            if (entry != null) {\n                GridCacheEntryInfo<K, V> e = entry.info();\n\n                if (e != null) {\n                    GridCacheVersion enqueueVer = null;\n\n                    try {\n                        synchronized (this) {\n                            checkObsolete();\n\n                            if (isNew() || !valid(topVer)) {\n                                // Version does not change for load ops.\n                                update(e.value(), e.valueBytes(), e.expireTime(), e.ttl(), e.isNew() ? ver : e.version());\n\n                                if (cctx.deferredDelete()) {\n                                    boolean deleted = val == null && valBytes == null;\n\n                                    if (deleted != deletedUnlocked()) {\n                                        deletedUnlocked(deleted);\n\n                                        if (deleted)\n                                            enqueueVer = e.version();\n                                    }\n                                }\n\n                                recordNodeId(cctx.affinity().primary(key, topVer).id());\n\n                                dhtVer = e.isNew() || e.isDeleted() ? null : e.version();\n\n                                return true;\n                            }\n\n                            return false;\n                        }\n                    }\n                    finally {\n                        if (enqueueVer != null)\n                            cctx.onDeferredDelete(this, enqueueVer);\n                    }\n                }\n            }\n            else\n                return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 734,
    "type": "Param",
    "comment": "@param strings",
    "code": "    public Long rpush(final String key, final String... string) {\n        checkIsInMulti();\n        client.rpush(key, string);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param string"
  },
  {
    "id": 735,
    "type": "Param",
    "comment": "@param mode Mode.",
    "code": "    private IgfsFileInfo resolveFileInfo(IgfsPath path, IgfsMode mode) throws IgniteCheckedException {\n        assert path != null;\n        assert mode != null;\n\n        IgfsFileInfo info = null;\n\n        switch (mode) {\n            case PRIMARY:\n                info = meta.info(meta.fileId(path));\n\n                break;\n\n            case DUAL_SYNC:\n            case DUAL_ASYNC:\n                info = meta.info(meta.fileId(path));\n\n                if (info == null) {\n                    IgfsFile status = secondaryFs.info(path);\n\n                    if (status != null)\n                        info = status.isDirectory() ? new IgfsFileInfo(true, status.properties()) :\n                            new IgfsFileInfo(status.blockSize(), status.length(), null, null, false,\n                            status.properties());\n                }\n\n                break;\n\n            default:\n                assert false : \"Unknown mode: \" + mode;\n        }\n\n        return info;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 736,
    "type": "Param",
    "comment": "@param retryCount",
    "code": "    public static int execute(Runnable runnable, int attemptsCount, long intervalMillis) {\n        int executionIndex = 0;\n        while (true) {\n            try {\n                runnable.run();\n                return executionIndex;\n            } catch (RuntimeException | AssertionError e) {\n                attemptsCount--;\n                executionIndex++;\n                if (attemptsCount > 0) {\n                    try {\n                        Thread.sleep(intervalMillis);\n                    } catch (InterruptedException ie) {\n                        ie.addSuppressed(e);\n                        throw new RuntimeException(ie);\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param attemptsCount Total number of attempts to execute the  runnable"
  },
  {
    "id": 737,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public static Collection<ClusterNode> remoteNodes(final GridCacheSharedContext ctx, AffinityTopologyVersion topVer) {\n        return ctx.discovery().remoteCacheNodes(topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 738,
    "type": "Param",
    "comment": "@param clickEvent",
    "code": "    public ComponentBuilder event(HoverEvent hoverEvent)\n    {\n        current.setHoverEvent( hoverEvent );\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param hoverEvent the hover event"
  },
  {
    "id": 739,
    "type": "Param",
    "comment": "@param tx Transaction to check.",
    "code": "    private boolean isSafeToForget(IgniteInternalTx<K, V> tx) {\n        Map.Entry<GridCacheVersion, AtomicInt> e = startVerCnts.firstEntry();\n\n        if (e == null)\n            return true;\n\n        assert e.getValue().get() >= 0;\n\n        return tx.endVersion().compareTo(e.getKey()) <= 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 740,
    "type": "Param",
    "comment": "@param oAuthRequest the incoming authorization request",
    "code": "\tpublic AuthorizationRequest checkForPreApproval(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n\t\t\n\t\t//First, check database to see if the user identified by the userAuthentication has stored an approval decision\n\t\t\n\t\t//getName may not be filled in? TODO: investigate\n\t\tString userId = userAuthentication.getName();\n\t\tString clientId = authorizationRequest.getClientId();\n\n\t\t//lookup ApprovedSites by userId and clientId\n\t\tboolean alreadyApproved = false;\n\t\tCollection<ApprovedSite> aps = approvedSiteService.getByClientIdAndUserId(clientId, userId);\n\t\tfor (ApprovedSite ap : aps) {\n\t\t\t\n\t\t\tif (!ap.isExpired()) {\n\t\t\t\n\t\t\t\t// if we find one that fits...\n\t\t\t\tif (scopesMatch(authorizationRequest.getScope(), ap.getAllowedScopes())) {\n\t\t\t\t\t\n\t\t\t\t\t//We have a match; update the access date on the AP entry and return true.\n\t\t\t\t\tap.setAccessDate(new Date());\n\t\t\t\t\tapprovedSiteService.save(ap);\n\t\n\t\t\t\t\tauthorizationRequest.getExtensionProperties().put(\"approved_site\", ap.getId());\n\t\t\t\t\tauthorizationRequest.setApproved(true);\t\t\t\t\t\n\t\t\t\t\talreadyApproved = true;\n\t\t\t\t}\n\t\t\t}\n        }\n\t\t\n\t\tif (!alreadyApproved) {\n\t\t\tWhitelistedSite ws = whitelistedSiteService.getByClientId(clientId);\n\t\t\tif (ws != null && scopesMatch(authorizationRequest.getScope(), ws.getAllowedScopes())) {\n\t\t\t\t\n\t\t\t\t//Create an approved site\n\t\t\t\tApprovedSite newSite = approvedSiteService.createApprovedSite(clientId, userId, null, ws.getAllowedScopes(), ws);\t\n\t\t\t\tauthorizationRequest.getExtensionProperties().put(\"approved_site\", newSite.getId());\n\t\t\t\tauthorizationRequest.setApproved(true);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn authorizationRequest;\n\t\t\n\t}\n",
    "label": 1,
    "rec": "@param authorizationRequest the incoming authorization request"
  },
  {
    "id": 741,
    "type": "Param",
    "comment": "@param tol the desired convergence tolerance.",
    "code": "    public static double eigen(Matrix A, double[] v, double tol, int maxIter) {\n        return eigen(A, v, 0.0, tol, maxIter);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 742,
    "type": "Param",
    "comment": "@param props Properties to be applied.",
    "code": "    public IgfsFileInfo updateDual(final IgfsSecondaryFileSystem fs, final IgfsPath path, final Map<String, String> props)\n        throws IgniteCheckedException {\n        assert fs != null;\n        assert path != null;\n        assert props != null && !props.isEmpty();\n\n        if (busyLock.enterBusy()) {\n            try {\n                SynchronizationTask<IgfsFileInfo> task = new SynchronizationTask<IgfsFileInfo>() {\n                    @Override public IgfsFileInfo onSuccess(Map<IgfsPath, IgfsFileInfo> infos)\n                        throws Exception {\n                        if (infos.get(path) == null)\n                            return null;\n\n                        fs.update(path, props);\n\n                        assert path.parent() == null || infos.get(path.parent()) != null;\n\n                        return updatePropertiesNonTx(infos.get(path.parent()).id(), infos.get(path).id(), path.name(),\n                            props);\n                    }\n\n                    @Override public IgfsFileInfo onFailure(@Nullable Exception err) throws IgniteCheckedException {\n                        U.error(log, \"Path update in DUAL mode failed [path=\" + path + \", properties=\" + props + ']',\n                            err);\n\n                        throw new IgniteCheckedException(\"Failed to update the path due to secondary file system exception: \" +\n                            path, err);\n                    }\n                };\n\n                return synchronizeAndExecute(task, fs, false, path);\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to update in DUAL mode because Grid is stopping: \" + path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 743,
    "type": "Param",
    "comment": "@param grid Grid instance.",
    "code": "    private GridCheckpointManager checkpoints(Ignite ignite) {\n        assert ignite != null;\n\n        return ((GridKernal) ignite).context().checkpoint();\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid instance."
  },
  {
    "id": 744,
    "type": "Param",
    "comment": "@param weightingMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&amp;api.xy=\" from the URL of the web UI",
    "code": "    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )\n    {\n        String weighting = weightingMap.getWeighting().toLowerCase();\n\n        if (\"shortest\".equalsIgnoreCase(weighting))\n        {\n            return new ShortestWeighting(encoder);\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty())\n        {\n            if (encoder.supports(PriorityWeighting.class))\n                return new PriorityWeighting(encoder, weightingMap);\n            else\n                return new FastestWeighting(encoder, weightingMap);\n        } else if (\"curvature\".equalsIgnoreCase(weighting))\n        {\n            if (encoder.supports(CurvatureWeighting.class))\n                return new CurvatureWeighting(encoder, weightingMap, ghStorage);\n            else\n                return new FastestWeighting(encoder, weightingMap);\n        }\n\n        throw new UnsupportedOperationException(\"weighting \" + weighting + \" not supported\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 745,
    "type": "Param",
    "comment": "@param principal the principal of the Subject whose Account is being retrieved.",
    "code": "    protected AuthorizingAccount queryForLdapAccount( PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principals instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        Set<String> roleNames;\n\n        try {\n            roleNames = getRoleNamesForUser(username, ldapContext);\n        } finally {\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        SimplePrincipalCollection principals = new SimplePrincipalCollection(getName(),username);\n        return new SimpleAuthorizingAccount( principals, null, roleNames, null );\n    }\n",
    "label": 1,
    "rec": "@param principals the principal of the Subject whose Account is being retrieved."
  },
  {
    "id": 746,
    "type": "Param",
    "comment": "@param idx Node index.",
    "code": "    private GridFuture<Integer> callAsync(int idx, Callable<Integer> job, @Nullable IgnitePredicate<ClusterNode> p)\n        throws GridException {\n        assert idx >= 0 && idx < NODES_CNT;\n        assert job != null;\n\n        execCntr.set(0);\n\n        GridCompute comp = p != null ? compute(grid(idx).forPredicate(p)) : grid(idx).compute();\n\n        comp = comp.enableAsync();\n\n        comp.call(job);\n\n        return comp.future();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 747,
    "type": "Param",
    "comment": "@param insets the insets to adjust.",
    "code": "    public static ElkPadding calculateRequiredNodeLabelSpace(final NodeAdapter<?> node,\n            final double labelSpacing, final ElkPadding nodeLabelPadding,\n            final Map<LabelLocation, LabelGroup> labelGroupsBoundingBoxes, final ElkPadding padding) {\n\n        // Check if there are any labels\n        if (!node.getLabels().iterator().hasNext()) {\n            return padding;\n        }\n        \n        // Retrieve the node's label placement policy\n        final Set<NodeLabelPlacement> nodeLabelPlacement = node.getProperty(CoreOptions.NODE_LABELS_PLACEMENT);\n        final LabelLocation nodeLabelLocation = LabelLocation.fromNodeLabelPlacement(nodeLabelPlacement);\n        \n        // Compute a bounding box for each location where labels should be placed.\n        // The size is calculated from the size of all labels stacked vertically at that location.\n        for (final LabelAdapter<?> label : node.getLabels()) {\n            LabelLocation labelPlacement =\n                    LabelLocation.fromNodeLabelPlacement(label.getProperty(CoreOptions.NODE_LABELS_PLACEMENT));\n            \n            // If no valid placement is set on the label, use the node's placement policy.\n            if (labelPlacement == LabelLocation.UNDEFINED) {\n                labelPlacement = nodeLabelLocation;\n            }\n            \n            // Save the location of this label in its id field for later use.\n            label.setVolatileId(labelPlacement.ordinal());\n            \n            // Create or retrieve the label group for the current label.\n            final Rectangle boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);\n            boundingBox.width = Math.max(boundingBox.width, label.getSize().x);\n            boundingBox.height += label.getSize().y + labelSpacing;\n        }\n        \n        // We need to count different label placement boxes towards different kinds of padding, depending on whether\n        // or not H_PRIORITY is set on the node itself (see H_PRIORITY documentation)\n        boolean hPrio = nodeLabelPlacement.contains(NodeLabelPlacement.H_PRIORITY);\n        \n        // Calculate the node label space required inside the node (only label groups on the inside\n        // are relevant here).\n        for (final Entry<LabelLocation, LabelGroup> entry : labelGroupsBoundingBoxes.entrySet()) {\n            final Rectangle boundingBox = entry.getValue();\n            \n            // From each existing label group, remove the last superfluous label spacing\n            // (the mere existence of a label group implies that it contains at least one label)\n            boundingBox.height -= labelSpacing;\n            switch (entry.getKey()) {\n            case IN_T_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_T_C:\n                padding.top = Math.max(\n                        padding.top,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                break;\n                \n            case IN_T_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.top = Math.max(\n                            padding.top,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n                \n            case IN_C_L:\n                padding.left = Math.max(\n                        padding.left,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                break;\n                \n            case IN_C_R:\n                padding.right = Math.max(\n                        padding.right,\n                        boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                break;\n                \n            case IN_B_L:\n                if (hPrio) {\n                    padding.left = Math.max(\n                            padding.left,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            case IN_B_C:\n                padding.bottom = Math.max(\n                        padding.bottom,\n                        boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                break;\n                \n            case IN_B_R:\n                if (hPrio) {\n                    padding.right = Math.max(\n                            padding.right,\n                            boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.bottom = Math.max(\n                            padding.bottom,\n                            boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n                \n            default:\n                // In all other cases, no specific action is required\n            }\n        }\n\n        // Add node label padding that aren't set yet\n        // This happens if e.g. a top inset is set but no top label is present\n        padding.top    = Math.max(padding.top, nodeLabelPadding.top);\n        padding.left   = Math.max(padding.left, nodeLabelPadding.left);\n        padding.right  = Math.max(padding.right, nodeLabelPadding.right);\n        padding.bottom = Math.max(padding.bottom, nodeLabelPadding.bottom);\n\n        return padding;\n    }\n\n",
    "label": 1,
    "rec": "@param padding the padding to adjust."
  },
  {
    "id": 748,
    "type": "Param",
    "comment": "@param requestCode",
    "code": "    public int startPluginActivityForResult(Context base, DLIntent dlIntent, int requestCode) {\n        String packageName = dlIntent.getPluginPackage();\n        if (packageName == null) throw new NullPointerException(\"package name is null\");\n        DLPluginPackage pluginPackage = packageHolder.get(packageName);\n        \n        if (pluginPackage == null) {\n            return START_RESULT_NO_PKG;\n        } else {\n            DexClassLoader loader = pluginPackage.loader;\n            String className = dlIntent.getPluginClass();\n            className = className == null ? pluginPackage.getDefaultActivity() : className;\n            if (className.startsWith(\".\")) {\n                className = packageName + className;\n            }\n            Class<?> clazz = null;\n            try {\n                clazz = loader.loadClass(className);\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n                return START_RESULT_NO_CLASS;\n            }\n            \n            Class<? extends Activity> activityClass = null;\n            if (DLBasePluginActivity.class.isAssignableFrom(clazz)) {\n                activityClass = DLProxyActivity.class;\n            } else if (DLBasePluginFragmentActivity.class.isAssignableFrom(clazz)) {\n                activityClass = DLProxyFragmentActivity.class;\n            } else {\n                return START_RESULT_TYPE_ERROR;\n            }\n            \n            dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);\n            dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);\n            dlIntent.setClass(mContext, activityClass);\n            \n            if (base instanceof Activity) {\n                ((Activity) base).startActivityForResult(dlIntent, requestCode);\n            } else {\n                base.startActivity(dlIntent);\n            }\n            return START_RESULT_SUCCESS;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 749,
    "type": "Param",
    "comment": "@param configStream",
    "code": "    public Object parse(InputStream stream) throws ParsingException {\n        XMLEventReader xmlEventReader = createEventReader(stream);\n        return parse(xmlEventReader);\n    }\n",
    "label": 1,
    "rec": "@param stream"
  },
  {
    "id": 750,
    "type": "Param",
    "comment": "@param entry Entry.",
    "code": "    private int extrasSize(Cache.Entry entry) throws Exception {\n        assert false : \"ignite-96\";\n\n        return -1;\n\n//        Method mthd = GridCacheMapEntry.class.getDeclaredMethod(\"extrasSize\");\n//\n//        mthd.setAccessible(true);\n//\n//        GridCacheContext ctx = U.field(entry, \"ctx\");\n//\n//        GridCacheEntryEx entry0 = ((GridCacheEntryImpl)entry).entryEx(false, ctx.discovery().topologyVersion());\n//\n//        return (Integer)mthd.invoke(entry0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 751,
    "type": "Param",
    "comment": "@param user",
    "code": "    protected BitmapDrawable getImage(final String userId) {\n        File avatarFile = new File(avatarDir, userId);\n\n        if (!avatarFile.exists() || avatarFile.length() == 0)\n            return null;\n\n        Bitmap bitmap = decode(avatarFile);\n        if (bitmap != null)\n            return new BitmapDrawable(context.getResources(), bitmap);\n        else {\n            avatarFile.delete();\n            return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param userId"
  },
  {
    "id": 752,
    "type": "Param",
    "comment": "@param entry Entry.",
    "code": "    private int extrasSize(CacheEntry entry) throws Exception {\n        Method mthd = GridCacheMapEntry.class.getDeclaredMethod(\"extrasSize\");\n\n        mthd.setAccessible(true);\n\n        GridCacheContext ctx = U.field(entry, \"ctx\");\n\n        GridCacheEntryEx entry0 = ((GridCacheEntryImpl)entry).entryEx(false, ctx.discovery().topologyVersion());\n\n        return (Integer)mthd.invoke(entry0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 753,
    "type": "Param",
    "comment": "@param statusBarFlag the status bar flag",
    "code": "    public ImmersionBar statusBarColorTransformEnable(boolean statusBarColorTransformEnable) {\n        mBarParams.statusBarColorEnabled = statusBarColorTransformEnable;\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param statusBarColorTransformEnable the status bar flag"
  },
  {
    "id": 754,
    "type": "Param",
    "comment": "@param tx Transaction to commit.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitTxAsync(final IgniteInternalTx tx) {\n        FutureHolder holder = lastFut.get();\n\n        holder.lock();\n\n        try {\n            IgniteInternalFuture fut = holder.future();\n\n            if (fut != null && !fut.isDone()) {\n                IgniteInternalFuture<IgniteInternalTx> f = new GridEmbeddedFuture<>(fut,\n                    new C2<Object, Exception, IgniteInternalFuture<IgniteInternalTx>>() {\n                        @Override public IgniteInternalFuture<IgniteInternalTx> apply(Object o, Exception e) {\n                            return tx.commitAsync();\n                        }\n                    }, ctx.kernalContext());\n\n                saveFuture(holder, f);\n\n                return f;\n            }\n\n            IgniteInternalFuture<IgniteInternalTx> f = tx.commitAsync();\n\n            saveFuture(holder, f);\n\n            ctx.tm().txContextReset();\n\n            return f;\n        }\n        finally {\n            holder.unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 755,
    "type": "Param",
    "comment": "@param url",
    "code": "    protected BitmapDrawable fetchAvatar(final String url, final String userId) {\n        File rawAvatar = new File(avatarDir, userId + \"-raw\");\n        HttpRequest request = HttpRequest.get(url);\n        if (request.ok())\n            request.receive(rawAvatar);\n\n        if (!rawAvatar.exists() || rawAvatar.length() == 0)\n            return null;\n\n        Bitmap bitmap = decode(rawAvatar);\n        if (bitmap == null) {\n            rawAvatar.delete();\n            return null;\n        }\n\n        bitmap = ImageUtils.roundCorners(bitmap, cornerRadius);\n        if (bitmap == null) {\n            rawAvatar.delete();\n            return null;\n        }\n\n        File roundedAvatar = new File(avatarDir, userId.toString());\n        FileOutputStream output = null;\n        try {\n            output = new FileOutputStream(roundedAvatar);\n            if (bitmap.compress(PNG, 100, output))\n                return new BitmapDrawable(context.getResources(), bitmap);\n            else\n                return null;\n        } catch (IOException e) {\n            Log.d(TAG, \"Exception writing rounded avatar\", e);\n            return null;\n        } finally {\n            if (output != null)\n                try {\n                    output.close();\n                } catch (IOException e) {\n                    // Ignored\n                }\n            rawAvatar.delete();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 756,
    "type": "Param",
    "comment": "@param peerGroup a PeerGroup to use for broadcast or null.",
    "code": "    public SendResult sendCoins(TransactionBroadcaster broadcaster, SendRequest request) {\n        // Does not need to be synchronized as sendCoinsOffline is and the rest is all thread-local.\n\n        // Commit the TX to the wallet immediately so the spent coins won't be reused.\n        // TODO: We should probably allow the request to specify tx commit only after the network has accepted it.\n        Transaction tx = sendCoinsOffline(request);\n        if (tx == null)\n            return null;  // Not enough money.\n        SendResult result = new SendResult();\n        result.tx = tx;\n        // The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has\n        // a txConfidenceListener registered. Once the tx is broadcast the peers will update the memory pool with the\n        // count of seen peers, the memory pool will update the transaction confidence object, that will invoke the\n        // txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged\n        // method.\n        result.broadcastComplete = broadcaster.broadcastTransaction(tx);\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param broadcaster the target to use for broadcast."
  },
  {
    "id": 757,
    "type": "Param",
    "comment": "@param p Predicate to check.",
    "code": "    public static boolean isAlwaysTrue(IgnitePredicate p) {\n        return p == ALWAYS_TRUE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 758,
    "type": "Param",
    "comment": "@param type Type description.",
    "code": "    protected int fillValueParameters(PreparedStatement stmt, int i, EntryMapping m, Object val)\n        throws CacheWriterException {\n        for (CacheQueryTypeDescriptor field : m.uniqValFields) {\n            Object fieldVal = extractField(m.valueType(), field.getJavaName(), val);\n\n            try {\n                if (fieldVal != null)\n                    stmt.setObject(i++, fieldVal);\n                else\n                    stmt.setNull(i++, field.getDbType());\n            }\n            catch (SQLException e) {\n                throw new CacheWriterException(\"Failed to set statement parameter name: \" + field.getDbName(), e);\n            }\n        }\n\n        return i;\n    }\n",
    "label": 1,
    "rec": "@param m Type mapping description."
  },
  {
    "id": 759,
    "type": "Param",
    "comment": "@param file file to parse",
    "code": "  public static Frame parseFrame(Key okey, File file) {\n    if( !file.exists() )\n      throw new RuntimeException(\"File not found \" + file);\n    if(okey == null)\n      okey = Key.make(file.getName());\n    Key fkey = NFSFileVec.make(file);\n    return ParseDataset2.parse(okey, new Key[] { fkey });\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 760,
    "type": "Param",
    "comment": "@param pointer data to access via a buffer or to copy to an array",
    "code": "    public static UShortIndexer create(final ShortPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new UShortRawIndexer(pointer, sizes, strides)\n                                             : new UShortBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            short[] array = new short[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new UShortArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 761,
    "type": "Param",
    "comment": "@param model Authentication flow model",
    "code": "    public Response createFlow(AuthenticationFlowRepresentation flow) {\n        this.auth.requireManage();\n\n        if (flow.getAlias() == null || flow.getAlias().isEmpty()) {\n            return ErrorResponse.exists(\"Failed to create flow with empty alias name\");\n        }\n\n        if (realm.getFlowByAlias(flow.getAlias()) != null) {\n            return ErrorResponse.exists(\"Flow \" + flow.getAlias() + \" already exists\");\n        }\n\n        realm.addAuthenticationFlow(RepresentationToModel.toModel(flow));\n        return Response.status(201).build();\n    }\n",
    "label": 1,
    "rec": "@param flow Authentication flow representation"
  },
  {
    "id": 762,
    "type": "Param",
    "comment": "@param userName",
    "code": "\tpublic boolean isOverloaded(String userId) {\n\n\t\treturn overloadedUsers.containsKey(userId.toLowerCase());\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 763,
    "type": "Param",
    "comment": "@param group Counter group's name.",
    "code": "    public GridHadoopCounter counter(String grp, String name) {\n        return counters.counter(grp, name, true);\n    }\n",
    "label": 1,
    "rec": "@param grp Counter group's name."
  },
  {
    "id": 764,
    "type": "Param",
    "comment": "@param key Entry key.",
    "code": "    public boolean onSwap(KeyCacheObject key, int partId) throws IgniteCheckedException {\n        return onSwapUnswap(key, partId, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 765,
    "type": "Param",
    "comment": "@param repositoryId",
    "code": "    public boolean contains(long id) {\n        if (ids == null)\n            load();\n        return ids.contains(id);\n    }\n",
    "label": 1,
    "rec": "@param id"
  },
  {
    "id": 766,
    "type": "Param",
    "comment": "@param keys Keys to lock.",
    "code": "    private boolean mapAsPrimary(Collection<KeyCacheObject> keys, long topVer) throws IgniteCheckedException {\n        // Assign keys to primary nodes.\n        Collection<KeyCacheObject> distributedKeys = new ArrayList<>(keys.size());\n\n        for (KeyCacheObject key : keys) {\n            if (!cctx.affinity().primary(cctx.localNode(), key, topVer)) {\n                // Remove explicit locks added so far.\n                for (KeyCacheObject k : keys)\n                    cctx.mvcc().removeExplicitLock(threadId, k, lockVer);\n\n                return false;\n            }\n\n            addLocalKey(key, topVer, distributedKeys);\n\n            if (isDone())\n                return true;\n        }\n\n        trackable = false;\n\n        if (tx != null)\n            tx.colocatedLocallyMapped(true);\n\n        if (!distributedKeys.isEmpty()) {\n            if (tx != null) {\n                for (KeyCacheObject key : distributedKeys)\n                    tx.addKeyMapping(cctx.txKey(key), cctx.localNode());\n            }\n\n            lockLocally(distributedKeys, topVer, null);\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 767,
    "type": "Param",
    "comment": "@param startColor starting color - 0 for white, 1 for black",
    "code": "  protected static int appendPattern(boolean[] target, int pos, int[] pattern, boolean startColor) {\n    boolean color = startColor;\n    int numAdded = 0;\n    for (int len : pattern) {\n      for (int j = 0; j < len; j++) {\n        target[pos++] = color;\n      }\n      numAdded += len;\n      color = !color; // flip color after each segment\n    }\n    return numAdded;\n  }\n",
    "label": 1,
    "rec": "@param startColor starting color - false for white, true for black"
  },
  {
    "id": 768,
    "type": "Param",
    "comment": "@param ch A character to convert to an integer digit",
    "code": "    public static int toDigit(char ch, int index) throws IgniteCheckedException {\n        int digit = Character.digit(ch, 16);\n\n        if (digit == -1)\n            throw new IgniteCheckedException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n\n        return digit;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 769,
    "type": "Param",
    "comment": "@param end",
    "code": "  public List<byte[]> lrange(final byte[] key, final long start, final long stop) {\n    checkIsInMultiOrPipeline();\n    client.lrange(key, start, stop);\n    return client.getBinaryMultiBulkReply();\n  }\n",
    "label": 1,
    "rec": "@param stop"
  },
  {
    "id": 770,
    "type": "Param",
    "comment": "@param entry Entry to add.",
    "code": "    @Nullable private GridCacheMvccCandidate<K> addEntry(AffinityTopologyVersion topVer, GridNearCacheEntry<K, V> entry, UUID dhtNodeId)\n        throws GridCacheEntryRemovedException {\n        // Check if lock acquisition is timed out.\n        if (timedOut)\n            return null;\n\n        // Add local lock first, as it may throw GridCacheEntryRemovedException.\n        GridCacheMvccCandidate<K> c = entry.addNearLocal(\n            dhtNodeId,\n            threadId,\n            lockVer,\n            timeout,\n            !inTx(),\n            inTx(),\n            implicitSingleTx()\n        );\n\n        if (inTx()) {\n            IgniteTxEntry<K, V> txEntry = tx.entry(entry.txKey());\n\n            txEntry.cached(entry, txEntry.keyBytes());\n        }\n\n        if (c != null)\n            c.topologyVersion(topVer);\n\n        synchronized (mux) {\n            entries.add(entry);\n        }\n\n        if (c == null && timeout < 0) {\n            if (log.isDebugEnabled())\n                log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n\n            onFailed(false);\n\n            return null;\n        }\n\n        // Double check if lock acquisition has already timed out.\n        if (timedOut) {\n            entry.removeLock(lockVer);\n\n            return null;\n        }\n\n        return c;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 771,
    "type": "Param",
    "comment": "@param out Output stream to that file.",
    "code": "    private GridGgfsFileWorkerBatch newBatch(final GridGgfsPath path, GridGgfsWriter writer) throws GridException {\n        assert path != null;\n        assert writer != null;\n\n        if (busyLock.enterBusy()) {\n            try {\n                GridGgfsFileWorkerBatch batch = new GridGgfsFileWorkerBatch(path, writer);\n\n                while (true) {\n                    GridGgfsFileWorker worker = workerMap.get(path);\n\n                    if (worker != null) {\n                        if (worker.addBatch(batch)) // Added batch to active worker.\n                            break;\n                        else\n                            workerMap.remove(path, worker); // Worker is stopping. Remove it from map.\n                    }\n                    else {\n                        worker = new GridGgfsFileWorker(\"ggfs-file-worker-\" + path) {\n                            @Override protected void onFinish() {\n                                workerMap.remove(path, this);\n                            }\n                        };\n\n                        boolean b = worker.addBatch(batch);\n\n                        assert b;\n\n                        if (workerMap.putIfAbsent(path, worker) == null) {\n                            worker.start();\n\n                            break;\n                        }\n                    }\n                }\n\n                return batch;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new GridException(\"Cannot create new output stream to the secondary file system because GGFS is \" +\n                \"stopping: \" + path);\n    }\n",
    "label": 1,
    "rec": "@param writer Writer of that file."
  },
  {
    "id": 772,
    "type": "Param",
    "comment": "@param data JSONArray of arguments to the plugin",
    "code": "    public PluginResult execute(String action, JSONArray data, String callbackId) {\n        PluginResult result = null;\n        if (NOTIFY.equals(action)) {\n            try {\n                String tag = data.getString(0);\n                String title = data.getString(1);\n                String body = data.getString(2);\n                Log.d(\"NotificationPlugin\", \"Notification: \" + tag + \", \" + title + \", \" + body);\n                showNotification(tag, title, body);\n                result = new PluginResult(Status.OK);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \"\n                        + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else if (CLEAR.equals(action)){\n            try {\n                String tag = data.getString(0);\n                Log.d(\"NotificationPlugin\", \"Notification cancel: \" + tag);\n                clearNotification(tag);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \" + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else {\n            result = new PluginResult(Status.INVALID_ACTION);\n            Log.d(\"NotificationPlugin\", \"Invalid action : \"+action+\" passed\");\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 773,
    "type": "Param",
    "comment": "@param account the Account of a newly authenticated user.",
    "code": "    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\n        assertPrincipals(info);\n\n        //get any existing session that may exist - we don't want to lose it:\n        Subject subject = getSubject();\n        Session session = null;\n        if (subject != null) {\n            session = subject.getSession(false);\n        }\n\n        InetAddress authcSourceIP = null;\n        if (token instanceof InetAuthenticationToken) {\n            authcSourceIP = ((InetAuthenticationToken) token).getInetAddress();\n        }\n        if (authcSourceIP == null) {\n            //try the thread local:\n            authcSourceIP = ThreadContext.getInetAddress();\n        }\n\n        return createSubject(info.getPrincipals(), session, true, authcSourceIP);\n    }\n",
    "label": 1,
    "rec": "@param info the AuthenticationInfo of a newly authenticated user."
  },
  {
    "id": 774,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorExecutorServiceConfiguration from(IgniteConfiguration c) {\n        VisorExecutorServiceConfiguration cfg = new VisorExecutorServiceConfiguration();\n\n        cfg.executeService(compactClass(c.getExecutorService()));\n        cfg.executeServiceShutdown(c.getExecutorServiceShutdown());\n\n        cfg.systemExecutorService(compactClass(c.getSystemExecutorService()));\n        cfg.systemExecutorServiceShutdown(c.getSystemExecutorServiceShutdown());\n\n        cfg.p2pExecutorService(compactClass(c.getPeerClassLoadingExecutorService()));\n        cfg.p2pExecutorServiceShutdown(c.getSystemExecutorServiceShutdown());\n\n        GridClientConnectionConfiguration cc = c.getClientConnectionConfiguration();\n\n        if (cc != null) {\n            cfg.restExecutorService(compactClass(cc.getRestExecutorService()));\n            cfg.restExecutorServiceShutdown(cc.isRestExecutorServiceShutdown());\n        }\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 775,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 776,
    "type": "Param",
    "comment": "@param context the subject context data that may provide (directly or indirectly through one of its values) a  PrincipalCollection identity.",
    "code": "    protected SubjectContext resolvePrincipals(SubjectContext context) {\n        PrincipalCollection principals = context.resolvePrincipals();\n        if (CollectionUtils.isEmpty(principals)) {\n            log.trace(\"No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.\");\n            principals = getRememberedIdentity(context);\n            if (!CollectionUtils.isEmpty(principals)) {\n                log.debug(\"Found remembered PrincipalCollection.  Adding to the context to be used \" +\n                        \"for subject construction by the SubjectFactory.\");\n                context.setPrincipals(principals);\n            } else {\n                log.trace(\"No remembered identity found.  Returning original context.\");\n            }\n        }\n\n        return context;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 777,
    "type": "Param",
    "comment": "@param maxWeight - The maximum weight of the knapsack",
    "code": "  public static int knapsack(int capacity, int [] W, int [] V) {\n    \n    if (W == null || V == null || W.length != V.length || capacity < 0) \n      throw new IllegalArgumentException(\"Invalid input\");\n    \n    final int N = W.length;\n    \n    // Initialize a table where individual rows represent items \n    // and columns represent the weight of the knapsack\n    int[][] DP = new int[N+1][capacity+1];\n    \n    for (int i = 1; i <= N; i++) {\n      \n      // Get the value and weight of the item\n      int w = W[i-1], v = V[i-1];\n      \n      for (int sz = 1; sz <= capacity; sz++) {\n        \n        // Consider not picking this element\n        DP[i][sz] = DP[i-1][sz];\n        \n        // Consider including the current element and\n        // see if this would be more profitable\n        if (sz >= w && DP[i-1][sz-w] + v > DP[i][sz])\n          DP[i][sz] = DP[i-1][sz-w] + v;\n        \n      }\n      \n    }\n    \n    int sz = capacity;\n    java.util.List <Integer> itemsSelected = new java.util.ArrayList<>();\n    \n    // Using the information inside the table we can backtrack and determine\n    // which items were selected during the dynamic programming phase. The idea\n    // is that if DP[i][sz] != DP[i-1][sz] then the item was selected\n    for (int i = N; i > 0; i--) {\n      if (DP[i][sz] != DP[i-1][sz]) {\n        int itemIndex = i-1;\n        itemsSelected.add(itemIndex);\n        sz -= W[itemIndex];\n      }\n    }\n    \n    // Return the items that were selected\n    // java.util.Collections.reverse(itemsSelected);\n    // return itemsSelected;\n    \n    // Return the maximum profit\n    return DP[N][capacity];\n    \n  }\n",
    "label": 1,
    "rec": "@param capacity - The maximum capacity of the knapsack"
  },
  {
    "id": 778,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public List<ClusterNode> nodes(K key, AffinityTopologyVersion topVer) {\n        return nodes(partition(key), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 779,
    "type": "Param",
    "comment": "@param end End of the interval (must be lesser or equal than maximum time)",
    "code": "    public BufferedImage createTimeIntervalImage(double starts[], double ends[], int width, int height, Color fill, Color border, Color background) {\n        if (starts.length != ends.length) {\n            throw new IllegalArgumentException(\"start and ends length should be equal\");\n        }\n        if (fill == null) {\n            fill = DEFAULT_FILL;\n        }\n        if (border == null) {\n            border = DEFAULT_BORDER;\n        }\n\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n\n        final Graphics2D g = image.createGraphics();\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n        //Draw brackground if any:\n        if (background != null) {\n            g.setBackground(background);\n            g.clearRect(0, 0, width, height);\n        }\n\n        g.translate(1, 0);//Start drawing at pixel 1\n\n        width -= 2;//Reduce fill area in 2 pixels for the borders\n        double xTickWidth = (double) width / range;\n\n        //Draw time interval filled parts:\n        if (range == 0) {//No range, Min=Max\n            //Fill all drawing area:\n            g.setColor(fill);\n            g.fillRect(0, 0, width, height);\n            g.setColor(border);\n            //Draw borders:\n            g.drawLine(-1, 0, -1, height);\n            g.drawLine(width, 0, width, height);\n        } else {\n            int startPixel, endPixel;\n            for (int i = 0; i < starts.length; i++) {\n                g.setColor(fill);\n                startPixel = (int) (xTickWidth * (normalizeToRange(starts[i]) - min));\n                endPixel = (int) (xTickWidth * (normalizeToRange(ends[i]) - min));\n\n                int rectWidth = endPixel - startPixel;\n                if (rectWidth == 0) {\n                    rectWidth = 1;//Draw at least 1 pixel if a range is small\n                }\n                g.fillRect(startPixel, 0, rectWidth, height);\n\n                //Draw borders:\n                g.setColor(border);\n                g.drawLine(startPixel, 0, startPixel, height);\n                g.drawLine(endPixel, 0, endPixel, height);\n            }\n        }\n\n        return image;\n    }\n",
    "label": 1,
    "rec": "@param ends Ends of the intervals (must be lesser or equal than maximum time)"
  },
  {
    "id": 780,
    "type": "Param",
    "comment": "@param ver Version to use.",
    "code": "    @Override protected void clearIndex(CacheObject val) {\n        // No-op.\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 781,
    "type": "Param",
    "comment": "@param writer Writer.",
    "code": "    private boolean writeHeader(Object obj, BinaryWriterExImpl writer) {\n        if (writer.tryWriteAsHandle(obj))\n            return false;\n\n        if (registered) {\n            PortableUtils.writeHeader(\n                writer,\n                typeId,\n                obj instanceof CacheObjectImpl ? 0 : obj.hashCode(),\n                null\n            );\n        }\n        else {\n            PortableUtils.writeHeader(\n                writer,\n                GridPortableMarshaller.UNREGISTERED_TYPE_ID,\n                obj instanceof CacheObjectImpl ? 0 : obj.hashCode(),\n                cls.getName()\n            );\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 782,
    "type": "Param",
    "comment": "@param cfg path to config file.",
    "code": "    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.mesosUrl = getStringProperty(MESOS_MASTER_URL, props, DEFAULT_MESOS_MASTER_URL);\n\n            prop.httpServerHost = getStringProperty(IGNITE_HTTP_SERVER_HOST, props, getNonLoopbackAddress());\n\n            String port = System.getProperty(\"PORT0\");\n\n            if (port != null && !port.isEmpty())\n                prop.httpServerPort = Integer.valueOf(port);\n            else\n                prop.httpServerPort = Integer.valueOf(getStringProperty(IGNITE_HTTP_SERVER_PORT, props,\n                    DEFAULT_HTTP_SERVER_PORT));\n\n            prop.clusterName = getStringProperty(IGNITE_CLUSTER_NAME, props, DEFAULT_CLUSTER_NAME);\n\n            prop.userLibsUrl = getStringProperty(IGNITE_USERS_LIBS_URL, props, null);\n            prop.ignitePackageUrl = getStringProperty(IGNITE_PACKAGE_URL, props, null);\n            prop.licenceUrl = getStringProperty(LICENCE_URL, props, null);\n            prop.igniteCfgUrl = getStringProperty(IGNITE_CONFIG_XML_URL, props, null);\n\n            prop.cpu = getDoubleProperty(IGNITE_TOTAL_CPU, props, UNLIMITED);\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RUN_CPU_PER_NODE, props, UNLIMITED);\n            prop.mem = getDoubleProperty(IGNITE_TOTAL_MEMORY, props, UNLIMITED);\n            prop.memPerNode = getDoubleProperty(IGNITE_MEMORY_PER_NODE, props, UNLIMITED);\n            prop.disk = getDoubleProperty(IGNITE_TOTAL_DISK_SPACE, props, UNLIMITED);\n            prop.diskPerNode = getDoubleProperty(IGNITE_DISK_SPACE_PER_NODE, props, 1024.0);\n            prop.nodeCnt = getDoubleProperty(IGNITE_NODE_COUNT, props, UNLIMITED);\n            prop.minCpu = getDoubleProperty(IGNITE_MIN_CPU_PER_NODE, props, DEFAULT_RESOURCE_MIN_CPU);\n            prop.minMemory = getDoubleProperty(IGNITE_MIN_MEMORY_PER_NODE, props, DEFAULT_RESOURCE_MIN_MEM);\n\n            prop.jvmOpts = getStringProperty(IGNITE_JVM_OPTS, props, \"\");\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORK_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            String pattern = getStringProperty(IGNITE_HOSTNAME_CONSTRAINT, props, null);\n\n            if (pattern != null) {\n                try {\n                    prop.hostnameConstraint = Pattern.compile(pattern);\n                }\n                catch (PatternSyntaxException e) {\n                    log.log(Level.WARNING, \"IGNITE_HOSTNAME_CONSTRAINT has invalid pattern. It will be ignore.\", e);\n                }\n            }\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 1,
    "rec": "@param config path to config file."
  },
  {
    "id": 783,
    "type": "Param",
    "comment": "@param task task to consider",
    "code": "    private boolean shouldTransmit(TaskContainer task, Property<?> property, TaskContainer remoteTask) {\n        if(!task.task.containsValue(property))\n            return false;\n\n        if(remoteTask == null)\n            return true;\n        if(!remoteTask.task.containsValue(property))\n            return true;\n        return !AndroidUtilities.equals(task.task.getValue(property),\n                remoteTask.task.getValue(property));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 784,
    "type": "Param",
    "comment": "@param integer the value to increment by",
    "code": "  public Double incrByFloat(final byte[] key, final double increment) {\n    checkIsInMultiOrPipeline();\n    client.incrByFloat(key, increment);\n    String dval = client.getBulkReply();\n    return (dval != null ? new Double(dval) : null);\n  }\n",
    "label": 1,
    "rec": "@param increment the value to increment by"
  },
  {
    "id": 785,
    "type": "Param",
    "comment": "@param entry Entry to touch.",
    "code": "    private boolean touch(Entry<GridGgfsBlockKey, byte[]> entry) {\n        byte[] val = entry.peek();\n\n        int blockSize = val != null ? val.length : 0;\n\n        MetaEntry meta = entry.meta(META_NODE);\n\n        // Entry has not been enqueued yet.\n        if (meta == null) {\n            while (true) {\n                Node<Entry<GridGgfsBlockKey, byte[]>> node = queue.offerLastx(entry);\n\n                meta = new MetaEntry(node, blockSize);\n\n                if (entry.putMetaIfAbsent(META_NODE, meta) != null) {\n                    // Was concurrently added, need to clear it from queue.\n                    queue.unlinkx(node);\n\n                    // Queue has not been changed.\n                    return false;\n                }\n                else if (node.item() != null) {\n                    if (!entry.isCached()) {\n                        // Was concurrently evicted, need to clear it from queue.\n                        queue.unlinkx(node);\n\n                        return false;\n                    }\n\n                    // Increment current size.\n                    changeSize(blockSize);\n\n                    return true;\n                }\n                // If node was unlinked by concurrent shrink() call, we must repeat the whole cycle.\n                else if (!entry.removeMeta(META_NODE, node))\n                    return false;\n            }\n        }\n        else {\n            int oldBlockSize = meta.size();\n\n            Node<Entry<GridGgfsBlockKey, byte[]>> node = meta.node();\n\n            if (queue.unlinkx(node)) {\n                // Move node to tail.\n                Node<Entry<GridGgfsBlockKey, byte[]>> newNode = queue.offerLastx(entry);\n\n                int delta = blockSize - oldBlockSize;\n\n                if (!entry.replaceMeta(META_NODE, meta, new MetaEntry(newNode, blockSize))) {\n                    // Was concurrently added, need to clear it from queue.\n                    if (queue.unlinkx(newNode))\n                        delta -= blockSize;\n                }\n\n                if (delta != 0) {\n                    changeSize(delta);\n\n                   if (delta > 0)\n                       // Total size increased, so shrinking could be needed.\n                       return true;\n                }\n            }\n        }\n\n        // Entry is already in queue.\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 786,
    "type": "Param",
    "comment": "@param nodeId Node ID.",
    "code": "    private GridProjection forOthers(Collection<UUID> excludeIds) {\n        assert excludeIds != null;\n\n        if (ids != null) {\n            guard();\n\n            try {\n                Set<UUID> nodeIds = new HashSet<>(ids.size());\n\n                for (UUID id : ids) {\n                    if (!excludeIds.contains(id))\n                        nodeIds.add(id);\n                }\n\n                return new GridProjectionAdapter(this, ctx, nodeIds);\n            }\n            finally {\n                unguard();\n            }\n        }\n        else\n            return forPredicate(new OthersFilter(excludeIds));\n    }\n",
    "label": 1,
    "rec": "@param excludeIds Node IDs."
  },
  {
    "id": 787,
    "type": "Param",
    "comment": "@param topOrder Maximum allowed node order.",
    "code": "    public static Collection<ClusterNode> allNodes(GridCacheSharedContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().cacheNodes(topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 788,
    "type": "Param",
    "comment": "@param recipient ID of the recipient.",
    "code": "        public boolean addRecipient(Object rcpt) {\n            synchronized (recipients) {\n                if (isDone())\n                    return false;\n\n                assert !recipients.containsKey(rcpt) : rcpt + \" -> \" + recipients;\n\n                recipients.put(rcpt, new QueueIterator(rcpt));\n            }\n\n            return true;\n        }\n",
    "label": 1,
    "rec": "@param rcpt ID of the recipient."
  },
  {
    "id": 789,
    "type": "Param",
    "comment": "@param len Length.",
    "code": "    private static String parseExpression(String text, int startPos, int len, OdbcEscapeType type, Pattern pattern) {\n        String val = parseExpression(text, startPos, len);\n\n        if (!pattern.matcher(val).matches())\n            throw new IgniteException(\"Invalid \" + type + \" escape sequence: \" + substring(text, startPos, len));\n\n        return val;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 790,
    "type": "Param",
    "comment": "@param pDegrees",
    "code": "    public double finalQ(int[] struct, double[] degrees, HierarchicalUndirectedGraph graph, AttributeModel attributeModel) {\n        AttributeTable nodeTable = attributeModel.getNodeTable();\n        AttributeColumn modCol = nodeTable.getColumn(MODULARITY_CLASS);\n        if (modCol == null) {\n            modCol = nodeTable.addColumn(MODULARITY_CLASS, \"Modularity Class\", AttributeType.INT, AttributeOrigin.COMPUTED, new Integer(0));\n        }\n\n        double res = 0;\n        double[] internal = new double[degrees.length];\n        for (Node n : graph.getNodes()) {\n            int n_index = structure.map.get(n);\n            AttributeRow row = (AttributeRow) n.getNodeData().getAttributes();\n            row.setValue(modCol, struct[n_index]);\n            for (Node neighbor : graph.getNeighbors(n)) {\n                if (n == neighbor) {\n                    continue;\n                }\n                int neigh_index = structure.map.get(neighbor);\n                if (struct[neigh_index] == struct[n_index]) {\n                    internal[struct[neigh_index]]++;\n                }\n            }\n        }\n        for (int i = 0; i < degrees.length; i++) {\n            internal[i] /= 2.0;\n            res += (internal[i] / graph.getEdgeCount()) - Math.pow(degrees[i] / (2 * graph.getEdgeCount()), 2);\n        }\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param degrees"
  },
  {
    "id": 791,
    "type": "Param",
    "comment": "@param matcher decides whether argument matches",
    "code": "    public static char charThat(ArgumentMatcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 792,
    "type": "Param",
    "comment": "@param c Cache.",
    "code": "    public static VisorCacheMetrics from(IgniteEx ignite, String cacheName) {\n        VisorCacheMetrics cm = new VisorCacheMetrics();\n\n        GridCacheProcessor cacheProcessor = ignite.context().cache();\n\n        IgniteCache<Object, Object> c = cacheProcessor.jcache(cacheName);\n\n        cm.name = cacheName;\n        cm.mode = cacheProcessor.cacheMode(cacheName);\n        cm.sys = cacheProcessor.systemCache(cacheName);\n\n        CacheMetrics m = c.metrics();\n\n        cm.size = m.getSize();\n        cm.keySize = m.getKeySize();\n\n        cm.reads = m.getCacheGets();\n        cm.writes = m.getCachePuts() + m.getCacheRemovals();\n        cm.hits = m.getCacheHits();\n        cm.misses = m.getCacheMisses();\n\n        cm.txCommits = m.getCacheTxCommits();\n        cm.txRollbacks = m.getCacheTxRollbacks();\n\n        cm.avgTxCommitTime = m.getAverageTxCommitTime();\n        cm.avgTxRollbackTime = m.getAverageTxRollbackTime();\n\n        cm.puts = m.getCachePuts();\n        cm.removals = m.getCacheRemovals();\n        cm.evictions = m.getCacheEvictions();\n\n        cm.avgReadTime = m.getAverageGetTime();\n        cm.avgPutTime = m.getAveragePutTime();\n        cm.avgRemovalTime = m.getAverageRemoveTime();\n\n        cm.readsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageGetTime());\n        cm.writesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAveragePutTime());\n        cm.hitsPerSec = -1;\n        cm.missesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageRemoveTime());\n        cm.commitsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxCommitTime());\n        cm.rollbacksPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxRollbackTime());\n\n        cm.qryMetrics = VisorCacheQueryMetrics.from(c.queryMetrics());\n\n        cm.dhtEvictQueueCurrSize = m.getDhtEvictQueueCurrentSize();\n        cm.txThreadMapSize = m.getTxThreadMapSize();\n        cm.txXidMapSize = m.getTxXidMapSize();\n        cm.txCommitQueueSize = m.getTxCommitQueueSize();\n        cm.txPrepareQueueSize = m.getTxPrepareQueueSize();\n        cm.txStartVerCountsSize = m.getTxStartVersionCountsSize();\n        cm.txCommittedVersionsSize = m.getTxCommittedVersionsSize();\n        cm.txRolledbackVersionsSize = m.getTxRolledbackVersionsSize();\n        cm.txDhtThreadMapSize = m.getTxDhtThreadMapSize();\n        cm.txDhtXidMapSize = m.getTxDhtXidMapSize();\n        cm.txDhtCommitQueueSize = m.getTxDhtCommitQueueSize();\n        cm.txDhtPrepareQueueSize = m.getTxDhtPrepareQueueSize();\n        cm.txDhtStartVerCountsSize = m.getTxDhtStartVersionCountsSize();\n        cm.txDhtCommittedVersionsSize = m.getTxDhtCommittedVersionsSize();\n        cm.txDhtRolledbackVersionsSize = m.getTxDhtRolledbackVersionsSize();\n\n        return cm;\n    }\n",
    "label": 1,
    "rec": "@param cacheName Cache name."
  },
  {
    "id": 793,
    "type": "Param",
    "comment": "@param store",
    "code": "  private Criteria createCriteria(HttpServletRequest request) {\n    Criteria criteria = ServiceRequestCriteriaBuilderUtils.buildRequest(MAPPING_FIELDS, request);\n\n    //Optional.ofNullable(start).ifPresent(criteria::setStartIndex);\n    //Optional.ofNullable(count).ifPresent(criteria::setMaxCount);\n\n    return criteria;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 794,
    "type": "Param",
    "comment": "@param c Actual cache.",
    "code": "    public VisorCache from(IgniteEx ignite, String cacheName, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n\n        GridCacheAdapter ca = ignite.context().cache().internalCache(cacheName);\n\n        // Cache was not started.\n        if (ca == null || !ca.context().started())\n            return null;\n\n        GridCacheContext cctx = ca.context();\n\n        name = cacheName;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cctx.affinityNode();\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0) {\n                    partitionsMap = top.localPartitionMap();\n                }\n            }\n        }\n\n        size = ca.size();\n        nearSize = ca.nearSize();\n        dynamicDeploymentId = cctx.dynamicDeploymentId();\n        dhtSize = size - nearSize;\n        primarySize = ca.primarySize();\n        offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        offHeapEntriesCnt = ca.offHeapEntriesCount();\n        partitions = ca.affinity().partitions();\n        metrics = new VisorCacheMetrics().from(ignite, cacheName);\n        near = cctx.isNear();\n\n        estimateMemorySize(ignite, ca, sample);\n\n        return this;\n    }\n",
    "label": 1,
    "rec": "@param cacheName Cache name."
  },
  {
    "id": 795,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    private boolean mapAsPrimary(Collection<? extends K> keys, AffinityTopologyVersion topVer) throws IgniteCheckedException {\n        // Assign keys to primary nodes.\n        Collection<K> distributedKeys = new ArrayList<>(keys.size());\n\n        for (K key : keys) {\n            if (!cctx.affinity().primary(cctx.localNode(), key, topVer)) {\n                // Remove explicit locks added so far.\n                for (K k : keys)\n                    cctx.mvcc().removeExplicitLock(threadId, k, lockVer);\n\n                return false;\n            }\n\n            addLocalKey(key, topVer, distributedKeys);\n\n            if (isDone())\n                return true;\n        }\n\n        trackable = false;\n\n        if (tx != null)\n            tx.colocatedLocallyMapped(true);\n\n        if (!distributedKeys.isEmpty()) {\n            if (tx != null) {\n                for (K key : distributedKeys)\n                    tx.addKeyMapping(cctx.txKey(key), cctx.localNode());\n            }\n\n            lockLocally(distributedKeys, topVer, null);\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 796,
    "type": "Param",
    "comment": "@param filter Filter.",
    "code": "    public Collection<V> values(IgnitePredicate<GridCacheEntry<K, V>>... filter) {\n        checkWeakQueue();\n\n        return allValues(filter);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 797,
    "type": "Param",
    "comment": "@param methodDescriptor",
    "code": "    public boolean isLocalMethod(String methodSignature) {\n        String[] parts = methodSignature.split(\"->\");\n        String className = parts[0];\n        if (!isLocalClass(className)) {\n            return false;\n        }\n\n        return getMethod(methodSignature) != null;\n    }\n",
    "label": 1,
    "rec": "@param methodSignature"
  },
  {
    "id": 798,
    "type": "Param",
    "comment": "@param ctx Cache context.",
    "code": "    public static Collection<ClusterNode> aliveRemoteNodes(final GridCacheContext ctx, AffinityTopologyVersion topOrder) {\n        return ctx.discovery().aliveRemoteCacheNodes(ctx.namex(), topOrder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 799,
    "type": "Param",
    "comment": "@param taskInfo Task info.",
    "code": "    public GridHadoopTaskInput input(GridHadoopTaskContext taskCtx) throws GridException {\n        switch (taskCtx.taskInfo().type()) {\n            case COMBINE:\n                return combinerMap.input((Comparator<Object>)job.combineGroupComparator());\n\n            case REDUCE:\n                int reducer = taskCtx.taskInfo().taskNumber();\n\n                GridHadoopMultimap m = maps.get(reducer);\n\n                if (m != null)\n                    return m.input((Comparator<Object>)job.reduceGroupComparator());\n\n                return new GridHadoopTaskInput() { // Empty input.\n                    @Override public boolean next() {\n                        return false;\n                    }\n\n                    @Override public Object key() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public Iterator<?> values() {\n                        throw new IllegalStateException();\n                    }\n\n                    @Override public void close() {\n                        // No-op.\n                    }\n                };\n\n            default:\n                throw new IllegalStateException(\"Illegal type: \" + taskCtx.taskInfo().type());\n        }\n    }\n",
    "label": 1,
    "rec": "@param taskCtx Task info."
  },
  {
    "id": 800,
    "type": "Param",
    "comment": "@param cache Cache.",
    "code": "    private Thread runCacheOperations(final IgniteInternalCache<Object,Object> cache, final int keys) {\n        Thread t = new Thread() {\n            @Override public void run() {\n                while (run) {\n                    TreeMap<Integer, String> vals = generateValues(keys);\n\n                    try {\n                        // Explicit lock.\n                        cache.lock(vals.firstKey(), 0);\n\n                        try {\n                            // Put or remove.\n                            if (ThreadLocalRandom.current().nextDouble(1) < 0.65)\n                                cache.putAll(vals);\n                            else\n                                cache.removeAll(vals.keySet());\n                        }\n                        catch (Exception e) {\n                            U.error(log(), \"Failed cache operation.\", e);\n                        }\n                        finally {\n                            cache.unlock(vals.firstKey());\n                        }\n\n                        U.sleep(100);\n                    }\n                    catch (Exception e){\n                        U.error(log(), \"Failed unlock.\", e);\n                    }\n                }\n            }\n        };\n\n        t.start();\n\n        return t;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 801,
    "type": "Param",
    "comment": "@param deserializePortable Deserialize portable flag.",
    "code": "    @Nullable public V get(K key, boolean deserializeBinary)\n        throws IgniteCheckedException {\n        return getAsync(key, deserializeBinary).get();\n    }\n",
    "label": 1,
    "rec": "@param deserializeBinary Deserialize binary flag."
  },
  {
    "id": 802,
    "type": "Param",
    "comment": "@param aff Cache affinity.",
    "code": "    private Object keyForNode(Affinity<Object> aff, ClusterNode node) {\n        assertNotNull(node);\n\n        Object key = null;\n\n        for (int i = 0; i < 1000; i++) {\n            if (aff.isPrimary(node, i)) {\n                key = i;\n\n                break;\n            }\n        }\n\n        assertNotNull(key);\n\n        return key;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 803,
    "type": "Param",
    "comment": "@param deviceNumber The bulb number the bridge has filed the bulb under.",
    "code": "\tpublic int getColorTemperature(String deviceId) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 154;\n\t\t}\n\t\tObject ct = settingsData.node(\"lights\").node(deviceId).node(\"state\").value(\"ct\");\n\t\tif(ct instanceof Integer) {\n\t\t\treturn (Integer) ct;\n\t\t} else {\n\t\t\treturn 154;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@param deviceId The bulb id the bridge has filed the bulb under."
  },
  {
    "id": 804,
    "type": "Param",
    "comment": "@param obsoleteVer Obsolete version.",
    "code": "    protected boolean evictNearEntry(GridCacheEntryEx<K, V> e, GridCacheVersion obsoleteVer, long topVer) {\n        assert e != null;\n        assert obsoleteVer != null;\n\n        if (isNearLocallyMapped(e, topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Evicting dht-local entry from near cache [entry=\" + e + \", tx=\" + this + ']');\n\n            if (e.markObsolete(obsoleteVer))\n                return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 805,
    "type": "Param",
    "comment": "@param unique Unique index.",
    "code": "        public IndexDescriptor addIndex(String idxName, GridIndexType type) throws GridException {\n            IndexDescriptor idx = new IndexDescriptor(type);\n\n            if (indexes.put(idxName, idx) != null)\n                throw new GridException(\"Index with name '\" + idxName + \"' already exists.\");\n\n            return idx;\n        }\n",
    "label": 1,
    "rec": "@param type Index type."
  },
  {
    "id": 806,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "    public Collection<ClusterNode> remoteCacheNodes(AffinityTopologyVersion topVer) {\n        return resolveDiscoCache(null, topVer).remoteCacheNodes(topVer.topologyVersion());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 807,
    "type": "Param",
    "comment": "@param string",
    "code": "    public Long lpush(final byte[] key, final byte[]... strings) {\n        checkIsInMulti();\n        client.lpush(key, strings);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param strings"
  },
  {
    "id": 808,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    long entryExpireTime(GridCacheTxKey<K> key) {\n        assert key != null;\n\n        GridCacheTxEntry<K, V> e = entry(key);\n\n        if (e != null) {\n            long ttl = e.ttl();\n\n            assert ttl != -1;\n\n            if (ttl > 0) {\n                long expireTime = U.currentTimeMillis() + ttl;\n\n                if (expireTime > 0)\n                    return expireTime;\n            }\n        }\n\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 809,
    "type": "Param",
    "comment": "@param i Start index for parameters.",
    "code": "    protected int fillValueParameters(PreparedStatement stmt, int idx, EntryMapping em, Object val)\n        throws CacheWriterException {\n        for (CacheTypeFieldMetadata field : em.uniqValFields) {\n            Object fieldVal = extractField(em.cacheName, em.valueType(), field.getJavaName(), val);\n\n            try {\n                if (fieldVal != null)\n                    stmt.setObject(idx++, fieldVal);\n                else\n                    stmt.setNull(idx++, field.getDatabaseType());\n            }\n            catch (SQLException e) {\n                throw new CacheWriterException(\"Failed to set statement parameter name: \" + field.getDatabaseName(), e);\n            }\n        }\n\n        return idx;\n    }\n",
    "label": 1,
    "rec": "@param idx Start index for parameters."
  },
  {
    "id": 810,
    "type": "Param",
    "comment": "@param props Properties to be applied.",
    "code": "    public boolean mkdirsDual(final IgniteFsFileSystem fs, final IgniteFsPath path, final Map<String, String> props)\n        throws GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert fs != null;\n                assert path != null;\n                assert props != null;\n\n                if (path.parent() == null)\n                    return true; // No additional handling for root directory is needed.\n\n                // Events to fire (can be done outside of a transaction).\n                final Deque<IgniteFsEvent> pendingEvts = new LinkedList<>();\n\n                SynchronizationTask<Boolean> task = new SynchronizationTask<Boolean>() {\n                    @Override public Boolean onSuccess(Map<IgniteFsPath, GridGgfsFileInfo> infos) throws Exception {\n                        fs.mkdirs(path, props);\n\n                        assert !infos.isEmpty();\n\n                        // Now perform synchronization again starting with the last created parent.\n                        IgniteFsPath parentPath = null;\n\n                        for (IgniteFsPath curPath : infos.keySet()) {\n                            if (parentPath == null || curPath.isSubDirectoryOf(parentPath))\n                                parentPath = curPath;\n                        }\n\n                        assert parentPath != null;\n\n                        GridGgfsFileInfo parentPathInfo = infos.get(parentPath);\n\n                        synchronize(fs, parentPath, parentPathInfo, path, true, null);\n\n                        if (evts.isRecordable(EVT_GGFS_DIR_CREATED)) {\n                            IgniteFsPath evtPath = path;\n\n                            while (!parentPath.equals(evtPath)) {\n                                pendingEvts.addFirst(new IgniteFsEvent(evtPath, locNode, EVT_GGFS_DIR_CREATED));\n\n                                evtPath = evtPath.parent();\n\n                                assert evtPath != null; // If this fails, then ROOT does not exist.\n                            }\n                        }\n\n                        return true;\n                    }\n\n                    @Override public Boolean onFailure(@Nullable Exception err) throws GridException {\n                        U.error(log, \"Directory creation in DUAL mode failed [path=\" + path + \", properties=\" + props +\n                            ']', err);\n\n                        throw new GridException(\"Failed to create the path due to secondary file system exception: \" +\n                            path, err);\n                    }\n                };\n\n                try {\n                    return synchronizeAndExecute(task, fs, false, path.parent());\n                }\n                finally {\n                    for (IgniteFsEvent evt : pendingEvts)\n                        evts.record(evt);\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to create directory in DUAL mode because Grid is stopping: \" +\n                path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 811,
    "type": "Param",
    "comment": "@param millis - duration in milliseconds",
    "code": "    public static VerificationAfterDelay after(Duration delay) {\n        return new After(delay, VerificationModeFactory.times(1));\n    }\n",
    "label": 1,
    "rec": "@param delay how to to wait before triggering verification"
  },
  {
    "id": 812,
    "type": "Param",
    "comment": "@param k the number of cluster.",
    "code": "    public static int[] seed(double[][] data, int k, ClusteringDistance distance) {\n        int n = data.length;\n        int[] y = new int[n];\n        double[] centroid = data[Math.randomInt(n)];\n\n        double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = Double.MAX_VALUE;\n        }\n\n        // pick the next center\n        for (int j = 1; j < k; j++) {\n            // Loop over the samples and compare them to the most recent center.  Store\n            // the distance from each sample to its closest center in scores.\n            for (int i = 0; i < n; i++) {\n                // compute the distance between this sample and the current center\n                double dist = 0.0;\n                switch (distance) {\n                    case EUCLIDEAN:\n                        dist = Math.squaredDistance(data[i], centroid);\n                        break;\n                    case EUCLIDEAN_MISSING_VALUES:\n                        dist = squaredDistance(data[i], centroid);\n                        break;\n                    case JENSEN_SHANNON_DIVERGENCE:\n                        dist = Math.JensenShannonDivergence(data[i], centroid);\n                        break;\n                }\n                \n                if (dist < d[i]) {\n                    d[i] = dist;\n                    y[i] = j - 1;\n                }\n            }\n\n            double cutoff = Math.random() * Math.sum(d);\n            double cost = 0.0;\n            int index = 0;\n            for (; index < n; index++) {\n                cost += d[index];\n                if (cost >= cutoff) {\n                    break;\n                }\n            }\n\n            centroid = data[index];\n        }\n\n        for (int i = 0; i < n; i++) {\n            // compute the distance between this sample and the current center\n            double dist = 0.0;\n            switch (distance) {\n                case EUCLIDEAN:\n                    dist = Math.squaredDistance(data[i], centroid);\n                    break;\n                case EUCLIDEAN_MISSING_VALUES:\n                    dist = squaredDistance(data[i], centroid);\n                    break;\n                case JENSEN_SHANNON_DIVERGENCE:\n                    dist = Math.JensenShannonDivergence(data[i], centroid);\n                    break;\n            }\n            \n            if (dist < d[i]) {\n                d[i] = dist;\n                y[i] = k - 1;\n            }\n        }\n\n        return y;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 813,
    "type": "Param",
    "comment": "@param callbackContext The callback context used when calling back into JavaScript.",
    "code": "    public PluginResult execute(String action, JSONArray data, String callbackId) {\n        PluginResult result = null;\n        if (NOTIFY.equals(action)) {\n            try {\n                String tag = data.getString(0);\n                String title = data.getString(1);\n                String body = data.getString(2);\n                Log.d(\"NotificationPlugin\", \"Notification: \" + tag + \", \" + title + \", \" + body);\n                showNotification(tag, title, body);\n                result = new PluginResult(Status.OK);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \"\n                        + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else if (CLEAR.equals(action)){\n            try {\n                String tag = data.getString(0);\n                Log.d(\"NotificationPlugin\", \"Notification cancel: \" + tag);\n                clearNotification(tag);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \" + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else {\n            result = new PluginResult(Status.INVALID_ACTION);\n            Log.d(\"NotificationPlugin\", \"Invalid action : \"+action+\" passed\");\n        }\n        return result;\n    }\n",
    "label": 1,
    "rec": "@param callbackId The callback id used when calling back into JavaScript"
  },
  {
    "id": 814,
    "type": "Param",
    "comment": "@param ids Ids to include.",
    "code": "    public Collection<ClusterNode> nodes(@Nullable Collection<UUID> ids, IgnitePredicate<UUID>... p) {\n        return F.isEmpty(ids) ? Collections.<ClusterNode>emptyList() :\n            F.view(\n                F.viewReadOnly(ids, U.id2Node(ctx), p),\n                F.notNull());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 815,
    "type": "Param",
    "comment": "@param userName the username you want",
    "code": "\tpublic User createUser(String userId) {\n\n\t\tif (getUsers().containsKey(userId.toLowerCase())) {\n\t\t\treturn null;\n\t\t}\n\t\tUser newUser = new User(this, userId);\n\t\tnewUser.setGroup(groups.getDefaultGroup(), false);\n\t\taddUser(newUser);\n\t\tsetUsersChanged(true);\n\t\treturn newUser;\n\t}\n",
    "label": 1,
    "rec": "@param userId the UUID or username you want"
  },
  {
    "id": 816,
    "type": "Param",
    "comment": "@param chol",
    "code": "  public Cholesky cholesky(Cholesky chol, int parallelize) {\n    long start = System.currentTimeMillis();\n    if( chol == null ) {\n      double[][] xx = _xx.clone();\n      for( int i = 0; i < xx.length; ++i )\n        xx[i] = xx[i].clone();\n      chol = new Cholesky(xx, _diag.clone());\n    }\n    final Cholesky fchol = chol;\n    final int sparseN = _diag.length;\n    final int denseN = _fullN - sparseN;\n    boolean spd=true;\n    // compute the cholesky of the diagonal and diagonal*dense parts\n    if( _diag != null ) for( int i = 0; i < sparseN; ++i ) {\n      double d = 1.0 / (chol._diag[i] = Math.sqrt(_diag[i]));\n      for( int j = 0; j < denseN; ++j )\n        chol._xx[j][i] = d*_xx[j][i];\n    }\n    Futures fs = new Futures();\n    // compute the outer product of diagonal*dense\n    for( int i = 0; i < denseN; ++i ) {\n      final int fi = i;\n      fs.add(new RecursiveAction() {\n        @Override protected void compute() {\n          for( int j = 0; j <= fi; ++j ) {\n            double s = 0;\n            for( int k = 0; k < sparseN; ++k )\n              s += fchol._xx[fi][k] * fchol._xx[j][k];\n            fchol._xx[fi][j + sparseN] = _xx[fi][j + sparseN] - s;\n          }\n        }\n      }.fork());\n    }\n    fs.blockForPending();\n        \n    // compute the cholesky of dense*dense-outer_product(diagonal*dense)\n    // TODO we still use Jama, which requires (among other things) copy and expansion of the matrix. Do it here without copy and faster.\n    double[][] arr = new double[denseN][];\n    for( int i = 0; i < arr.length; ++i )\n      arr[i] = Arrays.copyOfRange(fchol._xx[i], sparseN, sparseN + denseN);\n\n    Log.info (\"CHOLESKY PRECOMPUTE TIME \" + (System.currentTimeMillis()-start));\n    start = System.currentTimeMillis();\n    // parallelize cholesky\n    if (parallelize == 1) {\n      int p = Runtime.getRuntime().availableProcessors();\n      InPlaceCholesky d = InPlaceCholesky.decompose_2(arr, 10, p);\n      fchol.setSPD(d.isSPD());\n      arr = d.getL();\n      Log.info (\"H2O CHOLESKY DECOMPOSE TAKES: \" + (System.currentTimeMillis()-start));\n    } else {\n      // make it symmetric\n      for( int i = 0; i < arr.length; ++i )\n        for( int j = 0; j < i; ++j )\n          arr[j][i] = arr[i][j];\n      CholeskyDecomposition c = new Matrix(arr).chol();\n      fchol.setSPD(c.isSPD());\n      arr = c.getL().getArray();\n      Log.info (\"JAMA CHOLESKY DECOMPOSE TAKES: \" + (System.currentTimeMillis()-start));\n    }\n    for( int i = 0; i < arr.length; ++i )\n      System.arraycopy(arr[i], 0, fchol._xx[i], sparseN, i + 1);\n    return chol;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 817,
    "type": "Param",
    "comment": "@param col column id",
    "code": "\tpublic double columnMean(int column) {\n\t\tdouble sum = 0.0;\n\n\t\tfor (int i = 0; i < numRows; i++)\n\t\t\tsum += data[i][column];\n\n\t\treturn sum / numRows;\n\t}\n",
    "label": 1,
    "rec": "@param column column id"
  },
  {
    "id": 818,
    "type": "Param",
    "comment": "@param topVer Topology version.",
    "code": "        private boolean preloadEntry(ClusterNode pick, int p, GridCacheEntryInfo<K, V> entry, AffinityTopologyVersion topVer)\n            throws IgniteCheckedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isIgfsDataCache() &&\n                        cctx.dht().igfsDataSpaceUsed() > cctx.dht().igfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload IGFS data cache (IGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isDrEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (IgniteUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false, null, null, null);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (IgniteInterruptedCheckedException e) {\n                throw e;\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteCheckedException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 819,
    "type": "Param",
    "comment": "@param ancestorSchema a root resource schema",
    "code": "  public List<ResourceSchema> getSubResources(ResourceSchema parentSchema)\n  {\n    return _subResources.get(parentSchema);\n  }\n\n",
    "label": 1,
    "rec": "@param parentSchema a parent resource schema"
  },
  {
    "id": 820,
    "type": "Param",
    "comment": "@param commit",
    "code": "    public static Date getCommitterDate(final Commit commit) {\n        GitCommit rawCommit = commit.commit;\n        if (rawCommit == null)\n            return null;\n\n        User commitCommitter = rawCommit.committer;\n        return commitCommitter != null && commitCommitter.date != null? TimeUtils.stringToDate(commitCommitter.date): null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 821,
    "type": "Param",
    "comment": "@param additionalData additional data",
    "code": "  public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n      throws GeneralSecurityException {\n    return decrypt(ByteBuffer.wrap(ciphertext), associatedData);\n  }\n",
    "label": 1,
    "rec": "@param associatedData associated authenticated data"
  },
  {
    "id": 822,
    "type": "Param",
    "comment": "@param measure classification measure as the chromosome fitness measure.",
    "code": "    public BitString[] learn(int size, int generation, double[][] x, double[] y, double[][] testx, double[] testy, RegressionMeasure measure, BiFunction<double[][], double[], Regression<double[]>> trainer) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Invalid population size: \" + size);\n        }\n        \n        if (generation <= 0) {\n            throw new IllegalArgumentException(\"Invalid number of generations to go: \" + generation);\n        }\n        \n        if (x.length != y.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of X and Y don't match: %d != %d\", x.length, y.length));\n        }\n\n        if (testx.length != testy.length) {\n            throw new IllegalArgumentException(String.format(\"The sizes of test X and Y don't match: %d != %d\", testx.length, testy.length));\n        }\n\n        int p = x[0].length;\n        RegressionFitness fitness = new RegressionFitness(trainer, measure, x, y, testx, testy);\n        \n        BitString[] seeds = new BitString[size];\n        for (int i = 0; i < size; i++) {\n            seeds[i] = new BitString(p, fitness, crossover, crossoverRate, mutationRate);\n        }\n\n        GeneticAlgorithm<BitString> ga = new GeneticAlgorithm<>(seeds, selection);\n        ga.evolve(generation);       \n        \n        return seeds;        \n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 823,
    "type": "Param",
    "comment": "@param taskName Task name.",
    "code": "    private boolean visorTask(String taskCls) {\n        return taskCls.startsWith(VISOR_TASK_PREFIX);\n    }\n",
    "label": 1,
    "rec": "@param taskCls Task class name."
  },
  {
    "id": 824,
    "type": "Param",
    "comment": "@param format the format for the encoding",
    "code": "  public static byte[] ecPointEncode(EllipticCurve curve, EcPointFormat format, ECPoint point)\n      throws GeneralSecurityException {\n    EcUtil.checkPointOnCurve(point, curve);\n    int coordinateSize = EcUtil.fieldSizeInBytes(curve);\n    switch (format) {\n      case UNCOMPRESSED:\n        {\n          byte[] encoded = new byte[2 * coordinateSize + 1];\n          byte[] x = point.getAffineX().toByteArray();\n          byte[] y = point.getAffineY().toByteArray();\n          // Order of System.arraycopy is important because x,y can have leading 0's.\n          System.arraycopy(y, 0, encoded, 1 + 2 * coordinateSize - y.length, y.length);\n          System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);\n          encoded[0] = 4;\n          return encoded;\n        }\n      case COMPRESSED:\n        {\n          byte[] encoded = new byte[coordinateSize + 1];\n          byte[] x = point.getAffineX().toByteArray();\n          System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);\n          encoded[0] = (byte) (point.getAffineY().testBit(0) ? 3 : 2);\n          return encoded;\n        }\n      default:\n        throw new GeneralSecurityException(\"Invalid format:\" + format);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 825,
    "type": "Param",
    "comment": "@param serverNodesNum Server nodes number.",
    "code": "    private String topologySnapshotMessage(int srvNodesNum, int clientNodesNum, int totalCpus, double heap) {\n        return PREFIX + \" [\" +\n            (discoOrdered ? \"ver=\" + topSnap.get().topVer.topologyVersion() + \", \" : \"\") +\n            \"server nodes=\" + srvNodesNum +\n            \", client nodes=\" + clientNodesNum +\n            \", CPUs=\" + totalCpus +\n            \", heap=\" + heap + \"GB\" +\n            ']';\n    }\n",
    "label": 1,
    "rec": "@param srvNodesNum Server nodes number."
  },
  {
    "id": 826,
    "type": "Param",
    "comment": "@param igfs IGFS configuration.",
    "code": "    public static VisorIgfsConfiguration from(IgfsConfiguration igfs) {\n        VisorIgfsConfiguration cfg = new VisorIgfsConfiguration();\n\n        cfg.name(igfs.getName());\n        cfg.metaCacheName(igfs.getMetaCacheName());\n        cfg.dataCacheName(igfs.getDataCacheName());\n        cfg.blockSize(igfs.getBlockSize());\n        cfg.prefetchBlocks(igfs.getPrefetchBlocks());\n        cfg.streamBufferSize(igfs.getStreamBufferSize());\n        cfg.perNodeBatchSize(igfs.getPerNodeBatchSize());\n        cfg.perNodeParallelBatchCount(igfs.getPerNodeParallelBatchCount());\n\n        Igfs secFs = igfs.getSecondaryFileSystem();\n\n        if (secFs != null) {\n            Map<String, String> props = secFs.properties();\n\n            cfg.secondaryHadoopFileSystemUri(props.get(SECONDARY_FS_URI));\n            cfg.secondaryHadoopFileSystemConfigPath(props.get(SECONDARY_FS_CONFIG_PATH));\n        }\n\n        cfg.defaultMode(igfs.getDefaultMode());\n        cfg.pathModes(igfs.getPathModes());\n        cfg.dualModePutExecutorService(compactClass(igfs.getDualModePutExecutorService()));\n        cfg.dualModePutExecutorServiceShutdown(igfs.getDualModePutExecutorServiceShutdown());\n        cfg.dualModeMaxPendingPutsSize(igfs.getDualModeMaxPendingPutsSize());\n        cfg.maxTaskRangeLength(igfs.getMaximumTaskRangeLength());\n        cfg.fragmentizerConcurrentFiles(igfs.getFragmentizerConcurrentFiles());\n        cfg.fragmentizerLocalWritesRatio(igfs.getFragmentizerLocalWritesRatio());\n        cfg.fragmentizerEnabled(igfs.isFragmentizerEnabled());\n        cfg.fragmentizerThrottlingBlockLength(igfs.getFragmentizerThrottlingBlockLength());\n        cfg.fragmentizerThrottlingDelay(igfs.getFragmentizerThrottlingDelay());\n\n        Map<String, String> endpointCfg = igfs.getIpcEndpointConfiguration();\n        cfg.ipcEndpointConfiguration(endpointCfg != null ? endpointCfg.toString() : null);\n\n        cfg.ipcEndpointEnabled(igfs.isIpcEndpointEnabled());\n        cfg.maxSpace(igfs.getMaxSpaceSize());\n        cfg.managementPort(igfs.getManagementPort());\n        cfg.sequenceReadsBeforePrefetch(igfs.getSequentialReadsBeforePrefetch());\n        cfg.trashPurgeTimeout(igfs.getTrashPurgeTimeout());\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 827,
    "type": "Param",
    "comment": "@param offset offset number",
    "code": "    static float fromRelativeToFloat(String length, float relative, float offset, float scale, float fontSize) {\n        /*\n            TODO list\n\n            unit\trelative to\n            em\t    font size of the element\n            ex\t    x-height of the element\u00e2\u0080\u0099s font\n            ch\t    width of the \"0\" (ZERO, U+0030) glyph in the element\u00e2\u0080\u0099s font\n            rem\t    font size of the root element\n            vw\t    1% of viewport\u00e2\u0080\u0099s width\n            vh\t    1% of viewport\u00e2\u0080\u0099s height\n            vmin\t1% of viewport\u00e2\u0080\u0099s smaller dimension\n            vmax\t1% of viewport\u00e2\u0080\u0099s larger dimension\n\n            relative-size [ larger | smaller ]\n            absolute-size: [ xx-small | x-small | small | medium | large | x-large | xx-large ]\n\n            https://www.w3.org/TR/css3-values/#relative-lengths\n            https://www.w3.org/TR/css3-values/#absolute-lengths\n            https://drafts.csswg.org/css-cascade-4/#computed-value\n            https://drafts.csswg.org/css-fonts-3/#propdef-font-size\n            https://drafts.csswg.org/css2/fonts.html#propdef-font-size\n        */\n        length = length.trim();\n        int stringLength = length.length();\n        int percentIndex = stringLength - 1;\n        if (stringLength == 0) {\n            return offset;\n        } else if (length.codePointAt(percentIndex) == '%') {\n            return Float.valueOf(length.substring(0, percentIndex)) / 100 * relative + offset;\n        } else {\n            int twoLetterUnitIndex = stringLength - 2;\n            if (twoLetterUnitIndex > 0) {\n                String lastTwo = length.substring(twoLetterUnitIndex);\n                int end = twoLetterUnitIndex;\n                float unit = 1;\n\n                switch (lastTwo) {\n                    case \"px\":\n                        break;\n\n                    case \"em\":\n                        unit = fontSize;\n                        break;\n\n                    /*\n                     \"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n                     \"1pc\" equals \"15px\" (and therefore 15 user units)\n                     \"1mm\" would be \"3.543307px\" (3.543307 user units)\n                     \"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n                     \"1in\" equals \"90px\" (and therefore 90 user units)\n                     */\n\n                    case \"pt\":\n                        unit = 1.25f;\n                        break;\n\n                    case \"pc\":\n                        unit = 15;\n                        break;\n\n                    case \"mm\":\n                        unit = 3.543307f;\n                        break;\n\n                    case \"cm\":\n                        unit = 35.43307f;\n                        break;\n\n                    case \"in\":\n                        unit = 90;\n                        break;\n\n                    default:\n                        end = stringLength;\n                }\n\n                return Float.valueOf(length.substring(0, end)) * unit * scale + offset;\n            } else {\n                return Float.valueOf(length) * scale + offset;\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param offset offset for all units"
  },
  {
    "id": 828,
    "type": "Param",
    "comment": "@param allSigned If  true then all files must be signed.",
    "code": "    static boolean verify(String jarName, PublicKey pubKey, boolean allSigned, IgniteLogger log)\n        throws IOException {\n        assert jarName != null;\n        assert pubKey != null;\n\n        return verify0(jarName, pubKey, allSigned, log);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 829,
    "type": "Param",
    "comment": "@param account the Account stored in the data store to be compared against the submitted authentication token's credentials.",
    "code": "    protected Object getCredentials(AuthenticationInfo info) {\n        return info.getCredentials();\n    }\n",
    "label": 1,
    "rec": "@param info the AuthenticationInfo stored in the data store to be compared against the submitted authentication token's credentials."
  },
  {
    "id": 830,
    "type": "Param",
    "comment": "@param cache Cache.",
    "code": "                private boolean undeploy(Entry<K, V> e, GridCacheAdapter<K, V> cache) {\n                    K k = e.getKey();\n\n                    GridCacheEntryEx<K, V> entry = cache.peekEx(e.getKey());\n\n                    if (entry == null)\n                        return false;\n\n                    V v;\n\n                    try {\n                        v = entry.peek(GridCachePeekMode.GLOBAL, CU.<K, V>empty());\n                    }\n                    catch (GridCacheEntryRemovedException ignore) {\n                        return false;\n                    }\n                    catch (IgniteException ignore) {\n                        // Peek can throw runtime exception if unmarshalling failed.\n                        return true;\n                    }\n\n                    assert k != null : \"Key cannot be null for cache entry: \" + e;\n\n                    ClassLoader keyLdr = U.detectObjectClassLoader(k);\n                    ClassLoader valLdr = U.detectObjectClassLoader(v);\n\n                    boolean res = F.eq(ldr, keyLdr) || F.eq(ldr, valLdr);\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Finished examining entry [entryCls=\" + e.getClass() +\n                            \", key=\" + k + \", keyCls=\" + k.getClass() +\n                            \", valCls=\" + (v != null ? v.getClass() : \"null\") +\n                            \", keyLdr=\" + keyLdr + \", valLdr=\" + valLdr + \", res=\" + res + ']');\n\n                    return res;\n                }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 831,
    "type": "Param",
    "comment": "@param view",
    "code": "\tpublic static boolean isTranslucentStatusBar(Context context) {\n\t\tWindow w = unwrap(context).getWindow();\n\t\tWindowManager.LayoutParams lp = w.getAttributes();\n\t\tint flags = lp.flags;\n\t\tif ((flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "label": 1,
    "rec": "@param context Context"
  },
  {
    "id": 832,
    "type": "Param",
    "comment": "@param val Value.",
    "code": "    public boolean putToStore(@Nullable IgniteTx tx, K key, V val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = (K)cctx.unwrapPortableIfNeeded(key, false);\n                val = (V)cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            try {\n                store.put(tx, key, locStore ? F.t(val, ver) : val);\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 833,
    "type": "Param",
    "comment": "@param localCombiner If we have mapper with combiner.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input((Comparator<Object>)job.combineGroupComparator());\n                }\n\n            default:\n                return createInput(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "@param locCombiner If we have mapper with combiner."
  },
  {
    "id": 834,
    "type": "Param",
    "comment": "@param skipped Skipped set (possibly  null).",
    "code": "    private Set<KeyCacheObject> skip(Set<KeyCacheObject> skipped, KeyCacheObject key) {\n        if (skipped == null)\n            skipped = new GridLeanSet<>();\n\n        skipped.add(key);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Added key to skipped set: \" + key);\n\n        return skipped;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 835,
    "type": "Param",
    "comment": "@param categories the categories to use for logging level adjusting",
    "code": "\tpublic Log4j2LevelAdjuster categories(String... categoriesToAdjust) {\n\t\treturn categories(false, categoriesToAdjust);\n\t}\n",
    "label": 1,
    "rec": "@param categoriesToAdjust the categories to use for logging level adjusting"
  },
  {
    "id": 836,
    "type": "Param",
    "comment": "@param time timestamp",
    "code": "    public Frame getFrame(@NonNull T data, long time, int rotation) {\n        if (!isSetUp()) {\n            throw new IllegalStateException(\"Can't call getFrame() after releasing \" +\n                    \"or before setUp.\");\n        }\n\n        Frame frame = mFrameQueue.poll();\n        if (frame != null) {\n            LOG.v(\"getFrame for time:\", time, \"RECYCLING.\");\n        } else {\n            LOG.v(\"getFrame for time:\", time, \"CREATING.\");\n            frame = new Frame(this);\n        }\n        frame.setContent(data, time, rotation, mFrameSize, mFrameFormat);\n        return frame;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 837,
    "type": "Param",
    "comment": "@param c Transform closure to be applied for queue header.",
    "code": "    @Nullable private Long transformHeader(EntryProcessor<GridCacheQueueHeaderKey, GridCacheQueueHeader, Long> c)\n        throws IgniteCheckedException {\n        int cnt = 0;\n\n        while (true) {\n            try {\n                return (Long)cache.invoke(queueKey, c);\n            }\n            catch (CachePartialUpdateException e) {\n                if (cnt++ == MAX_UPDATE_RETRIES)\n                    throw e;\n                else {\n                    U.warn(log, \"Failed to update queue header, will retry [err=\" + e + ']');\n\n                    U.sleep(RETRY_DELAY);\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param c EntryProcessor to be applied for queue header."
  },
  {
    "id": 838,
    "type": "Param",
    "comment": "@param jarName JAR file name.",
    "code": "    static boolean verify(String jarName, PublicKey pubKey, boolean allSigned, IgniteLogger log)\n        throws IOException {\n        assert jarName != null;\n        assert pubKey != null;\n\n        return verify0(jarName, pubKey, allSigned, log);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 839,
    "type": "Param",
    "comment": "@param job Job to get reducers for.",
    "code": "    private Collection<Integer> allReducers(GridHadoopMapReducePlan plan) {\n        Collection<Integer> res = new HashSet<>();\n\n        for (int i = 0; i < plan.reducers(); i++)\n            res.add(i);\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param plan Map-reduce plan."
  },
  {
    "id": 840,
    "type": "Param",
    "comment": "@param isPassive set to true if login should be passive (without login screen shown)",
    "code": "    protected Response handleBrowserAuthenticationRequest(AuthenticationSessionModel authSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(authSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, authSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    // processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                AuthenticationManager.setRolesAndMappersInSession(authSession);\n\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(authSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.authenticationSessions().removeAuthenticationSession(realm, authSession);\n                    return response;\n                }\n\n                // Attach session once no requiredActions or other things are required\n                processor.attachSession();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, authSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow(null);\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 841,
    "type": "Param",
    "comment": "@param topSnapshot Topology snapshot for which candidate is added.",
    "code": "    public boolean addCandidate(AffinityTopologyVersion topVer, GridCacheMvccCandidate cand) {\n        lock();\n\n        try {\n            if (cands.isEmpty())\n                return false;\n\n            assert this.topVer.equals(this.topVer);\n\n            Deque<GridCacheMvccCandidate> deque = ensureDeque(cand.key());\n\n            GridCacheMvccCandidate old = F.first(deque);\n\n            deque.add(cand);\n\n            if (old != null && old.owner())\n                cand.setOwner();\n\n            return true;\n        }\n        finally {\n            unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@param topVer Topology snapshot for which candidate is added."
  },
  {
    "id": 842,
    "type": "Param",
    "comment": "@param value",
    "code": "    public boolean setbit(String key, long offset, boolean value) {\n        client.setbit(key, offset, value);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 843,
    "type": "Param",
    "comment": "@param serverNodesNum Server nodes number.",
    "code": "    private String topologySnapshotMessage(int srvNodesNum, int clientNodesNum, int totalCpus, double heap) {\n        return PREFIX + \" [\" +\n            (discoOrdered ? \"ver=\" + topSnap.get().topVer.topologyVersion() + \", \" : \"\") +\n            \"server nodes=\" + srvNodesNum +\n            \", client nodes=\" + clientNodesNum +\n            \", CPUs=\" + totalCpus +\n            \", heap=\" + heap + \"GB\" +\n            ']';\n    }\n",
    "label": 1,
    "rec": "@param srvNodesNum Server nodes number."
  },
  {
    "id": 844,
    "type": "Param",
    "comment": "@param startPos Start position.",
    "code": "    private static String parseExpression(String text, int startPos, int len, OdbcEscapeType type, Pattern pattern) {\n        String val = parseExpression(text, startPos, len);\n\n        if (!pattern.matcher(val).matches())\n            throw new IgniteException(\"Invalid \" + type + \" escape sequence: \" + substring(text, startPos, len));\n\n        return val;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 845,
    "type": "Param",
    "comment": "@param fileInfo File info of file opened to write.",
    "code": "    public IgniteInternalFuture<Boolean> writeStart(IgniteUuid fileId) {\n        WriteCompletionFuture fut = new WriteCompletionFuture(fileId);\n\n        WriteCompletionFuture oldFut = pendingWrites.putIfAbsent(fileId, fut);\n\n        assert oldFut == null : \"Opened write that is being concurrently written: \" + fileId;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Registered write completion future for file output stream [fileId=\" + fileId +\n                \", fut=\" + fut + ']');\n\n        return fut;\n    }\n",
    "label": 1,
    "rec": "@param fileId File ID."
  },
  {
    "id": 846,
    "type": "Param",
    "comment": "@param hintsMap all parameters influencing the weighting. E.g. parameters coming via GHRequest.getHints or directly via \"&amp;api.xy=\" from the URL of the web UI",
    "code": "    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph, TurnCostProvider turnCostProvider) {\n        String weightingStr = toLowerCase(hintsMap.getWeighting());\n        Weighting weighting = null;\n\n        if (\"shortest\".equalsIgnoreCase(weightingStr)) {\n            weighting = new ShortestWeighting(encoder, turnCostProvider);\n        } else if (\"fastest\".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {\n            if (encoder.supports(PriorityWeighting.class))\n                weighting = new PriorityWeighting(encoder, hintsMap, turnCostProvider);\n            else\n                weighting = new FastestWeighting(encoder, hintsMap, turnCostProvider);\n        } else if (\"curvature\".equalsIgnoreCase(weightingStr)) {\n            if (encoder.supports(CurvatureWeighting.class))\n                weighting = new CurvatureWeighting(encoder, hintsMap, turnCostProvider);\n\n        } else if (\"short_fastest\".equalsIgnoreCase(weightingStr)) {\n            weighting = new ShortFastestWeighting(encoder, hintsMap, turnCostProvider);\n        }\n\n        if (weighting == null)\n            throw new IllegalArgumentException(\"weighting \" + weightingStr + \" not supported\");\n\n        if (hintsMap.has(Routing.BLOCK_AREA)) {\n            String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, \"\");\n            GraphEdgeIdFinder.BlockArea blockArea = new GraphEdgeIdFinder(graph, locationIndex).\n                    parseBlockArea(blockAreaStr, DefaultEdgeFilter.allEdges(encoder), hintsMap.getDouble(\"block_area.edge_id_max_area\", 1000 * 1000));\n            return new BlockAreaWeighting(weighting, blockArea);\n        }\n\n        return weighting;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 847,
    "type": "Param",
    "comment": "@param nearNodeId Near node ID that initiated transaction.",
    "code": "            @Override public GridNearTxPrepareResponse apply(IgniteInternalFuture<GridNearTxPrepareResponse> f) {\n                try {\n                    return f.get();\n                }\n                catch (Exception e) {\n                    locTx.setRollbackOnly(); // Just in case.\n\n                    if (!X.hasCause(e, IgniteTxOptimisticCheckedException.class) &&\n                        !X.hasCause(e, IgniteFutureCancelledException.class))\n                        U.error(log, \"Failed to prepare DHT transaction: \" + locTx, e);\n\n                    return new GridNearTxPrepareResponse(\n                        req.version(),\n                        req.futureId(),\n                        req.miniId(),\n                        req.version(),\n                        req.version(),\n                        null,\n                        e,\n                        null,\n                        req.deployInfo() != null);\n                }\n            }\n",
    "label": 1,
    "rec": "@param locTx Local transaction."
  },
  {
    "id": 848,
    "type": "Param",
    "comment": "@param address destination IP and port.",
    "code": "    public Peer connectTo(InetSocketAddress address) {\n        return connectTo(address, true);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 849,
    "type": "Param",
    "comment": "@param type to check.",
    "code": "  public boolean contains(String memberKey)\n  {\n    return _memberKeyToIndexMap.containsKey(memberKey);\n  }\n\n",
    "label": 1,
    "rec": "@param memberKey to check."
  },
  {
    "id": 850,
    "type": "Param",
    "comment": "@param text Text.",
    "code": "    private static String parseExpression(String text, int startPos, int len, OdbcEscapeType type, Pattern pattern) {\n        String val = parseExpression(text, startPos, len);\n\n        if (!pattern.matcher(val).matches())\n            throw new IgniteException(\"Invalid \" + type + \" escape sequence: \" + substring(text, startPos, len));\n\n        return val;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 851,
    "type": "Param",
    "comment": "@param weightingStr specify e.g. fastest or shortest (or empty for default)",
    "code": "    public Weighting createWeighting( String weighting, FlagEncoder encoder )\n    {\n        // ignore case\n        weighting = weighting.toLowerCase();\n        if (\"fastest\".equals(weighting))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                return new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                return new FastestWeighting(encoder);\n        }\n        return new ShortestWeighting();\n    }\n",
    "label": 1,
    "rec": "@param weighting specify e.g. fastest or shortest (or empty for default)"
  },
  {
    "id": 852,
    "type": "Param",
    "comment": "@param file GGFS file information.",
    "code": "    private FileStatus convert(IgniteFsFile file) {\n        return new FileStatus(file.length(), file.isDirectory(), getDefaultReplication(),\n            file.groupBlockSize(), file.modificationTime(), file.accessTime(), permission(file),\n            file.property(PROP_USER_NAME, DFLT_USER_NAME), file.property(PROP_GROUP_NAME, \"users\"),\n            convert(file.path())) {\n            @Override public String toString() {\n                return \"FileStatus [path=\" + getPath() + \", isDir=\" + isDir() + \", len=\" + getLen() +\n                    \", mtime=\" + getModificationTime() + \", atime=\" + getAccessTime() + ']';\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 853,
    "type": "Param",
    "comment": "@param nanocoins How much currency to send, in nanocoins.",
    "code": "    public Transaction createSend(Address address, Coin value) throws InsufficientMoneyException {\n        SendRequest req = SendRequest.to(address, value);\n        if (params == UnitTestParams.get())\n            req.shuffleOutputs = false;\n        completeTx(req);\n        return req.tx;\n    }\n",
    "label": 1,
    "rec": "@param value How much currency to send."
  },
  {
    "id": 854,
    "type": "Param",
    "comment": "@param data Byte array.",
    "code": "    public static int serialize(byte[] data, int off, ClusterMetrics metrics) {\n        int start = off;\n\n        off = U.intToBytes(metrics.getMaximumActiveJobs(), data, off);\n        off = U.intToBytes(metrics.getCurrentActiveJobs(), data, off);\n        off = U.floatToBytes(metrics.getAverageActiveJobs(), data, off);\n        off = U.intToBytes(metrics.getMaximumWaitingJobs(), data, off);\n        off = U.intToBytes(metrics.getCurrentWaitingJobs(), data, off);\n        off = U.floatToBytes(metrics.getAverageWaitingJobs(), data, off);\n        off = U.intToBytes(metrics.getMaximumRejectedJobs(), data, off);\n        off = U.intToBytes(metrics.getCurrentRejectedJobs(), data, off);\n        off = U.floatToBytes(metrics.getAverageRejectedJobs(), data, off);\n        off = U.intToBytes(metrics.getMaximumCancelledJobs(), data, off);\n        off = U.intToBytes(metrics.getCurrentCancelledJobs(), data, off);\n        off = U.floatToBytes(metrics.getAverageCancelledJobs(), data, off);\n        off = U.intToBytes(metrics.getTotalRejectedJobs(), data , off);\n        off = U.intToBytes(metrics.getTotalCancelledJobs(), data , off);\n        off = U.intToBytes(metrics.getTotalExecutedJobs(), data , off);\n        off = U.longToBytes(metrics.getMaximumJobWaitTime(), data, off);\n        off = U.longToBytes(metrics.getCurrentJobWaitTime(), data, off);\n        off = U.doubleToBytes(metrics.getAverageJobWaitTime(), data, off);\n        off = U.longToBytes(metrics.getMaximumJobExecuteTime(), data, off);\n        off = U.longToBytes(metrics.getCurrentJobExecuteTime(), data, off);\n        off = U.doubleToBytes(metrics.getAverageJobExecuteTime(), data, off);\n        off = U.intToBytes(metrics.getTotalExecutedTasks(), data, off);\n        off = U.longToBytes(metrics.getCurrentIdleTime(), data, off);\n        off = U.longToBytes(metrics.getTotalIdleTime(), data , off);\n        off = U.intToBytes(metrics.getTotalCpus(), data, off);\n        off = U.doubleToBytes(metrics.getCurrentCpuLoad(), data, off);\n        off = U.doubleToBytes(metrics.getAverageCpuLoad(), data, off);\n        off = U.doubleToBytes(metrics.getCurrentGcCpuLoad(), data, off);\n        off = U.longToBytes(metrics.getHeapMemoryInitialized(), data, off);\n        off = U.longToBytes(metrics.getHeapMemoryUsed(), data, off);\n        off = U.longToBytes(metrics.getHeapMemoryCommitted(), data, off);\n        off = U.longToBytes(metrics.getHeapMemoryMaximum(), data, off);\n        off = U.longToBytes(metrics.getNonHeapMemoryInitialized(), data, off);\n        off = U.longToBytes(metrics.getNonHeapMemoryUsed(), data, off);\n        off = U.longToBytes(metrics.getNonHeapMemoryCommitted(), data, off);\n        off = U.longToBytes(metrics.getNonHeapMemoryMaximum(), data, off);\n        off = U.longToBytes(metrics.getStartTime(), data, off);\n        off = U.longToBytes(metrics.getNodeStartTime(), data, off);\n        off = U.longToBytes(metrics.getUpTime(), data, off);\n        off = U.intToBytes(metrics.getCurrentThreadCount(), data, off);\n        off = U.intToBytes(metrics.getMaximumThreadCount(), data, off);\n        off = U.longToBytes(metrics.getTotalStartedThreadCount(), data, off);\n        off = U.intToBytes(metrics.getCurrentDaemonThreadCount(), data, off);\n        off = U.longToBytes(metrics.getLastDataVersion(), data, off);\n        off = U.intToBytes(metrics.getSentMessagesCount(), data, off);\n        off = U.longToBytes(metrics.getSentBytesCount(), data, off);\n        off = U.intToBytes(metrics.getReceivedMessagesCount(), data, off);\n        off = U.longToBytes(metrics.getReceivedBytesCount(), data, off);\n        off = U.intToBytes(metrics.getOutboundMessagesQueueSize(), data, off);\n\n        assert off - start == METRICS_SIZE : \"Invalid metrics size [expected=\" + METRICS_SIZE + \", actual=\" +\n            (off - start) + ']';\n\n        return off;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 855,
    "type": "Param",
    "comment": "@param conditionQueryBuilder The builder of a specific set of conditions used in this query",
    "code": "    public Where<ModelClass> where(SQLCondition... conditions) {\n        return where().andThese(conditions);\n    }\n\n",
    "label": 1,
    "rec": "@param conditions The array of conditions that define this WHERE statement"
  },
  {
    "id": 856,
    "type": "Param",
    "comment": "@param params network parameters",
    "code": "    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed, List<ChildNumber> accountPath) {\n        return fromSeed(params, seed, Script.ScriptType.P2PKH, accountPath);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 857,
    "type": "Param",
    "comment": "@param relative relative number",
    "code": "    static float fromRelativeToFloat(String length, float relative, float offset, float scale, float fontSize) {\n        /*\n            TODO list\n\n            unit\trelative to\n            em\t    font size of the element\n            ex\t    x-height of the element\u00e2\u0080\u0099s font\n            ch\t    width of the \"0\" (ZERO, U+0030) glyph in the element\u00e2\u0080\u0099s font\n            rem\t    font size of the root element\n            vw\t    1% of viewport\u00e2\u0080\u0099s width\n            vh\t    1% of viewport\u00e2\u0080\u0099s height\n            vmin\t1% of viewport\u00e2\u0080\u0099s smaller dimension\n            vmax\t1% of viewport\u00e2\u0080\u0099s larger dimension\n\n            relative-size [ larger | smaller ]\n            absolute-size: [ xx-small | x-small | small | medium | large | x-large | xx-large ]\n\n            https://www.w3.org/TR/css3-values/#relative-lengths\n            https://www.w3.org/TR/css3-values/#absolute-lengths\n            https://drafts.csswg.org/css-cascade-4/#computed-value\n            https://drafts.csswg.org/css-fonts-3/#propdef-font-size\n            https://drafts.csswg.org/css2/fonts.html#propdef-font-size\n        */\n        length = length.trim();\n        int stringLength = length.length();\n        int percentIndex = stringLength - 1;\n        if (stringLength == 0) {\n            return offset;\n        } else if (length.codePointAt(percentIndex) == '%') {\n            return Float.valueOf(length.substring(0, percentIndex)) / 100 * relative + offset;\n        } else {\n            int twoLetterUnitIndex = stringLength - 2;\n            if (twoLetterUnitIndex > 0) {\n                String lastTwo = length.substring(twoLetterUnitIndex);\n                int end = twoLetterUnitIndex;\n                float unit = 1;\n\n                switch (lastTwo) {\n                    case \"px\":\n                        break;\n\n                    case \"em\":\n                        unit = fontSize;\n                        break;\n\n                    /*\n                     \"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n                     \"1pc\" equals \"15px\" (and therefore 15 user units)\n                     \"1mm\" would be \"3.543307px\" (3.543307 user units)\n                     \"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n                     \"1in\" equals \"90px\" (and therefore 90 user units)\n                     */\n\n                    case \"pt\":\n                        unit = 1.25f;\n                        break;\n\n                    case \"pc\":\n                        unit = 15;\n                        break;\n\n                    case \"mm\":\n                        unit = 3.543307f;\n                        break;\n\n                    case \"cm\":\n                        unit = 35.43307f;\n                        break;\n\n                    case \"in\":\n                        unit = 90;\n                        break;\n\n                    default:\n                        end = stringLength;\n                }\n\n                return Float.valueOf(length.substring(0, end)) * unit * scale + offset;\n            } else {\n                return Float.valueOf(length) * scale + offset;\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@param relative relative size for percentages"
  },
  {
    "id": 858,
    "type": "Param",
    "comment": "@param activeStatus criterion for specifying completed or uncompleted",
    "code": "    public Tag[] getGroupedTags(Order order, Criterion activeStatus) {\n        Criterion criterion = Criterion.and(activeStatus, MetadataCriteria.withKey(TaskToTagMetadata.KEY));\n        Query query = Query.select(TaskToTagMetadata.TAG_NAME, TaskToTagMetadata.TAG_UUID, COUNT).\n            join(Join.inner(Task.TABLE, Metadata.TASK.eq(Task.ID))).\n            where(criterion).\n            orderBy(order).groupBy(TaskToTagMetadata.TAG_NAME);\n        TodorooCursor<Metadata> cursor = metadataDao.query(query);\n        try {\n            ArrayList<Tag> array = new ArrayList<Tag>();\n            for (int i = 0; i < cursor.getCount(); i++) {\n                cursor.moveToNext();\n                Tag tag = Tag.tagFromUUID(cursor.get(TaskToTagMetadata.TAG_UUID));\n                if (tag != null)\n                    array.add(tag);\n            }\n            return array.toArray(new Tag[array.size()]);\n        } finally {\n            cursor.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 859,
    "type": "Param",
    "comment": "@param info account info after a successful authentication attempt.",
    "code": "    protected String displayName( Account account) {\n        Object  p = account.getPrincipal();\n        if ( p != null ) {\n            return p.toString();\n        } else {\n            return account.toString();\n        }\n    }\n",
    "label": 1,
    "rec": "@param account account after a successful authentication attempt."
  },
  {
    "id": 860,
    "type": "Param",
    "comment": "@param c Grid configuration.",
    "code": "    public static VisorBasicConfiguration from(GridEx g, IgniteConfiguration c) {\n        VisorBasicConfiguration cfg = new VisorBasicConfiguration();\n\n        cfg.gridName(c.getGridName());\n        cfg.ggHome(getProperty(GG_HOME, c.getGridGainHome()));\n        cfg.localHost(getProperty(GG_LOCAL_HOST, c.getLocalHost()));\n        cfg.nodeId(g.localNode().id());\n        cfg.marshaller(compactClass(c.getMarshaller()));\n        cfg.deploymentMode(compactObject(c.getDeploymentMode()));\n        cfg.daemon(boolValue(GG_DAEMON, c.isDaemon()));\n        cfg.jmxRemote(g.isJmxRemoteEnabled());\n        cfg.restart(g.isRestartEnabled());\n        cfg.networkTimeout(c.getNetworkTimeout());\n        cfg.licenseUrl(c.getLicenseUrl());\n        cfg.logger(compactClass(c.getGridLogger()));\n        cfg.discoStartupDelay(c.getDiscoveryStartupDelay());\n        cfg.mBeanServer(compactClass(c.getMBeanServer()));\n        cfg.noAscii(boolValue(GG_NO_ASCII, false));\n        cfg.noDiscoOrder(boolValue(GG_NO_DISCO_ORDER, false));\n        cfg.noShutdownHook(boolValue(GG_NO_SHUTDOWN_HOOK, false));\n        cfg.programName(getProperty(GG_PROG_NAME));\n        cfg.quiet(boolValue(GG_QUIET, true));\n        cfg.successFile(getProperty(GG_SUCCESS_FILE));\n        cfg.updateNotifier(boolValue(GG_UPDATE_NOTIFIER, true));\n        cfg.securityCredentialsProvider(compactClass(c.getSecurityCredentialsProvider()));\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 861,
    "type": "Param",
    "comment": "@param cachedContentRequest the request know by the  SpiceManager.",
    "code": "    private boolean match( CachedSpiceRequest< ? > cachedSpiceRequest, SpiceRequest< ? > spiceRequest ) {\n        if ( spiceRequest instanceof CachedSpiceRequest ) {\n            return spiceRequest == cachedSpiceRequest;\n        } else {\n            return cachedSpiceRequest.getSpiceRequest() == spiceRequest;\n        }\n    }\n",
    "label": 1,
    "rec": "@param cachedSpiceRequest the request know by the  SpiceManager."
  },
  {
    "id": 862,
    "type": "Param",
    "comment": "@param msgId Message ID.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, AffinityTopologyVersion topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!cctx.discovery().cacheNearNode(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listenAsync(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        synchronized (this) {\n                            // Release memory.\n                            reader0.resetTxFuture();\n                        }\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 863,
    "type": "Param",
    "comment": "@param account the Account from which to retrive the credentials which assumed to be in already-hashed form.",
    "code": "    protected Object getCredentials(AuthenticationInfo info) {\n        Object credentials = info.getCredentials();\n\n        byte[] storedBytes = toBytes(credentials);\n\n        if (credentials instanceof String || credentials instanceof char[]) {\n            //account.credentials were a char[] or String, so\n            //we need to do text decoding first:\n            if (isStoredCredentialsHexEncoded()) {\n                storedBytes = Hex.decode(storedBytes);\n            } else {\n                storedBytes = Base64.decode(storedBytes);\n            }\n        }\n        AbstractHash hash = newHashInstance();\n        hash.setBytes(storedBytes);\n        return hash;\n    }\n",
    "label": 1,
    "rec": "@param info the AuthenticationInfo from which to retrive the credentials which assumed to be in already-hashed form."
  },
  {
    "id": 864,
    "type": "Param",
    "comment": "@param obj Object.",
    "code": "    private boolean writeHeader(Object obj, BinaryWriterExImpl writer) {\n        if (writer.tryWriteAsHandle(obj))\n            return false;\n\n        if (registered) {\n            PortableUtils.writeHeader(\n                writer,\n                typeId,\n                obj instanceof CacheObjectImpl ? 0 : obj.hashCode(),\n                null\n            );\n        }\n        else {\n            PortableUtils.writeHeader(\n                writer,\n                GridPortableMarshaller.UNREGISTERED_TYPE_ID,\n                obj instanceof CacheObjectImpl ? 0 : obj.hashCode(),\n                cls.getName()\n            );\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 865,
    "type": "Param",
    "comment": "@param resType Expected result type.",
    "code": "    private static ClassProperty buildClassProperty(Class<?> keyCls, Class<?> valCls, String pathStr, Class<?> resType)\n        throws IgniteCheckedException {\n        ClassProperty res = buildClassProperty(true, keyCls, pathStr, resType);\n\n        if (res == null) // We check key before value consistently with PortableProperty.\n            res = buildClassProperty(false, valCls, pathStr, resType);\n\n        if (res == null)\n            throw new IgniteCheckedException(\"Failed to initialize property '\" + pathStr + \"' for \" +\n                \"key class '\" + keyCls + \"' and value class '\" + valCls + \"'. \" +\n                \"Make sure that one of these classes contains respective getter method or field.\");\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@param resType Result type."
  },
  {
    "id": 866,
    "type": "Param",
    "comment": "@param key Key.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, Object key, Object val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key instanceof GridCacheInternal)\n                return true;\n\n            if (convertPortable) {\n                key = cctx.unwrapPortableIfNeeded(key, false);\n                val = cctx.unwrapPortableIfNeeded(val, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(key, locStore ? F.t(val, ver) : val));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 867,
    "type": "Param",
    "comment": "@param g Grid.",
    "code": "    private static CacheQueue<String> initializeQueue(Ignite ignite, String queueName) throws IgniteCheckedException {\n        // Initialize new FIFO queue.\n        CacheQueue<String> queue = ignite.cache(CACHE_NAME).dataStructures().queue(queueName, 0, false, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < ignite.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 1,
    "rec": "@param ignite Ignite."
  },
  {
    "id": 868,
    "type": "Param",
    "comment": "@param c Cache.",
    "code": "    public static VisorCacheMetrics from(IgniteEx ignite, CacheProjection c) {\n        VisorCacheMetrics cm = new VisorCacheMetrics();\n\n        CacheMetrics m = c.metrics();\n\n        GridCacheProcessor cacheProcessor = ignite.context().cache();\n\n        cm.name = c.name();\n        cm.mode = cacheProcessor.cacheMode(c.name());\n        cm.sys = cacheProcessor.systemCache(c.name());\n\n        cm.size = m.getSize();\n        cm.keySize = m.getKeySize();\n\n        cm.reads = m.getCacheGets();\n        cm.writes = m.getCachePuts() + m.getCacheRemovals();\n        cm.hits = m.getCacheHits();\n        cm.misses = m.getCacheMisses();\n\n        cm.txCommits = m.getCacheTxCommits();\n        cm.txRollbacks = m.getCacheTxRollbacks();\n\n        cm.avgTxCommitTime = m.getAverageTxCommitTime();\n        cm.avgTxRollbackTime = m.getAverageTxRollbackTime();\n\n        cm.puts = m.getCachePuts();\n        cm.removals = m.getCacheRemovals();\n        cm.evictions = m.getCacheEvictions();\n\n        cm.avgReadTime = m.getAverageGetTime();\n        cm.avgPutTime = m.getAveragePutTime();\n        cm.avgRemovalTime = m.getAverageRemoveTime();\n\n        cm.readsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageGetTime());\n        cm.writesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAveragePutTime());\n        cm.hitsPerSec = -1;\n        cm.missesPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageRemoveTime());\n        cm.commitsPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxCommitTime());\n        cm.rollbacksPerSec = (int)(MICROSECONDS_IN_SECOND * 1.f / m.getAverageTxRollbackTime());\n\n        cm.qryMetrics = VisorCacheQueryMetrics.from(c.queries().metrics());\n\n        cm.dhtEvictQueueCurrSize = m.getDhtEvictQueueCurrentSize();\n        cm.txThreadMapSize = m.getTxThreadMapSize();\n        cm.txXidMapSize = m.getTxXidMapSize();\n        cm.txCommitQueueSize = m.getTxCommitQueueSize();\n        cm.txPrepareQueueSize = m.getTxPrepareQueueSize();\n        cm.txStartVerCountsSize = m.getTxStartVersionCountsSize();\n        cm.txCommittedVersionsSize = m.getTxCommittedVersionsSize();\n        cm.txRolledbackVersionsSize = m.getTxRolledbackVersionsSize();\n        cm.txDhtThreadMapSize = m.getTxDhtThreadMapSize();\n        cm.txDhtXidMapSize = m.getTxDhtXidMapSize();\n        cm.txDhtCommitQueueSize = m.getTxDhtCommitQueueSize();\n        cm.txDhtPrepareQueueSize = m.getTxDhtPrepareQueueSize();\n        cm.txDhtStartVerCountsSize = m.getTxDhtStartVersionCountsSize();\n        cm.txDhtCommittedVersionsSize = m.getTxDhtCommittedVersionsSize();\n        cm.txDhtRolledbackVersionsSize = m.getTxDhtRolledbackVersionsSize();\n\n        return cm;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 869,
    "type": "Param",
    "comment": "@param createDate",
    "code": "    public int delete(Date now) {\n        if (null != now) {\n            QueryHandler queryHandler = getQueryHandler(\"delete from SysAppToken bean\");\n            queryHandler.condition(\"bean.expiryDate is not null\");\n            queryHandler.condition(\"bean.expiryDate <= :expiryDate\").setParameter(\"expiryDate\", now);\n            return delete(queryHandler);\n        }\n        return 0;\n    }\n",
    "label": 1,
    "rec": "@param now"
  },
  {
    "id": 870,
    "type": "Param",
    "comment": "@param mapper GGFS blocks mapper.",
    "code": "    private int partition(IgfsGroupDataBlocksKeyMapper mapper, IgniteUuid fileId, long blockId, int partCnt) {\n        return U.safeAbs((Integer) mapper.affinityKey(new IgfsBlockKey(fileId, null, false, blockId)) % partCnt);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 871,
    "type": "Param",
    "comment": "@param account the account data constructed due to the successful attempt.",
    "code": "    public AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info) {\n        return new SuccessfulAuthenticationEvent(token, info);\n    }\n",
    "label": 1,
    "rec": "@param info"
  },
  {
    "id": 872,
    "type": "Param",
    "comment": "@param entry Preloaded entry.",
    "code": "        private boolean preloadEntry(GridNode pick, int p, GridCacheEntryInfo<K, V> entry, long topVer)\n            throws GridException, GridInterruptedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isGgfsDataCache() &&\n                        cctx.dht().ggfsDataSpaceUsed() > cctx.dht().ggfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload GGFS data cache (GGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isReplicationEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (GridUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (GridInterruptedException e) {\n                throw e;\n            }\n            catch (GridException e) {\n                throw new GridException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 873,
    "type": "Param",
    "comment": "@param m Type mapping description.",
    "code": "    protected int fillValueParameters(PreparedStatement stmt, int idx, EntryMapping em, Object val)\n        throws CacheWriterException {\n        for (CacheTypeFieldMetadata field : em.uniqValFields) {\n            Object fieldVal = extractField(em.cacheName, em.valueType(), field.getJavaName(), val);\n\n            try {\n                if (fieldVal != null)\n                    stmt.setObject(idx++, fieldVal);\n                else\n                    stmt.setNull(idx++, field.getDatabaseType());\n            }\n            catch (SQLException e) {\n                throw new CacheWriterException(\"Failed to set statement parameter name: \" + field.getDatabaseName(), e);\n            }\n        }\n\n        return idx;\n    }\n",
    "label": 1,
    "rec": "@param em Type mapping description."
  },
  {
    "id": 874,
    "type": "Param",
    "comment": "@param request",
    "code": "    public String delete(String path, Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysUser user = ControllerUtils.getAdminFromSession(session);\n        SysDept dept = sysDeptService.getEntity(user.getDeptId());\n        if (ControllerUtils.verifyNotEmpty(\"deptId\", user.getDeptId(), model)\n                || ControllerUtils.verifyNotEmpty(\"deptId\", dept, model)\n                || ControllerUtils.verifyCustom(\"noright\",\n                        !(dept.isOwnsAllPage() || null != sysDeptPageService.getEntity(new SysDeptPageId(user.getDeptId(),\n                                CommonConstants.SEPARATOR + TemplateComponent.INCLUDE_DIRECTORY + path))),\n                        model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        if (CommonUtils.notEmpty(ids)) {\n            SysSite site = getSite(request);\n            service.delete(site.getId(), ids, path);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.place\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), StringUtils.join(ids, ',')));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 875,
    "type": "Param",
    "comment": "@param tx Cache transaction.",
    "code": "    public boolean putToStore(@Nullable IgniteInternalTx tx, KeyCacheObject key, CacheObject val, GridCacheVersion ver)\n        throws IgniteCheckedException {\n        if (store != null) {\n            // Never persist internal keys.\n            if (key.internal())\n                return true;\n\n            Object storeKey = key.value(cctx);\n            Object storeVal = val.value(cctx);\n\n            if (convertPortable) {\n                storeKey = cctx.unwrapPortableIfNeeded(storeKey, false);\n                storeVal = cctx.unwrapPortableIfNeeded(storeVal, false);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Storing value in cache store [key=\" + key + \", val=\" + val + ']');\n\n            boolean ses = initSession(tx);\n\n            try {\n                store.write(new CacheEntryImpl<>(storeKey, locStore ? F.t(storeVal, ver) : storeVal));\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                if (ses)\n                    sesHolder.set(null);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Stored value in cache store [key=\" + storeKey + \", val=\" + storeVal + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 876,
    "type": "Param",
    "comment": "@param matchedHashes A list which will contain the matched txn (will be cleared) Required to be a LinkedHashSet in order to retain order or transactions in the block",
    "code": "    public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut) throws VerificationException {\n        matchedHashesOut.clear();\n        \n        // An empty set will not work\n        if (transactionCount == 0)\n            throw new VerificationException(\"Got a CPartialMerkleTree with 0 transactions\");\n        // check for excessively high numbers of transactions\n        if (transactionCount > Block.MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n            throw new VerificationException(\"Got a CPartialMerkleTree with more transactions than is possible\");\n        // there can never be more hashes provided than one for every txid\n        if (hashes.size() > transactionCount)\n            throw new VerificationException(\"Got a CPartialMerkleTree with more hashes than transactions\");\n        // there must be at least one bit per node in the partial tree, and at least one node per hash\n        if (matchedChildBits.length*8 < hashes.size())\n            throw new VerificationException(\"Got a CPartialMerkleTree with fewer matched bits than hashes\");\n        // calculate height of tree\n        int height = 0;\n        while (getTreeWidth(transactionCount, height) > 1)\n            height++;\n        // traverse the partial tree\n        ValuesUsed used = new ValuesUsed();\n        Sha256Hash merkleRoot = recursiveExtractHashes(height, 0, used, matchedHashesOut);\n        // verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)\n        if ((used.bitsUsed+7)/8 != matchedChildBits.length ||\n                // verify that all hashes were consumed\n                used.hashesUsed != hashes.size())\n            throw new VerificationException(\"Got a CPartialMerkleTree that didn't need all the data it provided\");\n        \n        return merkleRoot;\n    }\n",
    "label": 1,
    "rec": "@param matchedHashesOut A list which will contain the matched txn (will be cleared)."
  },
  {
    "id": 877,
    "type": "Param",
    "comment": "@param view",
    "code": "    protected AvatarHelper setImage(final BitmapDrawable image, final ImageView view, final User user) {\n        if (!Integer.valueOf(user.getId()).equals(view.getTag(id.iv_gravatar)))\n            return this;\n\n        view.setTag(id.iv_gravatar, null);\n\n        if (image != null) {\n            loaded.put(user.getId(), image);\n            view.setImageDrawable(image);\n            view.setVisibility(VISIBLE);\n        }\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 878,
    "type": "Param",
    "comment": "@param string",
    "code": "    public Long rpush(final String key, final String... strings) {\n        checkIsInMulti();\n        client.rpush(key, strings);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param strings"
  },
  {
    "id": 879,
    "type": "Param",
    "comment": "@param streamer Source streamer.",
    "code": "    public static VisorStreamerMetrics from(IgniteStreamer streamer) {\n        assert streamer != null;\n\n        GridStreamerMetrics m = streamer.metrics();\n\n        int windowSz = 0;\n\n        for (GridStreamerWindowMetrics wm : m.windowMetrics())\n            windowSz += wm.size();\n\n        VisorStreamerMetrics metrics = new VisorStreamerMetrics();\n\n        metrics.active(m.stageActiveExecutionCount());\n        metrics.waiting(m.stageWaitingExecutionCount());\n        metrics.capacity(m.executorServiceCapacity());\n\n        metrics.pipelineMinExecutionTime(m.pipelineMinimumExecutionTime());\n        metrics.pipelineAvgExecutionTime(m.pipelineAverageExecutionTime());\n        metrics.pipelineMaxExecutionTime(m.pipelineMaximumExecutionTime());\n\n        metrics.pipelineMinExecutionNodes(m.pipelineMinimumExecutionNodes());\n        metrics.pipelineAvgExecutionNodes(m.pipelineAverageExecutionNodes());\n        metrics.pipelineMaxExecutionNodes(m.pipelineMaximumExecutionNodes());\n\n        metrics.queryMinExecutionTime(m.queryMinimumExecutionTime());\n        metrics.queryAvgExecutionTime(m.queryAverageExecutionTime());\n        metrics.queryMaxExecutionTime(m.queryMaximumExecutionTime());\n\n        metrics.queryMinExecutionNodes(m.queryMinimumExecutionNodes());\n        metrics.queryAvgExecutionNodes(m.queryAverageExecutionNodes());\n        metrics.queryMaxExecutionNodes(m.queryMaximumExecutionNodes());\n\n        metrics.windowSize(windowSz);\n\n        return metrics;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 880,
    "type": "Param",
    "comment": "@param cacheFlagsStr String representation of cache flags bit set.",
    "code": "    public static GridCacheFlag[] parseCacheFlags(int cacheFlagsBits) {\n        if (cacheFlagsBits == 0)\n            return EMPTY_FLAGS;\n\n        EnumSet<GridCacheFlag> flagSet = EnumSet.noneOf(GridCacheFlag.class);\n\n        if ((cacheFlagsBits & 1) != 0)\n            flagSet.add(GridCacheFlag.SKIP_STORE);\n\n        if ((cacheFlagsBits & (1 << 1)) != 0)\n            flagSet.add(GridCacheFlag.SKIP_SWAP);\n\n        if ((cacheFlagsBits & (1 << 2)) != 0)\n            flagSet.add(GridCacheFlag.SYNC_COMMIT);\n\n        if ((cacheFlagsBits & (1 << 4)) != 0)\n            flagSet.add(GridCacheFlag.INVALIDATE);\n\n        return flagSet.toArray(new GridCacheFlag[flagSet.size()]);\n    }\n",
    "label": 1,
    "rec": "@param cacheFlagsBits Integer representation of cache flags bit set."
  },
  {
    "id": 881,
    "type": "Param",
    "comment": "@param execution",
    "code": "    protected Response resetCredentials(String code, String execution, String clientId) {\n        SessionCodeChecks checks = checksForCode(code, execution, clientId, RESET_CREDENTIALS_PATH);\n        if (!checks.verifyActiveAndValidAction(ClientSessionModel.Action.AUTHENTICATE.name(), ClientSessionCode.ActionType.USER)) {\n            return checks.getResponse();\n        }\n        final AuthenticationSessionModel authSession = checks.getAuthenticationSession();\n\n        if (!realm.isResetPasswordAllowed()) {\n            event.error(Errors.NOT_ALLOWED);\n            return ErrorPage.error(session, Messages.RESET_CREDENTIAL_NOT_ALLOWED);\n\n        }\n\n        return processResetCredentials(checks.isActionRequest(), execution, authSession);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 882,
    "type": "Param",
    "comment": "@param partition partition",
    "code": "    private boolean isMetadataPropagated(String topic, int part) {\n        scala.Option<PartitionStateInfo> partStateOption =\n            kafkaSrv.apis().metadataCache().getPartitionInfo(topic, part);\n\n        if (!partStateOption.isDefined())\n            return false;\n\n        PartitionStateInfo partState = partStateOption.get();\n\n        LeaderAndIsr LeaderAndIsr = partState.leaderIsrAndControllerEpoch().leaderAndIsr();\n\n        return ZkUtils.getLeaderForPartition(getZkClient(), topic, part) != null &&\n            Request.isValidBrokerId(LeaderAndIsr.leader()) && LeaderAndIsr.isr().size() >= 1;\n    }\n",
    "label": 1,
    "rec": "@param part Partition."
  },
  {
    "id": 883,
    "type": "Param",
    "comment": "@param database",
    "code": "    public int deleteWhere(AbstractDatabase database, Criterion where) {\n        return database.getDatabase().delete(Metadata.TABLE.getName(),\n                where.toString(), null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 884,
    "type": "Param",
    "comment": "@param color",
    "code": "    public StyledText foreground(final CharSequence text, final ColorStateList states) {\n        return append(text, new StateForegroundSpan(states));\n    }\n",
    "label": 1,
    "rec": "@param states"
  },
  {
    "id": 885,
    "type": "Param",
    "comment": "@param msgId Message ID.",
    "code": "    @Nullable public IgniteInternalFuture<Boolean> addReader(UUID nodeId, long msgId, AffinityTopologyVersion topVer)\n        throws GridCacheEntryRemovedException {\n        // Don't add local node as reader.\n        if (cctx.nodeId().equals(nodeId))\n            return null;\n\n        ClusterNode node = cctx.discovery().node(nodeId);\n\n        if (node == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because node left the grid: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node has no near cache, don't add it.\n        if (!cctx.discovery().cacheNearNode(node, cacheName())) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because near cache is disabled: \" + nodeId);\n\n            return null;\n        }\n\n        // If remote node is (primary?) or back up, don't add it as a reader.\n        if (cctx.affinity().belongs(node, partition(), topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Ignoring near reader because remote node is affinity node [locNodeId=\" + cctx.localNodeId()\n                    + \", rmtNodeId=\" + nodeId + \", key=\" + key + ']');\n\n            return null;\n        }\n\n        boolean ret = false;\n\n        GridCacheMultiTxFuture<K, V> txFut = null;\n\n        Collection<GridCacheMvccCandidate<K>> cands = null;\n\n        ReaderId<K, V> reader;\n\n        synchronized (this) {\n            checkObsolete();\n\n            reader = readerId(nodeId);\n\n            if (reader == null) {\n                reader = new ReaderId<>(nodeId, msgId);\n\n                ReaderId<K, V>[] rdrs = Arrays.copyOf(this.rdrs, this.rdrs.length + 1);\n\n                rdrs[rdrs.length - 1] = reader;\n\n                // Seal.\n                this.rdrs = rdrs;\n\n                // No transactions in ATOMIC cache.\n                if (!cctx.atomic()) {\n                    txFut = reader.getOrCreateTxFuture(cctx);\n\n                    cands = localCandidates();\n\n                    ret = true;\n                }\n            }\n            else {\n                txFut = reader.txFuture();\n\n                long id = reader.messageId();\n\n                if (id < msgId)\n                    reader.messageId(msgId);\n            }\n        }\n\n        if (ret) {\n            assert txFut != null;\n\n            if (!F.isEmpty(cands)) {\n                for (GridCacheMvccCandidate<K> c : cands) {\n                    IgniteInternalTx<K, V> tx = cctx.tm().tx(c.version());\n\n                    if (tx != null) {\n                        assert tx.local();\n\n                        txFut.addTx(tx);\n                    }\n                }\n            }\n\n            txFut.init();\n\n            if (!txFut.isDone()) {\n                final ReaderId<K, V> reader0 = reader;\n\n                txFut.listenAsync(new CI1<IgniteInternalFuture<?>>() {\n                    @Override public void apply(IgniteInternalFuture<?> f) {\n                        synchronized (this) {\n                            // Release memory.\n                            reader0.resetTxFuture();\n                        }\n                    }\n                });\n            }\n            else {\n                synchronized (this) {\n                    // Release memory.\n                    reader.resetTxFuture();\n                }\n\n                txFut = null;\n            }\n        }\n\n        return txFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 886,
    "type": "Param",
    "comment": "@param sUrl , input string",
    "code": "    public static String urlEncode(String stringToEncode) {\n        try {\n            return URLEncoder.encode(stringToEncode, \"UTF-8\").replace(\"+\", \"%20\");\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        }\n    }\n",
    "label": 1,
    "rec": "@param stringToEncode , input string"
  },
  {
    "id": 887,
    "type": "Param",
    "comment": "@param ids",
    "code": "    public String check(Long[] ids, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (notEmpty(ids)) {\n            SysSite site = getSite(request);\n            service.check(site.getId(), ids);\n            logOperateService.save(new LogOperate(site.getId(), getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"check.place\", getIpAddress(request), getDate(), join(ids, ',')));\n        }\n        return TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 888,
    "type": "Param",
    "comment": "@param methodMetaData the method to filter",
    "code": "    private String methodFilter(final ClassGen cg,\r\n                                final Method method) {\r\n        MethodMetaData methodMetaData =\r\n                TransformationUtil.createMethodMetaData(method);\r\n\r\n        String uuid = null;\r\n        if (methodMetaData.getName().equals(\"<init>\") ||\r\n                methodMetaData.getName().equals(\"<clinit>\") ||\r\n                methodMetaData.getName().startsWith(TransformationUtil.ORIGINAL_METHOD_PREFIX) ||\r\n                methodMetaData.getName().equals(TransformationUtil.GET_META_DATA_METHOD) ||\r\n                methodMetaData.getName().equals(TransformationUtil.SET_META_DATA_METHOD) ||\r\n                methodMetaData.getName().equals(TransformationUtil.GET_UUID_METHOD)) {\r\n            uuid = null;\r\n        }\r\n        else {\r\n            if (m_weaveModel.hasMethodPointcut(\r\n                    cg.getClassName(), methodMetaData)) {\r\n                uuid = m_weaveModel.getUuid();\r\n            }\r\n            if (m_weaveModel.hasThrowsPointcut(\r\n                    cg.getClassName(), methodMetaData)) {\r\n                uuid = m_weaveModel.getUuid();\r\n            }\r\n        }\r\n        return uuid;\r\n    }\r\n\n",
    "label": 1,
    "rec": "@param method the method to filter"
  },
  {
    "id": 889,
    "type": "Param",
    "comment": "@param buffer the buffer to be parsed.",
    "code": "\tprotected BigDecimal extractValue(byte[] buffer, int offset) {\n\t\tint size = buffer[offset] & SIZE_MASK;\n\t\tint precision = (buffer[offset] & PRECISION_MASK) >> PRECISION_SHIFT;\n\n\t\tint value = 0;\n\t\tint i;\n\t\tfor (i = 0; i < size; ++i) {\n\t\t\tvalue <<= 8;\n\t\t\tvalue |= buffer[offset + i + 1] & 0xFF;\n\t\t}\n\t\t\n\t\t// Deal with sign extension. All values are signed\n\t\tBigDecimal result;\n\t\tif ((buffer[offset + 1] & 0x80) == 0x80) {\n\n\t\t\t// MSB is signed\n\t\t\tif (size == 1) {\n\t\t\t\tvalue |= 0xffffff00;\n\t\t\t} else if (size == 2) {\n\t\t\t\tvalue |= 0xffff0000;\n\t\t\t}\n\t\t}\n\n\t\tresult = BigDecimal.valueOf(value);\n\n\t\tBigDecimal divisor = BigDecimal.valueOf(Math.pow(10, precision));\n\t\treturn result.divide(divisor);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 890,
    "type": "Param",
    "comment": "@param file a Gzipped file",
    "code": "  private int getGzipSizeUncompressed(File zipFile) throws IOException {\n    RandomAccessFile raf = new RandomAccessFile(zipFile, \"r\");\n    raf.seek(raf.length() - 4);\n    int b4 = raf.read();\n    int b3 = raf.read();\n    int b2 = raf.read();\n    int b1 = raf.read();\n    raf.close();\n    return (b1 << 24) | (b2 << 16) + (b3 << 8) + b4;\n  }\n",
    "label": 1,
    "rec": "@param file Gzipped file to get the size for"
  },
  {
    "id": 891,
    "type": "Param",
    "comment": "@param key",
    "code": "    public String lset(final byte[] key, final long index, final byte[] value) {\n\tcheckIsInMulti();\n\tclient.lset(key, index, value);\n\treturn client.getStatusCodeReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 892,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    private Integer key(Ignite ignite, int mode) {\n        GridCache<Integer, Integer> cache = ignite.cache(null);\n\n        GridCacheAffinity<Integer> aff = cache.affinity();\n\n        Integer key = null;\n\n        for (int i = lastKey + 1; i < 1_000_000; i++) {\n            boolean pass = false;\n\n            switch(mode) {\n                case PRIMARY: pass = aff.isPrimary(ignite.cluster().localNode(), i); break;\n\n                case BACKUP: pass = aff.isBackup(ignite.cluster().localNode(), i); break;\n\n                case NOT_PRIMARY_AND_BACKUP: pass = !aff.isPrimaryOrBackup(ignite.cluster().localNode(), i); break;\n\n                default: fail();\n            }\n\n            lastKey = i;\n\n            if (pass) {\n                key = i;\n\n                break;\n            }\n        }\n\n        assertNotNull(key);\n\n        return key;\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 893,
    "type": "Param",
    "comment": "@param m Grid marshaller.",
    "code": "    static GridSharedFsCheckpointData read(File file, GridMarshaller m, IgniteLogger log)\n        throws IOException, GridException {\n        assert file != null;\n        assert m != null;\n        assert log != null;\n\n        InputStream in = new FileInputStream(file);\n\n        try {\n            return (GridSharedFsCheckpointData)m.unmarshal(in, U.gridClassLoader());\n        }\n        finally {\n            U.close(in, log);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 894,
    "type": "Param",
    "comment": "@param grid Grid.",
    "code": "    private String txGet(Ignite ignite, String key) throws Exception {\n        try (GridCacheTx tx = ignite.cache(null).txStart(PESSIMISTIC, REPEATABLE_READ)) {\n            GridCacheEntryEx<String, Integer> dhtEntry = dht(ignite).peekEx(key);\n\n            if (DEBUG)\n                info(\"DHT entry [hash=\" + System.identityHashCode(dhtEntry) + \", xid=\" + tx.xid() +\n                    \", entry=\" + dhtEntry + ']');\n\n            String val = ignite.<String, String>cache(null).get(key);\n\n            assertNotNull(val);\n            assertEquals(\"val\", val);\n\n            tx.commit();\n\n            return val;\n        }\n    }\n",
    "label": 1,
    "rec": "@param ignite Grid."
  },
  {
    "id": 895,
    "type": "Param",
    "comment": "@param privateDerivation whether to use private or public derivation",
    "code": "    public ExtendedHierarchicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation) {\n        ExtendedHierarchicKey parent = get(parentPath, relative, createParent);\n        int nAttempts = 0;\n        while (nAttempts++ < MAX_CHILD_DERIVATION_ATTEMPTS) {\n            try {\n                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getChildNumberPath(), privateDerivation);\n                return deriveChild(parent, createChildNumber);\n            } catch (HDDerivationException ignore) { }\n        }\n        throw new HDDerivationException(\"Maximum number of child derivation attempts reached, this is probably an indication of a bug.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 896,
    "type": "Param",
    "comment": "@param ggfs GGFS flag.",
    "code": "    private static GridHadoopFileBlock split(boolean igfs, String file, long start, long len, String... hosts) {\n        URI uri = URI.create((igfs ? \"igfs://igfs@\" : \"hdfs://\") + file);\n\n        return new GridHadoopFileBlock(hosts, uri, start, len);\n    }\n",
    "label": 1,
    "rec": "@param igfs IGFS flag."
  },
  {
    "id": 897,
    "type": "Param",
    "comment": "@param repository",
    "code": "    public Issue getIssue(Repo repository, int number) {\n        ItemReferences<Issue> repoIssues = repos.get(InfoUtils.createRepoId(repository));\n        return repoIssues != null ? repoIssues.get(number) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 898,
    "type": "Param",
    "comment": "@param member",
    "code": "    public Long zrem(final byte[] key, final byte[]... members) {\n        checkIsInMulti();\n        client.zrem(key, members);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param members"
  },
  {
    "id": 899,
    "type": "Param",
    "comment": "@param node Node.",
    "code": "    public boolean alive(ClusterNode node) {\n        assert node != null;\n\n        return alive(node.id());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 900,
    "type": "Param",
    "comment": "@param userVersion Version to create.",
    "code": "    private String makeUserVersion(String userVer) {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \" +\n            \"<beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" \" +\n            \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" +\n            \"xmlns:util=\\\"http://www.springframework.org/schema/util\\\" \" +\n            \"xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans \" +\n            \"http://www.springframework.org/schema/beans/spring-beans.xsd \" +\n            \"http://www.springframework.org/schema/util \" +\n            \"http://www.springframework.org/schema/util/spring-util.xsd\\\"> \" +\n            \"<bean id=\\\"userVersion\\\" class=\\\"java.lang.String\\\"><constructor-arg value=\\\"\" + userVer + \"\\\"/></bean> \" +\n            \"</beans>\";\n    }\n",
    "label": 1,
    "rec": "@param userVer Version to create."
  },
  {
    "id": 901,
    "type": "Param",
    "comment": "@param meta Job metadata.",
    "code": "    private JobLocalState initState(GridHadoopJobMetadata meta) {\n        GridHadoopJobId jobId = meta.jobId();\n\n        GridHadoopJob job = ctx.jobFactory().createJob(jobId, meta.jobInfo());\n\n        JobLocalState state = new JobLocalState(job, meta);\n\n        return F.addIfAbsent(activeJobs, jobId, state);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 902,
    "type": "Param",
    "comment": "@param bullEyeCornerPoints the array of bull's eye corners",
    "code": "  private ResultPoint[] getMatrixCornerPoints(ResultPoint[] bullsEyeCorners) throws NotFoundException {\n    return expandSquare(bullsEyeCorners, 2 * nbCenterLayers, getDimension());\n  }\n",
    "label": 1,
    "rec": "@param bullsEyeCorners the array of bull's eye corners"
  },
  {
    "id": 903,
    "type": "Param",
    "comment": "@param cache Cache.",
    "code": "    private Iterable<Integer> primaryKeysForCache(GridCache<Integer,String> cache, int cnt) {\n        Collection<Integer> found = new ArrayList<>(cnt);\n\n        for (int i = 0; i < 10000; i++) {\n            if (cache.affinity().isPrimary(grid(caches.indexOf(cache)).localNode(), i)) {\n                found.add(i);\n\n                if (found.size() == cnt)\n                    return found;\n            }\n        }\n\n        throw new IllegalStateException(\"Unable to find \" + cnt + \" keys as primary for cache.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 904,
    "type": "Param",
    "comment": "@param repository - a bean that implements  ReactorSessionRepository.",
    "code": "\tpublic WebSessionManager webSessionManager(ReactiveSessionRepository<? extends Session> repository) {\n\t\tSpringSessionWebSessionStore<? extends Session> sessionStore = new SpringSessionWebSessionStore<>(repository);\n\t\tDefaultWebSessionManager manager = new DefaultWebSessionManager();\n\t\tmanager.setSessionStore(sessionStore);\n\n\t\tif (this.webSessionIdResolver != null) {\n\t\t\tmanager.setSessionIdResolver(this.webSessionIdResolver);\n\t\t}\n\n\t\treturn manager;\n\t}\n",
    "label": 1,
    "rec": "@param repository - a bean that implements  ReactiveSessionRepository."
  },
  {
    "id": 905,
    "type": "Param",
    "comment": "@param redirectToAuthentication if true redirect to flow url. If initial call to protocol is a POST, you probably want to do this. This is so we can disable the back button on browser",
    "code": "    protected Response handleBrowserAuthenticationRequest(ClientSessionModel clientSession, LoginProtocol protocol, boolean isPassive, boolean redirectToAuthentication) {\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(clientSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n        event.detail(Details.CODE_ID, clientSession.getId());\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            try {\n                if (processor.authenticateOnly() == null) {\n                    processor.attachSession();\n                } else {\n                    Response response = protocol.sendError(clientSession, Error.PASSIVE_LOGIN_REQUIRED);\n                    session.sessions().removeClientSession(realm, clientSession);\n                    return response;\n                }\n                if (processor.isActionRequired()) {\n                    Response response = protocol.sendError(clientSession, Error.PASSIVE_INTERACTION_REQUIRED);\n                    session.sessions().removeClientSession(realm, clientSession);\n                    return response;\n\n                }\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n            return processor.finishAuthentication(protocol);\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(session, realm, clientConnection, uriInfo, clientSession);\n                if (redirectToAuthentication) {\n                    return processor.redirectToFlow();\n                }\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 906,
    "type": "Param",
    "comment": "@param brokerProperties the properties to use for configuring Kafka Broker(s).",
    "code": "\tpublic EmbeddedKafkaBroker brokerProperties(Map<String, String> properties) {\n\t\tthis.brokerProperties.putAll(properties);\n\t\treturn this;\n\t}\n",
    "label": 1,
    "rec": "@param properties the properties to use for configuring Kafka Broker(s)."
  },
  {
    "id": 907,
    "type": "Param",
    "comment": "@param missedMap Missed keys.",
    "code": "                @Override public void apply(KeyCacheObject key, Object val) {\n                    if (isRollbackOnly()) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Ignoring loaded value for read because transaction was rolled back: \" +\n                                IgniteTxLocalAdapter.this);\n\n                        return;\n                    }\n\n                    GridCacheVersion ver = missedMap.get(key);\n\n                    if (ver == null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Value from storage was never asked for [key=\" + key + \", val=\" + val + ']');\n\n                        return;\n                    }\n\n                    CacheObject cacheVal = cacheCtx.toCacheObject(val);\n\n                    Object visibleVal = val;\n\n                    IgniteTxKey txKey = cacheCtx.txKey(key);\n\n                    IgniteTxEntry txEntry = entry(txKey);\n\n                    if (txEntry != null) {\n                        if (!readCommitted())\n                            txEntry.readValue(cacheVal);\n\n                        if (!F.isEmpty(txEntry.entryProcessors()))\n                            visibleVal = txEntry.applyEntryProcessors(visibleVal);\n                    }\n\n                    // In pessimistic mode we hold the lock, so filter validation\n                    // should always be valid.\n                    if (pessimistic())\n                        ver = null;\n\n                    // Initialize next version.\n                    if (nextVer == null)\n                        nextVer = cctx.versions().next(topologyVersion());\n\n                    while (true) {\n                        assert txEntry != null || readCommitted() || groupLock() || skipVals;\n\n                        GridCacheEntryEx e = txEntry == null ? entryEx(cacheCtx, txKey) : txEntry.cached();\n\n                        try {\n                            // Must initialize to true since even if filter didn't pass,\n                            // we still record the transaction value.\n                            boolean set;\n\n                            try {\n                                set = e.versionedValue(cacheVal, ver, nextVer);\n                            }\n                            catch (GridCacheEntryRemovedException ignore) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Got removed entry in transaction getAll method \" +\n                                        \"(will try again): \" + e);\n\n                                if (pessimistic() && !readCommitted() && !isRollbackOnly() &&\n                                    (!groupLock() || F.eq(e.key(), groupLockKey()))) {\n                                    U.error(log, \"Inconsistent transaction state (entry got removed while \" +\n                                        \"holding lock) [entry=\" + e + \", tx=\" + IgniteTxLocalAdapter.this + \"]\");\n\n                                    setRollbackOnly();\n\n                                    return;\n                                }\n\n                                if (txEntry != null)\n                                    txEntry.cached(entryEx(cacheCtx, txKey), null);\n\n                                continue; // While loop.\n                            }\n\n                            // In pessimistic mode, we should always be able to set.\n                            assert set || !pessimistic();\n\n                            if (readCommitted() || groupLock() || skipVals) {\n                                cacheCtx.evicts().touch(e, topologyVersion());\n\n                                if (visibleVal != null)\n                                    map.put(key.<K>value(cacheCtx), (V)CU.skipValue(visibleVal, skipVals));\n                            }\n                            else {\n                                assert txEntry != null;\n\n                                txEntry.setAndMarkValid(cacheVal);\n\n                                if (visibleVal != null)\n                                    map.put(key.<K>value(cacheCtx), (V)visibleVal);\n                            }\n\n                            loaded.add(key);\n\n                            if (log.isDebugEnabled())\n                                log.debug(\"Set value loaded from store into entry from transaction [set=\" + set +\n                                    \", matchVer=\" + ver + \", newVer=\" + nextVer + \", entry=\" + e + ']');\n\n                            break; // While loop.\n                        }\n                        catch (IgniteCheckedException ex) {\n                            throw new IgniteException(\"Failed to put value for cache entry: \" + e, ex);\n                        }\n                    }\n                }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 908,
    "type": "Param",
    "comment": "@param topVer Topology snapshot for which candidate is added.",
    "code": "    public boolean addCandidate(GridDiscoveryTopologySnapshot topSnapshot, GridCacheMvccCandidate cand) {\n        lock();\n\n        try {\n            if (cands.isEmpty())\n                return false;\n\n            assert this.topSnapshot.topologyVersion() == topSnapshot.topologyVersion();\n\n            Deque<GridCacheMvccCandidate> deque = ensureDeque(cand.key());\n\n            GridCacheMvccCandidate old = F.first(deque);\n\n            deque.add(cand);\n\n            if (old != null && old.owner())\n                cand.setOwner();\n\n            return true;\n        }\n        finally {\n            unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@param topSnapshot Topology snapshot for which candidate is added."
  },
  {
    "id": 909,
    "type": "Param",
    "comment": "@param filterItems items to filter",
    "code": "    public Object doFilter(Iterable<T> filterItems, Configuration configuration) {\n        JsonProvider provider = configuration.getProvider();\n        Object result = provider.createArray();\n        for (T filterItem : filterItems) {\n            if (accept(filterItem, configuration)) {\n                provider.setProperty(result, provider.length(result), filterItem);\n            }\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 910,
    "type": "Param",
    "comment": "@param srvNodesNum Server nodes number.",
    "code": "    private String topologySnapshotMessage(int serverNodesNum, int clientNodesNum, int totalCpus, double heap) {\n        return PREFIX + \" [\" +\n            (discoOrdered ? \"ver=\" + topSnap.get().topVer.topologyVersion() + \", \" : \"\") +\n            \"servers=\" + serverNodesNum +\n            \", clients=\" + clientNodesNum +\n            \", CPUs=\" + totalCpus +\n            \", heap=\" + heap + \"GB\" +\n            ']';\n    }\n",
    "label": 1,
    "rec": "@param serverNodesNum Server nodes number."
  },
  {
    "id": 911,
    "type": "Param",
    "comment": "@param fullPermissionName",
    "code": "\tpublic boolean comparePermissionString(String userAcessLevel, String fullPermissionName) {\n\t\tif (userAcessLevel == null || fullPermissionName == null) {\n\t\t\treturn false;\n\t\t}\n\t\tGroupManager.logger.finest(\"COMPARING \" + userAcessLevel + \" WITH \" + fullPermissionName);\n\n\t\tif (userAcessLevel.startsWith(\"+\")) {\n\t\t\tuserAcessLevel = userAcessLevel.substring(1);\n\t\t} else if (userAcessLevel.startsWith(\"-\")) {\n\t\t\tuserAcessLevel = userAcessLevel.substring(1);\n\t\t}\n\n\t\tif (fullPermissionName.startsWith(\"+\")) {\n\t\t\tfullPermissionName = fullPermissionName.substring(1);\n\t\t} else if (fullPermissionName.startsWith(\"-\")) {\n\t\t\tfullPermissionName = fullPermissionName.substring(1);\n\t\t}\n\n\t\tStringTokenizer levelATokenizer = new StringTokenizer(userAcessLevel, \".\");\n\t\tStringTokenizer levelBTokenizer = new StringTokenizer(fullPermissionName, \".\");\n\t\twhile (levelATokenizer.hasMoreTokens() && levelBTokenizer.hasMoreTokens()) {\n\t\t\tString levelA = levelATokenizer.nextToken();\n\t\t\tString levelB = levelBTokenizer.nextToken();\n\t\t\tGroupManager.logger.finest(\"ROUND \" + levelA + \" AGAINST \" + levelB);\n\t\t\tif (levelA.contains(\"*\")) {\n\t\t\t\tGroupManager.logger.finest(\"WIN\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (levelA.equalsIgnoreCase(levelB)) {\n\t\t\t\tif (!levelATokenizer.hasMoreTokens() && !levelBTokenizer.hasMoreTokens()) {\n\t\t\t\t\tGroupManager.logger.finest(\"WIN\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tGroupManager.logger.finest(\"NEXT\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tGroupManager.logger.finest(\"FAIL\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n\t\tGroupManager.logger.finest(\"FAIL\");\n\t\treturn false;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 912,
    "type": "Param",
    "comment": "@param charSequence the CharSequence the predicate will check for",
    "code": "    public static Predicate<String> contains(CharSequence contains) {\r\n        return new ContainsPredicate(contains);\r\n    }\r\n\n",
    "label": 1,
    "rec": "@param contains the CharSequence the predicate will check for"
  },
  {
    "id": 913,
    "type": "Param",
    "comment": "@param p Partition.",
    "code": "        private boolean preloadEntry(GridNode pick, int p, GridCacheEntryInfo<K, V> entry, long topVer)\n            throws GridException, GridInterruptedException {\n            try {\n                GridCacheEntryEx<K, V> cached = null;\n\n                try {\n                    cached = cctx.dht().entryEx(entry.key());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Preloading key [key=\" + entry.key() + \", part=\" + p + \", node=\" + pick.id() + ']');\n\n                    if (cctx.dht().isGgfsDataCache() &&\n                        cctx.dht().ggfsDataSpaceUsed() > cctx.dht().ggfsDataSpaceMax()) {\n                        LT.error(log, null, \"Failed to preload GGFS data cache (GGFS space size exceeded maximum \" +\n                            \"value, will ignore preload entries): \" + name());\n\n                        if (cached.markObsoleteIfEmpty(null))\n                            cached.context().cache().removeIfObsolete(cached.key());\n\n                        return true;\n                    }\n\n                    if (preloadPred == null || preloadPred.apply(entry)) {\n                        if (cached.initialValue(\n                            entry.value(),\n                            entry.valueBytes(),\n                            entry.version(),\n                            entry.ttl(),\n                            entry.expireTime(),\n                            true,\n                            topVer,\n                            cctx.isReplicationEnabled() ? DR_PRELOAD : DR_NONE\n                        )) {\n                            cctx.evicts().touch(cached, topVer); // Start tracking.\n\n                            if (cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_LOADED) && !cached.isInternal())\n                                cctx.events().addEvent(cached.partition(), cached.key(), cctx.localNodeId(),\n                                    (GridUuid)null, null, EVT_CACHE_PRELOAD_OBJECT_LOADED, entry.value(), true, null,\n                                    false);\n                        }\n                        else if (log.isDebugEnabled())\n                            log.debug(\"Preloading entry is already in cache (will ignore) [key=\" + cached.key() +\n                                \", part=\" + p + ']');\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Preload predicate evaluated to false for entry (will ignore): \" + entry);\n                }\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Entry has been concurrently removed while preloading (will ignore) [key=\" +\n                            cached.key() + \", part=\" + p + ']');\n                }\n                catch (GridDhtInvalidPartitionException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Partition became invalid during preloading (will ignore): \" + p);\n\n                    return false;\n                }\n            }\n            catch (GridInterruptedException e) {\n                throw e;\n            }\n            catch (GridException e) {\n                throw new GridException(\"Failed to cache preloaded entry (will stop preloading) [local=\" +\n                    cctx.nodeId() + \", node=\" + pick.id() + \", key=\" + entry.key() + \", part=\" + p + ']', e);\n            }\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 914,
    "type": "Param",
    "comment": "@param integer",
    "code": "  public Long decrBy(final String key, final long decrement) {\n    checkIsInMultiOrPipeline();\n    client.decrBy(key, decrement);\n    return client.getIntegerReply();\n  }\n",
    "label": 1,
    "rec": "@param decrement"
  },
  {
    "id": 915,
    "type": "Param",
    "comment": "@param desc File descriptor of file or directory to delete.",
    "code": "    private boolean delete0(FileDescriptor desc, @Nullable IgniteFsPath parentPath, boolean recursive)\n        throws GridException {\n        IgniteFsPath curPath = parentPath == null ? new IgniteFsPath() : new IgniteFsPath(parentPath, desc.fileName);\n\n        if (desc.isFile) {\n            deleteFile(curPath, desc, true);\n\n            return true;\n        }\n        else {\n            if (recursive) {\n                meta.softDelete(desc.parentId, desc.fileName, desc.fileId);\n\n                return true;\n            }\n            else {\n                Map<String, GridGgfsListingEntry> infoMap = meta.directoryListing(desc.fileId);\n\n                if (F.isEmpty(infoMap)) {\n                    deleteFile(curPath, desc, true);\n\n                    return true;\n                }\n                else\n                    // Throw exception if not empty and not recursive.\n                    throw new GridGgfsDirectoryNotEmptyException(\"Failed to remove directory (directory is not empty \" +\n                        \"and recursive flag is not set)\");\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 916,
    "type": "Param",
    "comment": "@param posteriori the input/output vector.",
    "code": "    public static int softmax(double[] x, int k) {\n        int y = -1;\n        double max = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < k; i++) {\n            if (x[i] > max) {\n                max = x[i];\n                y = i;\n            }\n        }\n\n        double Z = 0.0;\n        for (int i = 0; i < k; i++) {\n            double out = Math.exp(x[i] - max);\n            x[i] = out;\n            Z += out;\n        }\n\n        for (int i = 0; i < k; i++) {\n            x[i] /= Z;\n        }\n\n        return y;\n    }\n",
    "label": 1,
    "rec": "@param x the input/output vector."
  },
  {
    "id": 917,
    "type": "Param",
    "comment": "@param obsoleteVer Obsolete version.",
    "code": "    protected boolean evictNearEntry(GridCacheEntryEx<K, V> e, GridCacheVersion obsoleteVer, AffinityTopologyVersion topVer) {\n        assert e != null;\n        assert obsoleteVer != null;\n\n        if (isNearLocallyMapped(e, topVer)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Evicting dht-local entry from near cache [entry=\" + e + \", tx=\" + this + ']');\n\n            if (e.markObsolete(obsoleteVer))\n                return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 918,
    "type": "Param",
    "comment": "@param replicate_training_data whether or not the training data is replicated on each node",
    "code": "  private static long computeTrainSamplesPerIteration(final DeepLearning mp, final long numRows, long model_size) {\n    long tspi = mp.train_samples_per_iteration;\n    assert(tspi == 0 || tspi == -1 || tspi == -2 || tspi >= 1);\n    if (tspi == 0 || (!mp.replicate_training_data && tspi == -1) ) {\n      tspi = numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n    }\n    else if (tspi == -1) {\n      tspi = (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows;\n      if (!mp.quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n    } else if (tspi == -2) {\n      // automatic tuning based on CPU speed, network speed and model size\n\n      // measure cpu speed\n      double total_gflops = 0;\n      for (H2ONode h2o : H2O.CLOUD._memary) {\n        HeartBeat hb = h2o._heartbeat;\n        total_gflops += hb._gflops;\n      }\n      if (mp.single_node_mode) total_gflops /= H2O.CLOUD.size();\n      if (total_gflops == 0) {\n        total_gflops = Linpack.run(H2O.SELF._heartbeat._cpus_allowed) * (mp.single_node_mode ? 1 : H2O.CLOUD.size());\n      }\n\n      int[] msg_sizes = new int[]{ (int)(model_size*4) == (model_size*4) ? (int)(model_size*4) : Integer.MAX_VALUE };\n      double[] microseconds_collective = new double[msg_sizes.length];\n      NetworkTest.NetworkTester nt = new NetworkTest.NetworkTester(msg_sizes,null,microseconds_collective,model_size>1e6 ? 1 : 5 /*repeats*/,false,true /*only collectives*/);\n      nt.compute2();\n\n      //length of the network traffic queue based on log-tree rollup (2 log(nodes))\n      int network_queue_length = mp.single_node_mode || H2O.CLOUD.size() == 1? 1 : 2*(int)Math.floor(Math.log(H2O.CLOUD.size())/Math.log(2));\n\n      // heuristics\n      double flops_overhead_per_row = 30;\n      if (mp.activation == Activation.Maxout || mp.activation == Activation.MaxoutWithDropout) {\n        flops_overhead_per_row *= 8;\n      } else if (mp.activation == Activation.Tanh || mp.activation == Activation.TanhWithDropout) {\n        flops_overhead_per_row *= 5;\n      }\n\n      // target fraction of comm vs cpu time: 5%\n      double fraction = mp.single_node_mode || H2O.CLOUD.size() == 1 ? 1e-3 : 0.05; //one single node mode, there's no model averaging effect, so less need to shorten the M/R iteration\n\n      // estimate the time for communication (network) and training (compute)\n      double time_comm_us = (H2O.CLOUD.size() == 1 ? 1e4 /* add 10ms for single-node */ : 0) + network_queue_length * microseconds_collective[0];\n      double time_per_row_us  = flops_overhead_per_row * model_size / (total_gflops * 1e9) / H2O.SELF._heartbeat._cpus_allowed * 1e6;\n\n      // compute the optimal number of training rows per iteration\n      // fraction := time_comm_us / (time_comm_us + tspi * time_per_row_us)  ==>  tspi = (time_comm_us/fraction - time_comm_us)/time_per_row_us\n      tspi = (long)((time_comm_us / fraction - time_comm_us)/ time_per_row_us);\n\n      tspi = Math.max(1, tspi); //at least 1 point\n      tspi = Math.min(tspi, (mp.single_node_mode ? 1 : H2O.CLOUD.size()) * numRows * 10); //not more than 10x of what train_samples_per_iteration=-1 would do\n\n      // If the number is close to a multiple of epochs, use that -> prettier scoring\n      if (tspi > numRows && Math.abs(tspi % numRows)/(double)numRows < 0.2)  tspi = tspi - tspi % numRows;\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows)); //limit to number of epochs desired\n\n      if (!mp.quiet_mode) {\n        Log.info(\"Auto-tuning parameter 'train_samples_per_iteration':\");\n        Log.info(\"Estimated compute power : \" + (int)total_gflops + \" GFlops\");\n        Log.info(\"Estimated time for comm : \" + PrettyPrint.usecs((long)time_comm_us));\n        Log.info(\"Estimated time per row  : \" + ((long)time_per_row_us > 0 ? PrettyPrint.usecs((long)time_per_row_us) : time_per_row_us + \" usecs\"));\n        Log.info(\"Estimated training speed: \" + (int)(1e6/time_per_row_us) + \" rows/sec\");\n        Log.info(\"Setting train_samples_per_iteration (\" + mp.train_samples_per_iteration + \") to auto-tuned value: \" + tspi);\n      }\n\n    } else {\n      // limit user-given value to number of epochs desired\n      tspi = Math.min(tspi, (long)(mp.epochs * numRows));\n    }\n    assert(tspi != 0 && tspi != -1 && tspi != -2 && tspi >= 1);\n    return tspi;\n  }\n",
    "label": 1,
    "rec": "@param model_size Size of the model in #weights and #biases"
  },
  {
    "id": 919,
    "type": "Param",
    "comment": "@param runner runner.",
    "code": "  public static Event create(final Object runner, final EventType type, final EventData eventData)\n      throws NullPointerException {\n    Preconditions.checkNotNull(eventData, \"EventData was null\");\n    return new Event(runner, type, eventData);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 920,
    "type": "Param",
    "comment": "@param ignite Ignite.",
    "code": "    private static TimerTask scheduleQuery(final Ignite g, Timer timer) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                final IgniteStreamer streamer = g.streamer(\"popular-numbers\");\n\n                try {\n                    // Send reduce query to all 'popular-numbers' streamers\n                    // running on local and remote nodes.\n                    Collection<StreamerIndexEntry<Integer, Integer, Long>> col = streamer.context().reduce(\n                        // This closure will execute on remote nodes.\n                        new IgniteClosure<StreamerContext,\n                                                                            Collection<StreamerIndexEntry<Integer, Integer, Long>>>() {\n                            @Override public Collection<StreamerIndexEntry<Integer, Integer, Long>> apply(\n                                StreamerContext ctx) {\n                                StreamerIndex<Integer, Integer, Long> view = ctx.<Integer>window().index();\n\n                                return view.entries(-1 * POPULAR_NUMBERS_CNT);\n                            }\n                        },\n                        // The reducer will always execute locally, on the same node\n                        // that submitted the query.\n                        new PopularNumbersReducer());\n\n                    for (StreamerIndexEntry<Integer, Integer, Long> cntr : col)\n                        System.out.printf(\"%3d=%d\\n\", cntr.key(), cntr.value());\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 921,
    "type": "Param",
    "comment": "@param itemName unused",
    "code": "    private static EcobeeActionProvider getActionProvider(String selection) throws Exception {\n        EcobeeActionService service = EcobeeActionService.getEcobeeActionService();\n        if (service == null) {\n            throw new Exception(String.format(\"Ecobee Service is not configured, Action for selection %1$s not queued.\",\n                    selection));\n        }\n\n        EcobeeActionProvider actionProvider = service.getEcobeeActionProvider();\n        if (actionProvider == null) {\n            throw new Exception(String.format(\n                    \"Ecobee Action Provider is not configured, Action for selection %1$s not queued.\", selection));\n        }\n\n        return actionProvider;\n    }\n",
    "label": 1,
    "rec": "@param selection unused"
  },
  {
    "id": 922,
    "type": "Param",
    "comment": "@param requestEnvelope request envelope",
    "code": "    protected ResponseEnvelope invoke(UnmarshalledRequest<RequestEnvelope> unmarshalledRequest, Object context) {\n        RequestEnvelope requestEnvelope = unmarshalledRequest.getUnmarshalledRequest();\n        JsonNode requestEnvelopeJson = unmarshalledRequest.getRequestJson();\n\n        if (skillId != null && !requestEnvelope.getContext().getSystem().getApplication().getApplicationId().equals(skillId)) {\n            throw new AskSdkException(\"AlexaSkill ID verification failed.\");\n        }\n\n        ServiceClientFactory factory = apiClient != null ? ServiceClientFactory.builder()\n                .withDefaultApiConfiguration(getApiConfiguration(requestEnvelope))\n                .build() : null;\n\n        HandlerInput handlerInput = HandlerInput.builder()\n                .withRequestEnvelope(requestEnvelope)\n                .withPersistenceAdapter(persistenceAdapter)\n                .withContext(context)\n                .withServiceClientFactory(factory)\n                .withRequestEnvelopeJson(requestEnvelopeJson)\n                .build();\n\n        Optional<Response> response = requestDispatcher.dispatch(handlerInput);\n        return ResponseEnvelope.builder()\n                .withResponse(response != null ? response.orElse(null) : null)\n                .withSessionAttributes\n                        (requestEnvelope.getSession() != null ? handlerInput.getAttributesManager().getSessionAttributes() : null)\n                .withVersion(SdkConstants.FORMAT_VERSION)\n                .withUserAgent(UserAgentUtils.getUserAgent(customUserAgent))\n                .build();\n    }\n",
    "label": 1,
    "rec": "@param unmarshalledRequest unmarshalled output from  JacksonJsonUnmarshaller, containing a  RequestEnvelope and a JSON representation of the request."
  },
  {
    "id": 923,
    "type": "Param",
    "comment": "@param deviceId The bulb id the bridge has filed the bulb under.",
    "code": "\tpublic int getBrightness(int deviceNumber) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(Integer.toString(deviceNumber)).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 1,
    "rec": "@param deviceNumber The bulb number the bridge has filed the bulb under."
  },
  {
    "id": 924,
    "type": "Param",
    "comment": "@param tmps",
    "code": "                private Object decodeBoolean(final IoBuffer buff, final String[] sa) {\n                    this.assertCommand(sa[0], \"result\");\n                    final int valueLen = Integer.parseInt(sa[2]);\n                    if (valueLen == 0) {\n                        return new BooleanCommand(Integer.parseInt(sa[1]), null, Integer.parseInt(sa[3]));\n                    }\n                    else {\n                        if (buff.remaining() < valueLen) {\n                            buff.reset();\n                            return null;\n                        }\n                        else {\n                            final byte[] data = new byte[valueLen];\n                            buff.get(data);\n                            return new BooleanCommand(Integer.parseInt(sa[1]), ByteUtils.getString(data),\n                                Integer.parseInt(sa[3]));\n                        }\n                    }\n                }\n",
    "label": 1,
    "rec": "@param sa"
  },
  {
    "id": 925,
    "type": "Param",
    "comment": "@param ignite Grid.",
    "code": "    public static VisorCache from(Ignite g, GridCache c, int sample) throws IgniteCheckedException {\n        assert g != null;\n        assert c != null;\n\n        String cacheName = c.name();\n\n        GridCacheAdapter ca = ((IgniteKernal)g).internalCache(cacheName);\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && cfg.getDistributionMode() != CacheDistributionMode.CLIENT_ONLY;\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(-1)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = g.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<CacheEntry> set = ca.entrySet();\n\n        long memSz = 0;\n\n        Iterator<CacheEntry> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name(cacheName);\n        cache.mode(mode);\n        cache.memorySize(memSz);\n        cache.size(size);\n        cache.nearSize(near);\n        cache.dhtSize(size - near);\n        cache.primarySize(ca.primarySize());\n        cache.offHeapAllocatedSize(ca.offHeapAllocatedSize());\n        cache.offHeapEntriesCount(ca.offHeapEntriesCount());\n        cache.swapSize(swapSize);\n        cache.swapKeys(swapKeys);\n        cache.partitions(ca.affinity().partitions());\n        cache.primaryPartitions(pps);\n        cache.backupPartitions(bps);\n        cache.metrics(VisorCacheMetrics.from(ca));\n        cache.partitionMap(partsMap);\n\n        return cache;\n    }\n",
    "label": 1,
    "rec": "@param g Grid."
  },
  {
    "id": 926,
    "type": "Param",
    "comment": "@param sessionType the sessionType to be checked",
    "code": "    protected boolean checkPermissions(Mode mode, Audio audio) {\n        checkPermissionsManifestOrThrow(mode, audio);\n        // Manifest is OK at this point. Let's check runtime permissions.\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) return true;\n\n        Context c = getContext();\n        boolean needsCamera = true;\n        boolean needsAudio = mode == Mode.VIDEO && audio == Audio.ON;\n\n        needsCamera = needsCamera && c.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED;\n        needsAudio = needsAudio && c.checkSelfPermission(Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED;\n\n        if (needsCamera || needsAudio) {\n            requestPermissions(needsCamera, needsAudio);\n            return false;\n        }\n        return true;\n    }\n",
    "label": 1,
    "rec": "@param mode the sessionType to be checked"
  },
  {
    "id": 927,
    "type": "Param",
    "comment": "@param type The type of the class where the method is located.",
    "code": "\tpublic static Method method(Class<?> declaringClass, Class<?>... parameterTypes) {\n\t\treturn Whitebox.getMethod(declaringClass, parameterTypes);\n\t}\n",
    "label": 1,
    "rec": "@param declaringClass The declaringClass of the class where the method is located."
  },
  {
    "id": 928,
    "type": "Param",
    "comment": "@param local Enforce local.",
    "code": "    private ClusterGroup projection(boolean loc) {\n        if (loc || ctx.isLocal() || isReplicatedDataNode())\n            return ctx.kernalContext().grid().cluster().forLocal();\n\n        if (ctx.isReplicated())\n            return ctx.kernalContext().grid().cluster().forDataNodes(ctx.name()).forRandom();\n\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param loc Enforce local."
  },
  {
    "id": 929,
    "type": "Param",
    "comment": "@param command environment variable name.",
    "code": "    private String exec(Session ses, String cmd) throws JSchException, IOException {\n        ChannelExec ch = null;\n\n        try {\n            ch = (ChannelExec)ses.openChannel(\"exec\");\n\n            ch.setCommand(cmd);\n\n            ch.connect();\n\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(ch.getInputStream()))) {\n                return reader.readLine();\n            }\n        }\n        finally {\n            if (ch != null && ch.isConnected())\n                ch.disconnect();\n        }\n    }\n",
    "label": 1,
    "rec": "@param cmd environment variable name."
  },
  {
    "id": 930,
    "type": "Param",
    "comment": "@param policy Eviction policy.",
    "code": "    public static Integer evictionPolicyMaxSize(CacheEvictionPolicy plc) {\n        if (plc instanceof CacheLruEvictionPolicyMBean)\n            return ((CacheLruEvictionPolicyMBean)plc).getMaxSize();\n\n        if (plc instanceof CacheRandomEvictionPolicyMBean)\n            return ((CacheRandomEvictionPolicyMBean)plc).getMaxSize();\n\n        if (plc instanceof CacheFifoEvictionPolicyMBean)\n            return ((CacheFifoEvictionPolicyMBean)plc).getMaxSize();\n\n        return null;\n    }\n",
    "label": 1,
    "rec": "@param plc Eviction policy."
  },
  {
    "id": 931,
    "type": "Param",
    "comment": "@param member",
    "code": "    public Long sadd(final byte[] key, final byte[]... members) {\n        checkIsInMulti();\n        client.sadd(key, members);\n        return client.getIntegerReply();\n    }\n",
    "label": 1,
    "rec": "@param members"
  },
  {
    "id": 932,
    "type": "Return",
    "comment": "@return true if and only if rendered node labels should be drawn as primitive shapes.",
    "code": "public boolean textAsShape(final int visibleNodeCount, final int visibleEdgeCount) {\n    return false;\n}",
    "label": 1,
    "rec": "@return true if and only if rendered node label text should be drawn as primitive shapes."
  },
  {
    "id": 933,
    "type": "Return",
    "comment": "@return Query with range.",
    "code": "        protected String loadCacheRangeQuery(boolean appendLowerBound, boolean appendUpperBound) {\n            return dialect.loadCacheRangeQuery(tblMeta.getSchema(), tblMeta.getTable(), keyCols, cols,\n                appendLowerBound, appendUpperBound);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 934,
    "type": "Return",
    "comment": "@return Value for property 'hiValue'.",
    "code": "public IntegralDataTypeHolder getHiValue() {\n    return upperLimit;\n}",
    "label": 1,
    "rec": "@return Value for property 'upperLimit'."
  },
  {
    "id": 935,
    "type": "Return",
    "comment": "@return numBytes byte long array.",
    "code": "    public static byte[] bigIntegerToBytes(BigInteger b, int numBytes) {\n        checkArgument(b.signum() >= 0, \"b must be positive or zero\");\n        checkArgument(numBytes > 0, \"numBytes must be positive\");\n        byte[] src = b.toByteArray();\n        byte[] dest = new byte[numBytes];\n        boolean isFirstByteOnlyForSign = src[0] == 0;\n        int length = isFirstByteOnlyForSign ? src.length - 1 : src.length;\n        checkArgument(length <= numBytes, \"The given number does not fit in \" + numBytes);\n        int srcPos = isFirstByteOnlyForSign ? 1 : 0;\n        int destPos = numBytes - length;\n        System.arraycopy(src, srcPos, dest, destPos, length);\n        return dest;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 936,
    "type": "Return",
    "comment": "@return a new instance of {@link PatternFragment}",
    "code": "public static ImageFragment newInstance(int resId) {\n    ImageFragment fragment = new ImageFragment();\n    Bundle args = new Bundle();\n    args.putInt(ARG_PATTERN, resId);\n    fragment.setArguments(args);\n    return fragment;\n}",
    "label": 1,
    "rec": "@return a new instance of {@link ImageFragment}"
  },
  {
    "id": 937,
    "type": "Return",
    "comment": "@return true if the resource is valid and should not be a candidate of cleanup based on the underlying rules, false otherwise.",
    "code": "    public boolean isValid(Resource resource) {\n        LOGGER.debug(String.format(\"Checking if resource %s of type %s is a cleanup candidate against %d rules and %d exclusion rules.\",\n                resource.getId(), resource.getResourceType(), rules.size(), exclusionRules.size()));\n\n        for (Rule exclusionRule : exclusionRules) {\n            if (exclusionRule.isValid(resource)) {\n                LOGGER.info(String.format(\"Resource %s is not marked as a cleanup candidate because of an exclusion rule.\", resource.getId()));\n                return true;\n            }\n        }\n\n        // We create a clone of the resource each time when we try the rule. In the first iteration of the rules\n        // we identify the rule with the nearest termination date if there is any rule considers the resource\n        // as a cleanup candidate. Then the rule is applied to the original resource.\n        Rule nearestRule = null;\n        if (rules.size() == 1) {\n            nearestRule = rules.get(0);\n        } else {\n            Date nearestTerminationTime = null;\n            for (Rule rule : rules) {\n                Resource clone = resource.cloneResource();\n                if (!rule.isValid(clone)) {\n                    if (clone.getExpectedTerminationTime() != null) {\n                        if (nearestTerminationTime == null || nearestTerminationTime.after(clone.getExpectedTerminationTime())) {\n                            nearestRule = rule;\n                            nearestTerminationTime = clone.getExpectedTerminationTime();\n                        }\n                    }\n                }\n            }\n        }\n        if (nearestRule != null && !nearestRule.isValid(resource)) {\n            LOGGER.info(String.format(\"Resource %s is marked as a cleanup candidate.\", resource.getId()));\n            return false;\n        } else {\n            LOGGER.info(String.format(\"Resource %s is not marked as a cleanup candidate.\", resource.getId()));\n            return true;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 938,
    "type": "Return",
    "comment": "@return the nodejs executable in the system is exists, {@code null} otherwise.",
    "code": "public String getExecutable() throws IOException {\n    File exe = getExeFile(getPlatform());\n    if (exe.exists()) {\n        return exe.getPath();\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the nodejs executable in the executable system is exists, {@code null} otherwise."
  },
  {
    "id": 939,
    "type": "Return",
    "comment": "@return Partition.",
    "code": "    public int partition(Object key) {\n        GridAffinityAssignmentCache aff0 = aff;\n\n        if (key instanceof KeyCacheObject && ((KeyCacheObject)key).partition() != -1)\n            return ((KeyCacheObject)key).partition();\n\n        if (aff0 == null)\n            throw new IgniteException(FAILED_TO_FIND_CACHE_ERR_MSG + cctx.name());\n\n        int p = affFunction.partition(affinityKey(key));\n\n        if (key instanceof KeyCacheObject)\n            ((KeyCacheObject)key).partition(p);\n\n        return p;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 940,
    "type": "Return",
    "comment": "@return A time object for the tapped day or null if the position wasn't in a day",
    "code": "public int getDayFromLocation(float x, float y) {\n    int dayStart = mPadding;\n    if (x < dayStart || x > mWidth - mPadding) {\n        return -NUM;\n    }\n    int row = (int) (y - MONTH_HEADER_SIZE) / mRowHeight;\n    int column = (int) ((x - dayStart) * mNumDays / (mWidth - dayStart - mPadding));\n    int day = column - findDayOffset() + NUM;\n    day += row * mNumDays;\n    if (day < NUM || day > mNumCells) {\n        return -NUM;\n    }\n    return day;\n}",
    "label": 1,
    "rec": "@return The day number, or -1 if the position wasn't in a day"
  },
  {
    "id": 941,
    "type": "Return",
    "comment": "@return Integer reply, specifically: 1 if the new element was removed 0 if the new element was not a member of the set",
    "code": "    public Long srem(final byte[] key, final byte[] member) {\n        checkIsInMulti();\n        client.srem(key, member);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 942,
    "type": "Return",
    "comment": "@return edited issue",
    "code": "public Single<Issue> editIssue(Repository repository, int issueNumber, IssueRequest request) {\n    return service.editIssue(repository.owner().login(), repository.name(), issueNumber, request).map(response -> addIssueOrThrow(repository, response, R.string.error_edit_issue));\n}",
    "label": 1,
    "rec": "@return A {@link Single} representing the changed issues"
  },
  {
    "id": 943,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    @Nullable @Override public CacheObject unswap(boolean needVal)\n        throws IgniteCheckedException, GridCacheEntryRemovedException {\n        boolean swapEnabled = cctx.swap().swapEnabled();\n\n        if (!swapEnabled && !cctx.isOffHeapEnabled())\n            return null;\n\n        synchronized (this) {\n            checkObsolete();\n\n            if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {\n                GridCacheSwapEntry e;\n\n                if (cctx.offheapTiered()) {\n                    e = cctx.swap().readOffheapPointer(this);\n\n                    if (e != null) {\n                        if (e.offheapPointer() > 0) {\n                            offHeapPointer(e.offheapPointer());\n\n                            flags |= IS_OFFHEAP_PTR_MASK;\n\n                            if (needVal) {\n                                CacheObject val = cctx.fromOffheap(offHeapPointer(), false);\n\n                                e.value(val);\n                            }\n                        }\n                        else // Read from swap.\n                            offHeapPointer(0);\n                    }\n                }\n                else\n                    e = detached() ? cctx.swap().read(this, true, true, true, false) : cctx.swap().readAndRemove(this);\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Read swap entry [swapEntry=\" + e + \", cacheEntry=\" + this + ']');\n\n                flags |= IS_UNSWAPPED_MASK;\n\n                // If there is a value.\n                if (e != null) {\n                    long delta = e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis();\n\n                    if (delta >= 0) {\n                        CacheObject val = e.value();\n\n                        val = cctx.kernalContext().cacheObjects().prepareForCache(val, cctx);\n\n                        // Set unswapped value.\n                        update(val, e.expireTime(), e.ttl(), e.version(), false);\n\n                        // Must update valPtr again since update() will reset it.\n                        if (cctx.offheapTiered() && e.offheapPointer() > 0)\n                            offHeapPointer(e.offheapPointer());\n\n                        return val;\n                    }\n                    else\n                        clearIndex(e.value());\n                }\n            }\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 944,
    "type": "Return",
    "comment": "@return model elements",
    "code": "public static IModelElement[] getModelElements(IEvaluatedType evaluatedType, ISourceModuleContext context, int offset) {\n    ISourceModule sourceModule = context.getSourceModule();\n    IModelElement[] elements = internalGetModelElements(evaluatedType, context, offset);\n    return PHPModelUtils.filterElements(sourceModule, elements);\n}",
    "label": 1,
    "rec": "@return model elements or <code>null</code> in case no element could be found"
  },
  {
    "id": 945,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteInternalFuture<IgniteInternalTx<K, V>> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteInternalFuture<IgniteInternalTx>)(IgniteInternalFuture)prep;\n\n            return new GridFinishedFuture<IgniteInternalTx>(this);\n        }\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (IgniteTxOptimisticCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listen(new CI1<IgniteInternalFuture<IgniteInternalTx<K, V>>>() {\n                @Override public void apply(IgniteInternalFuture<IgniteInternalTx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (IgniteTxOptimisticCheckedException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (IgniteCheckedException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 946,
    "type": "Return",
    "comment": "@return the location of the platform",
    "code": "public static Location getInstanceLocation() {\n    return InternalPlatform.getDefault().getInstanceLocation();\n}",
    "label": 1,
    "rec": "@return the location of the platform's instance data area"
  },
  {
    "id": 947,
    "type": "Return",
    "comment": "@return Callable for execution in async and sync mode.",
    "code": "    private Callable<Boolean> internalSet(final T val, final S stamp) {\n        return new Callable<Boolean>() {\n            @Override public Boolean call() throws Exception {\n                IgniteTxEx tx = CU.txStartInternal(ctx, atomicView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicStampedValue<T, S> stmp = atomicView.get(key);\n\n                    if (stmp == null)\n                        throw new IgniteCheckedException(\"Failed to find atomic stamped with given name: \" + name);\n\n                    stmp.set(val, stamp);\n\n                    atomicView.put(key, stmp);\n\n                    tx.commit();\n\n                    return true;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to set [val=\" + val + \", stamp=\" + stamp + \", atomicStamped=\" + this + ']', e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 948,
    "type": "Return",
    "comment": "@return Array of node IDs this predicate is based on. Returns  null if predicate has no IDs.",
    "code": "    public Set<UUID> nodeIds(){\n        return ids;\n    }\n",
    "label": 1,
    "rec": "@return Set of node IDs this predicate is based on."
  },
  {
    "id": 949,
    "type": "Return",
    "comment": "@return int time in milliseconds",
    "code": "    public int getTotalTimeMean() {\n        return rollingCommandUserLatencyDistributionStream.getLatestMean();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 950,
    "type": "Return",
    "comment": "@return {@linkplain TccCompensationVO}",
    "code": "public static HmilyCompensationVO buildVO(final CoordinatorRepositoryAdapter adapter) {\n    HmilyCompensationVO vo = new HmilyCompensationVO();\n    vo.setTransId(adapter.getTransId());\n    vo.setCreateTime(DateUtils.parseDate(adapter.getCreateTime()));\n    vo.setRetriedCount(adapter.getRetriedCount());\n    vo.setLastTime(DateUtils.parseDate(adapter.getLastTime()));\n    vo.setVersion(adapter.getVersion());\n    vo.setTargetClass(adapter.getTargetClass());\n    vo.setTargetMethod(adapter.getTargetMethod());\n    vo.setConfirmMethod(adapter.getConfirmMethod());\n    vo.setCancelMethod(adapter.getCancelMethod());\n    return vo;\n}",
    "label": 1,
    "rec": "@return {@linkplain HmilyCompensationVO}"
  },
  {
    "id": 951,
    "type": "Return",
    "comment": "@return Kernal context.",
    "code": "    public static GridKernalContext context(Ignite ignite) {\n        assert ignite != null;\n\n        return ((IgniteKernal) ignite).context();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 952,
    "type": "Return",
    "comment": "@return the options available for the given option container, or an empty collection if the are not any options available for the given option container.",
    "code": "public Collection<Property> availableOptionPropertiesFor(EObject o) {\n    EObject target = o;\n    if (target instanceof BuiltInOption)\n        target = target.eContainer();\n    if (target instanceof Protobuf)\n        return fileOptions();\n    if (target instanceof Enum)\n        return enumOptions();\n    if (target instanceof Message)\n        return messageOptions();\n    return emptyList();\n}",
    "label": 1,
    "rec": "@return the options available for the given option or option container, or an empty collection if the are not any options available for the given option container."
  },
  {
    "id": 953,
    "type": "Return",
    "comment": "@return boolean",
    "code": "    public boolean isSuccessfulExecution() {\n        return executionResult.getEventCounts().contains(HystrixEventType.SUCCESS);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 954,
    "type": "Return",
    "comment": "@return true if the method has a JSecurity HasRole or HasPermission annotation, false otherwise.",
    "code": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( Implies.class ) != null ) ||\n                 (method.getAnnotation( HasRole.class ) != null ) );\n    }\n",
    "label": 1,
    "rec": "@return true if the method has a JSecurity HasRole or Implies annotation, false otherwise."
  },
  {
    "id": 955,
    "type": "Return",
    "comment": "@return Cache affinity config.",
    "code": "    public VisorCacheAffinityConfig affinityConfig() {\n        return affinity;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 956,
    "type": "Return",
    "comment": "@return the total free memory size of the OS. 0 if there is an error.",
    "code": "  long getOsTotalFreeMemorySize() {\n    if (!Files.isRegularFile(Paths.get(MEM_INFO_FILE))) {\n      // Mac doesn't support /proc/meminfo for example.\n      return 0;\n    }\n\n    List<String> lines;\n    // The file /proc/meminfo is assumed to contain only ASCII characters.\n    // The assumption is that the file is not too big. So it is simpler to read the whole file into memory.\n    try {\n      lines = Files.readAllLines(Paths.get(MEM_INFO_FILE), StandardCharsets.UTF_8);\n    } catch (IOException e) {\n      String errMsg = \"Failed to open mem info file: \" + MEM_INFO_FILE;\n      logger.error(errMsg, e);\n      return 0;\n    }\n    return getOsTotalFreeMemorySizeFromStrings(lines);\n  }\n",
    "label": 1,
    "rec": "@return the total free memory size of the OS. 0 if there is an error or the OS doesn't support this memory check."
  },
  {
    "id": 957,
    "type": "Return",
    "comment": "@return Query closure.",
    "code": "    public List<IgniteInClosure<IgniteStreamer>> getClosures() {\n        return clos;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 958,
    "type": "Return",
    "comment": "@return returns true if path traversal should be stopped when hitting one of this node.",
    "code": "public boolean isPathStopper(PathNode node) {\n    return super.isPathStopper(node) || (node instanceof OrFork) || (node instanceof OrJoin) || (node instanceof Stub);\n}",
    "label": 1,
    "rec": "@return true if path traversal should be stopped when hitting one of this node."
  },
  {
    "id": 959,
    "type": "Return",
    "comment": "@return Part ID constructed from the given cache ID and partition ID.",
    "code": "    public static long pageId(int partId, byte flag, long pageIdx) {\n        long fileId = 0;\n\n        fileId = (fileId << FLAG_SIZE) | (flag & FLAG_MASK);\n        fileId = (fileId << PART_ID_SIZE) | (partId & PART_ID_MASK);\n\n        return pageId((int)fileId, pageIdx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 960,
    "type": "Return",
    "comment": "@return de-serialized object from Json or empty object if the response doesn't have a body.",
    "code": "@Override\nprotected String parseResponse(HttpResponse response) throws HttpResponseException, IOException {\n    final StatusLine statusLine = response.getStatusLine();\n    String responseBody = response.getEntity() != null ? EntityUtils.toString(response.getEntity()) : STR;\n    if (statusLine.getStatusCode() >= NUM) {\n        logger.error(String.format(STR, statusLine.getStatusCode()));\n        throw new HttpResponseException(statusLine.getStatusCode(), responseBody);\n    }\n    return responseBody;\n}",
    "label": 1,
    "rec": "@return de-serialized object from Json or null if the response doesn't have a body."
  },
  {
    "id": 961,
    "type": "Return",
    "comment": "@return the  Subject that owns the  Session Session with the specified  sessionId",
    "code": "    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        Map<String, Object> context = new HashMap<String, Object>(1);\n        context.put(SubjectFactory.SESSION_ID, sessionId);\n        return getSubject(context);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 962,
    "type": "Return",
    "comment": "@return integer value of parameter",
    "code": "\tprotected int getIntParameter(String key, int def) {\n\t\tString val = m_parameters.get(key);\n\t\tif (val == null) return (def); // param not found\n\t\tint ret = def;\n\t\ttry {\n\t\t\tret = Utils.strToInt(val);\n\t\t} catch (NumberFormatException e) {\n\t\t\tlogger.error(\"malformed int parameter in command handler: {}\", key);\n\t\t}\n\t\treturn ret;\n\t}\n",
    "label": 1,
    "rec": "@return value of parameter"
  },
  {
    "id": 963,
    "type": "Return",
    "comment": "@return Hadoop configuration.",
    "code": "    public GridHadoopConfiguration hadoopConfiguration(String gridName) {\n        GridHadoopConfiguration cfg = new GridHadoopConfiguration();\n\n        cfg.setMaxParallelTasks(3);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 964,
    "type": "Return",
    "comment": "@return a mocked up version of this mediator's resolver.",
    "code": "public Resolver getMockResolver() {\n    return new CompilationUnitTypeOracleResolver(new TypeOracleBuildContext(new MethodArgNamesLookup()));\n}",
    "label": 1,
    "rec": "@return a mocked up version of this updater's resolver."
  },
  {
    "id": 965,
    "type": "Return",
    "comment": "@return Objects number.",
    "code": "    private long size(Class<?> cls) throws IgniteCheckedException {\n        return (Long)grid().cache(null).query(\n            new SqlFieldsQuery(\"select count(*) from \" + GridQueryProcessor.typeName(cls)).setLocal(true))\n            .getAll().get(0).get(0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 966,
    "type": "Return",
    "comment": "@return NetworkOrigin Network that the IP belongs to (internal, external or labs)",
    "code": "public NetworkOrigin getNeworkOrigin(final String ip) {\n    final String sanitizedIp = sanitizeIp(ip);\n    if (sanitizedIp != null) {\n        if (isLabsHost(sanitizedIp)) {\n            return NetworkOrigin.WIKIMEDIA_LABS;\n        } else if (isTrustedProxy(sanitizedIp)) {\n            return NetworkOrigin.WIKIMEDIA;\n        }\n    }\n    return NetworkOrigin.INTERNET;\n}",
    "label": 1,
    "rec": "@return NetworkOrigin Network that the IP belongs to (wikimedia, wikimedia labs, or internet)"
  },
  {
    "id": 967,
    "type": "Return",
    "comment": "@return initialized and configured  CacheInvocationContext",
    "code": "    public static CacheInvocationContext<CacheRemove> createCacheRemoveInvocationContext(MetaHolder metaHolder) {\n        if (metaHolder.getMethod().isAnnotationPresent(CacheRemove.class)) {\n            Method method = metaHolder.getMethod();\n            CacheRemove cacheRemove = method.getAnnotation(CacheRemove.class);\n            MethodExecutionAction cacheKeyMethod = createCacheKeyAction(cacheRemove.cacheKeyMethod(), metaHolder);\n            return new CacheInvocationContext<>(cacheRemove, cacheKeyMethod, metaHolder.getObj(), method, metaHolder.getArgs());\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 968,
    "type": "Return",
    "comment": "@return the directory \"$(ControllerConfig.defaultDir)/library\": This needs to be improved",
    "code": "protected static File getLibraryInstallDir() {\n    return new File(System.getProperty(STR, System.getProperty(STR)) + File.separator + STR + File.separator + STR);\n}",
    "label": 1,
    "rec": "@return the directory \"System.getProperty(\"app.home\", System.getProperty(\"user.home\")/lib/udfs\""
  },
  {
    "id": 969,
    "type": "Return",
    "comment": "@return Version represented as  GridUuid",
    "code": "    public IgniteUuid asGridUuid() {\n        return new IgniteUuid(new UUID(((long)topOrder << 32) | nodeOrderDrId, globalTime), order);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 970,
    "type": "Return",
    "comment": "@return Space names.",
    "code": "    private static GridSqlQuery collectAllSpaces(GridSqlQuery qry, Set<String> spaces) {\n        if (qry instanceof GridSqlUnion) {\n            GridSqlUnion union = (GridSqlUnion)qry;\n\n            collectAllSpaces(union.left(), spaces);\n            collectAllSpaces(union.right(), spaces);\n        }\n        else {\n            GridSqlSelect select = (GridSqlSelect)qry;\n\n            collectAllSpacesInFrom(select.from(), spaces);\n\n            for (GridSqlElement el : select.select(false))\n                collectAllSpacesInSubqueries(el, spaces);\n\n            collectAllSpacesInSubqueries(select.where(), spaces);\n        }\n\n        return qry;\n    }\n",
    "label": 1,
    "rec": "@return Query."
  },
  {
    "id": 971,
    "type": "Return",
    "comment": "@return an array of codewords.",
    "code": "  int[] readCodewords() throws FormatException {\n    int width = bitMatrix.getWidth();\n    int height = bitMatrix.getHeight();\n\n    erasures = new int[MAX_CW_CAPACITY];\n\n    // Get the number of pixels in a module across the X dimension\n    //float moduleWidth = bitMatrix.getModuleWidth();\n    float moduleWidth = 1.0f; // Image has been sampled and reduced\n\n    int[] rowCounters = new int[width];\n    int[] codewords = new int[MAX_CW_CAPACITY];\n    int next = 0;\n    int matchingConsecutiveScans = 0;\n    boolean rowInProgress = false;\n    int rowNumber = 0;\n    int rowHeight = 0;\n    for (int i = 1; i < height; i++) {\n      if (rowNumber >= MAX_ROWS) {\n        // Something is wrong, since we have exceeded\n        // the maximum rows in the specification.\n        throw FormatException.getFormatInstance();\n      }\n      int rowDifference = 0;\n      // Scan a line of modules and check the\n      // difference between this and the previous line\n      for (int j = 0; j < width; j++) {\n        // Accumulate differences between this line and the\n        // previous line.\n        if (bitMatrix.get(j, i) != bitMatrix.get(j, i - 1)) {\n          rowDifference++;\n        }\n      }\n      if (rowDifference <= moduleWidth * MAX_ROW_DIFFERENCE) {\n        for (int j = 0; j < width; j++) {\n          // Accumulate the black pixels on this line\n          if (bitMatrix.get(j, i)) {\n            rowCounters[j]++;\n          }\n        }\n        // Increment the number of consecutive rows of pixels\n        // that are more or less the same\n        matchingConsecutiveScans++;\n        // Height of a row is a multiple of the module size in pixels\n        // Usually at least 3 times the module size\n        if (matchingConsecutiveScans >= moduleWidth * 2) { // MGMG\n          // We have some previous matches as well as a match here\n          // Set processing a unique row.\n          rowInProgress = true;\n        }\n      } else {\n        if (rowInProgress) {\n          // Process Row\n          next = processRow(rowCounters, rowNumber, rowHeight, codewords, next);\n          if (next == -1) {\n            // Something is wrong, since we have exceeded\n            // the maximum columns in the specification.\n            throw FormatException.getFormatInstance();\n          }\n          // Reinitialize the row counters.\n          for (int j = 0; j < rowCounters.length; j++) {\n            rowCounters[j] = 0;\n          }\n          rowNumber++;\n          rowHeight = 0;\n        }\n        matchingConsecutiveScans = 0;\n        rowInProgress = false;\n      }\n      rowHeight++;\n    }\n    // Check for a row that was in progress before we exited above.\n    if (rowInProgress) {\n      // Process Row\n      if (rowNumber >= MAX_ROWS) {\n        // Something is wrong, since we have exceeded\n        // the maximum rows in the specification.\n        throw FormatException.getFormatInstance();\n      }\n      next = processRow(rowCounters, rowNumber, rowHeight, codewords, next);\n      rowNumber++;\n      rows = rowNumber;\n    }\n    erasures = trimArray(erasures, eraseCount);\n    return trimArray(codewords, next);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 972,
    "type": "Return",
    "comment": "@return method object with given name and signature, or null",
    "code": "public Method containsMethod(String name, String signature) {\n    for (Method method : methodsList) {\n        if (method.getName().equals(name) && method.getSignature().equals(signature)) {\n            return method;\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return method object with given name and signature, or null if not found"
  },
  {
    "id": 973,
    "type": "Return",
    "comment": "@return Runnable that can be executed in a different thread with the same projection as for current thread.",
    "code": "    public Runnable projectSafe(final Runnable r) {\n        assert r != null;\n\n        // Have to get projection per call used by calling thread to use it in a new thread.\n        final GridCacheProjectionImpl<K, V> prj = projectionPerCall();\n\n        if (prj == null)\n            return r;\n\n        return new GPR() {\n            @Override public void run() {\n                GridCacheProjectionImpl<K, V> oldPrj = projectionPerCall();\n\n                projectionPerCall(prj);\n\n                try {\n                    r.run();\n                }\n                finally {\n                    projectionPerCall(oldPrj);\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 974,
    "type": "Return",
    "comment": "@return {@code true} if the query specifies at least a role and job name, otherwise {@code false}.",
    "code": "public static boolean isJobScoped(Builder taskQuery) {\n    TaskQuery q = taskQuery.get();\n    return (q.isSetOwner() && q.getOwner().isSetRole() && q.isSetEnvironment() && q.isSetJobName()) || q.isSetJobKeys();\n}",
    "label": 1,
    "rec": "@return {@code true} if the query specifies at least one job key, otherwise {@code false}."
  },
  {
    "id": 975,
    "type": "Return",
    "comment": "@return Whether the specified request has been approved by the current user.",
    "code": "\tpublic boolean isApproved(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n\t\tif (useTokenServices && super.isApproved(authorizationRequest, userAuthentication)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!userAuthentication.isAuthenticated()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn authorizationRequest.isApproved() || autoApproveClients.contains(authorizationRequest.getClientId());\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 976,
    "type": "Return",
    "comment": "@return the delta time in milliseconds",
    "code": "    public long getTime()\n    {\n        return nanoTime / 1000000;\n    }\n",
    "label": 1,
    "rec": "@return the delta nanoTime in milliseconds"
  },
  {
    "id": 977,
    "type": "Return",
    "comment": "@return An ECKey containing only the public part, or null if recovery wasn't possible.",
    "code": "    public static ECKey recoverFromSignature(int recId, ECDSASignature sig, Sha256Hash message, boolean compressed) {\n        Preconditions.checkArgument(recId >= 0, \"recId must be positive\");\n        Preconditions.checkArgument(sig.r.signum() >= 0, \"r must be positive\");\n        Preconditions.checkArgument(sig.s.signum() >= 0, \"s must be positive\");\n        Preconditions.checkNotNull(message);\n        // 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)\n        //   1.1 Let x = r + jn\n        BigInteger n = CURVE.getN();  // Curve order.\n        BigInteger i = BigInteger.valueOf((long) recId / 2);\n        BigInteger x = sig.r.add(i.multiply(n));\n        //   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine\n        //        specified in Section 2.3.7, where mlen = \u00e2\u008c\u0088(log2 p)/8\u00e2\u008c\u0089 or mlen = \u00e2\u008c\u0088m/8\u00e2\u008c\u0089.\n        //   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the\n        //        conversion routine specified in Section 2.3.4. If this conversion routine outputs \"invalid\", then\n        //        do another iteration of Step 1.\n        //\n        // More concisely, what these points mean is to use X as a compressed public key.\n        BigInteger prime = SecP256K1Curve.q;\n        if (x.compareTo(prime) >= 0) {\n            // Cannot have point co-ordinates larger than this as everything takes place modulo Q.\n            return null;\n        }\n        // Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.\n        // So it's encoded in the recId.\n        ECPoint R = decompressKey(x, (recId & 1) == 1);\n        //   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).\n        if (!R.multiply(n).isInfinity())\n            return null;\n        //   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.\n        BigInteger e = message.toBigInteger();\n        //   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)\n        //   1.6.1. Compute a candidate public key as:\n        //               Q = mi(r) * (sR - eG)\n        //\n        // Where mi(x) is the modular multiplicative inverse. We transform this into the following:\n        //               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)\n        // Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation\n        // ** is point multiplication and + is point addition (the EC group operator).\n        //\n        // We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive\n        // inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.\n        BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n);\n        BigInteger rInv = sig.r.modInverse(n);\n        BigInteger srInv = rInv.multiply(sig.s).mod(n);\n        BigInteger eInvrInv = rInv.multiply(eInv).mod(n);\n        ECPoint q = ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv);\n        return ECKey.fromPublicOnly(q, compressed);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 978,
    "type": "Return",
    "comment": "@return the format",
    "code": "public String getFormat() {\n    return mp3FrameHeader.getVersionAsString() + STR + mp3FrameHeader.getLayerAsString();\n}",
    "label": 1,
    "rec": "@return the format of the audio (i.e. MPEG-1 Layer3)"
  },
  {
    "id": 979,
    "type": "Return",
    "comment": "@return a List",
    "code": "    public List<IZuulFilter> getFiltersByType(String filterType) {\n\n        List<IZuulFilter> list = hashFiltersByType.get(filterType);\n        if (list != null) return list;\n\n        list = new ArrayList<IZuulFilter>();\n\n        Collection<IZuulFilter> filters = filterRegistry.getAllFilters();\n        for (Iterator<IZuulFilter> iterator = filters.iterator(); iterator.hasNext(); ) {\n            IZuulFilter filter = iterator.next();\n            if (filter.filterType().equals(filterType)) {\n                list.add(filter);\n            }\n        }\n\n        // Sort by filterOrder.\n        Collections.sort(list, new Comparator<IZuulFilter>() {\n            @Override\n            public int compare(IZuulFilter o1, IZuulFilter o2) {\n                return o1.filterOrder() - o2.filterOrder();\n            }\n        });\n\n        hashFiltersByType.putIfAbsent(filterType, list);\n        return list;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 980,
    "type": "Return",
    "comment": "@return the size.",
    "code": "int getSize() {\n    if (this.endPosition > -NUM && this.startPosition > -NUM) {\n        return this.endPosition - this.startPosition;\n    } else {\n        return -NUM;\n    }\n}",
    "label": 1,
    "rec": "@return the size or -1 if either start or end position is not positive."
  },
  {
    "id": 981,
    "type": "Return",
    "comment": "@return if this note is sharped.",
    "code": "    public boolean isSharped() {\n        byte note = getToneByte();\n        return Tone.getById(note).isSharped(note);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 982,
    "type": "Return",
    "comment": "@return a transformed AssertionWrapper instance",
    "code": "public SamlAssertionWrapper getTransformedToken() {\n    return transformedToken;\n}",
    "label": 1,
    "rec": "@return a transformed SamlAssertionWrapper instance"
  },
  {
    "id": 983,
    "type": "Return",
    "comment": "@return  MockitoGenericMetadata representing this generic return type.",
    "code": "    public MockitoGenericMetadata resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        System.out.println(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnType(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new IllegalStateException(\"ouch\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 984,
    "type": "Return",
    "comment": "@return a collection of string tags associated with this entity",
    "code": "public TagChangeSet getTags() {\n    if (tags == null) {\n        tags = new TagChangeSet();\n    }\n    return tags;\n}",
    "label": 1,
    "rec": "@return added and removed tags"
  },
  {
    "id": 985,
    "type": "Return",
    "comment": "@return Page ID of newly allocated page.",
    "code": "    protected long allocatePage0() throws IgniteCheckedException {\n        return pageMem.allocatePage(cacheId, 0, PageIdAllocator.FLAG_IDX);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 986,
    "type": "Return",
    "comment": "@return whether a Java line breakpoint is already registered with the breakpoint manager for a type with the given name at the given line number",
    "code": "public static IJavaLineBreakpoint lineBreakpointExists(String typeName, int lineNumber) throws CoreException {\n    String modelId = getPluginIdentifier();\n    String markerType = JavaLineBreakpoint.getMarkerType();\n    IBreakpointManager manager = DebugPlugin.getDefault().getBreakpointManager();\n    IBreakpoint[] breakpoints = manager.getBreakpoints(modelId);\n    for (int i = NUM; i < breakpoints.length; i++) {\n        if (!(breakpoints[i] instanceof IJavaLineBreakpoint)) {\n            continue;\n        }\n        IJavaLineBreakpoint breakpoint = (IJavaLineBreakpoint) breakpoints[i];\n        if (breakpoint.getMarker().getType().equals(markerType)) {\n            if (breakpoint.getTypeName().equals(typeName)) {\n                if (breakpoint.getLineNumber() == lineNumber) {\n                    return breakpoint;\n                }\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return a Java line breakpoint that is already registered with the breakpoint manager for a type with the given name at the given line number or <code>null</code> if no such breakpoint is registered"
  },
  {
    "id": 987,
    "type": "Return",
    "comment": "@return PartitionManager instance based on LDAP store",
    "code": "    protected PartitionManager createPartitionManager(Map<String,String> ldapConfig) {\n        IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();\n\n        Properties connectionProps = new Properties();\n        connectionProps.put(\"com.sun.jndi.ldap.connect.pool\", \"true\");\n\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.authentication\", \"none simple\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.initsize\", \"1\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.maxsize\", \"10\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.prefsize\", \"5\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.timeout\", \"300000\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.protocol\", \"plain\");\n        checkSystemProperty(\"com.sun.jndi.ldap.connect.pool.debug\", \"off\");\n\n        String vendor = ldapConfig.get(LdapConstants.VENDOR);\n\n        // RHDS is using \"nsuniqueid\" as unique identifier instead of \"entryUUID\"\n        if (vendor != null && vendor.equals(LdapConstants.VENDOR_RHDS)) {\n            checkSystemProperty(LDAPIdentityStoreConfiguration.ENTRY_IDENTIFIER_ATTRIBUTE_NAME, \"nsuniqueid\");\n        }\n\n        boolean activeDirectory = vendor != null && vendor.equals(LdapConstants.VENDOR_ACTIVE_DIRECTORY);\n\n        // Try to compute properties based on LDAP server type, but still allow to override them through System properties TODO: Should allow better way than overriding from System properties. Perhaps init from XML?\n        String ldapLoginName = getNameOfLDAPAttribute(\"keycloak.ldap.idm.loginName\", UID, CN, activeDirectory);\n        String ldapFirstName = getNameOfLDAPAttribute(\"keycloak.ldap.idm.firstName\", CN, \"givenName\", activeDirectory);\n        String ldapLastName = getNameOfLDAPAttribute(\"keycloak.ldap.idm.lastName\", SN, SN, activeDirectory);\n        String ldapEmail =  getNameOfLDAPAttribute(\"keycloak.ldap.idm.email\", EMAIL, EMAIL, activeDirectory);\n\n        logger.infof(\"LDAP Attributes mapping: loginName: %s, firstName: %s, lastName: %s, email: %s\", ldapLoginName, ldapFirstName, ldapLastName, ldapEmail);\n\n        // Use same mapping for User and Agent for now\n        builder\n            .named(\"SIMPLE_LDAP_STORE_CONFIG\")\n                .stores()\n                    .ldap()\n                        .connectionProperties(connectionProps)\n                        .addCredentialHandler(LDAPKeycloakCredentialHandler.class)\n                        .baseDN(ldapConfig.get(LdapConstants.BASE_DN))\n                        .bindDN(ldapConfig.get(LdapConstants.BIND_DN))\n                        .bindCredential(ldapConfig.get(LdapConstants.BIND_CREDENTIAL))\n                        .url(ldapConfig.get(LdapConstants.CONNECTION_URL))\n                        .activeDirectory(activeDirectory)\n                        .supportAllFeatures()\n                        .mapping(User.class)\n                            .baseDN(ldapConfig.get(LdapConstants.USER_DN_SUFFIX))\n                            .objectClasses(\"inetOrgPerson\", \"organizationalPerson\")\n                            .attribute(\"loginName\", ldapLoginName, true)\n                            .attribute(\"firstName\", ldapFirstName)\n                            .attribute(\"lastName\", ldapLastName)\n                            .attribute(\"email\", ldapEmail);\n\n        // Workaround to override the LDAPIdentityStore with our own :/\n        List<IdentityConfiguration> identityConfigs = builder.buildAll();\n        IdentityStoreConfiguration identityStoreConfig = identityConfigs.get(0).getStoreConfiguration().get(0);\n        ((AbstractIdentityStoreConfiguration)identityStoreConfig).setIdentityStoreType(KeycloakLDAPIdentityStore.class);\n\n        return new DefaultPartitionManager(identityConfigs);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 988,
    "type": "Return",
    "comment": "@return a set of property identifiers, or an empty set, if the entity provides no properties or <code>entityClass</code> was <code>null</code>.",
    "code": "public static Set<String> getPropertyNames(Class<? extends EntityBase> entityClass) {\n    return getProperties(entityClass).keySet();\n}",
    "label": 1,
    "rec": "@return an immutable set of property names, or an empty set, if the entity has no properties or <code>entityClass</code> was <code>null</code>."
  },
  {
    "id": 989,
    "type": "Return",
    "comment": "@return Topology version.",
    "code": "    public AffinityTopologyVersion topologyVersion() {\n        GridDhtPartitionsExchangeFuture lastInitializedFut0 = lastInitializedFut;\n\n        return lastInitializedFut0 != null\n            ? lastInitializedFut0.exchangeId().topologyVersion() : AffinityTopologyVersion.NONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 990,
    "type": "Return",
    "comment": "@return the new int array backed by a buffer or an array",
    "code": "    public static IntIndexer create(final IntPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new IntRawIndexer(pointer, sizes, strides)\n                                             : new IntBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            int[] array = new int[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new IntArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new int indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 991,
    "type": "Return",
    "comment": "@return Local node ID.",
    "code": "    public UUID localNodeId() {\n        return ctx.localNodeId();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 992,
    "type": "Return",
    "comment": "@return an iterator the unfiled roster entries.",
    "code": "public Collection<RosterEntry> getUnfiledEntries() {\n    return Collections.unmodifiableList(unfiledEntries);\n}",
    "label": 1,
    "rec": "@return the unfiled roster entries."
  },
  {
    "id": 993,
    "type": "Return",
    "comment": "@return Multi bulk reply, specifically the list of common elements.",
    "code": "  public Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    client.sinter(keys);\n    final List<String> members = client.getMultiBulkReply();\n    return SetFromList.of(members);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 994,
    "type": "Return",
    "comment": "@return The {@link ModelClass}",
    "code": "public TModel getModelObject(int index) {\n    return getJsonModel(index).toModel();\n}",
    "label": 1,
    "rec": "@return The {@link TModel}"
  },
  {
    "id": 995,
    "type": "Return",
    "comment": "@return Entry.",
    "code": "    public static GridCacheSwapEntryImpl unmarshal(byte[] arr, boolean valOnly) {\n        if (valOnly) {\n            long off = BYTE_ARR_OFF + VERSION_OFFSET; // Skip ttl, expire time.\n\n            boolean verEx = UNSAFE.getByte(arr, off++) != 0;\n\n            off += verEx ? VERSION_EX_SIZE : VERSION_SIZE;\n\n            int arrLen = UNSAFE.getInt(arr, off);\n\n            off += 4;\n\n            byte type = UNSAFE.getByte(arr, off++);\n\n            byte[] valBytes = new byte[arrLen];\n\n            UNSAFE.copyMemory(arr, off, valBytes, BYTE_ARR_OFF, arrLen);\n\n            return new GridCacheSwapEntryImpl(ByteBuffer.wrap(valBytes),\n                type,\n                null,\n                0L,\n                0L,\n                null,\n                null);\n        }\n\n        long off = BYTE_ARR_OFF;\n\n        long ttl = UNSAFE.getLong(arr, off);\n\n        off += 8;\n\n        long expireTime = UNSAFE.getLong(arr, off);\n\n        off += 8;\n\n        boolean verEx = UNSAFE.getBoolean(arr, off++);\n\n        GridCacheVersion ver = U.readVersion(arr, off, verEx);\n\n        off += verEx ? VERSION_EX_SIZE : VERSION_SIZE;\n\n        int arrLen = UNSAFE.getInt(arr, off);\n\n        off += 4;\n\n        byte type = UNSAFE.getByte(arr, off++);\n\n        byte[] valBytes = new byte[arrLen];\n\n        UNSAFE.copyMemory(arr, off, valBytes, BYTE_ARR_OFF, arrLen);\n\n        off += arrLen;\n\n        IgniteUuid valClsLdrId = U.readGridUuid(arr, off);\n\n        off += valClsLdrId == null ? 1 : (1 + GUID_SIZE);\n\n        IgniteUuid keyClsLdrId = U.readGridUuid(arr, off);\n\n        return new GridCacheSwapEntryImpl(ByteBuffer.wrap(valBytes),\n            type,\n            ver,\n            ttl,\n            expireTime,\n            keyClsLdrId,\n            valClsLdrId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 996,
    "type": "Return",
    "comment": "@return Future if offer accepted, null if batch is full, already started or completed",
    "code": "public Observable<ResponseType> offer(RequestArgumentType arg) {\n    if (batchStarted.get()) {\n        return null;\n    }\n    if (batchLock.readLock().tryLock()) {\n        try {\n            int s = count.incrementAndGet();\n            if (s > maxBatchSize) {\n                return null;\n            } else {\n                CollapsedRequestObservableFunction<ResponseType, RequestArgumentType> f = new CollapsedRequestObservableFunction<ResponseType, RequestArgumentType>(arg);\n                requests.add(f);\n                return Observable.create(f);\n            }\n        } finally {\n            batchLock.readLock().unlock();\n        }\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return Observable if offer accepted, null if batch is full, already started or completed"
  },
  {
    "id": 997,
    "type": "Return",
    "comment": "@return Collection of remote candidates.",
    "code": "    public List<GridCacheMvccCandidate> remoteCandidates(GridCacheVersion... excludeVers) {\n        return candidates(rmts, false, true, excludeVers);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 998,
    "type": "Return",
    "comment": "@return Column spi.",
    "code": "public T2<String, Map<String, Object>> collisionSpi() {\n    return colSpi;\n}",
    "label": 1,
    "rec": "@return Collision SPI."
  },
  {
    "id": 999,
    "type": "Return",
    "comment": "@return author name or null if missing",
    "code": "    public static Date getAuthorDate(final Commit commit) {\n        GitCommit rawCommit = commit.commit();\n        if (rawCommit == null)\n            return null;\n\n        GitUser commitAuthor = rawCommit.author();\n        return commitAuthor != null && commitAuthor.date() != null ? commitAuthor.date() : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1000,
    "type": "Return",
    "comment": "@return the delta time in milliseconds",
    "code": "public long getTime() {\n    return nanoTime / NUM;\n}",
    "label": 1,
    "rec": "@return the delta nanoTime in milliseconds"
  },
  {
    "id": 1001,
    "type": "Return",
    "comment": "@return New page ID.",
    "code": "    public static long rotatePageId(long pageId) {\n        assert flag(pageId) == PageIdAllocator.FLAG_IDX : flag(pageId); // Possible only for index pages.\n\n        int partId = partId(pageId);\n        int pageIdx = pageIndex(pageId);\n\n        return pageId(partId + 1, PageIdAllocator.FLAG_IDX, pageIdx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1002,
    "type": "Return",
    "comment": "@return an array of interfaces.",
    "code": "public static Set getAllInterfaces(final Object[] objects) {\n    final Set interfaces = new HashSet();\n    for (int i = NUM; i < objects.length; i++) {\n        if (objects[i] != null) {\n            getInterfaces(objects[i].getClass(), interfaces);\n        }\n    }\n    interfaces.remove(InvokerReference.class);\n    return interfaces;\n}",
    "label": 1,
    "rec": "@return an set of interfaces. The set may be empty"
  },
  {
    "id": 1003,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String delete(Integer id, HttpServletRequest request, HttpSession session, ModelMap model) {\n        SysSite site = siteComponent.getSite(request.getServerName());\n        SysDept entity = service.delete(site.getId(), id);\n        if (null != entity) {\n            sysDeptCategoryService.delete(entity.getId(), null);\n            sysDeptPageService.delete(entity.getId(), null);\n            sysDeptConfigService.delete(entity.getId(), null);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"delete.dept\", RequestUtils.getIpAddress(request), CommonUtils.getDate(),\n                    JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1004,
    "type": "Return",
    "comment": "@return RemoteSharedObjectDescriptions[] to determine replica descriptions for each receiver. A null return value indicates that no replicas are to be created. If the returned array is not null, then it <b>must</b> be of same length as the receivers parameter.",
    "code": "protected SharedObjectDescription[] getReplicaDescriptions(ID[] receivers) {\n    SharedObjectDescription[] descriptions = null;\n    if (receivers == null || receivers.length == NUM) {\n        descriptions = new SharedObjectDescription[NUM];\n        descriptions[NUM] = getReplicaDescription((receivers == null) ? null : receivers[NUM]);\n    } else {\n        descriptions = new SharedObjectDescription[receivers.length];\n        for (int i = NUM; i < receivers.length; i++) {\n            descriptions[i] = getReplicaDescription(receivers[i]);\n        }\n    }\n    return descriptions;\n}",
    "label": 1,
    "rec": "@return SharedObjectDescriptions[] to determine replica descriptions for each receiver. A null return value indicates that no replicas are to be created. If the returned array is not null, then it <b>must</b> be of same length as the receivers parameter."
  },
  {
    "id": 1005,
    "type": "Return",
    "comment": "@return IO.",
    "code": "    private BPlusIO<L> io(ByteBuffer buf) {\n        assert buf != null;\n\n        int type = PageIO.getType(buf);\n        int ver = PageIO.getVersion(buf);\n\n        if (innerIos.getType() == type)\n            return innerIos.forVersion(ver);\n\n        if (leafIos.getType() == type)\n            return leafIos.forVersion(ver);\n\n        throw new IllegalStateException(\"Unknown page type: \" + type + \" pageId: \" + PageIO.getPageId(buf));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1006,
    "type": "Return",
    "comment": "@return the Sender singleton instance",
    "code": "public static SenderFactory getInstance() {\n    if (instance == null) {\n        synchronized (lock) {\n            if (instance == null) {\n                instance = new SenderFactory();\n            }\n        }\n    }\n    return instance;\n}",
    "label": 1,
    "rec": "@return the SenderFactory singleton instance"
  },
  {
    "id": 1007,
    "type": "Return",
    "comment": "@return Stratified frame",
    "code": "  public static Frame sampleFrameStratified(final Frame fr, Vec label, final float[] sampling_ratios, final long seed, final boolean debug) {\n    if (fr == null) return null;\n    fr.closeAppendables();\n    assert(label.isEnum());\n    assert(sampling_ratios != null && sampling_ratios.length == label.domain().length);\n    final int labelidx = fr.find(label); //which column is the label?\n    assert(labelidx >= 0);\n\n    final boolean poisson = false; //beta feature\n\n    Frame r = new MRTask2() {\n      @Override\n      public void map(Chunk[] cs, NewChunk[] ncs) {\n        final Random rng = getDeterRNG(seed + cs[0].cidx());\n        for (int r = 0; r < cs[0]._len; r++) {\n          if (cs[labelidx].isNA0(r)) continue; //skip missing labels\n          final int label = (int)cs[labelidx].at80(r);\n          assert(sampling_ratios.length > label && label >= 0);\n          int sampling_reps;\n          if (poisson) {\n            sampling_reps = Utils.getPoisson(sampling_ratios[label], rng);\n          } else {\n            final float remainder = sampling_ratios[label] - (int)sampling_ratios[label];\n            sampling_reps = (int)sampling_ratios[label] + (rng.nextFloat() < remainder ? 1 : 0);\n          }\n          for (int i = 0; i < ncs.length; i++) {\n            for (int j = 0; j < sampling_reps; ++j) {\n              ncs[i].addNum(cs[i].at0(r));\n            }\n          }\n        }\n      }\n    }.doAll(fr.numCols(), fr).outputFrame(fr.names(), fr.domains());\n\n    // Confirm the validity of the distribution\n    long[] dist = new ClassDist(r.vecs()[labelidx]).doAll(r.vecs()[labelidx]).dist();\n\n    if (debug) {\n      long sumdist = Utils.sum(dist);\n      Log.info(\"After stratified sampling: \" + sumdist + \" rows.\");\n      for (int i=0; i<dist.length;++i) {\n        Log.info(\"Class \" + r.vecs()[labelidx].domain(i) + \": count: \" + dist[i]\n                + \" sampling ratio: \" + sampling_ratios[i] + \" actual relative frequency: \" + (float)dist[i] / sumdist * dist.length);\n      }\n    }\n\n    // Re-try if we didn't get at least one example from each class\n    if (Utils.minValue(dist) == 0) {\n      Log.info(\"Re-doing stratified sampling because not all classes were represented (unlucky draw).\");\n      return sampleFrameStratified(fr, label, sampling_ratios, seed+1, debug);\n    }\n\n    // shuffle intra-chunk\n    Frame shuffled = shuffleFramePerChunk(r, seed+0x580FF13);\n    r.delete();\n\n    return shuffled;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1008,
    "type": "Return",
    "comment": "@return Flux stream containing simulated wind speed data",
    "code": "        public Flux<Payload> requestStream(Payload payload) {\n            String streamName = payload.getDataUtf8();\n            if (DATA_STREAM_NAME.equals(streamName)) {\n                return Flux.from(dataPublisher);\n            }\n            return Flux.error(new IllegalArgumentException(streamName));\n        }\n",
    "label": 1,
    "rec": "@return Flux stream containing simulated measurement data"
  },
  {
    "id": 1009,
    "type": "Return",
    "comment": "@return the decoded string",
    "code": "  private String getEncodedData(boolean[] correctedBits) throws FormatException {\n    int endIndex = codewordSize * ddata.getNbDatablocks() - invertedBitCount;\n    if (endIndex > correctedBits.length) {\n      throw FormatException.getFormatInstance();\n    }\n    return getEncodedData(correctedBits, endIndex);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1010,
    "type": "Return",
    "comment": "@return build the object considering and validating the received order is a PLACE (otherwise throw an {@link java.lang.IllegalArgumentException}",
    "code": "public static RobotOrder buildRobotOrderStart(String line) throws OutOfTableException {\n    if (line == null || line.isEmpty()) {\n        throw new IllegalArgumentException(STR);\n    }\n    Matcher matcher = PLACE_ORDER_PATTERN.matcher(line);\n    if (matcher.matches()) {\n        try {\n            return new RobotOrder().setStartPosition(new Position(Short.valueOf(matcher.group(NUM)).shortValue(), Short.valueOf(matcher.group(NUM)).shortValue())).setStartOrientation(Orientation.build(matcher.group(NUM)));\n        } catch (UnknownOrientationException e) {\n            throw new IllegalArgumentException(STR + line + STR);\n        }\n    } else {\n        throw new IllegalArgumentException(STR + line + STR);\n    }\n}",
    "label": 1,
    "rec": "@return build the object considering and validating the received order is a PLACE"
  },
  {
    "id": 1011,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static float anyFloat() {\n        return reportMatcher(Any.ANY).floatValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1012,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 1013,
    "type": "Return",
    "comment": "@return a new CommandDP",
    "code": "\tprivate Datapoint createDP(String dpt) throws KNXFormatException {\n\t\tint mainNumber=Integer.parseInt(dpt.substring(0, dpt.indexOf('.')));\n\t\t\n\t\treturn new CommandDP(new GroupAddress(\"1/2/3\"), \"test\", mainNumber, dpt);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1014,
    "type": "Return",
    "comment": "@return a Filter that performs xor on two other filters.",
    "code": "public static <E> Predicates.XorPredicate<E> xor(Predicate<E> left, Predicate<E> right) {\n    return new Predicates.XorPredicate<E>(left, right);\n}",
    "label": 1,
    "rec": "@return a Predicate that performs xor on two other predicates."
  },
  {
    "id": 1015,
    "type": "Return",
    "comment": "@return The decoded string representing the Numeric data.",
    "code": "  private static BigInteger decodeBase900toBase10(int[] codewords, int count) {\n    BigInteger result = BigInteger.ZERO;\n    for (int i = 0; i < count; i++) {\n      result = result.add(EXP900[count - i - 1].multiply(BigInteger.valueOf(codewords[i])));\n    }\n    return result;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1016,
    "type": "Return",
    "comment": "@return A present if one can be extracted, absent otherwise.",
    "code": "public static Optional<Set<IJobKey>> from(Query.Builder query) {\n    if (Query.isJobScoped(query)) {\n        TaskQuery taskQuery = query.get();\n        ImmutableSet.Builder<IJobKey> builder = ImmutableSet.builder();\n        if (taskQuery.isSetJobName()) {\n            builder.add(from(taskQuery.getOwner().getRole(), taskQuery.getEnvironment(), taskQuery.getJobName()));\n        }\n        if (taskQuery.isSetJobKeys()) {\n            builder.addAll(IJobKey.setFromBuilders(taskQuery.getJobKeys()));\n        }\n        return Optional.of(assertValid(builder.build()));\n    } else {\n        return Optional.absent();\n    }\n}",
    "label": 1,
    "rec": "@return A present if keys can be extracted, absent otherwise."
  },
  {
    "id": 1017,
    "type": "Return",
    "comment": "@return instance of supplied Class; new Class is defined in the same class loader",
    "code": "    public static Factory enhance(Class cls, Callback callback) {\n        return (Factory)enhanceHelper(cls.isInterface() ? null : cls,\n                                      cls.isInterface() ? new Class[]{ cls } : null,\n                                      callback, cls.getClassLoader(), null, null );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1018,
    "type": "Return",
    "comment": "@return an {@link Iterator} visiting the given {@code kedge} and all connected edges in a(n almost) breadth first search fashion",
    "code": "public static Iterator<ElkGraphElement> getConnectedElements(final ElkEdge edge, final boolean addPorts) {\n    final SelectionIterator sourceSideIt = new DefaultSelectionIterator(edge, addPorts, false);\n    final SelectionIterator targetSideIt = new DefaultSelectionIterator(edge, addPorts, true);\n    return getConnectedElements(edge, sourceSideIt, targetSideIt);\n}",
    "label": 1,
    "rec": "@return an {@link Iterator} visiting the given {@code edge} and all connected edges in a(n almost) breadth first search fashion"
  },
  {
    "id": 1019,
    "type": "Return",
    "comment": "@return false.",
    "code": "    public static boolean anyBoolean() {\n        reportMatcher(new InstanceOf(Boolean.class)); \n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1020,
    "type": "Return",
    "comment": "@return list of {@link MavenSpyLogProcessor.MavenArtifact}",
    "code": "@Nonnull\npublic static List<MavenArtifact> listParentProjects(final Element mavenSpyLogs, final Logger logger) {\n    final List<MavenArtifact> result = new ArrayList<>();\n    for (final Element dependencyResolutionResult : XmlUtils.getExecutionEvents(mavenSpyLogs, STR)) {\n        final Element parentProjectElt = XmlUtils.getUniqueChildElementOrNull(dependencyResolutionResult, STR);\n        if (parentProjectElt == null) {\n            continue;\n        }\n        final MavenArtifact parentProject = new MavenArtifact();\n        parentProject.groupId = parentProjectElt.getAttribute(STR);\n        parentProject.artifactId = parentProjectElt.getAttribute(STR);\n        parentProject.version = parentProjectElt.getAttribute(STR);\n        parentProject.baseVersion = parentProject.version;\n        parentProject.snapshot = parentProject.version.endsWith(STR);\n        result.add(parentProject);\n    }\n    return result;\n}",
    "label": 1,
    "rec": "@return list of {@link MavenArtifact}"
  },
  {
    "id": 1021,
    "type": "Return",
    "comment": "@return BluetoothGatt after connection reaches  com.polidea.rxandroidble.RxBleConnection.RxBleConnectionState#CONNECTED state.",
    "code": "    private Observable<BluetoothGatt> getConnectedBluetoothGatt() {\n        // start connecting the BluetoothGatt\n        // note: Due to different Android BLE stack implementations it is not certain whether `connectGatt()` or `BluetoothGattCallback`\n        // will emit BluetoothGatt first\n        return Observable.fromCallable(\n                new Callable<BluetoothGatt>() {\n                    @Override\n                    public BluetoothGatt call() throws Exception {\n                        return connectionCompat.connectGatt(bluetoothDevice, autoConnect, rxBleGattCallback.getBluetoothGattCallback());\n                    }\n                }\n        )\n                .mergeWith(rxBleGattCallback.getBluetoothGatt())\n                // relay BluetoothGatt instance updates\n                .doOnNext(new Action1<BluetoothGatt>() {\n                    @Override\n                    public void call(BluetoothGatt gatt) {\n                        bluetoothGattBehaviorSubject.onNext(gatt);\n                    }\n                })\n                // finish relaying if there won't be more updates\n                .doOnTerminate(new Action0() {\n                    @Override\n                    public void call() {\n                        bluetoothGattBehaviorSubject.onCompleted();\n                    }\n                })\n                // disconnect may happen even if the connection was not established yet\n                .mergeWith(rxBleGattCallback.<BluetoothGatt>observeDisconnect())\n                // capture BluetoothGatt when connected\n                .sample(rxBleGattCallback\n                        .getOnConnectionStateChange()\n                        .filter(new Func1<RxBleConnection.RxBleConnectionState, Boolean>() {\n                            @Override\n                            public Boolean call(RxBleConnection.RxBleConnectionState rxBleConnectionState) {\n                                return rxBleConnectionState == CONNECTED;\n                            }\n                        }))\n                .take(1)\n                // finish relaying if there won't be more updates\n                .doOnTerminate(new Action0() {\n                    @Override\n                    public void call() {\n                        bluetoothGattBehaviorSubject.onCompleted();\n                    }\n                });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1022,
    "type": "Return",
    "comment": "@return A new StopWatchParser to use to parse log messages.",
    "code": "private StopWatchParser newStopWatchParser() {\n    try {\n        return (StopWatchParser) Class.forName(stopWatchParserClassName).newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(STR + e.getMessage(), e);\n    }\n}",
    "label": 1,
    "rec": "@return The newly created StopWatchParser"
  },
  {
    "id": 1023,
    "type": "Return",
    "comment": "@return default schema set",
    "code": "    public static SchemaSet getDefaultSchemaSet()\n    {\n        return new SchemaSet(Collections.<Schema>emptyList(), true)\n        {\n            @Override\n            public String toDocumentation()\n            {\n                return \"Default schema\";\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1024,
    "type": "Return",
    "comment": "@return Instance of {@link IdeLevel2Dependencies} from main artifact.",
    "code": "@NotNull\npublic IdeDependencies getSelectedMainCompileLevel2Dependencies() {\n    IdeAndroidArtifact mainArtifact = getMainArtifact();\n    return mainArtifact.getLevel2Dependencies();\n}",
    "label": 1,
    "rec": "@return Instance of {@link IdeDependencies} from main artifact."
  },
  {
    "id": 1025,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(SparseMatrix[] data, int fold) throws Exception {\n\n\t\tSparseMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\t\t/* baselines */\n\t\tcase \"globalavg\":\n\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"useravg\":\n\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"itemavg\":\n\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"random\":\n\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"constant\":\n\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"mostpop\":\n\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\n\t\t\t/* cores */\n\t\tcase \"userknn\":\n\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"itemknn\":\n\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"regsvd\":\n\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\tcase \"biasedmf\":\n\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\tcase \"svd++\":\n\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"pmf\":\n\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\tcase \"climf\":\n\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\tcase \"socialmf\":\n\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold);\n\t\tcase \"trustmf\":\n\t\t\treturn new TrustMF(trainMatrix, testMatrix, fold);\n\n\t\t\t/* extension */\n\t\tcase \"nmf\":\n\t\t\treturn new NMF(trainMatrix, testMatrix, fold);\n\t\tcase \"hybrid\":\n\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\tcase \"slopeone\":\n\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-basemf\":\n\t\t\treturn new BaseMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dmf\":\n\t\t\treturn new DMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-basenm\":\n\t\t\treturn new BaseNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dnm\":\n\t\t\treturn new DNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-drmplus\":\n\t\t\treturn new DRMPlus(trainMatrix, testMatrix, fold);\n\t\tdefault:\n\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1026,
    "type": "Return",
    "comment": "@return {@link ProvisionInfo} instance, if available.",
    "code": "@Deprecated\ndefault Optional<AllocatedHosts> getProvisionInfo() {\n    return Optional.of(allocatedHosts());\n}",
    "label": 1,
    "rec": "@return {@link AllocatedHosts} instance, if available."
  },
  {
    "id": 1027,
    "type": "Return",
    "comment": "@return Callable for execution in async and sync mode.",
    "code": "    private Callable<Long> internalGetAndSet(final long l) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteInternalTx tx = CU.txStartInternal(ctx, atomicView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicLongValue val = atomicView.get(key);\n\n                    if (val == null)\n                        throw new IgniteCheckedException(\"Failed to find atomic long with given name: \" + name);\n\n                    long retVal = val.get();\n\n                    val.set(l);\n\n                    atomicView.put(key, val);\n\n                    tx.commit();\n\n                    return retVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to get and set: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1028,
    "type": "Return",
    "comment": "@return Meta URI for the current configuration.",
    "code": "public String buildMeta() {\n    return new StringBuilder(host).append(STR).append(PREFIX_META).append(STR).append(assembleConfig()).append(target).toString();\n}",
    "label": 1,
    "rec": "@return Meta URL for the current configuration."
  },
  {
    "id": 1029,
    "type": "Return",
    "comment": "@return 0 for success, < 0 otherwise",
    "code": "    public int run() throws PulsarClientException, IOException {\n        if (mainOptions.size() != 1)\n            throw (new ParameterException(\"Please provide one and only one topic name.\"));\n        if (this.subscriptionName == null || this.subscriptionName.isEmpty())\n            throw (new ParameterException(\"Subscription name is not provided.\"));\n        if (this.numMessagesToConsume < 0)\n            throw (new ParameterException(\"Number of messages should be zero or positive.\"));\n\n        String topic = this.mainOptions.get(0);\n        \n        if(this.serviceURL.startsWith(\"ws\")) {\n            return consumeFromWebSocket(topic);\n        }else {\n            return consume(topic);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1030,
    "type": "Return",
    "comment": "@return text encoded within the Data Matrix Code",
    "code": "  public DecoderResult decode(BitMatrix bits) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion(bits);\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    String text = DecodedBitStreamParser.decode(resultBytes);\n    return new DecoderResult(resultBytes, text);\n  }\n",
    "label": 1,
    "rec": "@return text and bytes encoded within the Data Matrix Code"
  },
  {
    "id": 1031,
    "type": "Return",
    "comment": "@return  true if near cache should be enabled.",
    "code": "    protected boolean nearEnabled() {\n        return nearConfiguration() != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1032,
    "type": "Return",
    "comment": "@return a list of fields defined in this document",
    "code": "public Collection<String> getFieldNames() {\n    return this.keySet();\n}",
    "label": 1,
    "rec": "@return a list of field names defined in this document - this Collection is directly backed by this SolrDocument."
  },
  {
    "id": 1033,
    "type": "Return",
    "comment": "@return Sorted list of nodes.",
    "code": "    private List<ClusterNode> sort(Collection<ClusterNode> nodes) {\n        List<ClusterNode> sorted = new ArrayList<>(nodes.size());\n\n        sorted.addAll(nodes);\n\n        Collections.sort(sorted, nodeCmp);\n\n        return sorted;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1034,
    "type": "Return",
    "comment": "@return the directory \"$(pwd)/library\": This needs to be improved",
    "code": "protected static File getLibraryInstallDir() {\n    String workingDir = System.getProperty(STR);\n    return new File(workingDir, STR);\n}",
    "label": 1,
    "rec": "@return the directory \"$(ControllerConfig.defaultDir)/library\": This needs to be improved"
  },
  {
    "id": 1035,
    "type": "Return",
    "comment": "@return intent",
    "code": "    public static Intent createIntent(Repo repository) {\n        return createIntent(null, repository.owner.login,\n            repository.name, repository.owner);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1036,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)",
    "code": "  private Frame reBalance(final Frame fr, boolean local) {\n    int cores = 0;\n    for( H2ONode node : H2O.CLOUD._memary ) {\n      if (local) cores = Math.max(cores, node._heartbeat._num_cpus);\n      else cores += node._heartbeat._num_cpus;\n    }\n    final int chunks = 4*cores;\n    if (force_load_balance && chunks < fr.numRows()) {\n//      return MRUtils.shuffleAndBalance(fr, chunks, seed, local, shuffle_training_data) : fr;\n      Key newKey = fr._key != null ? Key.make(fr._key.toString() + \".balanced\") : Key.make();\n      return rebalanceDataset(newKey, fr, chunks);\n    }\n    else return fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks"
  },
  {
    "id": 1037,
    "type": "Return",
    "comment": "@return Encoded string",
    "code": "    public String getBodyAsString() {\n        if (body == null) {\n            return \"\";\n        }\n\n        return Strings.stringFromBytes(body, getCharset());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1038,
    "type": "Return",
    "comment": "@return Validation state that should be effective for the parent element state",
    "code": "public boolean pop() throws XMLStreamException {\n    if (mSize == NUM) {\n        throw new IllegalStateException(STR);\n    }\n    mSize -= NUM;\n    int index = mSize;\n    mElements[index] = null;\n    mElements[index + NUM] = null;\n    mElements[index + NUM] = null;\n    mElements[index + NUM] = null;\n    int nsCount = mNamespaces.size() - mNsCounts[index >> NUM];\n    if (nsCount > NUM) {\n        mLastNsContext = null;\n        mNamespaces.removeLast(nsCount);\n    }\n    return (index > NUM);\n}",
    "label": 1,
    "rec": "@return True if stack still has elements; false if not (root closed)"
  },
  {
    "id": 1039,
    "type": "Return",
    "comment": "@return boolean",
    "code": "    public boolean isExecutionComplete() {\n        return isExecutionComplete;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1040,
    "type": "Return",
    "comment": "@return  True if  #setValue or  #remove was called.",
    "code": "    public boolean modified() {\n        if (modified) {\n            if (!hadVal && val == null)\n                return false;\n        }\n\n        return modified;\n    }\n",
    "label": 1,
    "rec": "@return  True if entry was modified."
  },
  {
    "id": 1041,
    "type": "Return",
    "comment": "@return Default cache transaction isolation.",
    "code": "    public TransactionIsolation getDefaultTxIsolation() {\n        return dfltIsolation;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1042,
    "type": "Return",
    "comment": "@return the new short array backed by a buffer or an array",
    "code": "    public static UShortIndexer create(final ShortPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new UShortRawIndexer(pointer, sizes, strides)\n                                             : new UShortBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            short[] array = new short[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new UShortArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new short indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 1043,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String logout(Long userId, HttpServletRequest request, HttpServletResponse response) {\n        SysUser admin = getAdminFromSession(request.getSession());\n        if (null != userId && null != admin && userId == admin.getId()) {\n            Cookie userCookie = RequestUtils.getCookie(request.getCookies(), CommonConstants.getCookiesAdmin());\n            if (null != userCookie && CommonUtils.notEmpty(userCookie.getValue())) {\n                String value = userCookie.getValue();\n                if (null != value) {\n                    String[] userData = value.split(CommonConstants.getCookiesUserSplit());\n                    if (userData.length > 1) {\n                        sysUserTokenService.delete(userData[1]);\n                    }\n                }\n            }\n            clearAdminToSession(request.getContextPath(), request.getSession(), response);\n        }\n        return REDIRECT + CommonConstants.getDefaultPage();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1044,
    "type": "Return",
    "comment": "@return The brightness as a value from 0 -  HueBulb#MAX_BRIGHTNESS",
    "code": "\tpublic int getBrightness(String deviceId) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(deviceId).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 1,
    "rec": "@return The brightness as a value from 0 - 255"
  },
  {
    "id": 1045,
    "type": "Return",
    "comment": "@return DyeColor of this dye",
    "code": "    public DyeColor getColor() {\n        return DyeColor.getByWoolData(getData());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1046,
    "type": "Return",
    "comment": "@return the instance of {@link com.simplegeo.client.http.SimpleGeoHandler} that is associated with the type",
    "code": "public SimpleGeoJSONHandlerIfc getHandler(Handler type) {\n    SimpleGeoJSONHandlerIfc handler = null;\n    switch(type) {\n        case GEOJSON:\n            handler = geoJSONHandler;\n            break;\n        case RECORD:\n            handler = recordHandler;\n            break;\n        case JSON:\n            handler = jsonHandler;\n            break;\n        default:\n            break;\n    }\n    return handler;\n}",
    "label": 1,
    "rec": "@return the instance of {@link com.simplegeo.client.handler.SimpleGeoJSONHandlerIfc} that is associated with the type"
  },
  {
    "id": 1047,
    "type": "Return",
    "comment": "@return Affinity nodes.",
    "code": "    private Collection<ClusterNode> affinityNodes(Ignite g, int p) {\n        return affinity(g).mapPartitionToPrimaryAndBackups(p);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1048,
    "type": "Return",
    "comment": "@return A DBusErrorMessage, or null if no error is pending.",
    "code": "public DBusExecutionException getError() {\n    synchronized (pendingErrors) {\n        if (pendingErrors.size() == NUM)\n            return null;\n        else\n            return pendingErrors.removeFirst().getException();\n    }\n}",
    "label": 1,
    "rec": "@return A DBusExecutionException, or null if no error is pending."
  },
  {
    "id": 1049,
    "type": "Return",
    "comment": "@return Collection of entry IDs to be deleted.",
    "code": "    public Collection<GridUuid> pendingDeletes() throws GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                GridGgfsFileInfo trashInfo = id2InfoPrj.get(TRASH_ID);\n\n                if (trashInfo != null) {\n                    Map<String, GridGgfsListingEntry> listing = trashInfo.listing();\n\n                    if (listing != null && !listing.isEmpty()) {\n                        return F.viewReadOnly(listing.values(), new IgniteClosure<GridGgfsListingEntry, GridUuid>() {\n                            @Override public GridUuid apply(GridGgfsListingEntry e) {\n                                return e.fileId();\n                            }\n                        });\n                    }\n                }\n\n                return Collections.emptySet();\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to get pending deletes because Grid is stopping.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1050,
    "type": "Return",
    "comment": "@return instance of the Authentication object",
    "code": "    public static Authentication create(String authPluginClassName, Map<String, String> authParams)\n            throws UnsupportedAuthenticationException {\n        try {\n            return DefaultImplementation.createAuthentication(authPluginClassName, authParams);\n        } catch (Throwable t) {\n            throw new UnsupportedAuthenticationException(t);\n        }\n    }\n",
    "label": 1,
    "rec": "@return instance of the Authentication-Plugin"
  },
  {
    "id": 1051,
    "type": "Return",
    "comment": "@return html representation of messages (one per row)",
    "code": "  public static List<Message> getReceivedMessages() {\n    List<Message> messageList = messageRepository.retrieve(MAX_MESSAGES);\n    return messageList;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1052,
    "type": "Return",
    "comment": "@return the aspects",
    "code": "public AspectContainer[] getAspectContainers() {\n    initialize();\n    return m_aspectContainers;\n}",
    "label": 1,
    "rec": "@return the aspect containers"
  },
  {
    "id": 1053,
    "type": "Return",
    "comment": "@return Topology snapshot message.",
    "code": "    private String topologySnapshotMessage(int rmtNodesNum, int totalCpus, double heap) {\n        return PREFIX + \" [\" +\n            (discoOrdered ? \"ver=\" + topVer.get().topologyVersion() + \", \" : \"\") +\n            \"nodes=\" + (rmtNodesNum + 1) +\n            \", CPUs=\" + totalCpus +\n            \", heap=\" + heap + \"GB\" +\n            ']';\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1054,
    "type": "Return",
    "comment": "@return The current IconDrawable for chaining.",
    "code": "public IconicsDrawable sizeRes(int dimenRes) {\n    return sizePx(mContext.getResources().getDimensionPixelSize(dimenRes));\n}",
    "label": 1,
    "rec": "@return The current IconExtDrawable for chaining."
  },
  {
    "id": 1055,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte not(byte first) {\n        return mockingProgress.getLastArguments().reportNot().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1056,
    "type": "Return",
    "comment": "@return  Repo or null if unparseable",
    "code": "    public static Repository getRepository(Uri uri) {\n        List<String> segments = uri.getPathSegments();\n        if (segments == null)\n            return null;\n        if (segments.size() < 2)\n            return null;\n\n        String repoOwner = segments.get(0);\n        if (!RepositoryUtils.isValidOwner(repoOwner))\n            return null;\n\n        String repoName = segments.get(1);\n        if (!RepositoryUtils.isValidRepo(repoName))\n            return null;\n\n        return InfoUtils.createRepoFromData(repoOwner, repoName);\n    }\n",
    "label": 1,
    "rec": "@return  Repository or null if unparseable"
  },
  {
    "id": 1057,
    "type": "Return",
    "comment": "@return Dummy metrics provider.",
    "code": "    protected GridDiscoveryMetricsProvider createMetricsProvider() {\n        return new GridDiscoveryMetricsProvider() {\n            /** {@inheritDoc} */\n            @Override public ClusterNodeMetrics getMetrics() { return new ClusterDiscoveryMetricsAdapter(); }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1058,
    "type": "Return",
    "comment": "@return size of the \"tree-nodes\" cache",
    "code": "@Deprecated\npublic int getTreeNodesCacheSize() {\n    return NUM;\n}",
    "label": 1,
    "rec": "@return {@code 0}"
  },
  {
    "id": 1059,
    "type": "Return",
    "comment": "@return Empty projection exception.",
    "code": "    public static GridEmptyProjectionException emptyTopologyException() {\n        return new GridEmptyProjectionException(\"Topology projection is empty. Note that predicate based \" +\n            \"projection can be empty from call to call.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1060,
    "type": "Return",
    "comment": "@return dialog",
    "code": "public static LightAlertDialog.Builder create(final Context context) {\n    return new LightAlertDialog.Builder(context, THEME_HOLO_LIGHT);\n}",
    "label": 1,
    "rec": "@return dialog builder"
  },
  {
    "id": 1061,
    "type": "Return",
    "comment": "@return Kernal context.",
    "code": "    public static GridKernalContext context(Ignite ignite) {\n        assert ignite != null;\n\n        return ((GridKernal) ignite).context();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1062,
    "type": "Return",
    "comment": "@return A task that can be resolved upon registering the token with BaaS.",
    "code": "private Task<Void> registerWithServer(final String registrationToken) {\n    final Map<String, Object> request = getRegisterPushDeviceRequest(registrationToken);\n    return getStitchClient().executePipeline(new PipelineStage(Actions.REGISTER_PUSH, request)).continueWith(new Continuation<List<Object>, Void>() {\n\n        @Override\n        public Void then(@NonNull Task<List<Object>> task) throws Exception {\n            if (!task.isSuccessful()) {\n                throw task.getException();\n            }\n            addInfoToConfigs(_info);\n            return null;\n        }\n    });\n}",
    "label": 1,
    "rec": "@return A task that can be resolved upon registering the token with Stitch."
  },
  {
    "id": 1063,
    "type": "Return",
    "comment": "@return Context.",
    "code": "    public BinaryContext context() {\n        return ctx;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1064,
    "type": "Return",
    "comment": "@return Fail spis.",
    "code": "public T2<String, Map<String, Object>>[] failoverSpis() {\n    return failSpis;\n}",
    "label": 1,
    "rec": "@return Failover SPIs."
  },
  {
    "id": 1065,
    "type": "Return",
    "comment": "@return the matching section in the response",
    "code": "    public Device getDevice(String device) {\n        for (Device d : devices) {\n            if (device.equals(d.getDeviceName())) {\n                return d;\n            }\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1066,
    "type": "Return",
    "comment": "@return a Float[]",
    "code": "public Vector getCenter() {\n    return center;\n}",
    "label": 1,
    "rec": "@return the center of the Canopy"
  },
  {
    "id": 1067,
    "type": "Return",
    "comment": "@return  CharacterSetECI representing ECI of given value, or null if it is legal but unsupported",
    "code": "  public static CharacterSetECI getCharacterSetECIByValue(int value) {\n    if (VALUE_TO_ECI == null) {\n      initialize();\n    }\n    if (value < 0 || value >= 900) {\n      throw new IllegalArgumentException(\"Bad ECI value: \" + value);\n    }\n    return (CharacterSetECI) VALUE_TO_ECI.get(Integer.valueOf(value));\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1068,
    "type": "Return",
    "comment": "@return null if the statuscode is unknown.",
    "code": "private int statusCodeToExceptionCode(StatusCode status) {\n    switch(status) {\n        case EOK:\n            return BKException.Code.OK;\n        case ENOENTRY:\n            return BKException.Code.NoSuchEntryException;\n        case ENOLEDGER:\n            return BKException.Code.NoSuchLedgerExistsException;\n        case EBADVERSION:\n            return BKException.Code.ProtocolVersionException;\n        case EUA:\n            return BKException.Code.UnauthorizedAccessException;\n        case EFENCED:\n            return BKException.Code.LedgerFencedException;\n        case EREADONLY:\n            return BKException.Code.WriteOnReadOnlyBookieException;\n        case ETOOMANYREQUESTS:\n            return BKException.Code.TooManyRequestsException;\n        default:\n            return BKException.Code.UNINITIALIZED;\n    }\n}",
    "label": 1,
    "rec": "@return {@link BKException.Code.UNINITIALIZED} if the statuscode is unknown."
  },
  {
    "id": 1069,
    "type": "Return",
    "comment": "@return this builder for method chaining.",
    "code": "        public AnimationBuilder withDuration(long duration) {\n            this.duration = duration;\n            return this;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1070,
    "type": "Return",
    "comment": "@return State of  device",
    "code": "\tprivate State getStateFromConfig(Config pilightConfig, PilightBindingConfig bindingConfig) {\n\t\tLocation loc = pilightConfig.getConfig().get(bindingConfig.getLocation());\n\t\tif (loc != null) {\n\t\t\tDevice dev = loc.getDevices().get(bindingConfig.getDevice());\n\t\t\t\n\t\t\tif (dev != null) {\n\t\t\t\tString devType = dev.getType().toString();\n\t\t\t\tif (devType.equals(DeviceType.SWITCH) || devType.equals(DeviceType.DIMMER)) {\n\t\t\t\t\tOnOffType state = OnOffType.valueOf(dev.getState().toUpperCase());\n\t\t\t\t\t\n\t\t\t\t\tif (dev.getDimlevel() != null && dev.getDimlevel() > 0) {\n\t\t\t\t\t\tif (state.equals(OnOffType.ON))\n\t\t\t\t\t\t\treturn new PercentType(getPercentageFromDimLevel(dev.getDimlevel().toString()));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn PercentType.ZERO;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn state;\n\t\t\t\t} else if (devType.equals(DeviceType.VALUE)) {\n\t\t\t\t\tbindingConfig.setScale(dev.getScale());\n\t\t\t\t\t\n\t\t\t\t\tString property = bindingConfig.getProperty();\n\t\t\t\t\tif (dev.getProperties().containsKey(property)) {\n\t\t\t\t\t\tString value = dev.getProperties().get(property);\n\t\t\t\t\t\treturn getStateFromProperty(value, bindingConfig);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "label": 1,
    "rec": "@return Current state of the item"
  },
  {
    "id": 1071,
    "type": "Return",
    "comment": "@return Ignite runtime exception.",
    "code": "    public static IgniteException convertException(IgniteCheckedException e) {\n        if (e instanceof IgniteInterruptedCheckedException)\n            return new IgniteInterruptedException(e.getMessage(), (InterruptedException)e.getCause());\n        else if (e instanceof IgniteFutureCancelledCheckedException)\n            return new IgniteFutureCancelledException(e.getMessage(), e.getCause());\n        else if (e instanceof IgniteFutureTimeoutCheckedException)\n            return new IgniteFutureTimeoutException(e.getMessage(), e.getCause());\n        else if (e instanceof ClusterGroupEmptyCheckedException)\n            return new ClusterGroupEmptyException(e.getMessage(), e.getCause());\n        else if (e instanceof ClusterTopologyCheckedException)\n            return new ClusterTopologyException(e.getMessage(), e.getCause());\n        else if (e instanceof IgniteDeploymentCheckedException)\n            return new IgniteDeploymentException(e.getMessage(), e.getCause());\n        else if (e instanceof ComputeTaskTimeoutCheckedException)\n            return new ComputeTaskTimeoutException(e.getMessage(), e.getCause());\n        else if (e.getCause() instanceof IgniteException)\n            return (IgniteException)e.getCause();\n\n        return new IgniteException(e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1072,
    "type": "Return",
    "comment": "@return list of registrations",
    "code": "@SuppressWarnings(STR)\npublic <T> List<RegisteredServiceProvider<T>> getRegistrations(Class<T> service) {\n    ImmutableList.Builder<RegisteredServiceProvider<T>> ret;\n    synchronized (providers) {\n        List<RegisteredServiceProvider<?>> registered = providers.get(service);\n        if (registered == null) {\n            return ImmutableList.<RegisteredServiceProvider<T>>of();\n        }\n        ret = ImmutableList.<RegisteredServiceProvider<T>>builder();\n        for (RegisteredServiceProvider<?> provider : registered) {\n            ret.add((RegisteredServiceProvider<T>) provider);\n        }\n    }\n    return ret.build();\n}",
    "label": 1,
    "rec": "@return a copy of the list of registrations"
  },
  {
    "id": 1073,
    "type": "Return",
    "comment": "@return list of messages to send",
    "code": "    private List<Message<byte[]>> generateMessages(List<byte[]> messageBodies) {\n        List<Message<byte[]>> messagesToSend = new ArrayList<>();\n\n        try {\n            for (byte[] msgBody : messageBodies) {\n                MessageBuilder<byte[]> msgBuilder = MessageBuilder.create();\n                msgBuilder.setContent(msgBody);\n                messagesToSend.add(msgBuilder.build());\n            }\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n        }\n\n        return messagesToSend;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1074,
    "type": "Return",
    "comment": "@return A Promela string that calls a trace function.",
    "code": "public String toPromelaTraceString() {\n    String inlineFn;\n    int ownerId;\n    if (isLocalEvent()) {\n        inlineFn = STR;\n        ownerId = pid;\n    } else if (isRecvEvent()) {\n        inlineFn = STR;\n        ownerId = channelId.getScmId();\n    } else if (isSendEvent()) {\n        inlineFn = STR;\n        ownerId = channelId.getScmId();\n    } else {\n        return STR + getPromelaEType() + STR;\n    }\n    return String.format(STR, inlineFn, ownerId, getPromelaEType());\n}",
    "label": 1,
    "rec": "@return A Promela string that calls a trace function. This is used to track the most recent event for use in never claims."
  },
  {
    "id": 1075,
    "type": "Return",
    "comment": "@return If this row was accepted.",
    "code": "        @Override protected boolean accept(GridH2Row row) {\n            if (row instanceof GridH2AbstractKeyValueRow) {\n                if (((GridH2AbstractKeyValueRow) row).expirationTime() <= time)\n                    return false;\n            }\n\n            if (fltr == null)\n                return true;\n\n            Object key = row.getValue(keyCol).getObject();\n            Object val = row.getValue(valCol).getObject();\n\n            assert key != null;\n            assert val != null;\n\n            return fltr.apply(key, val);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1076,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Collection<Hdr> getSupportedHdr() {\n        return Collections.unmodifiableSet(supportedHdr);\n    }\n",
    "label": 1,
    "rec": "@return a collection of supported values."
  },
  {
    "id": 1077,
    "type": "Return",
    "comment": "@return  True if need to unwrap internal entries.",
    "code": "    private boolean unwrapEntries() {\n        return !(updater instanceof IgniteDataStreamerCacheUpdaters.InternalUpdater);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1078,
    "type": "Return",
    "comment": "@return The primary key columns",
    "code": "public String[] getPrimaryKeyColumns() {\n    return _primaryKeyColumns;\n}",
    "label": 1,
    "rec": "@return The primary key column names"
  },
  {
    "id": 1079,
    "type": "Return",
    "comment": "@return  true if this check is enabled.",
    "code": "    private boolean checkEnabled() {\n        return U.getAnnotation(getClass(), IgniteSpiConsistencyChecked.class) != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1080,
    "type": "Return",
    "comment": "@return Maximum number of entries or null",
    "code": "private Optional<Integer> readMaxEntriesRequestJournal(ServletContext context) {\n    String str = context.getInitParameter(STR);\n    if (str == null) {\n        return Optional.absent();\n    }\n    return Optional.of(Integer.parseInt(str));\n}",
    "label": 1,
    "rec": "@return Maximum number of entries or absent"
  },
  {
    "id": 1081,
    "type": "Return",
    "comment": "@return the current zoom value",
    "code": "    public float getZoom() {\n        return mCameraEngine.getZoomValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1082,
    "type": "Return",
    "comment": "@return set method list",
    "code": "public static Map<String, String> getAllSetterMethods(PsiClass psiClass, String currentMethodName) {\n    Map<String, String> methodNames = new HashMap<String, String>();\n    PsiMethod[] psiMethods = null;\n    String prefix = STR;\n    if (!currentMethodName.contains(STR)) {\n        psiMethods = psiClass.getAllMethods();\n    } else {\n        prefix = currentMethodName.substring(NUM, currentMethodName.lastIndexOf(STR));\n        String getterMethod = STR + StringUtil.capitalize(prefix);\n        PsiClass psiFieldClass = findGetterMethodReturnType(psiClass, getterMethod);\n        if (psiFieldClass != null) {\n            psiMethods = psiFieldClass.getAllMethods();\n            prefix = prefix + STR;\n        }\n    }\n    if (psiMethods != null && psiMethods.length > NUM) {\n        for (PsiMethod psiMethod : psiMethods) {\n            String methodName = psiMethod.getName();\n            if (methodName.startsWith(STR) && psiMethod.getParameterList().getParametersCount() == NUM) {\n                String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(STR, STR));\n                String type = psiMethod.getParameterList().getParameters()[NUM].getType().getPresentableText();\n                methodNames.put(name, type);\n            }\n        }\n    }\n    return methodNames;\n}",
    "label": 1,
    "rec": "@return set method list without prefix"
  },
  {
    "id": 1083,
    "type": "Return",
    "comment": "@return true the current xml entry is a way entry and has nodes",
    "code": "    boolean filterWay(XMLStreamReader sReader) throws XMLStreamException {\n\n        readWayAttributes( sReader );\n\n        if( wayNodes.size() < 2 )\n            return false;\n\n        return acceptWay.accept(osmProperties)>0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1084,
    "type": "Return",
    "comment": "@return the annotations infos",
    "code": "public AnnotationElement.Annotation[] getAnnotations() {\n    return getAnnotationReader().getAnnotationElements();\n}",
    "label": 1,
    "rec": "@return the annotations"
  },
  {
    "id": 1085,
    "type": "Return",
    "comment": "@return string like \"dc=something,dc=org\" from the DN like \"uid=joe,dc=something,dc=org\"",
    "code": "    public String getParentDn() {\n        LinkedList<Entry> parentDnEntries = new LinkedList<>(entries);\n        parentDnEntries.remove();\n        return toString(parentDnEntries);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1086,
    "type": "Return",
    "comment": "@return The current part if it implements <code>IDiagramWorkbenchPart</code>; <code>null</code> otherwise",
    "code": "protected IDiagramWorkbenchPart getDiagramWorkbenchPart() {\n    IDiagramWorkbenchPart diagramPart = null;\n    IWorkbenchPart part = getWorkbenchPart();\n    if (part instanceof IDiagramWorkbenchPart) {\n        diagramPart = (IDiagramWorkbenchPart) part;\n    } else {\n        diagramPart = (IDiagramWorkbenchPart) part.getAdapter(IDiagramWorkbenchPart.class);\n    }\n    return diagramPart;\n}",
    "label": 1,
    "rec": "@return The current part if it implements or adapts to <code>IDiagramWorkbenchPart</code>; <code>null</code> otherwise"
  },
  {
    "id": 1087,
    "type": "Return",
    "comment": "@return  True if cross-cache transaction can include this new cache.",
    "code": "    public boolean txCompatible(IgniteInternalTx<K, V> tx, Iterable<Integer> activeCacheIds, GridCacheContext<K, V> cacheCtx) {\n        if (cacheCtx.system() ^ tx.system())\n            return false;\n\n        for (Integer cacheId : activeCacheIds) {\n            GridCacheContext<K, V> activeCacheCtx = cacheContext(cacheId);\n\n            // Check that caches have the same store.\n            if (activeCacheCtx.store().store() != cacheCtx.store().store())\n                return false;\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1088,
    "type": "Return",
    "comment": "@return {@link KiHttpServletRequest KiHttpServletRequest} instance wrapping the original.",
    "code": "protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n    return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n}",
    "label": 1,
    "rec": "@return {@link ShiroHttpServletRequest KiHttpServletRequest} instance wrapping the original."
  },
  {
    "id": 1089,
    "type": "Return",
    "comment": "@return a  RequestProcessor that will be used to process requests.",
    "code": "    protected RequestProcessor createRequestProcessor(CacheManager cacheManager, RequestProgressManager requestProgressManager, RequestRunner requestRunner) {\n        return new RequestProcessor(cacheManager, requestProgressManager, requestRunner);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1090,
    "type": "Return",
    "comment": "@return description string",
    "code": "public String toString() {\n    return getBriefDescription();\n}",
    "label": 1,
    "rec": "@return brief description of FrameBody"
  },
  {
    "id": 1091,
    "type": "Return",
    "comment": "@return edited gist",
    "code": "    public Gist editGist(Gist gist) throws IOException {\n        return addGist(new EditGistClient(context, gist.id, RequestUtils.editGist(gist)).executeSync());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1092,
    "type": "Return",
    "comment": "@return File id already stored in meta cache or  null if passed file info was stored.",
    "code": "    private GridGgfsFileInfo putIfAbsentNonTx(GridUuid parentId, String fileName, GridGgfsFileInfo newFileInfo)\n        throws GridException {\n        if (log.isDebugEnabled())\n            log.debug(\"Locking parent id [parentId=\" + parentId + \", fileName=\" + fileName + \", newFileInfo=\" +\n                newFileInfo + ']');\n\n        validTxState(true);\n\n        // Lock only parent file ID.\n        GridGgfsFileInfo parentInfo = info(parentId);\n\n        assert validTxState(true);\n\n        if (parentInfo == null)\n            throw new GridGgfsFileNotFoundException(\"Failed to lock parent directory (not found): \" + parentId);\n\n        if (!parentInfo.isDirectory())\n            throw new GridGgfsInvalidPathException(\"Parent file is not a directory: \" + parentInfo);\n\n        Map<String, GridGgfsListingEntry> parentListing = parentInfo.listing();\n\n        assert parentListing != null;\n\n        GridGgfsListingEntry entry = parentListing.get(fileName);\n\n        assert validTxState(true);\n\n        if (entry != null) {\n            newFileInfo = info(entry.fileId());\n\n            assert newFileInfo != null : \"Expects file info exist: \" + entry.fileId();\n\n            return newFileInfo;\n        }\n\n        GridUuid fileId = newFileInfo.id();\n\n        if (!id2InfoPrj.putxIfAbsent(fileId, newFileInfo))\n            throw new GridGgfsException(\"Failed to add file details into cache: \" + newFileInfo);\n\n        assert metaCache.get(parentId) != null;\n\n        id2InfoPrj.transform(parentId, new UpdateListing(fileName, new GridGgfsListingEntry(newFileInfo), false));\n\n        return null;\n    }\n",
    "label": 1,
    "rec": "@return File info already stored in meta cache or  null if passed file info was stored."
  },
  {
    "id": 1093,
    "type": "Return",
    "comment": "@return True if oapi is found in the root paths.",
    "code": "    static boolean isOpenShift(Client client) {\n        URL masterUrl = client.getMasterUrl();\n        if (IS_OPENSHIFT.containsKey(masterUrl)) {\n            return IS_OPENSHIFT.get(masterUrl);\n        } else {\n            RootPaths rootPaths = client.rootPaths();\n            if (rootPaths != null) {\n                List<String> paths = rootPaths.getPaths();\n                if (paths != null) {\n                    for (String path : paths) {\n                        // lets detect the new API Groups APIs for OpenShift\n                        if (path.endsWith(\".openshift.io\") || path.contains(\".openshift.io/\")) {\n                            USES_OPENSHIFT_APIGROUPS.putIfAbsent(masterUrl, true);\n                            IS_OPENSHIFT.putIfAbsent(masterUrl, true);\n                            return true;\n                        }\n                    }\n                    for (String path : paths) {\n                        if (java.util.Objects.equals(\"/oapi\", path) || java.util.Objects.equals(\"oapi\", path)) {\n                            IS_OPENSHIFT.putIfAbsent(masterUrl, true);\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        IS_OPENSHIFT.putIfAbsent(masterUrl, false);\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1094,
    "type": "Return",
    "comment": "@return BusyBox version is found, null if not found.",
    "code": "public static String getBusyBoxVersion() {\n    RootTools.log(InternalVariables.TAG, STR);\n    InternalVariables.busyboxVersion = null;\n    try {\n        new InternalMethods().doExec(new String[] { STR }, InternalVariables.timeout);\n    } catch (TimeoutException ex) {\n        RootTools.log(InternalVariables.TAG, STR);\n    } catch (Exception e) {\n        RootTools.log(InternalVariables.TAG, STR);\n        return STR;\n    }\n    return InternalVariables.busyboxVersion;\n}",
    "label": 1,
    "rec": "@return BusyBox version is found, \"\" if not found."
  },
  {
    "id": 1095,
    "type": "Return",
    "comment": "@return leader",
    "code": "    public Participant      getLeader() throws Exception\n    {\n        Collection<String>      participantNodes = mutex.getParticipantNodes();\n        return getLeader(client, participantNodes);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1096,
    "type": "Return",
    "comment": "@return -1 if there have been no checkout invocations",
    "code": "    public long getAvgCheckoutWaitUs() {\n        long count = checkoutCount.get();\n        if(count > 0)\n            return totalCheckoutTimeUs.get() / count;\n        return 0;\n    }\n",
    "label": 1,
    "rec": "@return 0 if there have been no checkout invocations"
  },
  {
    "id": 1097,
    "type": "Return",
    "comment": "@return  True if entry is locally mapped as a primary or back up node.",
    "code": "    protected boolean isNearLocallyMapped(GridCacheEntryEx<K, V> e, long topVer) {\n        return ctx.affinity().belongs(ctx.localNode(), e.key(), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1098,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastUnstableBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastUnstableBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 1099,
    "type": "Return",
    "comment": "@return  True if portables should be deserialized,  false otherwise.",
    "code": "    private boolean deserializePortables(GridCacheContext cacheCtx) {\n        GridCacheProjectionImpl prj = cacheCtx.projectionPerCall();\n\n        return prj == null || prj.deserializePortables();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1100,
    "type": "Return",
    "comment": "@return the mShownBalance",
    "code": "public boolean isShownBalance() {\n    return mShowBalance;\n}",
    "label": 1,
    "rec": "@return the mShowBalance"
  },
  {
    "id": 1101,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    protected CacheConfiguration cacheConfiguration() {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setCacheMode(PARTITIONED);\n        cfg.setBackups(1);\n        cfg.setDistributionMode(nearEnabled ? NEAR_PARTITIONED : PARTITIONED_ONLY);\n\n        cfg.setWriteSynchronizationMode(FULL_SYNC);\n        cfg.setPreloadMode(SYNC);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1102,
    "type": "Return",
    "comment": "@return The cloned content data.",
    "code": "public byte[] getContentData() {\n    return contentData;\n}",
    "label": 1,
    "rec": "@return The request body data."
  },
  {
    "id": 1103,
    "type": "Return",
    "comment": "@return the constructed hostname + port.",
    "code": "    public static InetSocketAddress getAddr(String hostline)\n    {\n        URI uri;\n        try\n        {\n            uri = new URI( \"tcp://\" + hostline );\n        } catch ( URISyntaxException ex )\n        {\n            throw new IllegalArgumentException( \"Bad hostline\", ex );\n        }\n\n        return new InetSocketAddress( uri.getHost(), ( uri.getPort() ) == -1 ? DEFAULT_PORT : uri.getPort() );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1104,
    "type": "Return",
    "comment": "@return  GridMessaging for given projection.",
    "code": "    protected IgniteMessaging message(ClusterGroup prj) {\n        return prj.grid().message(prj);\n    }\n",
    "label": 1,
    "rec": "@return  org.gridgain.grid.messaging.IgniteMessaging for given projection."
  },
  {
    "id": 1105,
    "type": "Return",
    "comment": "@return The new node with the new partitions",
    "code": "    public static Node addPartitionToNode(final Node node, final Set<Integer> donatedPartitions) {\n        List<Integer> deepCopy = new ArrayList<Integer>(node.getPartitionIds());\n        deepCopy.addAll(donatedPartitions);\n        return updateNode(node, deepCopy);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1106,
    "type": "Return",
    "comment": "@return An array of URLs in the given spec, or <code>null</code>",
    "code": "private static URI[] getURLs(String spec) {\n    String[] urlSpecs = getArrayFromString(spec, STR);\n    ArrayList result = new ArrayList(urlSpecs.length);\n    for (int i = NUM; i < urlSpecs.length; i++) {\n        try {\n            result.add(new URI(urlSpecs[i]));\n        } catch (URISyntaxException e) {\n            LogHelper.log(new Status(IStatus.ERROR, InstallerActivator.PI_INSTALLER, STR + urlSpecs[i], e));\n        }\n    }\n    if (result.isEmpty())\n        return null;\n    return (URI[]) result.toArray(new URI[result.size()]);\n}",
    "label": 1,
    "rec": "@return An array of URIs in the given spec, or <code>null</code>"
  },
  {
    "id": 1107,
    "type": "Return",
    "comment": "@return the configure receiver queue size value",
    "code": "    public int getReceiverQueueSize() {\n        return conf.getReceiverQueueSize();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1108,
    "type": "Return",
    "comment": "@return the total byte size of the AllocationPointerOperations",
    "code": "public static final long getEndOffset(final long address) {\n    return getEndAddress(address) - getAddressOfDim(address);\n}",
    "label": 1,
    "rec": "@return the total byte size of the AllocationPointer"
  },
  {
    "id": 1109,
    "type": "Return",
    "comment": "@return All methods declared in this class hierarchy.",
    "code": "    public static Method[] getAllMethods(Class<?> clazz) {\n        if (clazz == null) {\n            throw new IllegalArgumentException(\"You must specify a class in order to get the methods.\");\n        }\n        Set<Method> methods = new LinkedHashSet<Method>();\n\n        Class<?> thisType = clazz;\n\n        while (thisType != null) {\n            final Class<?> type = thisType;\n            final Method[] declaredMethods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return type.getDeclaredMethods();\n                }\n\n            });\n            for (Method method : declaredMethods) {\n                method.setAccessible(true);\n                methods.add(method);\n            }\n            Collections.addAll(methods, type.getMethods());\n            thisType = thisType.getSuperclass();\n        }\n        return methods.toArray(new Method[methods.size()]);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1110,
    "type": "Return",
    "comment": "@return A task that can be resolved upon deregistering the device from BaaS.",
    "code": "private Task<Void> deregisterWithServer() {\n    final Map<String, Object> request = getDeregisterPushDeviceRequest();\n    return getStitchClient().executePipeline(new PipelineStage(Actions.DEREGISTER_PUSH, request)).continueWith(new Continuation<List<Object>, Void>() {\n\n        @Override\n        public Void then(@NonNull Task<List<Object>> task) throws Exception {\n            if (!task.isSuccessful()) {\n                throw task.getException();\n            }\n            removeInfoFromConfigs(_info);\n            return null;\n        }\n    });\n}",
    "label": 1,
    "rec": "@return A task that can be resolved upon deregistering the device from Stitch."
  },
  {
    "id": 1111,
    "type": "Return",
    "comment": "@return SPI instance.",
    "code": "    private CommunicationSpi getCommunication() {\n        GridTcpCommunicationSpi spi = new GridTcpCommunicationSpi();\n\n        spi.setTcpNoDelay(true);\n        spi.setSharedMemoryPort(-1);\n        spi.setConnectionBufferSize(0);\n\n        info(\"Comm SPI: \" + spi);\n\n        return spi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1112,
    "type": "Return",
    "comment": "@return System can satisfy the memory request or not Given Xms/Xmx values (in kb) used by java process, determine if system can satisfy the memory request",
    "code": "public boolean canSystemGrantMemory(long xmx) {\n    long freeMemSize = util.getOsTotalFreeMemorySize();\n    if (freeMemSize == NUM) {\n        return true;\n    }\n    if (freeMemSize - xmx < LOW_MEM_THRESHOLD) {\n        logger.info(String.format(STR, freeMemSize, xmx, LOW_MEM_THRESHOLD));\n        return false;\n    }\n    return true;\n}",
    "label": 1,
    "rec": "@return true if the system can satisfy the memory request Given Xmx value (in kb) used by java process, determine if system can satisfy the memory request"
  },
  {
    "id": 1113,
    "type": "Return",
    "comment": "@return Iterator over off-heap keys.",
    "code": "    public Iterator<KeyCacheObject> offHeapKeyIterator(boolean primary, boolean backup, long topVer) {\n        assert primary || backup;\n\n        if (!offheapEnabled)\n            return F.emptyIterator();\n\n        if (primary && backup)\n            return keyIterator(offheap.iterator(spaceName));\n\n        Set<Integer> parts = primary ? cctx.affinity().primaryPartitions(cctx.localNodeId(), topVer) :\n            cctx.affinity().backupPartitions(cctx.localNodeId(), topVer);\n\n        return new PartitionsKeyIterator(parts) {\n            @Override protected Iterator<KeyCacheObject> partitionIterator(int part)\n                throws IgniteCheckedException\n            {\n                return keyIterator(offheap.iterator(spaceName, part));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1114,
    "type": "Return",
    "comment": "@return the {@link WritableComparable} comparator used to compare keys.",
    "code": "public RawComparator getOutputKeyComparator() {\n    Class theClass = getClass(STR, null, RawComparator.class);\n    if (theClass != null)\n        return (RawComparator) ReflectionUtils.newInstance(theClass, this);\n    return WritableComparator.get(getMapOutputKeyClass());\n}",
    "label": 1,
    "rec": "@return the {@link RawComparator} comparator used to compare keys."
  },
  {
    "id": 1115,
    "type": "Return",
    "comment": "@return Class loader ID.",
    "code": "        IgniteUuid loaderId() {\n            return ldrId;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1116,
    "type": "Return",
    "comment": "@return Integer reply, specifically: an integer greater than 0 if one or more keys exist, 0 if none of the specified keys exist.",
    "code": "@Override\npublic Boolean exists(final byte[] key) {\n    checkIsInMultiOrPipeline();\n    client.exists(key);\n    return client.getIntegerReply() == NUM;\n}",
    "label": 1,
    "rec": "@return Boolean reply, true if the key exists, otherwise false"
  },
  {
    "id": 1117,
    "type": "Return",
    "comment": "@return DHT managers.",
    "code": "    private List<GridCacheManager> dhtManagers(GridCacheContext ctx) {\n        return F.asList(ctx.store(), ctx.events(), ctx.swap(), ctx.evicts(), ctx.queries(), ctx.continuousQueries(),\n            ctx.dr());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1118,
    "type": "Return",
    "comment": "@return Vec containing L2 norm (MSE) of each reconstructed row, caller is responsible for deletion",
    "code": "  public Frame scoreAutoEncoder(Frame frame) {\n    Frame fr = frame;\n    boolean adapt = true;\n    int ridx = fr.find(responseName());\n    if (ridx != -1) { // drop the response for scoring!\n      fr = new Frame(fr);\n      fr.remove(ridx);\n    }\n    // Adapt the Frame layout - returns adapted frame and frame containing only\n    // newly created vectors\n    Frame[] adaptFrms = adapt ? adapt(fr,false) : null;\n    // Adapted frame containing all columns - mix of original vectors from fr\n    // and newly created vectors serving as adaptors\n    Frame adaptFrm = adapt ? adaptFrms[0] : fr;\n    // Contains only newly created vectors. The frame eases deletion of these vectors.\n    Frame onlyAdaptFrm = adapt ? adaptFrms[1] : null;\n\n    final int len = _names.length-1;\n    adaptFrm.add(\"L2\",adaptFrm.anyVec().makeZero());\n    final double[] normMul = model_info().data_info()._normMul;\n\n    new MRTask2() {\n      @Override public void map( Chunk chks[] ) {\n        double tmp [] = new double[len];\n        float preds[] = new float [len];\n        for( int row=0; row<chks[0]._len; row++ ) {\n          for( int i=0; i<_names.length-1; i++ )\n            tmp[i] = chks[i].at0(row); //original data\n          score0(tmp,preds); //fill predictions (reconstruction)\n//          Log.info(\"row: \" + chks[0]._start + row);\n//          Log.info(\"actual\" + ArrayUtils.toString(tmp));\n//          Log.info(\"recons\" + ArrayUtils.toString(preds));\n          double l2 = 0;\n          for (int i=0; i<len; ++i)\n            l2 += Math.pow((preds[i] - tmp[i])*normMul[i], 2);\n//          Log.info(\"L2: \" + l2);\n          chks[len].set0(row,l2); //last vector stores the per-row L2 error\n        }\n      }\n    }.doAll(adaptFrm);\n\n    // Return just the output columns\n    int x=_names.length-1, y=adaptFrm.numCols();\n    final Frame l2 = adaptFrm.extractFrame(x, y);\n    if (adapt) onlyAdaptFrm.delete();\n    return l2;\n  }\n",
    "label": 1,
    "rec": "@return Frame containing one Vec with L2 norm (MSE) of each reconstructed row, caller is responsible for deletion"
  },
  {
    "id": 1119,
    "type": "Return",
    "comment": "@return a KeyManager for the given  typeUrl,  primitiveName and version at least  minVersion (if it exists in the catalogue).",
    "code": "  private KeyManager<PublicKeyVerify> publicKeyVerifyKeyManager(String typeUrl)\n      throws GeneralSecurityException {\n    switch (typeUrl) {\n      case EcdsaVerifyKeyManager.TYPE_URL:\n        return new EcdsaVerifyKeyManager();\n      case Ed25519PublicKeyManager.TYPE_URL:\n        return new Ed25519PublicKeyManager();\n      case RsaSsaPkcs1VerifyKeyManager.TYPE_URL:\n        return new RsaSsaPkcs1VerifyKeyManager();\n      default:\n        throw new GeneralSecurityException(\n            String.format(\n                \"No support for primitive 'PublicKeyVerify' with key type '%s'.\", typeUrl));\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1120,
    "type": "Return",
    "comment": "@return the currently active user service.",
    "code": "public static UserService getUserService() {\n    UserService userService = activeUserService;\n    if (userService == null) {\n        String type = BundleProperties.getProperty(USERSTORE_TYPE_PROPERTY, LOCAL_USERSTORE);\n        boolean useLocalFallback = BooleanUtils.toBoolean(BundleProperties.getProperty(USERSTORE_USE_LOCAL_FALLBACK_PROPERTY));\n        UserStoreConfig userStoreConfig = Configurations.getConfiguration(UserStoreConfig.class);\n        if (userStoreConfig != null) {\n            type = userStoreConfig.getType();\n            useLocalFallback = userStoreConfig.isUseLocalFallback();\n        }\n        if (StringUtils.isNotBlank(type)) {\n            userService = byType.get(type);\n        }\n        if (userService == null && useLocalFallback) {\n            LOG.info(MessageFormat.format(STR, type));\n            userService = byType.get(LOCAL_USERSTORE);\n        }\n        activeUserService = userService;\n    }\n    return userService;\n}",
    "label": 1,
    "rec": "@return the configured and active user service, or <code>null</code> if no user service is registered and fallback to the local user store is forbidden."
  },
  {
    "id": 1121,
    "type": "Return",
    "comment": "@return boolean",
    "code": "    public boolean isExecutionComplete() {\n        return commandState.get().equals(CommandState.TERMINAL);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1122,
    "type": "Return",
    "comment": "@return Afinity key.",
    "code": "        public Object key(boolean useColocatedData) {\n            return useColocatedData ? new AffinityKey<>(id, orderId) : id;\n        }\n",
    "label": 1,
    "rec": "@return Key."
  },
  {
    "id": 1123,
    "type": "Return",
    "comment": "@return Checks if disco ordering should be enforced.",
    "code": "    public static boolean relaxDiscoveryOrdered() {\n        return \"true\".equalsIgnoreCase(System.getProperty(IGNITE_NO_DISCO_ORDER));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1124,
    "type": "Return",
    "comment": "@return The found element or <code>null</code>",
    "code": "public static Element findElementById(Node startNode, String value, String namespace) {\n    Element foundElement = null;\n    if (startNode == null) {\n        return null;\n    }\n    Node startParent = startNode.getParentNode();\n    Node processedNode = null;\n    while (startNode != null) {\n        if (startNode.getNodeType() == Node.ELEMENT_NODE) {\n            Element se = (Element) startNode;\n            if (se.hasAttributeNS(namespace, STR) && value.equals(se.getAttributeNS(namespace, STR))) {\n                if (foundElement == null) {\n                    foundElement = se;\n                } else {\n                    log.warn(STR);\n                    return null;\n                }\n            }\n        }\n        processedNode = startNode;\n        startNode = startNode.getFirstChild();\n        if (startNode == null) {\n            startNode = processedNode.getNextSibling();\n        }\n        while (startNode == null) {\n            processedNode = processedNode.getParentNode();\n            if (processedNode == startParent) {\n                return foundElement;\n            }\n            startNode = processedNode.getNextSibling();\n        }\n    }\n    return foundElement;\n}",
    "label": 1,
    "rec": "@return The found element if there was exactly one match, or <code>null</code> otherwise"
  },
  {
    "id": 1125,
    "type": "Return",
    "comment": "@return Event predicate.",
    "code": "    public static IgnitePredicate<Event> eventType(@Nullable final int... types) {\n        return isEmpty(types) ? F.<Event>alwaysFalse() : new IgnitePredicate<Event>() {\n            @Override public boolean apply(Event e) {\n                assert e != null;\n\n                assert types != null;\n\n                for (int t : types) {\n                    if (e.type() == t)\n                        return true;\n                }\n\n                return false;\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1126,
    "type": "Return",
    "comment": "@return Either the total fee paid (assuming all existing inputs had a connected output) or null if we cannot afford the transaction.",
    "code": "public boolean completeTx(SendRequest req) {\n    lock.lock();\n    try {\n        Preconditions.checkArgument(!req.completed, STR);\n        BigInteger value = BigInteger.ZERO;\n        for (TransactionOutput output : req.tx.getOutputs()) {\n            value = value.add(output.getValue());\n        }\n        BigInteger totalOutput = value;\n        log.info(STR, req.tx.getOutputs().size(), bitcoinValueToFriendlyString(value));\n        BigInteger totalInput = BigInteger.ZERO;\n        for (TransactionInput input : req.tx.getInputs()) if (input.getConnectedOutput() != null)\n            totalInput = totalInput.add(input.getConnectedOutput().getValue());\n        else\n            log.warn(STR);\n        value = value.subtract(totalInput);\n        List<TransactionInput> originalInputs = new ArrayList<TransactionInput>(req.tx.getInputs());\n        boolean needAtLeastReferenceFee = false;\n        if (req.ensureMinRequiredFee) {\n            for (TransactionOutput output : req.tx.getOutputs()) if (output.getValue().compareTo(Utils.CENT) < NUM) {\n                needAtLeastReferenceFee = true;\n                break;\n            }\n        }\n        LinkedList<TransactionOutput> candidates = calculateSpendCandidates(true);\n        Address changeAddress = req.changeAddress;\n        int minSize = NUM;\n        BigInteger additionalValueForNextCategory = null;\n        CoinSelection selection3 = null;\n        CoinSelection selection2 = null;\n        TransactionOutput selection2Change = null;\n        CoinSelection selection1 = null;\n        TransactionOutput selection1Change = null;\n        while (true) {\n            req.tx.clearInputs();\n            for (TransactionInput input : originalInputs) req.tx.addInput(input);\n            BigInteger fees = req.fee.add(BigInteger.valueOf(minSize / NUM).multiply(req.feePerKb));\n            if (needAtLeastReferenceFee && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < NUM)\n                fees = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;\n            BigInteger valueNeeded = value.add(fees);\n            if (additionalValueForNextCategory != null)\n                valueNeeded = valueNeeded.add(additionalValueForNextCategory);\n            BigInteger additionalValueSelected = additionalValueForNextCategory;\n            CoinSelection selection = coinSelector.select(valueNeeded, candidates);\n            if (selection.valueGathered.compareTo(valueNeeded) < NUM)\n                break;\n            checkState(selection.gathered.size() > NUM || originalInputs.size() > NUM);\n            int size = NUM;\n            boolean eitherCategory2Or3 = false;\n            boolean isCategory3 = false;\n            BigInteger change = selection.valueGathered.subtract(valueNeeded);\n            if (additionalValueSelected != null)\n                change = change.add(additionalValueSelected);\n            TransactionOutput changeOutput = null;\n            if (req.ensureMinRequiredFee && !change.equals(BigInteger.ZERO) && change.compareTo(Utils.CENT) < NUM && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < NUM) {\n                eitherCategory2Or3 = true;\n                additionalValueForNextCategory = Utils.CENT;\n                change = change.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(fees));\n            }\n            if (change.compareTo(BigInteger.ZERO) > NUM) {\n                if (changeAddress == null)\n                    changeAddress = getChangeAddress();\n                changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);\n                if (req.ensureMinRequiredFee && Transaction.MIN_NONDUST_OUTPUT.compareTo(change) >= NUM) {\n                    isCategory3 = true;\n                    additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT.add(BigInteger.ONE));\n                } else {\n                    size += changeOutput.bitcoinSerialize().length + VarInt.sizeOf(req.tx.getOutputs().size()) - VarInt.sizeOf(req.tx.getOutputs().size() - NUM);\n                    if (!eitherCategory2Or3)\n                        additionalValueForNextCategory = null;\n                }\n            } else {\n                if (eitherCategory2Or3) {\n                    isCategory3 = true;\n                    additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);\n                }\n            }\n            for (TransactionOutput output : selection.gathered) {\n                req.tx.addInput(output);\n                checkState(req.tx.getInput(req.tx.getInputs().size() - NUM).getScriptBytes().length == NUM);\n                try {\n                    if (output.getScriptPubKey().isSentToAddress()) {\n                        size += this.findKeyFromPubHash(output.getScriptPubKey().getPubKeyHash()).getPubKey().length + NUM;\n                    } else if (output.getScriptPubKey().isSentToRawPubKey())\n                        size += NUM;\n                    else\n                        throw new RuntimeException(STR);\n                } catch (ScriptException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            size += req.tx.bitcoinSerialize().length;\n            if (size / NUM > minSize / NUM && req.feePerKb.compareTo(BigInteger.ZERO) > NUM) {\n                minSize = size;\n                additionalValueForNextCategory = additionalValueSelected;\n                continue;\n            }\n            if (isCategory3) {\n                if (selection3 == null)\n                    selection3 = selection;\n            } else if (eitherCategory2Or3) {\n                checkState(selection2 == null);\n                checkState(additionalValueForNextCategory.equals(Utils.CENT));\n                selection2 = selection;\n                selection2Change = checkNotNull(changeOutput);\n            } else {\n                checkState(selection1 == null);\n                checkState(additionalValueForNextCategory == null);\n                selection1 = selection;\n                selection1Change = changeOutput;\n            }\n            if (additionalValueForNextCategory != null) {\n                if (additionalValueSelected != null)\n                    checkState(additionalValueForNextCategory.compareTo(additionalValueSelected) > NUM);\n                continue;\n            }\n            break;\n        }\n        req.tx.clearInputs();\n        for (TransactionInput input : originalInputs) req.tx.addInput(input);\n        if (selection3 == null && selection2 == null && selection1 == null) {\n            log.warn(STR);\n            return false;\n        }\n        BigInteger lowestFee = null;\n        CoinSelection bestCoinSelection = null;\n        TransactionOutput bestChangeOutput = null;\n        if (selection1 != null) {\n            if (selection1Change != null)\n                lowestFee = selection1.valueGathered.subtract(selection1Change.getValue());\n            else\n                lowestFee = selection1.valueGathered;\n            bestCoinSelection = selection1;\n            bestChangeOutput = selection1Change;\n        }\n        if (selection2 != null) {\n            BigInteger fee = selection2.valueGathered.subtract(checkNotNull(selection2Change).getValue());\n            if (lowestFee == null || fee.compareTo(lowestFee) < NUM) {\n                lowestFee = fee;\n                bestCoinSelection = selection2;\n                bestChangeOutput = selection2Change;\n            }\n        }\n        if (selection3 != null) {\n            if (lowestFee == null || selection3.valueGathered.compareTo(lowestFee) < NUM) {\n                bestCoinSelection = selection3;\n                bestChangeOutput = null;\n            }\n        }\n        for (TransactionOutput output : bestCoinSelection.gathered) req.tx.addInput(output);\n        totalInput = totalInput.add(bestCoinSelection.valueGathered);\n        req.tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);\n        if (bestChangeOutput != null) {\n            req.tx.addOutput(bestChangeOutput);\n            totalOutput = totalOutput.add(bestChangeOutput.getValue());\n            log.info(STR, bitcoinValueToFriendlyString(bestChangeOutput.getValue()));\n        }\n        try {\n            req.tx.signInputs(Transaction.SigHash.ALL, this, req.aesKey);\n        } catch (ScriptException e) {\n            throw new RuntimeException(e);\n        }\n        int size = req.tx.bitcoinSerialize().length;\n        if (size > Transaction.MAX_STANDARD_TX_SIZE) {\n            log.error(STR, size, Transaction.MAX_STANDARD_TX_SIZE);\n            return false;\n        }\n        req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);\n        req.completed = true;\n        req.fee = totalInput.subtract(totalOutput);\n        log.info(STR, req.tx.getHashAsString(), req.tx.getInputs().size());\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}",
    "label": 1,
    "rec": "@return whether or not the requested send is affordable."
  },
  {
    "id": 1127,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            return IgnitionEx.gridx(stash.get()).nodeLocalMap();\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1128,
    "type": "Return",
    "comment": "@return true - allow the request chain to continue in this default implementation",
    "code": "protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n    if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {\n        if (log.isTraceEnabled()) {\n            log.trace(STR);\n        }\n        return true;\n    }\n    for (String path : this.appliedPaths.keySet()) {\n        if (pathsMatch(path, request)) {\n            log.trace(STR, path);\n            Object config = this.appliedPaths.get(path);\n            return isFilterChainContinued(request, response, path, config);\n        }\n    }\n    return true;\n}",
    "label": 1,
    "rec": "@return {@code true} if the filter chain is allowed to continue to execute, {@code false} if a subclass has handled the request explicitly."
  },
  {
    "id": 1129,
    "type": "Return",
    "comment": "@return  true if success.",
    "code": "    private boolean waitCacheSize(IgniteCache<Integer, String> cache, int expSize, long timeout)\n        throws InterruptedException {\n        assert cache != null;\n        assert expSize > 0;\n        assert timeout >= 0;\n\n        long end = System.currentTimeMillis() + timeout;\n\n        while (cache.localSize() < expSize) {\n            Thread.sleep(50);\n\n            if (end - System.currentTimeMillis() <= 0)\n                break;\n        }\n\n        return cache.localSize() >= expSize;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1130,
    "type": "Return",
    "comment": "@return ES search request",
    "code": "public ActionRequestBuilder explain(String sql) throws SqlParseException {\n    SQLQueryExpr sqlExpr = toSqlExpr(sql);\n    Select select = new SqlParser().parseSelect(sqlExpr);\n    Query query = QueryFactory.create(client, select);\n    return query.explain();\n}",
    "label": 1,
    "rec": "@return ES request"
  },
  {
    "id": 1131,
    "type": "Return",
    "comment": "@return this",
    "code": "    public long limit() {\n        return limit;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1132,
    "type": "Return",
    "comment": "@return The project's build configurations.",
    "code": "public Map<String, BuildConfiguration> getBuildConfigurations() {\n    return this.buildConfigurations;\n}",
    "label": 1,
    "rec": "@return The project's build configurations indexed by name."
  },
  {
    "id": 1133,
    "type": "Return",
    "comment": "@return Task name or  null if not found.",
    "code": "    public String resolveTaskName(int taskNameHash) {\n        if (taskNameHash == 0)\n            return null;\n\n        assert ctx.security().enabled();\n\n        try {\n            return taskMetaCache().localPeek(\n                new GridTaskNameHashKey(taskNameHash), CachePeekModes.ONHEAP_ONLY, null);\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1134,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Collection<WhiteBalance> getSupportedWhiteBalance() {\n        return Collections.unmodifiableSet(supportedWhiteBalance);\n    }\n",
    "label": 1,
    "rec": "@return a collection of supported values."
  },
  {
    "id": 1135,
    "type": "Return",
    "comment": "@return Server instance.",
    "code": "    private GridNioServer<Message> resetNioServer() throws IgniteCheckedException {\n        if (boundTcpPort >= 0)\n            throw new IgniteCheckedException(\"Tcp NIO server was already created on port \" + boundTcpPort);\n\n        IgniteCheckedException lastEx = null;\n\n        // If configured TCP port is busy, find first available in range.\n        for (int port = locPort; port < locPort + locPortRange; port++) {\n            try {\n                MessageFactory msgFactory = new MessageFactory() {\n                    private MessageFactory impl;\n\n                    @Nullable @Override public Message create(byte type) {\n                        if (impl == null)\n                            impl = getSpiContext().messageFactory();\n\n                        assert impl != null;\n\n                        return impl.create(type);\n                    }\n                };\n\n                GridNioMessageReaderFactory readerFactory = new GridNioMessageReaderFactory() {\n                    private MessageFormatter formatter;\n\n                    @Override public MessageReader reader(GridNioSession ses, MessageFactory msgFactory)\n                        throws IgniteCheckedException {\n                        if (formatter == null)\n                            formatter = getSpiContext().messageFormatter();\n\n                        assert formatter != null;\n\n                        UUID rmtNodeId = ses.meta(NODE_ID_META);\n\n                        return rmtNodeId != null ? formatter.reader(rmtNodeId, msgFactory) : null;\n                    }\n                };\n\n                GridNioMessageWriterFactory writerFactory = new GridNioMessageWriterFactory() {\n                    private MessageFormatter formatter;\n\n                    @Override public MessageWriter writer(GridNioSession ses) throws IgniteCheckedException {\n                        if (formatter == null)\n                            formatter = getSpiContext().messageFormatter();\n\n                        assert formatter != null;\n\n                        UUID rmtNodeId = ses.meta(NODE_ID_META);\n\n                        return rmtNodeId != null ? formatter.writer(rmtNodeId) : null;\n                    }\n                };\n\n                GridDirectParser parser = new GridDirectParser(msgFactory, readerFactory);\n\n                IgnitePredicate<Message> skipRecoveryPred = new IgnitePredicate<Message>() {\n                    @Override public boolean apply(Message msg) {\n                        return msg instanceof RecoveryLastReceivedMessage;\n                    }\n                };\n\n                boolean clientMode = Boolean.TRUE.equals(ignite.configuration().isClientMode());\n\n                IgniteBiInClosure<GridNioSession, Integer> queueSizeMonitor =\n                    !clientMode && slowClientQueueLimit > 0 ?\n                    new CI2<GridNioSession, Integer>() {\n                        @Override public void apply(GridNioSession ses, Integer qSize) {\n                            checkClientQueueSize(ses, qSize);\n                        }\n                    } :\n                    null;\n\n                GridNioFilter[] filters;\n\n                if (isSslEnabled()) {\n                    GridNioSslFilter sslFilter =\n                        new GridNioSslFilter(ignite.configuration().getSslContextFactory().create(),\n                            true, ByteOrder.nativeOrder(), log);\n\n                    sslFilter.directMode(true);\n\n                    sslFilter.wantClientAuth(true);\n                    sslFilter.needClientAuth(true);\n\n                    filters = new GridNioFilter[] {\n                        new GridNioCodecFilter(parser, log, true),\n                        new GridConnectionBytesVerifyFilter(log),\n                        sslFilter\n                    };\n                }\n                else\n                    filters = new GridNioFilter[] {\n                        new GridNioCodecFilter(parser, log, true),\n                        new GridConnectionBytesVerifyFilter(log)\n                    };\n\n                GridNioServer<Message> srvr =\n                    GridNioServer.<Message>builder()\n                        .address(locHost)\n                        .port(port)\n                        .listener(srvLsnr)\n                        .logger(log)\n                        .selectorCount(selectorsCnt)\n                        .gridName(gridName)\n                        .tcpNoDelay(tcpNoDelay)\n                        .directBuffer(directBuf)\n                        .byteOrder(ByteOrder.nativeOrder())\n                        .socketSendBufferSize(sockSndBuf)\n                        .socketReceiveBufferSize(sockRcvBuf)\n                        .sendQueueLimit(msgQueueLimit)\n                        .directMode(true)\n                        .metricsListener(metricsLsnr)\n                        .writeTimeout(sockWriteTimeout)\n                        .filters(filters)\n                        .writerFactory(writerFactory)\n                        .skipRecoveryPredicate(skipRecoveryPred)\n                        .messageQueueSizeListener(queueSizeMonitor)\n                        .build();\n\n                boundTcpPort = port;\n\n                // Ack Port the TCP server was bound to.\n                if (log.isInfoEnabled())\n                    log.info(\"Successfully bound to TCP port [port=\" + boundTcpPort +\n                        \", locHost=\" + locHost + ']');\n\n                srvr.idleTimeout(idleConnTimeout);\n\n                return srvr;\n            }\n            catch (IgniteCheckedException e) {\n                if (X.hasCause(e, SSLException.class))\n                    throw new IgniteSpiException(\"Failed to create SSL context. SSL factory: \"\n                        + ignite.configuration().getSslContextFactory() + '.', e);\n\n                lastEx = e;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to bind to local port (will try next port within range) [port=\" + port +\n                        \", locHost=\" + locHost + ']');\n\n                onException(\"Failed to bind to local port (will try next port within range) [port=\" + port +\n                    \", locHost=\" + locHost + ']', e);\n            }\n        }\n\n        // If free port wasn't found.\n        throw new IgniteCheckedException(\"Failed to bind to any port within range [startPort=\" + locPort +\n            \", portRange=\" + locPortRange + \", locHost=\" + locHost + ']', lastEx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1136,
    "type": "Return",
    "comment": "@return true, if we have enabled metric manager from Azkaban exec server",
    "code": "public static boolean isAvailable() {\n    return isInstantiated() && isManagerEnabled;\n}",
    "label": 1,
    "rec": "@return true, if we have Instantiated and enabled metric manager from Azkaban exec server"
  },
  {
    "id": 1137,
    "type": "Return",
    "comment": "@return list of nodes that key replicates to",
    "code": "    public List<Integer> getReplicationNodeList(final byte[] key) {\n        return Utils.nodeListToNodeIdList(this.routingStrategy.routeRequest(key));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1138,
    "type": "Return",
    "comment": "@return The count",
    "code": "public int getRegisteredResourceRequestCount(K key) {\n    int rc = NUM;\n    if (!requestQueueMap.containsKey(key)) {\n        return rc;\n    }\n    try {\n        Queue<AsyncResourceRequest<V>> requestQueue = getRequestQueueForExistingKey(key);\n        rc = requestQueue.size();\n    } catch (IllegalArgumentException iae) {\n        logger.debug(STR, iae);\n    }\n    return rc;\n}",
    "label": 1,
    "rec": "@return The count of queued resource requests. Returns 0 if no queue exists for given key."
  },
  {
    "id": 1139,
    "type": "Return",
    "comment": "@return data from memory",
    "code": "    private Observable<Parsed> lazyCache(@Nonnull final Key key) {\n        return Observable\n                .defer(new Callable<ObservableSource<? extends Parsed>>() {\n                    @Override\n                    public ObservableSource<? extends Parsed> call() {\n                        return cache(key);\n                    }\n                })\n                .onErrorResumeNext(new OnErrorResumeWithEmpty<Parsed>());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1140,
    "type": "Return",
    "comment": "@return returns cookie value (or null if cookie with given key does not exist)",
    "code": "public Optional<String> readCookie(String key) {\n    return Arrays.stream(request.getCookies()).filter(c -> key.equals(c.getName())).map(Cookie::getValue).findAny();\n}",
    "label": 1,
    "rec": "@return returns cookie value"
  },
  {
    "id": 1141,
    "type": "Return",
    "comment": "@return Job contexts for failed over jobs.",
    "code": "        public Set<ComputeJobContext> getFailedOverJobs() {\n            return failedOverJobs;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1142,
    "type": "Return",
    "comment": "@return a map of dependency variable names to maven dependency URLs.",
    "code": "@NotNull\npublic List<String> getDependencies() {\n    final List<String> dependencyList = Lists.newLinkedList();\n    NodeList dependencies = myDocument.getElementsByTagName(TAG_DEPENDENCY);\n    for (int index = NUM, max = dependencies.getLength(); index < max; index++) {\n        Element element = (Element) dependencies.item(index);\n        String dependencyName = element.getAttribute(ATTR_NAME);\n        String dependencyVersion = element.getAttribute(ATTR_VERSION);\n        if (dependencyName.equals(SUPPORT_ID) || dependencyName.equals(APP_COMPAT_ID) || dependencyName.equals(GRID_LAYOUT_ID)) {\n            dependencyList.add(getLibraryUrl(dependencyName, dependencyVersion));\n        }\n    }\n    return dependencyList;\n}",
    "label": 1,
    "rec": "@return a list of maven dependency URLs"
  },
  {
    "id": 1143,
    "type": "Return",
    "comment": "@return true if the wait for free space was interrupted prematurely",
    "code": "  private boolean ensureFreeSpace(long writeStartPos, long writeEndPos, boolean logDebugEnabled)\n  {\n    if (empty()) return false;\n\n    boolean interrupted = false;\n    if (QueuePolicy.BLOCK_ON_WRITE == _queueingPolicy)\n    {\n      interrupted = waitForReadEventsFreeSpace(logDebugEnabled, writeStartPos, writeEndPos);\n    } else {\n      freeUpSpaceForReadEvents(logDebugEnabled, writeStartPos, writeEndPos);\n    }\n    if (logDebugEnabled)\n      _log.debug(\"ensureFreeSpace: writeStart:\" + _bufferPositionParser.toString(writeStartPos) +\n                 \" writeEnd:\" + _bufferPositionParser.toString(writeEndPos) +\n                 \"; head:\" + _head + \"; tail:\" + _tail +\n                 \"; interrupted:\" + interrupted);\n    assert interrupted || !overwritesHead(writeStartPos, writeEndPos);\n\n    return interrupted;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1144,
    "type": "Return",
    "comment": "@return instanse of clazz class, new Class is defined in the same class loader",
    "code": "public static Factory enhance(Class cls, MethodInterceptor ih) {\n    return (Factory) enhanceHelper(cls.isInterface() ? null : cls, cls.isInterface() ? new Class[] { cls } : null, ih, cls.getClassLoader(), null, null);\n}",
    "label": 1,
    "rec": "@return instance of supplied Class; new Class is defined in the same class loader"
  },
  {
    "id": 1145,
    "type": "Return",
    "comment": "@return Task local class loader id.",
    "code": "    public IgniteUuid getClassLoaderId() {\n        return clsLdrId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1146,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forJavaClassPath() {\n    Collection<URL> urls = new ArrayList<URL>();\n    String javaClassPath = System.getProperty(STR);\n    if (javaClassPath != null) {\n        for (String path : javaClassPath.split(File.pathSeparator)) {\n            try {\n                urls.add(new File(path).toURI().toURL());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return distinctUrls(urls);\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 1147,
    "type": "Return",
    "comment": "@return Whether or not REST is enabled.",
    "code": "    private boolean isRestEnabled() {\n        assert cfg != null;\n\n        return cfg.getClientConnectionConfiguration() != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1148,
    "type": "Return",
    "comment": "@return this array",
    "code": "public int removeAll(long... values) {\n    _check();\n    int _size = size;\n    if (values != null && values.length > NUM) {\n        for (long v : values) {\n            boolean rem = true;\n            while (rem) {\n                rem = _remove(binarySearch(v));\n            }\n        }\n    }\n    return _size - size;\n}",
    "label": 1,
    "rec": "@return the number of removed items"
  },
  {
    "id": 1149,
    "type": "Return",
    "comment": "@return Managers present in both, DHT and Near caches.",
    "code": "    private Collection<GridCacheManager> dhtExcludes(GridCacheContext ctx) {\n        if (ctx.config().getCacheMode() == LOCAL || !isNearEnabled(ctx))\n            return Collections.emptyList();\n        else\n            return F.asList(ctx.queries(), ctx.continuousQueries(), ctx.store(), ctx.offheap(), ctx.ttl());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1150,
    "type": "Return",
    "comment": "@return An array of <code>HGHandle</code>s of all the links pointing to this atom. The returned array may have 0 elements, but it will never be <code>null</code>.",
    "code": "public IncidenceSet getIncidenceSet(HGHandle handle) {\n    return cache.getIncidenceCache().get(getPersistentHandle(handle));\n}",
    "label": 1,
    "rec": "@return The atom's <code>IncidenceSet</code>. The returned set may have 0 elements, but it will never be <code>null</code>."
  },
  {
    "id": 1151,
    "type": "Return",
    "comment": "@return edited issue",
    "code": "    public Issue editIssue(Repo repository, int issueNumber, EditIssueRequestDTO editIssueRequestDTO) throws IOException {\n        IssueInfo issueInfo = new IssueInfo(InfoUtils.createRepoInfo(repository));\n        issueInfo.num = issueNumber;\n        return addIssue(repository, new EditIssueClient(issueInfo, editIssueRequestDTO).observable().toBlocking().first());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1152,
    "type": "Return",
    "comment": "@return the fully qualified name of the class corresponding to this type.",
    "code": "public String getClassName() {\n    switch(sort) {\n        case VOID:\n            return STR;\n        case BOOLEAN:\n            return STR;\n        case CHAR:\n            return STR;\n        case BYTE:\n            return STR;\n        case SHORT:\n            return STR;\n        case INT:\n            return STR;\n        case FLOAT:\n            return STR;\n        case LONG:\n            return STR;\n        case DOUBLE:\n            return STR;\n        case ARRAY:\n            StringBuilder sb = new StringBuilder(getElementType().getClassName());\n            for (int i = getDimensions(); i > NUM; --i) {\n                sb.append(STR);\n            }\n            return sb.toString();\n        case OBJECT:\n            return new String(buf, off, len).replace(STR, STR);\n        default:\n            return null;\n    }\n}",
    "label": 1,
    "rec": "@return the binary name of the class corresponding to this type."
  },
  {
    "id": 1153,
    "type": "Return",
    "comment": "@return Grid configuration used for starting of grid.",
    "code": "    protected IgniteConfiguration getConfiguration(String gridName, GridTestResources rsrcs) throws Exception {\n        IgniteConfiguration cfg = new IgniteConfiguration();\n\n        cfg.setGridName(gridName);\n        cfg.setGridLogger(rsrcs.getLogger());\n        cfg.setMarshaller(rsrcs.getMarshaller());\n        cfg.setNodeId(rsrcs.getNodeId());\n        cfg.setGridGainHome(rsrcs.getGridgainHome());\n        cfg.setMBeanServer(rsrcs.getMBeanServer());\n        cfg.setPeerClassLoadingEnabled(true);\n        cfg.setMetricsLogFrequency(0);\n\n        GridTcpCommunicationSpi commSpi = new GridTcpCommunicationSpi();\n\n        commSpi.setLocalPort(GridTestUtils.getNextCommPort(getClass()));\n        commSpi.setTcpNoDelay(true);\n\n        cfg.setCommunicationSpi(commSpi);\n\n        GridTcpDiscoverySpi discoSpi = new GridTcpDiscoverySpi();\n\n        if (isDebug()) {\n            discoSpi.setMaxMissedHeartbeats(Integer.MAX_VALUE);\n            cfg.setNetworkTimeout(Long.MAX_VALUE);\n        }\n        else {\n            // Set network timeout to 10 sec to avoid unexpected p2p class loading errors.\n            cfg.setNetworkTimeout(10000);\n\n            // Increase max missed heartbeats to avoid unexpected node fails.\n            discoSpi.setMaxMissedHeartbeats(30);\n        }\n\n        // Set heartbeat interval to 1 second to speed up tests.\n        discoSpi.setHeartbeatFrequency(1000);\n\n        String mcastAddr = GridTestUtils.getNextMulticastGroup(getClass());\n\n        if (!F.isEmpty(mcastAddr)) {\n            GridTcpDiscoveryMulticastIpFinder ipFinder = new GridTcpDiscoveryMulticastIpFinder();\n\n            ipFinder.setMulticastGroup(mcastAddr);\n            ipFinder.setMulticastPort(GridTestUtils.getNextMulticastPort(getClass()));\n\n            discoSpi.setIpFinder(ipFinder);\n        }\n\n        cfg.setDiscoverySpi(discoSpi);\n\n        GridSharedFsCheckpointSpi cpSpi = new GridSharedFsCheckpointSpi();\n\n        Collection<String> paths = new ArrayList<>();\n\n        paths.add(getDefaultCheckpointPath(cfg.getMarshaller()));\n\n        cpSpi.setDirectoryPaths(paths);\n\n        cfg.setCheckpointSpi(cpSpi);\n\n        cfg.setRestEnabled(false);\n\n        cfg.setIncludeEventTypes(GridEventType.EVTS_ALL);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1154,
    "type": "Return",
    "comment": "@return the default directory where to store the database",
    "code": "public String getDatabaseStorageDirectory() {\n    File externalStorage;\n    externalStorage = Environment.getExternalStorageDirectory();\n    if (externalStorage == null || !externalStorage.exists() || !externalStorage.isDirectory() || !externalStorage.canWrite()) {\n        return getContext().getFilesDir().getAbsolutePath();\n    }\n    File defaultFolder = new File(externalStorage + File.separator + getContext().getPackageName());\n    if (!defaultFolder.exists()) {\n        defaultFolder = new File(externalStorage + STR);\n        if (!defaultFolder.exists()) {\n            if (!defaultFolder.mkdirs()) {\n                return getContext().getFilesDir().getAbsolutePath();\n            }\n        }\n    }\n    String databasePath;\n    if (defaultFolder.getAbsoluteFile().exists()) {\n        databasePath = defaultFolder.toString();\n    } else {\n        String internalFolder;\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) {\n            internalFolder = getContext().getApplicationInfo().dataDir;\n        } else {\n            internalFolder = STR + getContext().getApplicationContext().getPackageName();\n        }\n        internalFolder += STR;\n        databasePath = internalFolder;\n    }\n    return databasePath;\n}",
    "label": 1,
    "rec": "@return the default database directory"
  },
  {
    "id": 1155,
    "type": "Return",
    "comment": "@return array of value chache classes",
    "code": "    public static Class[] valueClasses() {\n        return valClasses;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1156,
    "type": "Return",
    "comment": "@return the address of the spin lock",
    "code": "public static SpinLock allocateSpinLock() {\n    long address = allocateAlignedMemory(UnsafeAdapter.LONG_SIZE);\n    putLong(address, NO_LOCK);\n    return new MemSpinLock(address);\n}",
    "label": 1,
    "rec": "@return the spin lock"
  },
  {
    "id": 1157,
    "type": "Return",
    "comment": "@return this image getter",
    "code": "    public HttpImageGetter bind(final TextView view, final String html, final Object id) {\n        view.setText(HtmlUtils.encode(html, loading));\n        view.setTag(id);\n        new RoboAsyncTask<CharSequence>(context) {\n\n            public CharSequence call() throws Exception {\n                if (html.indexOf(\"<img\") != -1)\n                    return HtmlUtils.encode(html, HttpImageGetter.this);\n                else\n                    return null;\n            }\n\n            protected void onSuccess(CharSequence html) throws Exception {\n                if (html == null)\n                    return;\n                if (!id.equals(view.getTag()))\n                    return;\n                view.setText(html);\n                view.setTag(null);\n            }\n        }.execute();\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1158,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Collection<Size> getSupportedPictureSizes() {\n        return Collections.unmodifiableSet(supportedPictureSizes);\n    }\n",
    "label": 1,
    "rec": "@return a collection of supported values."
  },
  {
    "id": 1159,
    "type": "Return",
    "comment": "@return Multi bulk reply",
    "code": "    public Set<String> keys(final String pattern) {\n        runChecks();\n        client.keys(pattern);\n        return BuilderFactory.STRING_SET\n                .build(client.getBinaryMultiBulkReply());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1160,
    "type": "Return",
    "comment": "@return Ordered map of parsed query string parameters.",
    "code": "public static Multimap<String, String> parse(final String input) {\n    checkNotNull(input);\n    Multimap<String, String> result = LinkedHashMultimap.create();\n    String[] fields = input.split(FIELD_SEPARATOR);\n    for (String field : fields) {\n        String key, value;\n        int i = field.indexOf(VALUE_SEPARATOR);\n        if (i == -NUM) {\n            key = field;\n            value = null;\n        } else {\n            key = field.substring(NUM, i);\n            value = field.substring(i + NUM, field.length());\n        }\n        result.put(key, value);\n    }\n    return result;\n}",
    "label": 1,
    "rec": "@return Ordered multimap of parsed query string parameters."
  },
  {
    "id": 1161,
    "type": "Return",
    "comment": "@return null or default values",
    "code": "    public T capture() {\n        Mockito.argThat(capturingMatcher);\n        return defaultValue(clazz);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1162,
    "type": "Return",
    "comment": "@return EnemyBot with lowest energy",
    "code": "public EnemyBot pickByLowestEnergy() {\n    List<EnemyBot> enemies = new ArrayList<EnemyBot>(_enemyTable.values());\n    Collections.sort(enemies);\n    for (EnemyBot enemy : enemies) {\n        if (_debug >= NUM)\n            System.out.println(STR + enemy.getName() + STR + enemy.getEnergy());\n    }\n    if (enemies.size() > NUM) {\n        return enemies.get(NUM);\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return EnemyBot with lowest energy, or null if no known enemies"
  },
  {
    "id": 1163,
    "type": "Return",
    "comment": "@return Size.",
    "code": "    private long size(String cacheName, IgniteKernal g) throws IgniteCheckedException {\n        if (offheap)\n            return ((IgniteKernal)g).cache(cacheName).offHeapEntriesCount();\n\n        return g.context().swap().swapSize(swapSpaceName(cacheName, g));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1164,
    "type": "Return",
    "comment": "@return Frame that can be load-balanced (and shuffled), depending on whether force_load_balance and shuffle_training_data are set",
    "code": "  private Frame reBalance(final Frame fr, long seed, boolean local) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 1165,
    "type": "Return",
    "comment": "@return Gaussian RBF functions with parameter learned from data.",
    "code": "    public static RBF<double[]>[] fit(double[][] x, int k, double r) {\n        if (r <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid scaling parameter: \" + r);\n        }\n\n        KMeans kmeans = new KMeans(x, k, 10);\n        double[][] centers = kmeans.centroids();\n\n        EuclideanDistance distance = new EuclideanDistance();\n        double[] width = estimateWidth(x, kmeans.getClusterLabel(), centers, kmeans.getClusterSize(), distance, r);\n        GaussianRadialBasis[] basis = gaussian(width);\n\n        return of(centers, basis, distance);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1166,
    "type": "Return",
    "comment": "@return a {@link PagedCollection}.",
    "code": "public ResourceCollection<Transaction> search(String query, int pageNumber) {\n    String queryString = new QueryString().append(STR, query).append(STR, pageNumber).toString();\n    NodeWrapper response = http.get(STR + queryString);\n    return new ResourceCollection<Transaction>(new TransactionPager(this, query), response, Transaction.class);\n}",
    "label": 1,
    "rec": "@return a {@link ResourceCollection}."
  },
  {
    "id": 1167,
    "type": "Return",
    "comment": "@return Future.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> finishColocatedLocal(boolean commit, GridNearTxLocal<K, V> tx) {\n        try {\n            if (commit) {\n                if (!tx.markFinalizing(USER_FINISH)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Will not finish transaction (it is handled by another thread): \" + tx);\n\n                    return null;\n                }\n\n                return tx.commitAsyncLocal();\n            }\n            else\n                return tx.rollbackAsyncLocal();\n        }\n        catch (Throwable e) {\n            U.error(log, \"Failed completing transaction [commit=\" + commit + \", tx=\" + tx + ']', e);\n\n            if (tx != null)\n                return tx.rollbackAsync();\n\n            return new GridFinishedFuture<>(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1168,
    "type": "Return",
    "comment": "@return the URL for the store page",
    "code": "public String getStoreUrl() {\n    return STR + this.appId;\n}",
    "label": 1,
    "rec": "@return This game's store page"
  },
  {
    "id": 1169,
    "type": "Return",
    "comment": "@return  True if address is reachable.",
    "code": "    public static boolean reachableByPing(InetAddress addr, int reachTimeout) {\n        try {\n            if (addr.isReachable(reachTimeout))\n                return true;\n\n            String cmd = String.format(\"ping -%s 1 %s\", U.isWindows() ? \"n\" : \"c\", addr.getHostAddress());\n\n            Process myProc = Runtime.getRuntime().exec(cmd);\n\n            myProc.waitFor();\n\n            return myProc.exitValue() == 0;\n        }\n        catch (IOException ignore) {\n            return false;\n        }\n        catch (InterruptedException ignored) {\n            Thread.currentThread().interrupt();\n\n            return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1170,
    "type": "Return",
    "comment": "@return SortedSet the looked up or create queue matching the requested type",
    "code": "    private HandlerList getEventListeners(Class<? extends Event> type) {\n        try {\n            Method method = getRegistrationClass(type).getDeclaredMethod(\"getHandlerList\");\n            method.setAccessible(true);\n            return (HandlerList)method.invoke(null);\n        } catch (Exception e) {\n            throw new IllegalPluginAccessException(e.toString());\n        }\n    }\n",
    "label": 1,
    "rec": "@return HandlerList The list of registered handlers for the event."
  },
  {
    "id": 1171,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte anyByte() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1172,
    "type": "Return",
    "comment": "@return The intersection of this {@link Range} and r",
    "code": "public boolean intersection(Range r, Range dest) {\n    if (intersects(r)) {\n        dest.set(Math.max(min, r.min), Math.min(max, r.max));\n        return true;\n    }\n    return false;\n}",
    "label": 1,
    "rec": "@return <code>true</code> if the intersection exists"
  },
  {
    "id": 1173,
    "type": "Return",
    "comment": "@return Latest topology snapshot.",
    "code": "        private Collection<ClusterNode> updateTopologyHistory(long topVer) {\n            GridTcpClientDiscoverySpi.this.topVer = topVer;\n\n            Collection<ClusterNode> allNodes = allNodes();\n\n            if (!topHist.containsKey(topVer)) {\n                assert topHist.isEmpty() || topHist.lastKey() == topVer - 1 :\n                    \"lastVer=\" + topHist.lastKey() + \", newVer=\" + topVer;\n\n                topHist.put(topVer, allNodes);\n\n                if (topHist.size() > topHistSize)\n                    topHist.pollFirstEntry();\n\n                assert topHist.lastKey() == topVer;\n                assert topHist.size() <= topHistSize;\n            }\n\n            return allNodes;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1174,
    "type": "Return",
    "comment": "@return the array of source vertices names",
    "code": "public List<String> getSourceVertices() {\n    return Collections.unmodifiableList(Arrays.asList(sources));\n}",
    "label": 1,
    "rec": "@return the array of source vertices (or source vertex group) names"
  },
  {
    "id": 1175,
    "type": "Return",
    "comment": "@return Conflict expire time.",
    "code": "    public long conflictExpireTime(int idx) {\n        if (conflictExpireTimes != null) {\n            assert idx >= 0 && idx < conflictExpireTimes.size();\n\n            return conflictExpireTimes.get(idx);\n        }\n\n        return CU.EXPIRE_TIME_CALCULATE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1176,
    "type": "Return",
    "comment": "@return an int array, containing due, reps, time, currentDeckdue",
    "code": "public static int[] getWidgetSmallStatus(Context context) {\n    openDBIfClosed(context);\n    Cursor cursor = null;\n    int due = NUM;\n    int eta = NUM;\n    int currentDeckdue = NUM;\n    int time = NUM;\n    String currentDeck = PrefSettings.getSharedPrefs(context).getString(STR, STR);\n    try {\n        cursor = mMetaDb.query(STR, new String[] { STR, STR, STR, STR, STR, STR }, null, null, null, null, null);\n        while (cursor.moveToNext()) {\n            int d = cursor.getInt(NUM) + cursor.getInt(NUM) + cursor.getInt(NUM);\n            due += d;\n            time += cursor.getInt(NUM);\n            eta += cursor.getInt(NUM);\n            if (currentDeck.equals(cursor.getString(NUM))) {\n                currentDeckdue = d;\n            }\n        }\n    } catch (SQLiteException e) {\n        Log.e(AnkiDroidApp.TAG, STR, e);\n    } finally {\n        if (cursor != null && !cursor.isClosed()) {\n            cursor.close();\n        }\n    }\n    return new int[] { due, time, eta, currentDeckdue };\n}",
    "label": 1,
    "rec": "@return an int array, containing due, time, eta, currentDeckdue"
  },
  {
    "id": 1177,
    "type": "Return",
    "comment": "@return a  KeyTemplate containing  HmacKey.",
    "code": "  public static KeyTemplate createHmacKeyTemplate(int keySize, int tagSize, HashType hash)\n      throws Exception {\n    HmacParams params = HmacParams.newBuilder()\n        .setHash(HashType.SHA256)\n        .setTagSize(tagSize)\n        .build();\n    HmacKeyFormat format = HmacKeyFormat.newBuilder()\n        .setParams(params)\n        .setKeySize(keySize)\n        .build();\n    return KeyTemplate.newBuilder()\n        .setValue(format.toByteString())\n        .setTypeUrl(HmacKeyManager.TYPE_URL)\n        .build();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1178,
    "type": "Return",
    "comment": "@return whether this view is in the ative page of the active perspective",
    "code": "protected boolean isActive() {\n    return fIsActive && getViewer() != null;\n}",
    "label": 1,
    "rec": "@return whether this view is in the active page of the active perspective and has been fully created."
  },
  {
    "id": 1179,
    "type": "Return",
    "comment": "@return Range of keys.",
    "code": "    private Set<String> rangeKeys(int fromIncl, int toExcl) {\n        return new HashSet<>(F.transform(F.range(fromIncl, toExcl), new C1<Integer, String>() {\n            @Override public String apply(Integer i) {\n                return \"key\" + i;\n            }\n        }));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1180,
    "type": "Return",
    "comment": "@return An URLEncoded (UTF-8) string with request parameters, e.g. \"parameter1=value1&parameter2=value1&parameter2=value2\"",
    "code": "public static String getParametersStringFromRequest(HttpServletRequest request) {\n    StringBuilder parametersString = new StringBuilder();\n    Map parameters = request.getParameterMap();\n    if (parameters != null && !parameters.isEmpty()) {\n        Set<String> parametersSet = parameters.keySet();\n        for (Iterator iterator = parametersSet.iterator(); iterator.hasNext(); ) {\n            String key = (String) iterator.next();\n            String[] values = request.getParameterValues(key);\n            if (values != null && values.length > NUM) {\n                for (int j = NUM; j < values.length; j++) {\n                    parametersString.append(key).append(STR).append(values[j]);\n                    if (j != (values.length - NUM)) {\n                        parametersString.append(STR);\n                    }\n                }\n            }\n        }\n    }\n    return parametersString.toString();\n}",
    "label": 1,
    "rec": "@return String with request parameters, e.g. \"parameter1=value1&parameter2=value1&parameter2=value2\""
  },
  {
    "id": 1181,
    "type": "Return",
    "comment": "@return Execution request.",
    "code": "    private MessageAdapter createExecutionRequest(GridStreamerExecutionBatch batch)\n        throws IgniteCheckedException {\n        boolean depEnabled = ctx.deploy().enabled();\n\n        byte[] batchBytes = ctx.config().getMarshaller().marshal(batch);\n\n        if (!depEnabled)\n            return new GridStreamerExecutionRequest(true, batchBytes, null, null, null, null, null);\n        else {\n            GridPeerDeployAware pda = new StreamerPda(batch.events());\n\n            GridDeployment dep = ctx.deploy().deploy(pda.deployClass(), pda.classLoader());\n\n            if (dep == null)\n                throw new IgniteCheckedException(\"Failed to get deployment for batch request [batch=\" + batch +\n                    \", pda=\" + pda + ']');\n\n            return new GridStreamerExecutionRequest(\n                false,\n                batchBytes,\n                dep.deployMode(),\n                dep.sampleClassName(),\n                dep.userVersion(),\n                dep.participants(),\n                dep.classLoaderId()\n            );\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1182,
    "type": "Return",
    "comment": "@return Maximum number of entries or null",
    "code": "    private Optional<Integer> readMaxEntriesRequestJournal(ServletContext context) {\n        String str = context.getInitParameter(\"maxEntriesRequestJournal\");\n        if(str == null) {\n            return Optional.absent();\n        }\n        return Optional.of(Integer.parseInt(str));\n    }\n",
    "label": 1,
    "rec": "@return Maximum number of entries or absent"
  },
  {
    "id": 1183,
    "type": "Return",
    "comment": "@return  true if protocol  p available for  node,  false otherwise.",
    "code": "    public static boolean restAvailable(GridClientNode node, GridClientProtocol p) {\n        return !node.availableAddresses(p, false).isEmpty();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1184,
    "type": "Return",
    "comment": "@return Instance of {@link IdeLevel2Dependencies} from test artifact, or {@code null} if current module has no test artifact.",
    "code": "@Nullable\npublic IdeDependencies getSelectedAndroidTestCompileDependencies() {\n    IdeAndroidArtifact androidTestArtifact = getSelectedVariant().getAndroidTestArtifact();\n    if (androidTestArtifact == null) {\n        return null;\n    }\n    return androidTestArtifact.getLevel2Dependencies();\n}",
    "label": 1,
    "rec": "@return Instance of {@link IdeDependencies} from test artifact, or {@code null} if current module has no test artifact."
  },
  {
    "id": 1185,
    "type": "Return",
    "comment": "@return gist or null if event doesn't apply",
    "code": "    public Repository getRepository(final Event event) {\n        if (event == null)\n            return null;\n\n        EventPayload payload = event.getPayload();\n        if (payload == null)\n            return null;\n\n        String type = event.getType();\n        if (TYPE_FORK.equals(type))\n            return ((ForkPayload) payload).getForkee();\n        if (TYPE_CREATE.equals(type) || TYPE_WATCH.equals(type))\n            return getRepository(event.getRepo(), event.getActor());\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1186,
    "type": "Return",
    "comment": "@return text encoded within the Data Matrix Code",
    "code": "  public DecoderResult decode(boolean[][] image) throws ReaderException {\n    int dimension = image.length;\n    BitMatrix bits = new BitMatrix(dimension);\n    for (int i = 0; i < dimension; i++) {\n      for (int j = 0; j < dimension; j++) {\n        if (image[i][j]) {\n          bits.set(i, j);\n        }\n      }\n    }\n    return decode(bits);\n  }\n",
    "label": 1,
    "rec": "@return text and bytes encoded within the Data Matrix Code"
  },
  {
    "id": 1187,
    "type": "Return",
    "comment": "@return Server instance.",
    "code": "    private GridNioServer<MessageAdapter> resetNioServer() throws IgniteCheckedException {\n        if (boundTcpPort >= 0)\n            throw new IgniteCheckedException(\"Tcp NIO server was already created on port \" + boundTcpPort);\n\n        IgniteCheckedException lastEx = null;\n\n        // If configured TCP port is busy, find first available in range.\n        for (int port = locPort; port < locPort + locPortRange; port++) {\n            try {\n                GridNioServer<MessageAdapter> srvr =\n                    GridNioServer.<MessageAdapter>builder()\n                        .address(locHost)\n                        .port(port)\n                        .listener(srvLsnr)\n                        .logger(log)\n                        .selectorCount(selectorsCnt)\n                        .gridName(gridName)\n                        .tcpNoDelay(tcpNoDelay)\n                        .directBuffer(directBuf)\n                        .byteOrder(ByteOrder.nativeOrder())\n                        .socketSendBufferSize(sockSndBuf)\n                        .socketReceiveBufferSize(sockRcvBuf)\n                        .sendQueueLimit(msgQueueLimit)\n                        .directMode(true)\n                        .metricsListener(metricsLsnr)\n                        .writeTimeout(sockWriteTimeout)\n                        .filters(new GridNioCodecFilter(new GridDirectParser(this), log, true),\n                            new GridConnectionBytesVerifyFilter(log))\n                        .messageWriterFactory(getSpiContext().messageWriterFactory())\n                        .build();\n\n                boundTcpPort = port;\n\n                // Ack Port the TCP server was bound to.\n                if (log.isInfoEnabled())\n                    log.info(\"Successfully bound to TCP port [port=\" + boundTcpPort +\n                        \", locHost=\" + locHost + ']');\n\n                srvr.idleTimeout(idleConnTimeout);\n\n                return srvr;\n            }\n            catch (IgniteCheckedException e) {\n                lastEx = e;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to bind to local port (will try next port within range) [port=\" + port +\n                        \", locHost=\" + locHost + ']');\n            }\n        }\n\n        // If free port wasn't found.\n        throw new IgniteCheckedException(\"Failed to bind to any port within range [startPort=\" + locPort +\n            \", portRange=\" + locPortRange + \", locHost=\" + locHost + ']', lastEx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1188,
    "type": "Return",
    "comment": "@return a {@link AndroidLifecycle} against this lifecycle.",
    "code": "public static AndroidLifecycleScopeProvider from(Lifecycle lifecycle) {\n    return new AndroidLifecycleScopeProvider(lifecycle);\n}",
    "label": 1,
    "rec": "@return a {@link AndroidLifecycleScopeProvider} against this lifecycle."
  },
  {
    "id": 1189,
    "type": "Return",
    "comment": "@return The tier of this potion",
    "code": "    public Tier getTier() {\n        return level == 2 ? Tier.TWO : Tier.ONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1190,
    "type": "Return",
    "comment": "@return the new double array backed by a buffer or an array",
    "code": "    public static DoubleIndexer create(final DoublePointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new DoubleRawIndexer(pointer, sizes, strides)\n                                             : new DoubleBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            double[] array = new double[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new DoubleArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new double indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 1191,
    "type": "Return",
    "comment": "@return true if the self-loops must be displayed in the preview",
    "code": "\tpublic boolean showSelfLoops() {\n\t\tPreviewController controller = Lookup.getDefault().lookup(PreviewController.class);\n\t\treturn controller.getSelfLoopSupervisor().getShowFlag();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1192,
    "type": "Return",
    "comment": "@return a file pointing at the archive for the given coordinate",
    "code": "@Nullable\npublic static File getArchiveForCoordinate(MavenCoordinate mavenCoordinate) {\n    SdkManager sdk = AndroidSdkUtils.tryToChooseAndroidSdk();\n    if (sdk == null) {\n        return null;\n    }\n    String sdkLocation = sdk.getLocation();\n    String artifactId = mavenCoordinate.getArtifactId();\n    String revision = mavenCoordinate.getFullRevision();\n    RepositoryLibrary library = EXTRAS_REPOSITORY.get(artifactId);\n    File path = new File(String.format(library.basePath, sdkLocation, library.id));\n    String revisionPath = String.format(MAVEN_REVISION_PATH, library.id, revision) + library.archiveExtension;\n    return new File(path, revisionPath);\n}",
    "label": 1,
    "rec": "@return a file pointing at the archive for the given coordinate or null if no SDK is configured"
  },
  {
    "id": 1193,
    "type": "Return",
    "comment": "@return the related Processing font",
    "code": "    private PFont getPFont(Font font) {\n        String fontName=font.getName();\n        if (fontMap.containsKey(fontName)) {\n            return fontMap.get(fontName);\n        }\n\n        PFont pFont = createFont(font);\n        fontMap.put(fontName, pFont);\n        return pFont;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1194,
    "type": "Return",
    "comment": "@return an empty {@link FastSet} if the method param was <code>null</code> or the unmodified method param.",
    "code": "public static Collection<Refreshable> buildRefreshed(Collection<Refreshable> currentAlreadyRefreshed) {\n    return currentAlreadyRefreshed == null ? new HashSet<Refreshable>(NUM) : currentAlreadyRefreshed;\n}",
    "label": 1,
    "rec": "@return an empty {@link Collection} if the method param was <code>null</code> or the unmodified method param."
  },
  {
    "id": 1195,
    "type": "Return",
    "comment": "@return URLs that point to potential locations of the library",
    "code": "    public static URL[] findLibrary(Class cls, ClassProperties properties, String libnameversion, boolean pathsFirst) {\n        if (libnameversion.trim().endsWith(\"#\")) {\n            return new URL[0];\n        }\n        String[] split = libnameversion.split(\"#\");\n        String[] s = split[0].split(\"@\");\n        String[] s2 = (split.length > 1 ? split[1] : split[0]).split(\"@\");\n        String libname = s[0];\n        String libname2 = s2[0];\n        String version = s.length > 1 ? s[s.length-1] : \"\";\n        String version2 = s2.length > 1 ? s2[s2.length-1] : \"\";\n\n        // If we do not already have the native library file ...\n        String subdir = properties.getProperty(\"platform\") + '/';\n        String prefix = properties.getProperty(\"platform.library.prefix\", \"\");\n        String suffix = properties.getProperty(\"platform.library.suffix\", \"\");\n        String[] styles = {\n            prefix + libname + suffix + version, // Linux style\n            prefix + libname + version + suffix, // Mac OS X style\n            prefix + libname + suffix            // without version\n        };\n        String[] styles2 = {\n            prefix + libname2 + suffix + version2, // Linux style\n            prefix + libname2 + version2 + suffix, // Mac OS X style\n            prefix + libname2 + suffix             // without version\n        };\n\n        String[] suffixes = properties.get(\"platform.library.suffix\").toArray(new String[0]);\n        if (suffixes.length > 1) {\n            styles = new String[3 * suffixes.length];\n            styles2 = new String[3 * suffixes.length];\n            for (int i = 0; i < suffixes.length; i++) {\n                styles[3 * i    ] = prefix + libname + suffixes[i] + version; // Linux style\n                styles[3 * i + 1] = prefix + libname + version + suffixes[i]; // Mac OS X style\n                styles[3 * i + 2] = prefix + libname + suffixes[i];           // without version\n                styles2[3 * i    ] = prefix + libname2 + suffixes[i] + version2; // Linux style\n                styles2[3 * i + 1] = prefix + libname2 + version2 + suffixes[i]; // Mac OS X style\n                styles2[3 * i + 2] = prefix + libname2 + suffixes[i];            // without version\n            }\n        }\n\n        List<String> paths = new ArrayList<String>();\n        paths.addAll(properties.get(\"platform.preloadpath\"));\n        paths.addAll(properties.get(\"platform.linkpath\"));\n        String libpath = System.getProperty(\"java.library.path\", \"\");\n        if (libpath.length() > 0) {\n            paths.addAll(Arrays.asList(libpath.split(File.pathSeparator)));\n        }\n        ArrayList<URL> urls = new ArrayList<URL>(styles.length * (1 + paths.size()));\n        for (int i = 0; cls != null && i < styles.length; i++) {\n            // ... then find it from in our resources ...\n            URL u = cls.getResource(subdir + styles[i]);\n            if (u != null) {\n                if (!styles[i].equals(styles2[i])) {\n                    try {\n                        u = new URL(u + \"#\" + styles2[i]);\n                    } catch (MalformedURLException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                urls.add(u);\n            }\n        }\n        // ... and in case of bad resources search the paths last, or first on user request.\n        int k = pathsFirst ? 0 : urls.size();\n        for (int i = 0; paths.size() > 0 && i < styles.length; i++) {\n            for (String path : paths) {\n                File file = new File(path, styles[i]);\n                if (file.exists()) {\n                    try {\n                        URL u = file.toURI().toURL();\n                        if (!styles[i].equals(styles2[i])) {\n                            u = new URL(u + \"#\" + styles2[i]);\n                        }\n                        urls.add(k++, u);\n                    } catch (MalformedURLException ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            }\n        }\n        return urls.toArray(new URL[urls.size()]);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1196,
    "type": "Return",
    "comment": "@return Collection of mapped blocks.",
    "code": "    public static Collection<GridHadoopInputSplit> splitJob(JobContext ctx) throws GridException {\n        try {\n            InputFormat<?, ?> format = U.newInstance(ctx.getInputFormatClass());\n\n            assert format != null;\n\n            List<InputSplit> splits = format.getSplits(ctx);\n\n            Collection<GridHadoopInputSplit> res = new ArrayList<>(splits.size());\n\n            for (InputSplit nativeSplit : splits) {\n                if (nativeSplit instanceof FileSplit) {\n                    FileSplit s = (FileSplit)nativeSplit;\n\n                    res.add(new GridHadoopFileBlock(s.getLocations(), s.getPath().toUri(), s.getStart(), s.getLength()));\n                }\n                else\n                    res.add(new GridHadoopSplitWrapper((Writable)nativeSplit, nativeSplit.getLocations()));\n            }\n\n            return res;\n        }\n        catch (IOException | ClassNotFoundException e) {\n            throw new GridException(e);\n        }\n        catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n\n            throw new GridInterruptedException(e);\n        }\n    }\n",
    "label": 1,
    "rec": "@return Collection of mapped splits."
  },
  {
    "id": 1197,
    "type": "Return",
    "comment": "@return  True if some mapping was added.",
    "code": "    private boolean map(Iterable<KeyCacheObject> keys, Collection<ClusterNode> exc) {\n        Map<ClusterNode, Set<KeyCacheObject>> mappings = null;\n\n        for (KeyCacheObject key : keys)\n            mappings = map(key, mappings, exc);\n\n        if (isDone())\n            return false;\n\n        boolean ret = false;\n\n        if (mappings != null) {\n            ClusterNode loc = cctx.localNode();\n\n            int curTopVer = topCntr.get();\n\n            if (!preloader.addFuture(this)) {\n                assert isDone() : this;\n\n                return false;\n            }\n\n            trackable = true;\n\n            // Create mini futures.\n            for (Map.Entry<ClusterNode, Set<KeyCacheObject>> mapped : mappings.entrySet()) {\n                ClusterNode n = mapped.getKey();\n                Set<KeyCacheObject> mappedKeys = mapped.getValue();\n\n                int cnt = F.size(mappedKeys);\n\n                if (cnt > 0) {\n                    ret = true;\n\n                    MiniFuture fut = new MiniFuture(n, mappedKeys, curTopVer, exc);\n\n                    GridDhtForceKeysRequest req = new GridDhtForceKeysRequest(\n                        cctx.cacheId(),\n                        futId,\n                        fut.miniId(),\n                        mappedKeys,\n                        topVer,\n                        cctx.deploymentEnabled());\n\n                    try {\n                        add(fut); // Append new future.\n\n                        assert !n.id().equals(loc.id());\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"Sending force key request [cacheName=\" + cctx.name() + \"node=\" + n.id() +\n                                \", req=\" + req + ']');\n\n                        cctx.io().send(n, req, cctx.ioPolicy());\n                    }\n                    catch (IgniteCheckedException e) {\n                        // Fail the whole thing.\n                        if (e instanceof ClusterTopologyCheckedException)\n                            fut.onResult((ClusterTopologyCheckedException)e);\n                        else if (!cctx.kernalContext().isStopping())\n                            fut.onResult(e);\n                    }\n                }\n            }\n        }\n\n        return ret;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1198,
    "type": "Return",
    "comment": "@return The current IconDrawable for chaining.",
    "code": "public IconicsDrawable sizeDp(int size) {\n    return sizePx(Utils.convertDpToPx(mContext, size));\n}",
    "label": 1,
    "rec": "@return The current IconExtDrawable for chaining."
  },
  {
    "id": 1199,
    "type": "Return",
    "comment": "@return Afinity key.",
    "code": "        public AffinityKey<Integer> key() {\n            return new AffinityKey<>(id, orderId);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1200,
    "type": "Return",
    "comment": "@return The map we are editing.",
    "code": "private URNspec getModel() {\n    return model;\n}",
    "label": 1,
    "rec": "@return The model we are editing."
  },
  {
    "id": 1201,
    "type": "Return",
    "comment": "@return Collection of keys for which given cache is backup.",
    "code": "    protected List<Integer> backupKeys(IgniteCache<?, ?> cache, int cnt, int startFrom) {\n        return findKeys(cache, cnt, startFrom, 1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1202,
    "type": "Return",
    "comment": "@return return true",
    "code": "public static boolean writeFile(String filePath, String content, boolean append) {\n    if (StringUtils.isEmpty(content)) {\n        return false;\n    }\n    FileWriter fileWriter = null;\n    try {\n        makeDirs(filePath);\n        fileWriter = new FileWriter(filePath, append);\n        fileWriter.write(content);\n        fileWriter.close();\n        return true;\n    } catch (IOException e) {\n        throw new RuntimeException(STR, e);\n    } finally {\n        if (fileWriter != null) {\n            try {\n                fileWriter.close();\n            } catch (IOException e) {\n                throw new RuntimeException(STR, e);\n            }\n        }\n    }\n}",
    "label": 1,
    "rec": "@return return false if content is empty, true otherwise"
  },
  {
    "id": 1203,
    "type": "Return",
    "comment": "@return Affinity nodes.",
    "code": "    public List<GridNode> nodes(int part, long topVer) {\n        // Resolve cached affinity nodes.\n        return cachedAffinity(topVer).get(part);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1204,
    "type": "Return",
    "comment": "@return an unmodifiable but sorted set of all extensions (see {@link EntityBase#compareTo(Object)}).",
    "code": "public SortedSet<ExtensionEntityBase> getAllExtensions() {\n    if (extensions == null) {\n        return new TreeSet<ExtensionEntityBase>(new ExtensionsComparator());\n    }\n    return extensions.getAllExtensions();\n}",
    "label": 1,
    "rec": "@return an unmodifiable but sorted set of all extensions (see {@link ExtensionsComparator})."
  },
  {
    "id": 1205,
    "type": "Return",
    "comment": "@return true if recording",
    "code": "    public boolean isRecording() {\n        // true if not idle.\n        return mState != STATE_IDLE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1206,
    "type": "Return",
    "comment": "@return  GridCompute for given grid's local node.",
    "code": "    protected IgniteCompute forLocal(Ignite ignite) {\n        return ignite.compute(ignite.cluster().forLocal());\n    }\n",
    "label": 1,
    "rec": "@return  org.gridgain.grid.compute.IgniteCompute for given grid's local node."
  },
  {
    "id": 1207,
    "type": "Return",
    "comment": "@return a  KeyTemplate containing a  HmacKeyFormat with some specified parameters.",
    "code": "  public static KeyTemplate createHmacKeyTemplate(int keySize, int tagSize, HashType hashType) {\n    HmacParams params = HmacParams.newBuilder()\n        .setHash(hashType)\n        .setTagSize(tagSize)\n        .build();\n    HmacKeyFormat format = HmacKeyFormat.newBuilder()\n        .setParams(params)\n        .setKeySize(keySize)\n        .build();\n    return KeyTemplate.newBuilder()\n        .setValue(format.toByteString())\n        .setTypeUrl(new HmacKeyManager().getKeyType())\n        .setOutputPrefixType(OutputPrefixType.TINK)\n        .build();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1208,
    "type": "Return",
    "comment": "@return A validation report containing accumulated validation errors",
    "code": "public Status validate(final String value, final Property schema) {\n    return doValidate(value, schema);\n}",
    "label": 1,
    "rec": "@return A status containing error code and description"
  },
  {
    "id": 1209,
    "type": "Return",
    "comment": "@return BlockFace attached to",
    "code": "    public BlockFace getAttachedFace() {\n        byte data = getData();\n\n        switch (data) {\n        case 0x1:\n            return BlockFace.WEST;\n\n        case 0x2:\n            return BlockFace.EAST;\n\n        case 0x3:\n            return BlockFace.NORTH;\n\n        case 0x4:\n            return BlockFace.SOUTH;\n\n        case 0x5:\n            return BlockFace.DOWN;\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1210,
    "type": "Return",
    "comment": "@return a {@link DocumentCollectionEntity} instance",
    "code": "static DocumentEntity of(String name) throws NullPointerException {\n    return new DefaultDocumentEntity(name);\n}",
    "label": 1,
    "rec": "@return a {@link DocumentEntity} instance"
  },
  {
    "id": 1211,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String save(CmsTag entity, HttpServletRequest request, HttpSession session, ModelMap model) {\n        SysSite site = siteComponent.getSite(request.getServerName());\n        if (null != entity.getId()) {\n            CmsTag oldEntity = service.getEntity(entity.getId());\n            if (null == oldEntity || ControllerUtils.verifyNotEquals(\"siteId\", site.getId(), oldEntity.getSiteId(), model)) {\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n            entity = service.update(entity.getId(), entity, ignoreProperties);\n            if (null != entity) {\n                logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                        LogLoginService.CHANNEL_WEB_MANAGER, \"update.tag\", RequestUtils.getIpAddress(request),\n                        CommonUtils.getDate(), JsonUtils.getString(entity)));\n            }\n        } else {\n            entity.setSiteId(site.getId());\n            service.save(entity);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"save.tag\", RequestUtils.getIpAddress(request), CommonUtils.getDate(),\n                    JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1212,
    "type": "Return",
    "comment": "@return Mesos",
    "code": "public Optional<JobEventRdbConfiguration> getRdbConfiguration() {\n    String driver = getValue(EnvironmentArgument.EVENT_TRACE_RDB_DRIVER);\n    String url = getValue(EnvironmentArgument.EVENT_TRACE_RDB_URL);\n    String username = getValue(EnvironmentArgument.EVENT_TRACE_RDB_USERNAME);\n    String password = getValue(EnvironmentArgument.EVENT_TRACE_RDB_PASSWORD);\n    if (!Strings.isNullOrEmpty(driver) && !Strings.isNullOrEmpty(url) && !Strings.isNullOrEmpty(username)) {\n        return Optional.of(new JobEventRdbConfiguration(driver, url, username, password, JobTraceEvent.LogLevel.INFO));\n    }\n    return Optional.absent();\n}",
    "label": 1,
    "rec": "@return RDB"
  },
  {
    "id": 1213,
    "type": "Return",
    "comment": "@return  True if recordable in debug mode.",
    "code": "    private boolean recordable(TcpDiscoveryAbstractMessage msg) {\n        return !(msg instanceof TcpDiscoveryHeartbeatMessage) &&\n            !(msg instanceof TcpDiscoveryStatusCheckMessage) &&\n            !(msg instanceof TcpDiscoveryDiscardMessage) &&\n            !(msg instanceof TcpDiscoveryConnectionCheckMessage);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1214,
    "type": "Return",
    "comment": "@return A boolean",
    "code": "public boolean isActive() {\n    if (!getPreferences().isSyncEnabled())\n        return false;\n    NetworkUtilities networkUtilities = new NetworkUtilities(getContext());\n    if (!networkUtilities.isOnline())\n        return false;\n    if (getPreferences().shouldSyncOnlyOnWifi()) {\n        if (!networkUtilities.isOnWiFi())\n            return false;\n    }\n    return true;\n}",
    "label": 1,
    "rec": "@return A boolean indicating that sync can be performed."
  },
  {
    "id": 1215,
    "type": "Return",
    "comment": "@return Grid Started grid.",
    "code": "    protected Ignite startGrid(String gridName, GridConfiguration cfg) throws Exception {\n        cfg.setGridName(gridName);\n\n        return G.start(cfg);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1216,
    "type": "Return",
    "comment": "@return Portable context.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            IgniteKernal g = IgnitionEx.gridx(gridName);\n\n            if (g == null)\n                throw new IllegalStateException(\"Failed to find grid for name: \" + gridName);\n\n            return ((CacheObjectBinaryProcessorImpl)g.context().cacheObjects()).binaryContext();\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n    }\n",
    "label": 1,
    "rec": "@return Binary context."
  },
  {
    "id": 1217,
    "type": "Return",
    "comment": "@return  True if partition is empty.",
    "code": "    public boolean isEmpty() {\n        return map.size() == 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1218,
    "type": "Return",
    "comment": "@return The new user if he has been added successfully, else absent is returned.",
    "code": "public User<ID> createNewUser(String name) {\n    User<ID> alreadyThere = userByName.get(name);\n    if (alreadyThere != null) {\n        return alreadyThere;\n    }\n    ID userIdent = users.getIdentity(addedUsers++);\n    User<ID> newOne = new User<ID>(name, userIdent);\n    userByName.put(name, newOne);\n    userById.put(userIdent, newOne);\n    return newOne;\n}",
    "label": 1,
    "rec": "@return The new user if it has been added successfully or the already existing user object with the given name."
  },
  {
    "id": 1219,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte gt(byte value) {\n        reportMatcher(new GreaterThan<Byte>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1220,
    "type": "Return",
    "comment": "@return true if this authentication realm \"understands\" how to process submissions for the submitted token instances of the class, false otherwise.",
    "code": "    public boolean supports(AuthenticationToken token) {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Received null AuthenticationToken.  Returning false for supports(token) implementation (can't \" +\n                \"process null tokens).\" );\n        }\n        return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());\n    }\n",
    "label": 1,
    "rec": "@return true if this authentication realm can process the submitted token instance of the class, false otherwise."
  },
  {
    "id": 1221,
    "type": "Return",
    "comment": "@return Affinity nodes.",
    "code": "    public List<ClusterNode> nodes(int part, AffinityTopologyVersion topVer) {\n        if (cctx.isLocal())\n            topVer = new AffinityTopologyVersion(1);\n\n        GridAffinityAssignmentCache aff0 = aff;\n\n        if (aff0 == null)\n            throw new IgniteException(FAILED_TO_FIND_CACHE_ERR_MSG + cctx.name());\n\n        return aff0.nodes(part, topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1222,
    "type": "Return",
    "comment": "@return true if network is available (at least one way to connect to network is connected or connecting).",
    "code": "public boolean isNetworkAvailable(Context context) {\n    return networkStateChecker.isNetworkAvailable(context);\n}",
    "label": 1,
    "rec": "@return true if network is available."
  },
  {
    "id": 1223,
    "type": "Return",
    "comment": "@return Service.",
    "code": "    public Service service() {\n        return cfg.getService();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1224,
    "type": "Return",
    "comment": "@return context rpc context",
    "code": "public Object removeAttachment(String key) {\n    return attachments.remove(key);\n}",
    "label": 1,
    "rec": "@return Old value"
  },
  {
    "id": 1225,
    "type": "Return",
    "comment": "@return Execution future.",
    "code": "    private IgniteFuture<GridRestResponse> broadcast(String cacheName, Callable<Object> c) {\n        IgniteCompute comp = ctx.grid().compute(ctx.grid().forCache(cacheName)).withNoFailover().enableAsync();\n\n        try {\n            comp.broadcast(c);\n\n            IgniteFuture<Collection<Object>> fut = comp.future();\n\n            return fut.chain(new C1<IgniteFuture<Collection<Object>>, GridRestResponse>() {\n                @Override public GridRestResponse apply(IgniteFuture<Collection<Object>> fut) {\n                    try {\n                        fut.get();\n\n                        return new GridRestResponse();\n                    }\n                    catch (IgniteCheckedException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            });\n        }\n        catch (IgniteCheckedException e) {\n            // Should not be thrown since uses asynchronous execution.\n            return new GridFinishedFutureEx<>(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1226,
    "type": "Return",
    "comment": "@return the <codE>GatedPaneFigure</code>",
    "code": "protected final BorderedFigure getGatedPaneFigure() {\n    return (BorderedFigure) getFigure();\n}",
    "label": 1,
    "rec": "@return the <codE>BorderedFigure</code>"
  },
  {
    "id": 1227,
    "type": "Return",
    "comment": "@return the minimal encoded bytes of the value",
    "code": "    public byte[] encode() {\n        byte[] bytes;\n        switch (sizeOf(value)) {\n            case 1:\n                return new byte[]{(byte) value};\n            case 3:\n                bytes = new byte[3];\n                bytes[0] = (byte) 253;\n                Utils.uint16ToByteArrayLE((int) value, bytes, 1);\n                return bytes;\n            case 5:\n                bytes = new byte[5];\n                bytes[0] = (byte) 254;\n                Utils.uint32ToByteArrayLE(value, bytes, 1);\n                return bytes;\n            default:\n                bytes = new byte[9];\n                bytes[0] = (byte) 255;\n                Utils.int64ToByteArrayLE(value, bytes, 1);\n                return bytes;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1228,
    "type": "Return",
    "comment": "@return a {@link DocumentCollectionEntity} instance",
    "code": "static DocumentEntity of(String name, List<Document> documents) throws NullPointerException {\n    DefaultDocumentEntity entity = new DefaultDocumentEntity(name);\n    entity.addAll(documents);\n    return entity;\n}",
    "label": 1,
    "rec": "@return a {@link DocumentEntity} instance"
  },
  {
    "id": 1229,
    "type": "Return",
    "comment": "@return true if the operation was actually queued, false if not",
    "code": "    void logError(String reason, final Throwable e)\n    {\n        if ( (reason == null) || (reason.length() == 0) )\n        {\n            reason = \"n/a\";\n        }\n\n        if ( !Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES) || !(e instanceof KeeperException) )\n        {\n            if ( e instanceof KeeperException.ConnectionLossException )\n            {\n                if ( LOG_ALL_CONNECTION_ISSUES_AS_ERROR_LEVEL || logAsErrorConnectionErrors.compareAndSet(true, false) )\n                {\n                    log.error(reason, e);\n                }\n                else\n                {\n                    log.debug(reason, e);\n                }\n            }\n            else\n            {\n                log.error(reason, e);\n            }\n        }\n\n        final String localReason = reason;\n        unhandledErrorListeners.forEach(l -> l.unhandledError(localReason, e));\n\n        if ( debugUnhandledErrorListener != null )\n        {\n            debugUnhandledErrorListener.unhandledError(reason, e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1230,
    "type": "Return",
    "comment": "@return an EventProcessor wrapping an Offerable",
    "code": "public static <E> Procedure<E> fromOfferable(final Offerable<E> offerable) {\n    return new Offerable2Procedure<E>(offerable);\n}",
    "label": 1,
    "rec": "@return an Procedure wrapping an Offerable"
  },
  {
    "id": 1231,
    "type": "Return",
    "comment": "@return list if there was already one",
    "code": "        protected Collection<TYPE> initialize(long taskId) {\n            if(cache.containsKey(taskId))\n                return get(taskId);\n            cache.put(taskId, new HashMap<String, TYPE>());\n            return null;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1232,
    "type": "Return",
    "comment": "@return The contact read",
    "code": "@Processor\n@InvalidateConnectionOn(exception = NotAuthenticatedException.class)\npublic Contact readContact(String objectId) {\n    return (Contact) read(ServiceSourceCollection.Contacts, objectId);\n}",
    "label": 1,
    "rec": "@return an instance of {@link org.mule.module.servicesource.model.contact.Contact}"
  },
  {
    "id": 1233,
    "type": "Return",
    "comment": "@return Multi bulk reply, specifically the list of common elements.",
    "code": "  public Set<String> sunion(final String... keys) {\n    checkIsInMulti();\n    client.sunion(keys);\n    final List<String> members = client.getMultiBulkReply();\n    if (members == null) {\n      return null;\n    }\n    return new HashSet<String>(members);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1234,
    "type": "Return",
    "comment": "@return the name of the remote user",
    "code": "public User getUser() {\n    return user;\n}",
    "label": 1,
    "rec": "@return the remote user"
  },
  {
    "id": 1235,
    "type": "Return",
    "comment": "@return Pair (array) of bucket name and key name.",
    "code": "  public static String[] decodeKey(Key k) {\n    return decodeKeyImpl(k);\n//    assert checkBijection(k, res[0], res[1]);\n//    return res;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1236,
    "type": "Return",
    "comment": "@return Returns the startTime.",
    "code": "public Date getStartTime() {\n    if (startTime == null)\n        startTime = new Date();\n    if (isAllDay()) {\n        return ScheduleUtil.truncate(startTime);\n    } else {\n        return startTime;\n    }\n}",
    "label": 1,
    "rec": "@return Returns the startTime. If the allDay property is true, the startTime is truncated to 00:00."
  },
  {
    "id": 1237,
    "type": "Return",
    "comment": "@return BlockFace indicating where this sign is facing",
    "code": "    public BlockFace getFacing() {\n        byte data = getData();\n\n        if (!isWallSign()) {\n            switch (data) {\n            case 0x0:\n                return BlockFace.SOUTH;\n\n            case 0x1:\n                return BlockFace.WEST_NORTH_WEST;\n\n            case 0x2:\n                return BlockFace.NORTH_WEST;\n\n            case 0x3:\n                return BlockFace.NORTH_NORTH_WEST;\n\n            case 0x4:\n                return BlockFace.WEST;\n\n            case 0x5:\n                return BlockFace.NORTH_NORTH_EAST;\n\n            case 0x6:\n                return BlockFace.NORTH_EAST;\n\n            case 0x7:\n                return BlockFace.EAST_NORTH_EAST;\n\n            case 0x8:\n                return BlockFace.NORTH;\n\n            case 0x9:\n                return BlockFace.EAST_SOUTH_EAST;\n\n            case 0xA:\n                return BlockFace.SOUTH_EAST;\n\n            case 0xB:\n                return BlockFace.SOUTH_SOUTH_EAST;\n\n            case 0xC:\n                return BlockFace.EAST;\n\n            case 0xD:\n                return BlockFace.SOUTH_SOUTH_WEST;\n\n            case 0xE:\n                return BlockFace.SOUTH_WEST;\n\n            case 0xF:\n                return BlockFace.WEST_SOUTH_WEST;\n            }\n\n            return null;\n        } else {\n            return getAttachedFace().getOppositeFace();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1238,
    "type": "Return",
    "comment": "@return The location of the contents of this project",
    "code": "public URI getContentLocation() {\n    return this.contentLocation;\n}",
    "label": 1,
    "rec": "@return The location of the contents of this clone"
  },
  {
    "id": 1239,
    "type": "Return",
    "comment": "@return  True if key is in the map.",
    "code": "        boolean containsKey(K k) {\n            GridCacheEntryEx<K, V> e = ctx.cache().peekEx(k);\n\n            try {\n                return e != null && !e.obsolete() && (!e.deleted() || e.lockedByThread()) && F.isAll(e.wrap(false), filter);\n            }\n            catch (GridCacheEntryRemovedException ignore) {\n                return false;\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1240,
    "type": "Return",
    "comment": "@return the {@link org.apache.tez.dag.api.EdgeManagerContext} for the input",
    "code": "public EdgeManagerPluginContext getContext() {\n    return this.context;\n}",
    "label": 1,
    "rec": "@return the {@link org.apache.tez.dag.api.EdgeManagerPluginContext} for the input"
  },
  {
    "id": 1241,
    "type": "Return",
    "comment": "@return  True if there is a persistent storage.",
    "code": "    public boolean removeAllFromStore(@Nullable GridCacheTx tx, Collection<? extends K> keys) throws IgniteCheckedException {\n        if (F.isEmpty(keys))\n            return true;\n\n        if (keys.size() == 1) {\n            K key = keys.iterator().next();\n\n            return removeFromStore(tx, key);\n        }\n\n        if (store != null) {\n            Collection<? extends K> keys0;\n\n            keys0 = convertPortable ?\n                F.viewReadOnly(keys, new C1<K, K>() {\n                    @Override public K apply(K k) {\n                        return (K)cctx.unwrapPortableIfNeeded(k, false);\n                    }\n                }) :\n                keys;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Removing values from cache store [keys=\" + keys0 + ']');\n\n            try {\n                store.removeAll(tx, keys0);\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Removed values from cache store [keys=\" + keys0 + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1242,
    "type": "Return",
    "comment": "@return Integer reply, specifically: an integer greater than 0 if one or more keys exist, 0 if none of the specified keys exist.",
    "code": "@Override\npublic Boolean exists(final String key) {\n    checkIsInMultiOrPipeline();\n    client.exists(key);\n    return client.getIntegerReply() == NUM;\n}",
    "label": 1,
    "rec": "@return Boolean reply, true if the key exists, otherwise false"
  },
  {
    "id": 1243,
    "type": "Return",
    "comment": "@return Partition resend timeout get from system property.",
    "code": "    private static long getResendTimeout() {\n        try {\n            return Long.parseLong(GridSystemProperties.getString(GridSystemProperties.GG_PRELOAD_RESEND_TIMEOUT,\n                String.valueOf(GridDhtPreloader.DFLT_PRELOAD_RESEND_TIMEOUT)));\n        }\n        catch (NumberFormatException ignored) {\n            return GridDhtPreloader.DFLT_PRELOAD_RESEND_TIMEOUT;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1244,
    "type": "Return",
    "comment": "@return all groups where getGroupType() is same as this.getGroupTypeValue()",
    "code": "public Collection ejbFindAll() throws FinderException {\n    String theUserType = STR;\n    SelectQuery query = idoSelectQuery();\n    query.addCriteria(new MatchCriteria(idoQueryTable(), getGroupTypeColumnName(), MatchCriteria.NOTEQUALS, GenericEntity.COLUMN_VALUE_TRUE, true));\n    int prefetchSize = NUM;\n    return super.idoFindPKsByQueryUsingLoadBalance(query, prefetchSize);\n}",
    "label": 1,
    "rec": "@return all groups excluding user representative groups"
  },
  {
    "id": 1245,
    "type": "Return",
    "comment": "@return Default cache transaction isolation.",
    "code": "    public IgniteTxIsolation getDefaultTxIsolation() {\n        return dfltIsolation;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1246,
    "type": "Return",
    "comment": "@return <code>true</code> if the gate is closed after this call, <code>false</code> if {@link #finalOpenGate()} has been called or the gate is open after this call.",
    "code": "public boolean closeGate() {\n    gate.close();\n    return true;\n}",
    "label": 1,
    "rec": "@return <code>true</code> in all cases."
  },
  {
    "id": 1247,
    "type": "Return",
    "comment": "@return Integer reply, specifically: 1 if the key was renamed 0 if the target key already exist",
    "code": "    public Long renamenx(final byte[] oldkey, final byte[] newkey) {\n        checkIsInMulti();\n        client.renamenx(oldkey, newkey);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1248,
    "type": "Return",
    "comment": "@return {@link Integer}",
    "code": "private static int getIndexOfIdColumn(final List<HBaseColumn> columns) {\n    for (int i = NUM; i < columns.size(); i++) {\n        if (HBaseDataContext.FIELD_ID.equals(columns.get(i).getColumnFamily())) {\n            return i;\n        }\n    }\n    return -NUM;\n}",
    "label": 1,
    "rec": "@return index of the ID-column"
  },
  {
    "id": 1249,
    "type": "Return",
    "comment": "@return an AuthenticationInfo object that represents the authentication information for the given username, or null if an account cannot be found with the given username.",
    "code": "    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        Principal principal = token.getPrincipal();\n\n        try {\n\n            for( AccountEntry entry : accounts ) {\n                if( entry.getUsername().equals( principal.getName() ) ) {\n                    return new SimpleAuthenticationInfo( new UsernamePrincipal( principal.getName() ),\n                                                  entry.getPassword().toCharArray() );\n\n                }\n            }\n\n        } catch (Exception e) {\n            throw new AuthenticationException( \"Unexpected exception while authenticating user.\", e );\n        }\n\n        // User could not be found, so return null\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1250,
    "type": "Return",
    "comment": "@return List of returned strings",
    "code": "public Hashtable executeExtendedHello(String domain) throws IOException, MailException {\n    if (EventLogger.getMinimumLevel() >= EventLogger.DEBUG_INFO) {\n        EventLogger.logEvent(AppInfo.GUID, (STR + domain + STR).getBytes(), EventLogger.DEBUG_INFO);\n    }\n    String[] result = executeFollow(STR + domain);\n    Hashtable items = new Hashtable();\n    for (int i = NUM; i < result.length; i++) {\n        if (result[i].length() > NUM) {\n            items.put(result[i].substring(NUM), Boolean.TRUE);\n        }\n    }\n    return items;\n}",
    "label": 1,
    "rec": "@return Table of returned strings"
  },
  {
    "id": 1251,
    "type": "Return",
    "comment": "@return the mandatory command classes.",
    "code": "\t\tpublic CommandClass[] getMandatoryCommandClasses() {\n\t\t\tswitch (this) {\n\t\t\t\tcase NOT_USED:\n\t\t\t\tcase PORTABLE_REMOTE_CONTROLLER:\n\t\t\t\tcase PC_CONTROLLER:\n\t\t\t\tcase BASIC_REPEATER_SLAVE:\n\t\t\t\tcase SWITCH_REMOTE_BINARY:\n\t\t\t\tcase SWITCH_REMOTE_MULTILEVEL: \n\t\t\t\tcase SWITCH_REMOTE_TOGGLE_BINARY:\n\t\t\t\tcase SWITCH_REMOTE_TOGGLE_MULTILEVEL:\n\t\t\t\tcase ROUTING_SENSOR_BINARY: // In the documentation Binary Sensor command class is specified, but this is already on the generic class...\n\t\t\t\tcase ROUTING_SENSOR_MULTILEVEL: // In the documentation Multilevel Sensor command class is specified, but this is already on the generic class...\n\t\t\t\tcase DOOR_LOCK:\n\t\t\t\tcase THERMOSTAT_HEATING:\n\t\t\t\t\treturn new CommandClass[0];\n\t\t\t\tcase PORTABLE_SCENE_CONTROLLER:\n\t\t\t\tcase SCENE_CONTROLLER:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.ASSOCIATION, CommandClass.SCENE_CONTROLLER_CONF, CommandClass.MANUFACTURER_SPECIFIC };\n\t\t\t\tcase POWER_SWITCH_BINARY:\n\t\t\t\tcase POWER_SWITCH_MULTILEVEL:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.SWITCH_ALL };\n\t\t\t\tcase SCENE_SWITCH_BINARY:\n\t\t\t\tcase SCENE_SWITCH_MULTILEVEL:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.SCENE_ACTIVATION, CommandClass.SCENE_ACTUATOR_CONF, CommandClass.SWITCH_ALL, CommandClass.MANUFACTURER_SPECIFIC };\n\t\t\t\tcase MOTOR_MULTIPOSITION:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.VERSION, CommandClass.MANUFACTURER_SPECIFIC };\n\t\t\t\tcase MOTOR_CONTROL_CLASS_A:\n\t\t\t\tcase MOTOR_CONTROL_CLASS_B:\n\t\t\t\tcase MOTOR_CONTROL_CLASS_C:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.SWITCH_BINARY, CommandClass.VERSION, CommandClass.MANUFACTURER_SPECIFIC };\n\t\t\t\tcase SWITCH_TOGGLE_BINARY: \n\t\t\t\t\treturn new CommandClass[] { CommandClass.SWITCH_TOGGLE_BINARY };\n\t\t\t\tcase SWITCH_TOGGLE_MULTILEVEL: \n\t\t\t\t\treturn new CommandClass[] { CommandClass.SWITCH_TOGGLE_MULTILEVEL };\n\t\t\t\tcase ENERGY_PRODUCTION:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.ENERGY_PRODUCTION };\n\t\t\t\tcase SIMPLE_WINDOW_COVERING:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.BASIC_WINDOW_COVERING };\n\t\t\t\tcase THERMOSTAT_GENERAL:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.MANUFACTURER_SPECIFIC, CommandClass.THERMOSTAT_MODE, CommandClass.THERMOSTAT_SETPOINT };\n\t\t\t\tcase SETBACK_SCHEDULE_THERMOSTAT:\n\t\t\t\t\t// TODO: Battery and Wake Up command classes are mandatory for battery operated setback schedule thermostats.\n\t\t\t\t\treturn new CommandClass[] { CommandClass.CLIMATE_CONTROL_SCHEDULE, CommandClass.MANUFACTURER_SPECIFIC, CommandClass.MULTI_CMD, CommandClass.VERSION };\n\t\t\t\tcase SATELLITE_RECEIVER:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.SIMPLE_AV_CONTROL, CommandClass.MANUFACTURER_SPECIFIC, CommandClass.VERSION };\n\t\t\t\tcase ALARM_SENSOR_ROUTING_BASIC:\n\t\t\t\tcase SMOKE_SENSOR_ROUTING_BASIC:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.MANUFACTURER_SPECIFIC, CommandClass.ASSOCIATION, CommandClass.VERSION };\n\t\t\t\tcase ALARM_SENSOR_ROUTING:\n\t\t\t\tcase ALARM_SENSOR_ZENSOR_ADVANCED:\n\t\t\t\tcase SMOKE_SENSOR_ROUTING:\n\t\t\t\tcase SMOKE_SENSOR_ZENSOR_ADVANCED:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.MANUFACTURER_SPECIFIC, CommandClass.BATTERY, CommandClass.ASSOCIATION, CommandClass.VERSION };\n\t\t\t\tcase ALARM_SENSOR_ZENSOR_BASIC:\n\t\t\t\tcase SMOKE_SENSOR_ZENSOR_BASIC:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.MANUFACTURER_SPECIFIC, CommandClass.VERSION };\n\t\t\t\tcase ALARM_SENSOR_ZENSOR:\n\t\t\t\tcase SMOKE_SENSOR_ZENSOR:\n\t\t\t\t\treturn new CommandClass[] { CommandClass.MANUFACTURER_SPECIFIC, CommandClass.BATTERY, CommandClass.VERSION };\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\treturn new CommandClass[0];\n\t\t\t}\n\t\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1252,
    "type": "Return",
    "comment": "@return The character read.",
    "code": "Character read() throws EOFException {\n    if (position < fileContents.length()) {\n        return fileContents.charAt(position);\n    } else {\n        throw new EOFException();\n    }\n}",
    "label": 1,
    "rec": "@return The character read or null if at the end of the file."
  },
  {
    "id": 1253,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte gt(byte value) {\n        return reportMatcher(new GreaterThan<Byte>(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1254,
    "type": "Return",
    "comment": "@return the project that contains the resource at the given URI.",
    "code": "public IProject project(URI resourceUri) {\n    IFile file = file(resourceUri);\n    return (file != null) ? file.getProject() : null;\n}",
    "label": 1,
    "rec": "@return the project that contains the resource at the given URI, or {@code null} if the resource at the given URI is not in a workspace."
  },
  {
    "id": 1255,
    "type": "Return",
    "comment": "@return Integer reply, specifically: 1 if the element is a member of the set 0 if the element is not a member of the set OR if the key does not exist",
    "code": "    public Boolean sismember(final String key, final String member) {\n        runChecks();\n        client.sismember(key, member);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1256,
    "type": "Return",
    "comment": "@return service attribute filter",
    "code": "public static AttributeFilter attributes(final Map<String, ?> sampleAttributes) {\n    return new AttributeFilter() {\n\n        public boolean matches(final Map<String, ?> attributes) {\n            return null != attributes && attributes.entrySet().containsAll(sampleAttributes.entrySet());\n        }\n    };\n}",
    "label": 1,
    "rec": "@return sample attribute filter"
  },
  {
    "id": 1257,
    "type": "Return",
    "comment": "@return GGFS exception.",
    "code": "    public static IgniteFsException cast(String msg, IOException e) {\n        if (e instanceof FileNotFoundException)\n            return new IgfsFileNotFoundException(e);\n        else if (e instanceof ParentNotDirectoryException)\n            return new IgniteFsParentNotDirectoryException(msg, e);\n        else if (e instanceof PathIsNotEmptyDirectoryException)\n            return new IgfsDirectoryNotEmptyException(e);\n        else if (e instanceof PathExistsException)\n            return new IgniteFsPathAlreadyExistsException(msg, e);\n        else\n            return new IgniteFsException(msg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1258,
    "type": "Return",
    "comment": "@return {@link AbstractTaskListElement category} where the new task must be added to, or null if it must not be added to the task list",
    "code": "@SuppressWarnings(STR)\nprotected AbstractTaskCategory getCategory() {\n    int index = categoryChooser.getSelectionIndex();\n    if (addToCategory.getSelection() && index != -NUM) {\n        if (index == NUM) {\n            return TasksUiPlugin.getTaskListManager().getTaskList().getAutomaticCategory();\n        }\n        return ((List<AbstractTaskCategory>) categoryChooser.getData()).get(index - NUM);\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return {@link AbstractTaskContainer category} where the new task must be added to, or null if it must not be added to the task list"
  },
  {
    "id": 1259,
    "type": "Return",
    "comment": "@return Affinity.",
    "code": "    private CacheConsistentHashAffinityFunction affinity(int idx) {\n        return (CacheConsistentHashAffinityFunction)grid(idx).jcache(null).configuration().getAffinity();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1260,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)",
    "code": "  private Frame reBalance(final Frame fr, boolean local) {\n    int cores = 0;\n    for( H2ONode node : H2O.CLOUD._memary ) {\n      if (local) cores = Math.max(cores, node._heartbeat._num_cpus);\n      else cores += node._heartbeat._num_cpus;\n    }\n    final int chunks = 4*cores;\n    if (force_load_balance && chunks < fr.numRows()) {\n//      return MRUtils.shuffleAndBalance(fr, chunks, seed, local, shuffle_training_data) : fr;\n      return rebalanceDataset(Key.make(fr._key.toString() + \".balanced\"), fr, chunks);\n    }\n    else return fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks"
  },
  {
    "id": 1261,
    "type": "Return",
    "comment": "@return org.openhab.core.types.State",
    "code": "\tpublic State getOHState() {\n\t\tString sOHState = StateTraslator.statesSoulissToOH(this.getNote(),\n\t\t\t\tthis.getType(), (short) this.getState());\n\t\tif (sOHState != null) {\n\t\t\treturn OnOffType.valueOf(sOHState);\n\t\t} else {\n\t\t\t//return new DecimalType(Math.round((this.getState() / 254) * 100));\n\t\t\treturn new PercentType(Math.round((this.getState() / 254) * 100));\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1262,
    "type": "Return",
    "comment": "@return deleted nodes",
    "code": "    public int simplify(PointList points) {\n        int removed = simplify(points, 0, points.size() - 1);\n        compressNew(points, removed);\n        return removed;\n    }\n",
    "label": 1,
    "rec": "@return removed nodes"
  },
  {
    "id": 1263,
    "type": "Return",
    "comment": "@return instanse of clazz class, new Class is defined in the same class loader",
    "code": "      public static Factory override(Class clazz, MethodInterceptor interceptor ){\n          \n         return (Factory)enhanceHelper(false, null , clazz.isInterface() ? null : clazz,\n                                       clazz.isInterface() ? new Class[]{clazz} : null ,\n                                       interceptor, clazz.getClassLoader(), null, null );\n     }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1264,
    "type": "Return",
    "comment": "@return an {@link KGraphAdapter} for the passed graph.",
    "code": "public static ElkGraphAdapter adapt(final ElkNode graph) {\n    return new ElkGraphAdapter(graph);\n}",
    "label": 1,
    "rec": "@return an {@link ElkGraphAdapter} for the passed graph."
  },
  {
    "id": 1265,
    "type": "Return",
    "comment": "@return File path.",
    "code": "    public IgfsPath path() {\n        return path;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1266,
    "type": "Return",
    "comment": "@return {@linkplain TccTransaction}",
    "code": "public HmilyTransaction getTccTransaction(final String key) {\n    try {\n        return LOADING_CACHE.get(key);\n    } catch (ExecutionException e) {\n        return new HmilyTransaction();\n    }\n}",
    "label": 1,
    "rec": "@return {@linkplain HmilyTransaction}"
  },
  {
    "id": 1267,
    "type": "Return",
    "comment": "@return Result.",
    "code": "    public Object[] unwrapBinariesInArrayIfNeeded(Object[] arr, boolean keepBinary, boolean cpy) {\n        if (BinaryUtils.knownArray(arr))\n            return arr;\n\n        Object[] res = new Object[arr.length];\n\n        for (int i = 0; i < arr.length; i++)\n            res[i] = unwrapBinary(arr[i], keepBinary, cpy);\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1268,
    "type": "Return",
    "comment": "@return the AuthenticationInfo associated with the user account corresponding to the specified token",
    "code": "    protected Account doSingleRealmAuthentication( Realm realm, AuthenticationToken token ) {\n        if ( !realm.supports( token.getClass() ) ) {\n            String msg = \"Single configured realm [\" + realm + \"] does not support authentication tokens of type [\" +\n                token.getClass().getName() + \"].  Please ensure that the appropriate Realm implementation is \" +\n                \"configured correctly or that the realm accepts AuthenticationTokens of this type.\";\n            throw new UnsupportedTokenException( msg );\n        }\n        Account account = realm.getAccount( token );\n        if ( account == null ) {\n            String msg = \"Single configured realm [\" + realm + \"] was unable to find account data for the \" +\n                \"submitted AuthenticationToken [\" + token + \"].\";\n            throw new UnknownAccountException( msg );\n        }\n        return account;\n    }\n",
    "label": 1,
    "rec": "@return the Account associated with the user account corresponding to the specified token"
  },
  {
    "id": 1269,
    "type": "Return",
    "comment": "@return Key.",
    "code": "    public KeyCacheObject key() {\n        return key;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1270,
    "type": "Return",
    "comment": "@return a promise that can be use to track when all the data has been written into the socket",
    "code": "public SendMessageInfo sendMessages(final List<Entry> entries) {\n    return sendMessages(entries, null);\n}",
    "label": 1,
    "rec": "@return a SendMessageInfo object that contains the detail of what was sent to consumer"
  },
  {
    "id": 1271,
    "type": "Return",
    "comment": "@return connection string",
    "code": "    public String getConnectString()\n    {\n        return spec.getConnectString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1272,
    "type": "Return",
    "comment": "@return a ColumnFamilyEntity instance",
    "code": "static ColumnEntity of(String name) {\n    return new DefaultColumnEntity(name);\n}",
    "label": 1,
    "rec": "@return a ColumnEntity instance"
  },
  {
    "id": 1273,
    "type": "Return",
    "comment": "@return intent",
    "code": "    public Intent create(final String uri) {\n        int issueNumber = issueMatcher.getNumber(uri);\n        if (issueNumber > 0)\n            return createIssueIntent(uri, issueNumber);\n\n        String gistId = gistMatcher.getId(uri);\n        if (gistId != null)\n            return createGistIntent(uri, gistId);\n\n        Intent intent = new Intent(ACTION_VIEW, Uri.parse(uri));\n        intent.addCategory(CATEGORY_BROWSABLE);\n        return intent;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1274,
    "type": "Return",
    "comment": "@return the singleton {@link PhpAstLexer5}",
    "code": "private static org.eclipse.php.internal.core.ast.scanner.php4.PhpAstLexer getLexer4(Reader reader) throws IOException {\n    final org.eclipse.php.internal.core.ast.scanner.php4.PhpAstLexer phpAstLexer4 = ASTParser.PHP_AST_LEXER4;\n    phpAstLexer4.yyreset(reader);\n    phpAstLexer4.resetCommentList();\n    return phpAstLexer4;\n}",
    "label": 1,
    "rec": "@return the singleton {@link org.eclipse.php.internal.core.ast.scanner.php4.PhpAstLexer}"
  },
  {
    "id": 1275,
    "type": "Return",
    "comment": "@return Multi bulk reply, specifically the list of common elements.",
    "code": "    public Set<byte[]> sunion(final byte[]... keys) {\n        checkIsInMulti();\n        client.sunion(keys);\n        final List<byte[]> members = client.getBinaryMultiBulkReply();\n        return new HashSet<byte[]>(members);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1276,
    "type": "Return",
    "comment": "@return an enumeration of all entries matching this search query.",
    "code": "public final IntEnumerator searchRange(final int xMin, final int xMax) {\n    final NodeStack nodeStack = new NodeStack();\n    final int totalCount = searchRange(m_root, nodeStack, xMin, xMax, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    return new IntEnumerator() {\n\n        private int count = totalCount;\n\n        private Node currentLeafNode = null;\n\n        private int wholeLeafNodes = NUM;\n\n        private int currentNodeInx;\n\n        public final int numRemaining() {\n            return count;\n        }\n\n        public final int nextInt() {\n            int returnThis = NUM;\n            if (currentLeafNode == null) {\n                while (true) {\n                    currentLeafNode = nodeStack.pop();\n                    if (isLeafNode(currentLeafNode)) {\n                        currentNodeInx = NUM;\n                        break;\n                    }\n                    for (int i = currentLeafNode.sliceCount; i > NUM; ) nodeStack.push(currentLeafNode.data.children[--i]);\n                    if (isLeafNode(currentLeafNode.data.children[NUM]))\n                        wholeLeafNodes += currentLeafNode.sliceCount;\n                }\n            }\n            if (wholeLeafNodes > NUM) {\n                returnThis = currentLeafNode.values[currentNodeInx];\n            } else\n                for (int i = currentNodeInx; i < currentLeafNode.sliceCount; i++) if (currentLeafNode.values[i] >= xMin) {\n                    returnThis = currentLeafNode.values[i];\n                    break;\n                }\n            if (++currentNodeInx == currentLeafNode.sliceCount) {\n                currentLeafNode = null;\n                if (wholeLeafNodes > NUM)\n                    wholeLeafNodes--;\n            }\n            count--;\n            return returnThis;\n        }\n    };\n}",
    "label": 1,
    "rec": "@return an non-descending enumeration of all entries matching this search query, duplicated included."
  },
  {
    "id": 1277,
    "type": "Return",
    "comment": "@return dot product of row of the first matrix and column of the second matrix",
    "code": "\tpublic static double product(DenseMatrix m, int mrow, DenseMatrix n, int ncol) {\n\t\tassert m.numColumns == n.numRows;\n\n\t\tdouble res = 0;\n\t\tfor (int j = 0; j < m.numColumns; j++)\n\t\t\tres += m.get(mrow, j) * n.get(j, ncol);\n\n\t\treturn res;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1278,
    "type": "Return",
    "comment": "@return A validation report containing validation errors",
    "code": "public Status validateResponse(final HttpServerExchange exchange, final SwaggerOperation swaggerOperation) {\n    requireNonNull(exchange, STR);\n    requireNonNull(swaggerOperation, STR);\n    io.swagger.models.Response swaggerResponse = swaggerOperation.getOperation().getResponses().get(Integer.toString(exchange.getStatusCode()));\n    if (swaggerResponse == null) {\n        swaggerResponse = swaggerOperation.getOperation().getResponses().get(STR);\n    }\n    if (swaggerResponse == null) {\n        return new Status(STR, exchange.getStatusCode(), swaggerOperation.getPathString().original());\n    }\n    if (swaggerResponse.getSchema() == null) {\n        return null;\n    }\n    String body = exchange.getOutputStream().toString();\n    if (body == null || body.length() == NUM) {\n        return new Status(STR, swaggerOperation.getMethod(), swaggerOperation.getPathString().original());\n    }\n    return schemaValidator.validate(body, swaggerResponse.getSchema());\n}",
    "label": 1,
    "rec": "@return A status containing validation error"
  },
  {
    "id": 1279,
    "type": "Return",
    "comment": "@return false.",
    "code": "    public static boolean anyBoolean() {\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1280,
    "type": "Return",
    "comment": "@return account",
    "code": "    public static Account getAccount(final Context context) {\n        final Account[] accounts = AccountManager.get(context)\n                .getAccountsByType(GITHUB_ACCOUNT_TYPE);\n        return accounts.length > 0 ? accounts[0] : null;\n    }\n",
    "label": 1,
    "rec": "@return account or null if none"
  },
  {
    "id": 1281,
    "type": "Return",
    "comment": "@return the edge's angle",
    "code": "    public Float getAngle() {\n        Point p1 = node1.getPosition();\n        Point p2 = node2.getPosition();\n\n        return (float) Math.atan2(p2.getY() - p1.getY(), p2.getX() - p1.getX());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1282,
    "type": "Return",
    "comment": "@return the associated {@link com.raizlabs.android.dbflow.structure.container.ContainerAdapter} within this database for the specified table. These are used for {@link com.raizlabs.android.dbflow.structure.container.ModelContainer} and require {@link com.raizlabs.android.dbflow.structure.Model} to add the {@link ModelContainer}.",
    "code": "public ModelContainerAdapter getModelContainerAdapterForTable(Class<? extends Model> table) {\n    return modelContainerAdapters.get(table);\n}",
    "label": 1,
    "rec": "@return the associated {@link ModelContainerAdapter} within this database for the specified table. These are used for {@link com.raizlabs.android.dbflow.structure.container.ModelContainer} and require {@link com.raizlabs.android.dbflow.structure.Model} to add the {@link ModelContainer}."
  },
  {
    "id": 1283,
    "type": "Return",
    "comment": "@return true if the subject was successfully logged in, false otherwise",
    "code": "    protected boolean executeLogin(ServletRequest request, ServletResponse response) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to authenticate Subject based on Http BASIC Authentication request...\");\n        }\n\n        HttpServletRequest httpRequest = toHttp(request);\n        String authorizationHeader = httpRequest.getHeader(AUTHORIZATION_HEADER);\n\n        if (authorizationHeader != null && authorizationHeader.length() > 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Executing login with headers [\" + authorizationHeader + \"]\");\n            }\n\n            String[] authTokens = authorizationHeader.split(\" \");\n\n            if (authTokens[0].trim().equalsIgnoreCase(HttpServletRequest.BASIC_AUTH)) {\n                String encodedCredentials = authTokens[1];\n\n                String decodedCredentials = Base64.decodeToString(encodedCredentials);\n\n                String[] credentials = decodedCredentials.split(\":\");\n\n                if (credentials != null && credentials.length > 1) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Processing login request [\" + credentials[0] + \"]\");\n                    }\n                    Subject subject = getSubject(request, response);\n                    UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(credentials[0], credentials[1]);\n                    try {\n                        subject.login(usernamePasswordToken);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Successfully logged in user [\" + credentials[0] + \"]\");\n                        }\n                        return true;\n                    } catch (AuthenticationException ae) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Unable to log in subject [\" + credentials[0] + \"]\", ae);\n                        }\n                    }\n                }\n            }\n        }\n\n        //always default to sending the challenge.  If we've made it to this point in the code, that\n        //means the authentication attempt either never occured, or wasn't successful:\n        return sendChallenge(request, response);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1284,
    "type": "Return",
    "comment": "@return Previous projection set on this thread.",
    "code": "    @Nullable public CacheOperationContext enter(@Nullable CacheOperationContext opCtx) {\n        try {\n            GridCacheAdapter<K, V> cache = ctx.cache();\n\n            GridCachePreloader<K, V> preldr = cache != null ? cache.preloader() : null;\n\n            if (preldr == null)\n                throw new IllegalStateException(\"Grid is in invalid state to perform this operation. \" +\n                    \"It either not started yet or has already being or have stopped [gridName=\" + ctx.gridName() + ']');\n\n            preldr.startFuture().get();\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(\"Failed to wait for cache preloader start [cacheName=\" +\n                ctx.name() + \"]\", e);\n        }\n\n        onEnter();\n\n        rwLock.readLock();\n\n        if (stopped) {\n            rwLock.readUnlock();\n\n            throw new IllegalStateException(\"Cache has been stopped: \" + ctx.name());\n        }\n\n        // Must unlock in case of unexpected errors to avoid\n        // deadlocks during kernal stop.\n        try {\n            return setOperationContextPerCall(opCtx);\n        }\n        catch (RuntimeException e) {\n            rwLock.readUnlock();\n\n            throw e;\n        }\n    }\n",
    "label": 1,
    "rec": "@return Previous operation context set on this thread."
  },
  {
    "id": 1285,
    "type": "Return",
    "comment": "@return the Annotation that this interceptor will process for the specified method invocation.",
    "code": "    protected Annotation getAnnotation(MethodInvocation mi) {\n        return getResolver().getAnnotation(mi, getHandler().getAnnotationClass());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1286,
    "type": "Return",
    "comment": "@return an  org.jsecurity.realm.support.ldap.LdapDirectoryInfo instance containing information retrieved from LDAP that can be used to build an  AuthenticationInfo instance to return.",
    "code": "    protected LdapSecurityInfo queryForLdapDirectoryInfo(String username, LdapContext ctx) throws NamingException {\n\n        LdapSecurityInfo info = new LdapSecurityInfo();\n\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        // Perform context search\n        NamingEnumeration answer = ctx.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n                    processAttribute(info, attr);\n                }\n            }\n        }\n\n        return info;\n    }\n",
    "label": 1,
    "rec": "@return an  LdapSecurityInfo instance containing information retrieved from LDAP that can be used to build an  org.jsecurity.authc.AuthenticationInfo instance to return."
  },
  {
    "id": 1287,
    "type": "Return",
    "comment": "@return User-defined configuration.",
    "code": "        IgniteConfiguration config() {\n            return cfg;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1288,
    "type": "Return",
    "comment": "@return The mock.",
    "code": "    public Object toMock(Answer answer) {\n        return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));\n    }\n",
    "label": 1,
    "rec": "@return The mock or null if not mockable."
  },
  {
    "id": 1289,
    "type": "Return",
    "comment": "@return The filtered view.",
    "code": "    static Graph filteredView(GraphHopperStorage baseGraph, EdgeFilter edgeFilter) {\n        return new Graph() {\n            @Override\n            public Graph getBaseGraph() {\n                return baseGraph;\n            }\n\n            @Override\n            public int getNodes() {\n                return baseGraph.getNodes();\n            }\n\n            @Override\n            public int getEdges() {\n                return baseGraph.getEdges();\n            }\n\n            @Override\n            public NodeAccess getNodeAccess() {\n                return baseGraph.getNodeAccess();\n            }\n\n            @Override\n            public BBox getBounds() {\n                return baseGraph.getBounds();\n            }\n\n            @Override\n            public EdgeIteratorState edge(int a, int b) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public AllEdgesIterator getAllEdges() {\n                final AllEdgesIterator edge = baseGraph.getAllEdges();\n                return new AllEdgesIterator() {\n                    @Override\n                    public int length() {\n                        return edge.length();\n                    }\n\n                    @Override\n                    public boolean next() {\n                        while (edge.next()) {\n                            if (edgeFilter.accept(edge)) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n\n                    @Override\n                    public int getEdge() {\n                        return edge.getEdge();\n                    }\n\n                    @Override\n                    public int getOrigEdgeFirst() {\n                        return getEdge();\n                    }\n\n                    @Override\n                    public int getOrigEdgeLast() {\n                        return getEdge();\n                    }\n\n                    @Override\n                    public int getBaseNode() {\n                        return edge.getBaseNode();\n                    }\n\n                    @Override\n                    public int getAdjNode() {\n                        return edge.getAdjNode();\n                    }\n\n                    @Override\n                    public PointList fetchWayGeometry(int mode) {\n                        return edge.fetchWayGeometry(mode);\n                    }\n\n                    @Override\n                    public EdgeIteratorState setWayGeometry(PointList list) {\n                        edge.setWayGeometry(list);\n                        return this;\n                    }\n\n                    @Override\n                    public double getDistance() {\n                        return edge.getDistance();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setDistance(double dist) {\n                        edge.setDistance(dist);\n                        return this;\n                    }\n\n                    @Override\n                    public IntsRef getFlags() {\n                        return edge.getFlags();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setFlags(IntsRef flags) {\n                        edge.setFlags(flags);\n                        return this;\n                    }\n\n                    @Override\n                    public String getName() {\n                        return edge.getName();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setName(String name) {\n                        edge.setName(name);\n                        return this;\n                    }\n\n                    @Override\n                    public EdgeIteratorState detach(boolean reverse) {\n                        return edge.detach(reverse);\n                    }\n\n                    @Override\n                    public boolean get(BooleanEncodedValue property) {\n                        return edge.get(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {\n                        edge.set(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public boolean getReverse(BooleanEncodedValue property) {\n                        return edge.getReverse(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {\n                        edge.setReverse(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public int get(IntEncodedValue property) {\n                        return edge.get(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState set(IntEncodedValue property, int value) {\n                        edge.set(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public int getReverse(IntEncodedValue property) {\n                        return edge.getReverse(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {\n                        edge.setReverse(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public double get(DecimalEncodedValue property) {\n                        return edge.get(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState set(DecimalEncodedValue property, double value) {\n                        edge.set(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public double getReverse(DecimalEncodedValue property) {\n                        return edge.getReverse(property);\n                    }\n\n                    @Override\n                    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {\n                        edge.setReverse(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public <T extends Enum> T get(EnumEncodedValue<T> property) {\n                        return edge.get(property);\n                    }\n\n                    @Override\n                    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {\n                        edge.set(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {\n                        return edge.getReverse(property);\n                    }\n\n                    @Override\n                    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {\n                        edge.setReverse(property, value);\n                        return this;\n                    }\n\n                    @Override\n                    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            }\n\n            @Override\n            public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeExplorer createEdgeExplorer() {\n                return baseGraph.createEdgeExplorer(edgeFilter);\n            }\n\n            @Override\n            public Graph copyTo(Graph g) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public TurnCostExtension getTurnCostExtension() {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public int getOtherNode(int edge, int node) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public boolean isAdjacentToNode(int edge, int node) {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1290,
    "type": "Return",
    "comment": "@return {@link ContentDeliveryUnitCreator} for the resource.",
    "code": "public ContentHandlerFactory getContentDeliveryUnitCreator(String type) throws UnsupportedContentHandlerTypeException {\n    if (type == null) {\n        throw new IllegalArgumentException(STR);\n    }\n    for (int i = NUM; i < configLists.size(); i++) {\n        SmooksResourceConfigurationList list = configLists.get(i);\n        for (int ii = NUM; ii < list.size(); ii++) {\n            SmooksResourceConfiguration config = list.get(ii);\n            String selector = config.getSelector();\n            if (STR.equals(selector) && type.equalsIgnoreCase(config.getStringParameter(ContentHandlerFactory.PARAM_RESTYPE))) {\n                return (ContentHandlerFactory) getObject(config);\n            }\n        }\n    }\n    throw new UnsupportedContentHandlerTypeException(type);\n}",
    "label": 1,
    "rec": "@return {@link org.milyn.delivery.ContentHandlerFactory} for the resource."
  },
  {
    "id": 1291,
    "type": "Return",
    "comment": "@return an attributes in this relation",
    "code": "    private StructField parseAttribute() throws IOException, ParseException {\n        StructField attribute = null;\n\n        // Get attribute name.\n        getNextToken();\n        String attributeName = tokenizer.sval;\n        getNextToken();\n\n        // Check if attribute is nominal.\n        if (tokenizer.ttype == StreamTokenizer.TT_WORD) {\n            // Attribute is real, integer, or string.\n            if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_NUMERIC)) {\n                attribute = new StructField(attributeName, DataTypes.DoubleType);\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_REAL)) {\n                attribute = new StructField(attributeName, DataTypes.FloatType);\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_INTEGER)) {\n                attribute = new StructField(attributeName, DataTypes.IntegerType);\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_STRING)) {\n                attribute = new StructField(attributeName, DataTypes.StringType);\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_DATE)) {\n                if (tokenizer.nextToken() != StreamTokenizer.TT_EOL) {\n                    if ((tokenizer.ttype != StreamTokenizer.TT_WORD) && (tokenizer.ttype != '\\'') && (tokenizer.ttype != '\\\"')) {\n                        throw new ParseException(\"not a valid date format\", tokenizer.lineno());\n                    }\n                    attribute = new StructField(attributeName, DataTypes.datetime(tokenizer.sval));\n                    readTillEOL();\n                } else {\n                    attribute = new StructField(attributeName, DataTypes.DateTimeType);\n                    tokenizer.pushBack();\n                }\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_ATTRIBUTE_RELATIONAL)) {\n                logger.info(\"Encounter relational attribute {}. Flat out its attributes to top level.\", attributeName);\n                readTillEOL();\n\n            } else if (tokenizer.sval.equalsIgnoreCase(ARFF_END_SUBRELATION)) {\n                getNextToken();\n\n            } else {\n                throw new ParseException(\"Invalid attribute type or invalid enumeration\", tokenizer.lineno());\n            }\n\n        } else {\n\n            // Attribute is nominal.\n            List<String> attributeValues = new ArrayList<>();\n            tokenizer.pushBack();\n\n            // Get values for nominal attribute.\n            if (tokenizer.nextToken() != '{') {\n                throw new ParseException(\"{ expected at beginning of enumeration\", tokenizer.lineno());\n            }\n            while (tokenizer.nextToken() != '}') {\n                if (tokenizer.ttype == StreamTokenizer.TT_EOL) {\n                    throw new ParseException(\"} expected at end of enumeration\", tokenizer.lineno());\n                } else {\n                    attributeValues.add(tokenizer.sval.trim());\n                }\n            }\n\n            String[] values = new String[attributeValues.size()];\n            for (int i = 0; i < values.length; i++) {\n                values[i] = attributeValues.get(i);\n            }\n            attribute = new StructField(attributeName, DataTypes.StringType);//new NominalScale(values);\n        }\n\n        getLastToken(false);\n        getFirstToken();\n        if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n            throw new ParseException(PREMATURE_END_OF_FILE, tokenizer.lineno());\n        }\n\n        return attribute;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1292,
    "type": "Return",
    "comment": "@return directory name, or {@code \"default\"} if not found",
    "code": "public static String getSkinDirName(final HttpServletRequest request) {\n    if (Solos.isMobile(request)) {\n        return Solos.MOBILE_SKIN;\n    }\n    final String specifiedSkin = request.getParameter(Skin.SKIN);\n    if (StringUtils.isNotBlank(specifiedSkin)) {\n        final Set<String> skinDirNames = Skins.getSkinDirNames();\n        if (skinDirNames.contains(specifiedSkin)) {\n            return specifiedSkin;\n        } else {\n            return null;\n        }\n    }\n    return getSkinDirNameFromCookie(request);\n}",
    "label": 1,
    "rec": "@return directory name, or {@code null} if not found"
  },
  {
    "id": 1293,
    "type": "Return",
    "comment": "@return  Mode encoded by these bits",
    "code": "  public static Mode forBits(int bits) {\n    switch (bits) {\n      case 0x0:\n        return TERMINATOR;\n      case 0x1:\n        return NUMERIC;\n      case 0x2:\n        return ALPHANUMERIC;\n      case 0x3:\n        return STRUCTURED_APPEND;\n      case 0x4:\n        return BYTE;\n      case 0x5:\n        return FNC1_FIRST_POSITION;\n      case 0x7:\n        return ECI;\n      case 0x8:\n        return KANJI;\n      case 0x9:\n        return FNC1_SECOND_POSITION;\n      case 0xD:\n    \t  // 0xD is defined in GBT 18284-2000, may not be supported in foreign country\n        return HANZI;\n      default:\n        throw new IllegalArgumentException();\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1294,
    "type": "Return",
    "comment": "@return text encoded within the QR Code",
    "code": "  public DecoderResult decode(boolean[][] image) throws ReaderException {\n    int dimension = image.length;\n    BitMatrix bits = new BitMatrix(dimension);\n    for (int i = 0; i < dimension; i++) {\n      for (int j = 0; j < dimension; j++) {\n        if (image[i][j]) {\n          bits.set(i, j);\n        }\n      }\n    }\n    return decode(bits);\n  }\n",
    "label": 1,
    "rec": "@return text and bytes encoded within the QR Code"
  },
  {
    "id": 1295,
    "type": "Return",
    "comment": "@return true if the path was removed",
    "code": "    public boolean     removePath(String path)\n    {\n        return queue.remove(new PathHolder(path, reapingThresholdMs, null));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1296,
    "type": "Return",
    "comment": "@return A {@link AbstractBundle}object, or <code>null</code> if the identifier doesn't match any installed bundle.",
    "code": "public List<AbstractBundle> getBundleBySymbolicName(String symbolicName, Version version) {\n    synchronized (bundles) {\n        return bundles.getBundles(symbolicName, version);\n    }\n}",
    "label": 1,
    "rec": "@return A collection of {@link AbstractBundle} that match the symbolic name and version"
  },
  {
    "id": 1297,
    "type": "Return",
    "comment": "@return New MaterialData with the given data",
    "code": "    public MaterialData getNewData(final byte raw) {\n        try {\n            Constructor<? extends MaterialData> ctor = data.getConstructor(int.class, byte.class);\n\n            return ctor.newInstance(id, raw);\n        } catch (InstantiationException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IllegalArgumentException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (InvocationTargetException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchMethodException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (SecurityException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1298,
    "type": "Return",
    "comment": "@return BlockFace.TOP for upright (default), BlockFace.EAST (east-west), BlockFace.NORTH (north-sout), BlockFace.SELF (directionless)",
    "code": "    public BlockFace getDirection() {\n        switch ((getData() >> 2) & 0x3) {\n            case 0: // Up-down\n            default:\n                return BlockFace.UP;\n            case 1: // North-south\n                return BlockFace.WEST;\n            case 2: // East-west\n                return BlockFace.NORTH;\n            case 3: // Directionless (bark on all sides)\n                return BlockFace.SELF;\n        }\n    }\n",
    "label": 1,
    "rec": "@return BlockFace.TOP for upright (default), BlockFace.NORTH (east-west), BlockFace.WEST (north-sout), BlockFace.SELF (directionless)"
  },
  {
    "id": 1299,
    "type": "Return",
    "comment": "@return empty Set",
    "code": "    public static Set anySet() {\n        reportMatcher(new InstanceOf(Set.class));\n        return new HashSet(0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1300,
    "type": "Return",
    "comment": "@return the build target directory of the current project",
    "code": "public BuildOutputDirectory getTargetDirectory() {\n    return targetDirectory;\n}",
    "label": 1,
    "rec": "@return the build output directory of the current project"
  },
  {
    "id": 1301,
    "type": "Return",
    "comment": "@return Near future ID.",
    "code": "    public IgniteUuid nearFinishFutureId() {\n        return nearFinFutId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1302,
    "type": "Return",
    "comment": "@return the new float array backed by a buffer or an array",
    "code": "    public static FloatIndexer create(final FloatPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new FloatRawIndexer(pointer, sizes, strides)\n                                             : new FloatBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            float[] array = new float[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new FloatArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new float indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 1303,
    "type": "Return",
    "comment": "@return a new rule that assumes an existing running broker",
    "code": "\tpublic static ServerRunning isRunning() {\n\t\treturn new ServerRunning();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1304,
    "type": "Return",
    "comment": "@return  DetectorResult encapsulating results of detecting a QR Code",
    "code": "  public DetectorResult detect() throws NotFoundException {\n\n    ResultPoint[] cornerPoints = rectangleDetector.detect();\n    ResultPoint pointA = cornerPoints[0];\n    ResultPoint pointB = cornerPoints[1];\n    ResultPoint pointC = cornerPoints[2];\n    ResultPoint pointD = cornerPoints[3];\n\n    // Point A and D are across the diagonal from one another,\n    // as are B and C. Figure out which are the solid black lines\n    // by counting transitions\n    Vector transitions = new Vector(4);\n    transitions.addElement(transitionsBetween(pointA, pointB));\n    transitions.addElement(transitionsBetween(pointA, pointC));\n    transitions.addElement(transitionsBetween(pointB, pointD));\n    transitions.addElement(transitionsBetween(pointC, pointD));\n    Collections.insertionSort(transitions, new ResultPointsAndTransitionsComparator());\n\n    // Sort by number of transitions. First two will be the two solid sides; last two\n    // will be the two alternating black/white sides\n    ResultPointsAndTransitions lSideOne = (ResultPointsAndTransitions) transitions.elementAt(0);\n    ResultPointsAndTransitions lSideTwo = (ResultPointsAndTransitions) transitions.elementAt(1);\n\n    //give up if there is no chance we'll decode something...\n    if (lSideOne.transitions > MIN_GIVEUP_THRESHOLD ||\n        lSideTwo.transitions > MIN_GIVEUP_THRESHOLD) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    // Figure out which point is their intersection by tallying up the number of times we see the\n    // endpoints in the four endpoints. One will show up twice.\n    Hashtable pointCount = new Hashtable();\n    increment(pointCount, lSideOne.getFrom());\n    increment(pointCount, lSideOne.getTo());\n    increment(pointCount, lSideTwo.getFrom());\n    increment(pointCount, lSideTwo.getTo());\n\n    ResultPoint maybeTopLeft = null;\n    ResultPoint bottomLeft = null;\n    ResultPoint maybeBottomRight = null;\n    Enumeration points = pointCount.keys();\n    while (points.hasMoreElements()) {\n      ResultPoint point = (ResultPoint) points.nextElement();\n      Integer value = (Integer) pointCount.get(point);\n      if (value.intValue() == 2) {\n        bottomLeft = point; // this is definitely the bottom left, then -- end of two L sides\n      } else {\n        // Otherwise it's either top left or bottom right -- just assign the two arbitrarily now\n        if (maybeTopLeft == null) {\n          maybeTopLeft = point;\n        } else {\n          maybeBottomRight = point;\n        }\n      }\n    }\n\n    if (maybeTopLeft == null || bottomLeft == null || maybeBottomRight == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    // Bottom left is correct but top left and bottom right might be switched\n    ResultPoint[] corners = { maybeTopLeft, bottomLeft, maybeBottomRight };\n    // Use the dot product trick to sort them out\n    ResultPoint.orderBestPatterns(corners);\n\n    // Now we know which is which:\n    ResultPoint bottomRight = corners[0];\n    bottomLeft = corners[1];\n    ResultPoint topLeft = corners[2];\n\n    // Which point didn't we find in relation to the \"L\" sides? that's the top right corner\n    ResultPoint topRight;\n    if (!pointCount.containsKey(pointA)) {\n      topRight = pointA;\n    } else if (!pointCount.containsKey(pointB)) {\n      topRight = pointB;\n    } else if (!pointCount.containsKey(pointC)) {\n      topRight = pointC;\n    } else {\n      topRight = pointD;\n    }\n\n    // Next determine the dimension by tracing along the top or right side and counting black/white\n    // transitions. Since we start inside a black module, we should see a number of transitions\n    // equal to 1 less than the code dimension. Well, actually 2 less, because we are going to\n    // end on a black module:\n\n    // The top right point is actually the corner of a module, which is one of the two black modules\n    // adjacent to the white module at the top right. Tracing to that corner from either the top left\n    // or bottom right should work here.\n    int dimension = Math.max(transitionsBetween(topLeft, topRight).getTransitions(),\n                             transitionsBetween(bottomRight, topRight).getTransitions());\n    if ((dimension & 0x01) == 1) {\n      // it can't be odd, so, round... up?\n      dimension++;\n    }\n    dimension += 2;\n\n    //correct top right point to match the white module\n    ResultPoint correctedTopRight = correctTopRight(bottomLeft, bottomRight, topLeft, topRight, dimension);\n\n    //We redetermine the dimension using the corrected top right point\n    int dimension2 = Math.min(transitionsBetween(topLeft, correctedTopRight).getTransitions(),\n                              transitionsBetween(bottomRight, correctedTopRight).getTransitions());\n    dimension2++;\n    if ((dimension2 & 0x01) == 1) {\n      dimension2++;\n    }\n\n    BitMatrix bits = sampleGrid(image, topLeft, bottomLeft, bottomRight, correctedTopRight, dimension2);\n\n    return new DetectorResult(bits, new ResultPoint[]{topLeft, bottomLeft, bottomRight, correctedTopRight});\n  }\n",
    "label": 1,
    "rec": "@return  DetectorResult encapsulating results of detecting a Data Matrix Code"
  },
  {
    "id": 1305,
    "type": "Return",
    "comment": "@return a new session instance.",
    "code": "    public Session createSession(String host) {\n        return new SimpleSession(host);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1306,
    "type": "Return",
    "comment": "@return a nonce of the appropriate length for the given algorithm.",
    "code": "public static ByteString generateNonce(SecurityPolicy securityPolicy) {\n    return generateNonce(getNonceLength(securityPolicy));\n}",
    "label": 1,
    "rec": "@return a nonce of the appropriate length for the given security policy."
  },
  {
    "id": 1307,
    "type": "Return",
    "comment": "@return 2 preconfigured meta caches.",
    "code": "    private CacheConfiguration[] metaCaches(String... cacheNames) {\n        assertTrue(F.isEmpty(cacheNames) || cacheNames.length == 2);\n\n        if (F.isEmpty(cacheNames))\n            cacheNames = new String[] {metaCache1Name, metaCache2Name};\n\n        CacheConfiguration[] res = new CacheConfiguration[cacheNames.length];\n\n        for (int i = 0; i < cacheNames.length; i++) {\n            CacheConfiguration metaCache = defaultCacheConfiguration();\n\n            metaCache.setName(cacheNames[i]);\n            metaCache.setAtomicityMode(TRANSACTIONAL);\n            metaCache.setQueryIndexEnabled(false);\n\n            res[i] = metaCache;\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1308,
    "type": "Return",
    "comment": "@return the absolute file location to use for the given target or <code>null</code> if the given target is not managed",
    "code": "public File lookup(String managedFile, boolean add) throws IOException {\n    if (!open)\n        throw new IOException(EclipseAdaptorMsg.fileManager_notOpen);\n    Entry entry = (Entry) table.get(managedFile);\n    if (entry == null) {\n        if (add) {\n            add(managedFile);\n            entry = (Entry) table.get(managedFile);\n        } else {\n            return null;\n        }\n    }\n    return new File(getAbsolutePath(managedFile + STR + entry.getReadId()));\n}",
    "label": 1,
    "rec": "@return the absolute file location to use for the given managed file or <code>null</code> if the given managed file is not managed"
  },
  {
    "id": 1309,
    "type": "Return",
    "comment": "@return Size.",
    "code": "    private long size(String cacheName, IgniteKernal g) throws IgniteCheckedException {\n        if (offheap)\n            return ((IgniteKernal)g).getCache(cacheName).offHeapEntriesCount();\n\n        return g.context().swap().swapSize(swapSpaceName(cacheName, g));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1310,
    "type": "Return",
    "comment": "@return  True if portables should be deserialized,  false otherwise.",
    "code": "    private boolean deserializePortables(GridCacheContext cacheCtx) {\n        CacheOperationContext opCtx = cacheCtx.operationContextPerCall();\n\n        return opCtx == null || !opCtx.isKeepBinary();\n    }\n",
    "label": 1,
    "rec": "@return  True if binary should be deserialized,  false otherwise."
  },
  {
    "id": 1311,
    "type": "Return",
    "comment": "@return true if a and b are essentially equal, false otherwise.",
    "code": "  public static boolean equalsWithinOneSmallUlp(float a, float b) {\n    if (Float.isInfinite(a) || Float.isInfinite(b) && (a<b || b<a)) return false;\n    float ulp_a = Math.ulp(a);\n    float ulp_b = Math.ulp(b);\n    float small_ulp = Math.min(ulp_a, ulp_b);\n    float absdiff_a_b = Math.abs(a - b); // subtraction order does not matter, due to IEEE 754 spec\n    return absdiff_a_b <= small_ulp;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1312,
    "type": "Return",
    "comment": "@return an observable that emits the attached view or null.",
    "code": "public Observable<View> view() {\n    return views;\n}",
    "label": 1,
    "rec": "@return an observable that emits the current attached view or null."
  },
  {
    "id": 1313,
    "type": "Return",
    "comment": "@return fragment",
    "code": "    protected Fragment getFragment() {\n        FragmentProvider provider = getProvider();\n        if (provider != null)\n            return provider.getSelected();\n        else\n            return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1314,
    "type": "Return",
    "comment": "@return File file in which the response is stored",
    "code": "public File getTargetFile() {\n    if (frontendFile == null) {\n        frontendFile = getOriginalFile().isDirectory() ? getTargetFileByParsingURL() : getOriginalFile();\n    }\n    return frontendFile;\n}",
    "label": 1,
    "rec": "@return File final target file"
  },
  {
    "id": 1315,
    "type": "Return",
    "comment": "@return Multi bulk reply specifically a list of elements in the specified score range.",
    "code": "  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {\n    checkIsInMultiOrPipeline();\n    client.zrangeByScoreWithScores(key, min, max);\n    return getBinaryTupledSet();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1316,
    "type": "Return",
    "comment": "@return new {@code GcpKmsAeadKey} proto",
    "code": "@Override\npublic MessageLite newKey(MessageLite keyFormat) throws GeneralSecurityException {\n    if (!(keyFormat instanceof KmsAeadKeyFormat)) {\n        throw new GeneralSecurityException(STR);\n    }\n    KmsAeadKeyFormat format = (KmsAeadKeyFormat) keyFormat;\n    return KmsAeadKey.newBuilder().setParams(format).setVersion(VERSION).build();\n}",
    "label": 1,
    "rec": "@return new {@code KmsAeadKey} proto"
  },
  {
    "id": 1317,
    "type": "Return",
    "comment": "@return Collection of service descriptors.",
    "code": "    public Collection<ManagedServiceDescriptor> deployedServices() {\n        Collection<ManagedServiceDescriptor> descs = new ArrayList<>();\n\n        for (GridCacheEntry<Object, Object> e : cache.entrySetx()) {\n            if (!(e.getKey() instanceof GridServiceDeploymentKey))\n                continue;\n\n            GridServiceDeployment dep = (GridServiceDeployment)e.getValue();\n\n            ManagedServiceDescriptorImpl desc = new ManagedServiceDescriptorImpl(dep);\n\n            try {\n                GridServiceAssignments assigns = (GridServiceAssignments)cache.//flagsOn(GridCacheFlag.GET_PRIMARY).\n                    get(new GridServiceAssignmentsKey(dep.configuration().getName()));\n\n                if (assigns != null) {\n                    desc.topologySnapshot(assigns.assigns());\n\n                    descs.add(desc);\n                }\n            }\n            catch (GridException ex) {\n                log.error(\"Failed to get assignments from replicated cache for service: \" +\n                    dep.configuration().getName(), ex);\n            }\n        }\n\n        return descs;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1318,
    "type": "Return",
    "comment": "@return indicates if the locked memspace is valid. If false, the memspace has been invalidated and the snapshot index should be re-queried for a new address",
    "code": "@Override\npublic long lock(long address) {\n    long id = Thread.currentThread().getId();\n    if (UnsafeAdapter.getLong(address) != id) {\n        while (!UnsafeAdapter.compareAndSwapLong(null, address, UNLOCKED, id)) {\n            Thread.yield();\n        }\n    }\n    return UnsafeAdapter.getLong(address + UnsafeAdapter.LONG_SIZE);\n}",
    "label": 1,
    "rec": "@return the actual address of the mem-space"
  },
  {
    "id": 1319,
    "type": "Return",
    "comment": "@return Having.",
    "code": "    public GridSqlElement having() {\n        return havingCol >= 0 ? allExprs.get(havingCol) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1320,
    "type": "Return",
    "comment": "@return a {@link Claimer} with the above configuration.",
    "code": "public ProducerBarrier<T> createClaimer(final int bufferReserve, final EntryConsumer... entryConsumers) {\n    return new RingBufferProducerBarrier<T>(this, bufferReserve, entryConsumers);\n}",
    "label": 1,
    "rec": "@return a {@link ProducerBarrier} with the above configuration."
  },
  {
    "id": 1321,
    "type": "Return",
    "comment": "@return The timeout",
    "code": "    public long getTimeout(TimeUnit unit) {\n        return unit.convert(timeoutNs, TimeUnit.NANOSECONDS);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1322,
    "type": "Return",
    "comment": "@return a map of {item, ranking scores}",
    "code": "private List<Map.Entry<Integer, Double>> ranking(int u, Collection<Integer> ratedItems, Collection<Integer> candItems) throws Exception {\n    List<Map.Entry<Integer, Double>> itemRanks = new ArrayList<>(Lists.initSize(candItems));\n    for (final Integer j : candItems) {\n        if (!ratedItems.contains(j)) {\n            final double rank = ranking(u, j);\n            if (!Double.isNaN(rank)) {\n                itemRanks.add(new SimpleImmutableEntry<Integer, Double>(j, rank));\n            }\n        }\n    }\n    return itemRanks;\n}",
    "label": 1,
    "rec": "@return a collection of entry {item, ranking scores}"
  },
  {
    "id": 1323,
    "type": "Return",
    "comment": "@return Execution ID of task to be cancelled.",
    "code": "    public IgniteUuid sessionId() {\n        return sesId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1324,
    "type": "Return",
    "comment": "@return the annotation type.",
    "code": "public String getAnnotations() {\n    return (m_annotations != null ? m_annotations : m_defaultAnnotations).toString();\n}",
    "label": 1,
    "rec": "@return the annotation type for the suite."
  },
  {
    "id": 1325,
    "type": "Return",
    "comment": "@return the sampling rate for stochastic gradient tree boosting.",
    "code": "    public double getSamplingRate() {\n        return subsample;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1326,
    "type": "Return",
    "comment": "@return whether file was written successfully",
    "code": "public boolean write() {\n    if (isEmpty()) {\n        Log.warn(STR + getFullPath());\n        return true;\n    }\n    String pathAndName = getFullPath();\n    return data.saveAs(pathAndName);\n}",
    "label": 1,
    "rec": "@return Whether file was written successfully or is empty."
  },
  {
    "id": 1327,
    "type": "Return",
    "comment": "@return theme for page rendering, never null",
    "code": "    protected Theme getTheme() throws IOException {\n        return session.theme().getTheme(Theme.Type.ACCOUNT);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1328,
    "type": "Return",
    "comment": "@return temp instance",
    "code": "        public CuratorTempFramework buildTemp(long inactiveThreshold, TimeUnit unit)\n        {\n            return new CuratorTempFrameworkImpl(this, unit.toMillis(inactiveThreshold));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1329,
    "type": "Return",
    "comment": "@return estimated number of hashes needed to reverse the transaction. Zero if not seen in any block yet.",
    "code": "    public BigInteger getWorkDone(BlockChain chain) throws BlockStoreException {\n        if (getConfidenceType() != ConfidenceType.BUILDING)\n            throw new IllegalStateException(\"Confidence type is \" + getConfidenceType() + \", not BUILDING\");\n        BigInteger work = BigInteger.ZERO;\n        int depth = getDepthInBlocks(chain);\n        StoredBlock block = chain.getChainHead();\n        for (; depth > 0; depth--) {\n            work = work.add(block.getChainWork());\n            block = block.getPrev(chain.blockStore);\n        }\n        return work;\n    }\n",
    "label": 1,
    "rec": "@return estimated number of hashes needed to reverse the transaction."
  },
  {
    "id": 1330,
    "type": "Return",
    "comment": "@return the instance to use",
    "code": "    public ServiceInstance<T> getInstance() throws Exception\n    {\n        return providerStrategy.getInstance(instanceProvider);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1331,
    "type": "Return",
    "comment": "@return true if this instance has finished running (i.e. if state is FINISHED, ERROR or ABORTED",
    "code": "public boolean isFinished() {\n    return this.state.meansFinished();\n}",
    "label": 1,
    "rec": "@return true if this instance has finished running (delegates to this.state.meansFinished())"
  },
  {
    "id": 1332,
    "type": "Return",
    "comment": "@return Unmodifiable collection of counters.",
    "code": "    public GridHadoopCounters counters() {\n        return counters;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1333,
    "type": "Return",
    "comment": "@return a wrapper around {@code buffer} that ignores calls to {@link Buffer#close}.",
    "code": "public static ReadableBuffer ignoreClose(ReadableBuffer buffer) {\n    return new ForwardingReadableBuffer(buffer) {\n\n        @Override\n        public void close() {\n        }\n    };\n}",
    "label": 1,
    "rec": "@return a wrapper around {@code buffer} that ignores calls to {@link ReadableBuffer#close}."
  },
  {
    "id": 1334,
    "type": "Return",
    "comment": "@return Metrics adapter.",
    "code": "    private DiscoveryMetricsAdapter createMetrics(int waitingJobs, int activeJobs) {\n        DiscoveryMetricsAdapter metrics = new DiscoveryMetricsAdapter();\n\n        metrics.setCurrentWaitingJobs(waitingJobs);\n        metrics.setCurrentActiveJobs(activeJobs);\n\n        return metrics;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1335,
    "type": "Return",
    "comment": "@return true if the passed class has {@link SocketImpl} as a direct or indirect superclass",
    "code": "protected boolean isSocketImpl(CtClass clazz) throws NotFoundException {\n    if (Modifier.isAbstract(clazz.getModifiers()))\n        return false;\n    CtClass parent = clazz.getSuperclass();\n    while (parent != null && !parent.getName().equals(objectCtClass.getName())) {\n        if (parent.getName().equals(SOCK_NAME))\n            return true;\n        parent = parent.getSuperclass();\n    }\n    return false;\n}",
    "label": 1,
    "rec": "@return true if the passed class has {@link SocketImpl} as a direct or indirect superclass, is not abstract and does not already implement {@link ISocketImpl}"
  },
  {
    "id": 1336,
    "type": "Return",
    "comment": "@return a read context",
    "code": "    public static DocumentContext parse(File json) throws IOException {\n        return new ParseContextImpl().parse(json);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1337,
    "type": "Return",
    "comment": "@return the Student",
    "code": "public int getStudent() {\n    return student;\n}",
    "label": 1,
    "rec": "@return the Student ID"
  },
  {
    "id": 1338,
    "type": "Return",
    "comment": "@return Custom logger.",
    "code": "    public IgniteLogger logger() {\n        return logger;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1339,
    "type": "Return",
    "comment": "@return A valid instance or {@code null} if sanity checks failed.",
    "code": "private static UniversalFile create(String oneJarResource, String fileSystemLocation, boolean isDirectory) {\n    boolean isOneJarMode = false;\n    boolean resourceFound = false;\n    InputStream stream = UniversalFileCreator.class.getResourceAsStream(oneJarResource);\n    File file = new File(fileSystemLocation);\n    if (stream != null) {\n        isOneJarMode = true;\n        resourceFound = true;\n    }\n    if (file.exists()) {\n        isOneJarMode = false;\n        resourceFound = true;\n    }\n    if (!resourceFound) {\n        Log.error(TAG, STR + STR + oneJarResource + STR + fileSystemLocation + STR);\n        return null;\n    }\n    if (isOneJarMode && isDirectory) {\n        if (!oneJarResource.toLowerCase().endsWith(STR)) {\n            Log.error(TAG, STR + oneJarResource);\n            return null;\n        }\n    }\n    if (!isOneJarMode) {\n        if (file.isDirectory() != isDirectory) {\n            if (isDirectory) {\n                Log.error(TAG, STR + STR + fileSystemLocation);\n            } else {\n                Log.error(TAG, STR + STR + fileSystemLocation);\n            }\n            return null;\n        }\n    }\n    if (isOneJarMode) {\n        if (isDirectory) {\n            try {\n                return new UniversalFileFromJarFile(oneJarResource, new JarInputStream(stream));\n            } catch (IOException e) {\n                Log.error(TAG, STR + oneJarResource);\n                return null;\n            }\n        } else {\n            return new UniversalFileFromStreamResource(oneJarResource, stream);\n        }\n    } else {\n        if (isDirectory) {\n            return new UniversalFileFromFileSystemDirectory(file);\n        } else {\n            return new UniversalFileFromFileSystemFile(file);\n        }\n    }\n}",
    "label": 1,
    "rec": "@return A valid instance or {@code null} if resource could not be found or sanity checks failed."
  },
  {
    "id": 1340,
    "type": "Return",
    "comment": "@return results page",
    "code": "    public PageHandler getPage(String modelId, Integer categoryId) {\n        QueryHandler queryHandler = getQueryHandler(\"from CmsCategoryModel bean\");\n        if (CommonUtils.notEmpty(modelId)) {\n            queryHandler.condition(\"bean.id.modelId = :modelId\").setParameter(\"modelId\", modelId);\n        }\n        if (CommonUtils.notEmpty(categoryId)) {\n            queryHandler.condition(\"bean.id.categoryId = :categoryId\").setParameter(\"categoryId\", categoryId);\n        }\n        queryHandler.order(\"bean.id desc\");\n        PageHandler page = new PageHandler(1, null, 0, null);\n        page.setList(getList(queryHandler));\n        return page;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1341,
    "type": "Return",
    "comment": "@return true if address is in valid AB.CD.EF or (for X10) H.UU format",
    "code": "\tpublic static boolean s_isValid(String addr) {\n\t\tString[] fields = addr.split(\"\\\\.\");\n\t\tif (fields.length != 3) return false;\n\t\ttry{\n\t\t\t// convert the insteon xx.xx.xx address to integer to test\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tint test = Integer.parseInt(fields[2], 16) * 65536\n\t\t\t\t\t+ Integer.parseInt(fields[1], 16) * 256 +\n\t\t\t\t\t+ Integer.parseInt(fields[0], 16);\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "label": 1,
    "rec": "@return true if address is in valid AB.CD.EF format"
  },
  {
    "id": 1342,
    "type": "Return",
    "comment": "@return numBytes byte long array.",
    "code": "    public static byte[] bigIntegerToBytes(BigInteger b, int numBytes) {\n        byte[] bytes = new byte[numBytes];\n        byte[] biBytes = b.toByteArray();\n        int start = (biBytes.length == numBytes + 1) ? 1 : 0;\n        int length = Math.min(biBytes.length, numBytes);\n        System.arraycopy(biBytes, start, bytes, numBytes - length, length);\n        return bytes;        \n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1343,
    "type": "Return",
    "comment": "@return PSAgentAttemptId ps agent attempt id",
    "code": "public int getId() {\n    return id;\n}",
    "label": 1,
    "rec": "@return PSAgent ID"
  },
  {
    "id": 1344,
    "type": "Return",
    "comment": "@return Collection of write entries.",
    "code": "    public List<DataEntry> writeEntries() {\n        return writeEntries == null ? Collections.<DataEntry>emptyList() : writeEntries;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1345,
    "type": "Return",
    "comment": "@return <code>true</code>, if a property chunk must be written in order to store all needed values of tag.",
    "code": "private boolean isExtendedContentDescriptionMandatory(Tag tag) {\n    return !tag.isEmpty();\n}",
    "label": 1,
    "rec": "@return <code>true</code>, if an extended property chunk must be written in order to store tag values."
  },
  {
    "id": 1346,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String reCreateIndex(HttpServletRequest request, HttpSession session, ModelMap model) {\n        contentService.reCreateIndex();\n        SysSite site = siteComponent.getSite(request.getServerName());\n        Long userId = ControllerUtils.getAdminFromSession(session).getId();\n        logOperateService.save(new LogOperate(site.getId(), userId, LogLoginService.CHANNEL_WEB_MANAGER, \"reCreateIndex\",\n                RequestUtils.getIpAddress(request), CommonUtils.getDate(), CommonConstants.BLANK));\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1347,
    "type": "Return",
    "comment": "@return the new payload length",
    "code": "private TranslatedPayloadMetaData translateSingleFramePayloadLength(ByteBuffer buffer, Opcode optcode, int oldPayloadlength, int maxpacketsize, int oldRealpacketsize) throws InvalidFrameException, IncompleteException, LimitExceededException {\n    int payloadlength = oldPayloadlength, realpacketsize = oldRealpacketsize;\n    if (optcode == Opcode.PING || optcode == Opcode.PONG || optcode == Opcode.CLOSING) {\n        log.trace(STR);\n        throw new InvalidFrameException(STR);\n    }\n    if (payloadlength == NUM) {\n        realpacketsize += NUM;\n        translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);\n        byte[] sizebytes = new byte[NUM];\n        sizebytes[NUM] = buffer.get();\n        sizebytes[NUM] = buffer.get();\n        payloadlength = new BigInteger(sizebytes).intValue();\n    } else {\n        realpacketsize += NUM;\n        translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);\n        byte[] bytes = new byte[NUM];\n        for (int i = NUM; i < NUM; i++) {\n            bytes[i] = buffer.get();\n        }\n        long length = new BigInteger(bytes).longValue();\n        translateSingleFrameCheckLengthLimit(length);\n        payloadlength = (int) length;\n    }\n    return new TranslatedPayloadMetaData(payloadlength, realpacketsize);\n}",
    "label": 1,
    "rec": "@return the new payload data containing new payload length and new packet size"
  },
  {
    "id": 1348,
    "type": "Return",
    "comment": "@return Queue.",
    "code": "    private static IgniteQueue<String> initializeQueue(Ignite g, String queueName) throws IgniteException {\n        IgniteCollectionConfiguration colCfg = new IgniteCollectionConfiguration();\n\n        colCfg.setCacheName(CACHE_NAME);\n\n        // Initialize new FIFO queue.\n        IgniteQueue<String> queue = g.queue(queueName, colCfg, 0, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < g.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1349,
    "type": "Return",
    "comment": "@return The offer read",
    "code": "@Processor\n@InvalidateConnectionOn(exception = NotAuthenticatedException.class)\npublic Offer readOffer(String objectId) {\n    return (Offer) read(ServiceSourceCollection.Offers, objectId);\n}",
    "label": 1,
    "rec": "@return an instance of {@link org.mule.module.servicesource.model.offer.Offer}"
  },
  {
    "id": 1350,
    "type": "Return",
    "comment": "@return A new immutable path",
    "code": "    public HDPath extend(List<ChildNumber> path2) {\n        return this.extend(HDPath.M(path2));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1351,
    "type": "Return",
    "comment": "@return Query type.",
    "code": "    public String queryType() {\n        return qryType;\n    }\n",
    "label": 1,
    "rec": "@return Query type. Can be  \"SQL\",  \"TEXT\",  \"SCAN\" or  \"SPI\"."
  },
  {
    "id": 1352,
    "type": "Return",
    "comment": "@return Marshaller.",
    "code": "    public GridBinaryMarshaller marshaller() {\n        return portableMarsh;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1353,
    "type": "Return",
    "comment": "@return the {@link NetworkPartition}",
    "code": "public NetworkPartitionRef getNetworkPartitionByNetworkPartitionId(String networkPartitionId) {\n    if (networkPartitionRefs != null) {\n        for (NetworkPartitionRef networkPartition : networkPartitionRefs) {\n            if (networkPartition.getId().equals(networkPartitionId)) {\n                return networkPartition;\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the {@link NetworkPartitionRef}"
  },
  {
    "id": 1354,
    "type": "Return",
    "comment": "@return int time in milliseconds",
    "code": "    public int getTotalTimePercentile(double percentile) {\n        return rollingCommandLatencyStream.getTotalLatencyPercentile(percentile);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1355,
    "type": "Return",
    "comment": "@return An instance type for the local machine.",
    "code": "public static final InstanceType createDefaultInstanceType() {\n    final HardwareDescription hardwareDescription = HardwareDescriptionFactory.extractFromSystem();\n    int diskCapacityInGB = NUM;\n    final String tempDir = GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY, ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);\n    if (tempDir != null) {\n        File f = new File(tempDir);\n        diskCapacityInGB = (int) (f.getFreeSpace() / (NUM * NUM * NUM));\n    }\n    final int physicalMemory = (int) (hardwareDescription.getSizeOfPhysicalMemory() / (NUM * NUM));\n    return InstanceTypeFactory.construct(STR, hardwareDescription.getNumberOfCPUCores(), hardwareDescription.getNumberOfCPUCores(), physicalMemory, diskCapacityInGB, NUM);\n}",
    "label": 1,
    "rec": "@return the default instance type used for the local machine"
  },
  {
    "id": 1356,
    "type": "Return",
    "comment": "@return the speed in km/h",
    "code": "    public static double parseSpeed(String str) {\n        if (Helper.isEmpty(str))\n            return -1;\n\n        // on some German autobahns and a very few other places\n        if (\"none\".equals(str))\n            return MaxSpeed.UNLIMITED_SIGN_SPEED;\n\n        if (str.endsWith(\":rural\") || str.endsWith(\":trunk\"))\n            return 80;\n\n        if (str.endsWith(\":urban\"))\n            return 50;\n\n        if (str.equals(\"walk\") || str.endsWith(\":living_street\"))\n            return 6;\n\n        try {\n            int val;\n            // see https://en.wikipedia.org/wiki/Knot_%28unit%29#Definitions\n            int mpInteger = str.indexOf(\"mp\");\n            if (mpInteger > 0) {\n                str = str.substring(0, mpInteger).trim();\n                val = Integer.parseInt(str);\n                return val * DistanceCalcEarth.KM_MILE;\n            }\n\n            int knotInteger = str.indexOf(\"knots\");\n            if (knotInteger > 0) {\n                str = str.substring(0, knotInteger).trim();\n                val = Integer.parseInt(str);\n                return val * 1.852;\n            }\n\n            int kmInteger = str.indexOf(\"km\");\n            if (kmInteger > 0) {\n                str = str.substring(0, kmInteger).trim();\n            } else {\n                kmInteger = str.indexOf(\"kph\");\n                if (kmInteger > 0) {\n                    str = str.substring(0, kmInteger).trim();\n                }\n            }\n\n            return Integer.parseInt(str);\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1357,
    "type": "Return",
    "comment": "@return true if address is in valid AB.CD.EF format",
    "code": "\tpublic static boolean s_isValid(String addr) {\n\t\tif (addr == null) return false;\n\t\tif (X10.s_isValidAddress(addr)) return true;\n\t\tString[] fields = addr.split(\"\\\\.\");\n\t\tif (fields.length != 3) return false;\n\t\ttry{\n\t\t\t// convert the insteon xx.xx.xx address to integer to test\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tint test = Integer.parseInt(fields[2], 16) * 65536\n\t\t\t\t\t+ Integer.parseInt(fields[1], 16) * 256 +\n\t\t\t\t\t+ Integer.parseInt(fields[0], 16);\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "label": 1,
    "rec": "@return true if address is in valid AB.CD.EF or (for X10) H.UU format"
  },
  {
    "id": 1358,
    "type": "Return",
    "comment": "@return todoroo cursor. PLEASE CLOSE THIS CURSOR!",
    "code": "    private TodorooCursor<Metadata> getAlarmsForTask(long taskId) {\n        return PluginServices.getMetadataService().query(Query.select(AlarmFields.TIME).\n                join(Join.inner(Task.TABLE, Metadata.TASK.eq(Task.ID))).\n                where(Criterion.and(TaskCriteria.isActive(),\n                        MetadataCriteria.byTaskAndwithKey(taskId, AlarmFields.METADATA_KEY))));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1359,
    "type": "Return",
    "comment": "@return selected entry",
    "code": "public Word get(int index) {\n    return words.get(index);\n}",
    "label": 1,
    "rec": "@return selected word"
  },
  {
    "id": 1360,
    "type": "Return",
    "comment": "@return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.",
    "code": "    public long getBestHeight() {\n      return vPeerVersionMessage.bestHeight + blocksAnnounced.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1361,
    "type": "Return",
    "comment": "@return a NetworkParameters representing the network the address is intended for, or null if unknown.",
    "code": "    public NetworkParameters getParameters() {\n        return params;\n    }\n",
    "label": 1,
    "rec": "@return a NetworkParameters representing the network the address is intended for."
  },
  {
    "id": 1362,
    "type": "Return",
    "comment": "@return listenable",
    "code": "    public Listenable<PersistentNodeListener> getListenable()\n    {\n        return listeners;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1363,
    "type": "Return",
    "comment": "@return a BytesRef instance for the given ord",
    "code": "public BytesRef get(int ord, BytesRef ref) {\n    assert bytesStart != null : STR;\n    assert ord < bytesStart.length : STR + bytesStart.length;\n    return pool.setBytesRef(ref, bytesStart[ord]);\n}",
    "label": 1,
    "rec": "@return the given BytesRef instance populated with the bytes for the given ord"
  },
  {
    "id": 1364,
    "type": "Return",
    "comment": "@return Lazy iterator.",
    "code": "                    @Override public K getKey() {\n                        try {\n                            return unmarshalKey(cur0.getKey(), cctx.deploy().globalLoader());\n                        }\n                        catch (GridException e) {\n                            throw new GridRuntimeException(e);\n                        }\n                    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1365,
    "type": "Return",
    "comment": "@return the predicted class label. For MULTINOMIAL and BERNOULLI models, returns -1 if the instance does not contain any feature words.",
    "code": "    public int predict(SparseArray x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        if (posteriori == null) {\n            posteriori = new double[k];\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob = Math.log(priori[i]);\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += e.x * Math.log(condprob[i][e.i]);\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += Math.log(condprob[i][e.i]);\n                        } else {\n                            logprob += Math.log(1.0 - condprob[i][e.i]);\n                        }\n                    }\n                    break;\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        return label(posteriori);\n    }\n",
    "label": 1,
    "rec": "@return the predicted class label. If the instance is of all zeros, return returns Integer.MIN_VALUE."
  },
  {
    "id": 1366,
    "type": "Return",
    "comment": "@return Cancelled future ID.",
    "code": "    public IgniteUuid cancelledFutureId() {\n        return cancelledFutId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1367,
    "type": "Return",
    "comment": "@return true iff local can only be null for this flow info",
    "code": "public boolean canOnlyBeNull(VariableBinding binding) {\n    return isDefinitelyNull(binding) || isProtectedNull(binding);\n}",
    "label": 1,
    "rec": "@return true iff field or local can only be null for this flow info"
  },
  {
    "id": 1368,
    "type": "Return",
    "comment": "@return  True if success.",
    "code": "    private boolean waitCacheEmpty(IgniteCache<Integer, Object> cache, long timeout)\n        throws InterruptedException {\n        assert cache != null;\n        assert timeout >= 0;\n\n        long end = System.currentTimeMillis() + timeout;\n\n        while (end - System.currentTimeMillis() >= 0) {\n            if (cache.localSize() == 0)\n                return true;\n\n            Thread.sleep(500);\n        }\n\n        return cache.localSize() == 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1369,
    "type": "Return",
    "comment": "@return JSP.generatedInterfaceClass(), or if not specified, then Meta class' name removing \"Meta\" suffix, adding \"I\" prefix to simple name part. Eg: org.mypackage.MyCompMeta -> org.mypackage.IMyComp",
    "code": "public static String getGeneratedInterfaceClassName(Class metaClass) {\n    String jspGeneratedInterfaceClass = JSP.EMPTY;\n    if (metaClass.isAnnotationPresent(JSP.class)) {\n        JSP jsp = (JSP) metaClass.getAnnotation(JSP.class);\n        jspGeneratedInterfaceClass = jsp.generatedInterfaceClass();\n    }\n    return getSpecifiedOrAlternate(jspGeneratedInterfaceClass, JSP.EMPTY, metaClass.getName(), STR, STR, STR);\n}",
    "label": 1,
    "rec": "@return If the metaClass has a JSP annotation, then check for JSP.generatedInterfaceClass(), or if not specified, then Meta class' name removing \"Meta\" suffix, adding \"I\" prefix to simple name part. Eg: org.mypackage.MyCompMeta -> org.mypackage.IMyComp"
  },
  {
    "id": 1370,
    "type": "Return",
    "comment": "@return  True if all locks are owned.",
    "code": "    private boolean checkLocks() {\n        if (!locksReady)\n            return false;\n\n        synchronized (lockKeys) {\n            return lockKeys.isEmpty();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1371,
    "type": "Return",
    "comment": "@return a managed output stream for the target.",
    "code": "public ManagedOutputStream getOutputStream(String managedFile) throws IOException {\n    if (useReliableFiles) {\n        ReliableFileOutputStream out = new ReliableFileOutputStream(new File(getBase(), managedFile));\n        return new ManagedOutputStream(out, this, managedFile, null);\n    }\n    File tmpFile = createTempFile(managedFile);\n    return new ManagedOutputStream(new FileOutputStream(tmpFile), this, managedFile, tmpFile);\n}",
    "label": 1,
    "rec": "@return a managed output stream for the managed file."
  },
  {
    "id": 1372,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    public UUID readUuid() {\n        byte[] arr = readByteArray();\n\n        return arr != null ? IgniteByteUtils.bytesToUuid(arr, 0) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1373,
    "type": "Return",
    "comment": "@return ControllerSettings to setup needed params.",
    "code": "public BlurView setupWith(@NonNull ViewGroup rootView) {\n    BlurController blurController = new BlockingBlurController(this, rootView);\n    setBlurController(blurController);\n    if (!isHardwareAccelerated()) {\n        blurController.setBlurAutoUpdate(false);\n    }\n    return this;\n}",
    "label": 1,
    "rec": "@return {@link BlurView} to setup needed params."
  },
  {
    "id": 1374,
    "type": "Return",
    "comment": "@return Protobuff equivalent of the same",
    "code": "    public static RebalancePartitionInfoMap encodeRebalancePartitionInfoMap(RebalancePartitionsInfo stealInfo) {\n        return RebalancePartitionInfoMap.newBuilder()\n                                        .setStealerId(stealInfo.getStealerId())\n                                        .setDonorId(stealInfo.getDonorId())\n                                        .addAllReplicaToAddPartition(ProtoUtils.encodePerStorePartitionTuple(stealInfo.getStoreToReplicaToAddPartitionList()))\n                                        .setInitialCluster(new ClusterMapper().writeCluster(stealInfo.getInitialCluster()))\n                                        .build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1375,
    "type": "Return",
    "comment": "@return An empty {@link List} if no value is found for key.",
    "code": "@SuppressWarnings(STR)\npublic List<Toml> getTables(String key) {\n    List<Map<String, Object>> tableArray = (List<Map<String, Object>>) get(key);\n    if (tableArray == null) {\n        return null;\n    }\n    ArrayList<Toml> tables = new ArrayList<Toml>();\n    for (Map<String, Object> table : tableArray) {\n        tables.add(new Toml(null, table));\n    }\n    return tables;\n}",
    "label": 1,
    "rec": "@return A {@link List} of Toml instances or <code>null</code> if no value is found for key."
  },
  {
    "id": 1376,
    "type": "Return",
    "comment": "@return API response bean.",
    "code": "    BotApiResponse reply(List<String> to, List<Message> messages)\n            throws LineBotAPIException;\n\n    BotApiResponse push(List<String> to, List<Message> messages)\n            throws LineBotAPIException;\n\n    default BotApiResponse push(String to, Message messages)\n            throws LineBotAPIException {\n        return push(Collections.singletonList(to), Collections.singletonList(messages));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1377,
    "type": "Return",
    "comment": "@return {@link Repo} or null if unparseable",
    "code": "public static Repository getRepository(Uri uri) {\n    List<String> segments = uri.getPathSegments();\n    if (segments == null)\n        return null;\n    if (segments.size() < NUM)\n        return null;\n    String repoOwner = segments.get(NUM);\n    if (!RepositoryUtils.isValidOwner(repoOwner))\n        return null;\n    String repoName = segments.get(NUM);\n    if (!RepositoryUtils.isValidRepo(repoName))\n        return null;\n    return InfoUtils.createRepoFromData(repoOwner, repoName);\n}",
    "label": 1,
    "rec": "@return {@link Repository} or null if unparseable"
  },
  {
    "id": 1378,
    "type": "Return",
    "comment": "@return Filter.",
    "code": "    private IgnitePredicate<GridCacheMvccCandidate<K>> nodeIdFilter(final UUID nodeId) {\n        if (nodeId == null)\n            return F.alwaysTrue();\n\n        return new P1<GridCacheMvccCandidate<K>>() {\n            @Override public boolean apply(GridCacheMvccCandidate<K> c) {\n                UUID otherId = c.otherNodeId();\n\n                return c.nodeId().equals(nodeId) || (otherId != null && otherId.equals(nodeId));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1379,
    "type": "Return",
    "comment": "@return the cipher",
    "code": "public String getCipher() {\n    return cipherName;\n}",
    "label": 1,
    "rec": "@return the cipherName"
  },
  {
    "id": 1380,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteInternalFuture<IgniteInternalTx> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteInternalFuture<IgniteInternalTx>)(IgniteInternalFuture)prep;\n\n            return new GridFinishedFuture<IgniteInternalTx>(cctx.kernalContext(), this);\n        }\n\n        final GridDhtTxFinishFuture fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (IgniteTxOptimisticCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listenAsync(new CI1<IgniteInternalFuture<IgniteInternalTx>>() {\n                @Override public void apply(IgniteInternalFuture<IgniteInternalTx> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (IgniteTxOptimisticCheckedException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (IgniteCheckedException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1381,
    "type": "Return",
    "comment": "@return The binary size of the string (length + 2).",
    "code": "public static int size(String name) {\n    if (name.isEmpty())\n        return NUM;\n    return name.length() + NUM;\n}",
    "label": 1,
    "rec": "@return The binary size of the string."
  },
  {
    "id": 1382,
    "type": "Return",
    "comment": "@return Cluster configuration.",
    "code": "    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            return fromProperties(props);\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1383,
    "type": "Return",
    "comment": "@return fully constructed Node",
    "code": "public static Node buildNode(String content) {\n    return buildNode(null, content);\n}",
    "label": 1,
    "rec": "@return fully constructed root node"
  },
  {
    "id": 1384,
    "type": "Return",
    "comment": "@return Topology version.",
    "code": "        private AffinityTopologyVersion topologyVersion() {\n            return topVer;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1385,
    "type": "Return",
    "comment": "@return File id already stored in meta cache or  null if passed file info was stored.",
    "code": "    public GridGgfsFileInfo putIfAbsent(GridUuid parentId, String fileName, GridGgfsFileInfo newFileInfo)\n        throws GridException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert validTxState(false);\n                assert parentId != null;\n                assert fileName != null;\n                assert newFileInfo != null;\n\n                GridGgfsFileInfo res = null;\n\n                GridCacheTx tx = metaCache.txStart(PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    res = putIfAbsentNonTx(parentId, fileName, newFileInfo);\n\n                    tx.commit();\n                }\n                finally {\n                    tx.close();\n                }\n\n                return res;\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to put file because Grid is stopping [parentId=\" + parentId +\n                \", fileName=\" + fileName + \", newFileInfo=\" + newFileInfo + ']');\n    }\n",
    "label": 1,
    "rec": "@return File info already stored in meta cache or  null if passed file info was stored."
  },
  {
    "id": 1386,
    "type": "Return",
    "comment": "@return null if no list by this id exists, otherwise list name",
    "code": "    public String getList(String listId) {\n        TodorooCursor<MilkList> cursor = milkListDao.query(Query.select(\n                MilkList.NAME).where(MilkList.ID.eq(listId)));\n        try {\n            if(cursor.getCount() == 0)\n                return null;\n            cursor.moveToFirst();\n            return cursor.get(MilkList.NAME);\n        } finally {\n            cursor.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1387,
    "type": "Return",
    "comment": "@return the decrypted fragment.",
    "code": "private byte[] decryptFragment(byte[] ciphertextFragment) throws GeneralSecurityException {\n    if (session == null) {\n        return ciphertextFragment;\n    }\n    byte[] fragment = ciphertextFragment;\n    CipherSuite cipherSuite = session.getReadState().getCipherSuite();\n    LOGGER.log(Level.FINER, STR, session.getReadState());\n    switch(cipherSuite.getCipherType()) {\n        case NULL:\n            break;\n        case AEAD:\n            fragment = decryptAEAD(ciphertextFragment);\n            break;\n        case BLOCK:\n            fragment = decryptBlockCipher(ciphertextFragment);\n            break;\n        case STREAM:\n            break;\n        default:\n            break;\n    }\n    return fragment;\n}",
    "label": 1,
    "rec": "@return the (de-crypted) TLSPlaintext.fragment"
  },
  {
    "id": 1388,
    "type": "Return",
    "comment": "@return  True if transaction has been committed or rolled back,  false otherwise.",
    "code": "    public boolean isCompleted(IgniteTxEx<K, V> tx) {\n        return completedVers.containsKey(tx.xidVersion());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1389,
    "type": "Return",
    "comment": "@return true if {@param headerViewId} is not 0, false otherwise",
    "code": "private boolean hasHeader() {\n    return headerViewId != NUM || headerView != null;\n}",
    "label": 1,
    "rec": "@return true if {@param headerViewId} is not 0 or if {@param headerView} is not null, false otherwise"
  },
  {
    "id": 1390,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte geq(byte value) {\n        reportMatcher(new GreaterOrEqual<Byte>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1391,
    "type": "Return",
    "comment": "@return the build date of the version",
    "code": "public Optional<String> getBuildDate() {\n    return Optional.ofNullable(buildDate);\n}",
    "label": 1,
    "rec": "@return the build date of the version or null (in case this isn't a real build but runs in an IDE etc.)"
  },
  {
    "id": 1392,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static float floatThat(Matcher<Float> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1393,
    "type": "Return",
    "comment": "@return the JobInfo object",
    "code": "private static InputJobInfo getJobInfo(JobContext jobContext) throws Exception {\n    String jobString = jobContext.getConfiguration().get(HCatConstants.HCAT_KEY_JOB_INFO);\n    if (jobString == null) {\n        throw new Exception(STR);\n    }\n    return (InputJobInfo) HCatUtil.deserialize(jobString);\n}",
    "label": 1,
    "rec": "@return the InputJobInfo object"
  },
  {
    "id": 1394,
    "type": "Return",
    "comment": "@return enum value",
    "code": "\tpublic static APICode getAPICodeValue(String code) {\n\t\tAPICode apiCode;\n\t\t\n\t\tif (codeToAPICodeValue == null) {\n\t\t\tinitMapping();\n\t\t}\n\t\t\n\t\tapiCode = codeToAPICodeValue.get(code);\n\t\t\n\t\tif(apiCode == null)\n\t\t\tapiCode = UnknownCode;\n\t\t\n\t\treturn apiCode;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1395,
    "type": "Return",
    "comment": "@return the pointcut",
    "code": "public Expression getExpression() {\n    return m_expression;\n}",
    "label": 1,
    "rec": "@return the expression"
  },
  {
    "id": 1396,
    "type": "Return",
    "comment": "@return the weighting to be used for route calculation",
    "code": "    public Weighting createWeighting( String weighting, FlagEncoder encoder )\n    {\n        // ignore case\n        weighting = weighting.toLowerCase();\n        if (\"shortest\".equals(weighting))\n            return new ShortestWeighting();\n        return new FastestWeighting(encoder);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1397,
    "type": "Return",
    "comment": "@return get method list",
    "code": "public static Map<String, String> getAllGetterMethods(PsiClass psiClass, String currentMethodName) {\n    Map<String, String> methodNames = new HashMap<String, String>();\n    PsiMethod[] psiMethods = null;\n    String prefix = STR;\n    if (!currentMethodName.contains(STR)) {\n        psiMethods = psiClass.getAllMethods();\n    } else {\n        prefix = currentMethodName.substring(NUM, currentMethodName.lastIndexOf(STR));\n        String getterMethod = STR + StringUtil.capitalize(prefix);\n        PsiClass psiFieldClass = findGetterMethodReturnType(psiClass, getterMethod);\n        if (psiFieldClass != null) {\n            psiMethods = psiFieldClass.getAllMethods();\n            prefix = prefix + STR;\n        }\n    }\n    if (psiMethods != null && psiMethods.length > NUM) {\n        for (PsiMethod psiMethod : psiMethods) {\n            String methodName = psiMethod.getName();\n            if (methodName.startsWith(STR) && psiMethod.getParameterList().getParametersCount() == NUM) {\n                String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(STR, STR));\n                String type = psiMethod.getReturnType().getPresentableText();\n                methodNames.put(name, type);\n            }\n            if (methodName.startsWith(STR) && psiMethod.getParameterList().getParametersCount() == NUM) {\n                String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(STR, STR));\n                String type = psiMethod.getReturnType().getPresentableText();\n                methodNames.put(name, type);\n            }\n        }\n    }\n    methodNames.remove(STR);\n    return methodNames;\n}",
    "label": 1,
    "rec": "@return get method list without prefix"
  },
  {
    "id": 1398,
    "type": "Return",
    "comment": "@return null.",
    "code": "    public static String startsWith(String prefix) {\n        return LastArguments.instance().reportMatcher(new StartsWith(prefix)).<String>nullValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1399,
    "type": "Return",
    "comment": "@return true if ValueType is a ENTITY or COLLECTION_ENTITY, otherwise false",
    "code": "public boolean isEntity() {\n    return getValueType() == ValueType.ENTITY || getValueType() == ValueType.COLLECTION_ENTITY;\n}",
    "label": 1,
    "rec": "@return true if the value type is ENTITY or COLLECTION_ENTITY, otherwise false"
  },
  {
    "id": 1400,
    "type": "Return",
    "comment": "@return Integer reply, this commands will reply with the new value of key after the increment.",
    "code": "    public Long incrBy(final byte[] key, final int integer) {\n        checkIsInMulti();\n        client.incrBy(key, integer);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1401,
    "type": "Return",
    "comment": "@return Returns greater than zero when this.floatValue() > object.floatValue(), zero when this.floatValue() == object.floatValue(), and less than zero when this.floatValue() < object.floatValue()",
    "code": "public int compareTo(Float object) {\n    int f1, f2;\n    int NaNbits = Float.floatToIntBits(Float.NaN);\n    if ((f1 = Float.floatToIntBits(value)) == NaNbits) {\n        if (Float.floatToIntBits(object.value) == NaNbits) {\n            return NUM;\n        }\n        return NUM;\n    }\n    if ((f2 = Float.floatToIntBits(object.value)) == NaNbits) {\n        return -NUM;\n    }\n    if (value == object.value) {\n        if (f1 == f2) {\n            return NUM;\n        }\n        return f1 > f2 ? NUM : -NUM;\n    }\n    return value > object.value ? NUM : -NUM;\n}",
    "label": 1,
    "rec": "@return Returns greater than zero when this.floatValue() is greater than object.floatValue(), zero when this.floatValue() equals object.floatValue(), and less than zero when this.floatValue() is less than object.floatValue()"
  },
  {
    "id": 1402,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(SparseMatrix[] data, int fold) throws Exception {\n\n\t\tSparseMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\n\t\t/* baselines */\n\t\t\tcase \"globalavg\":\n\t\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\t\tcase \"useravg\":\n\t\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\t\tcase \"itemavg\":\n\t\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\t\tcase \"random\":\n\t\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\t\tcase \"constant\":\n\t\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\t\tcase \"mostpop\":\n\t\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\n\t\t\t\t/* rating prediction */\n\t\t\tcase \"userknn\":\n\t\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\t\tcase \"itemknn\":\n\t\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\t\tcase \"regsvd\":\n\t\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\t\tcase \"biasedmf\":\n\t\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"svd++\":\n\t\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\t\tcase \"pmf\":\n\t\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"bpmf\":\n\t\t\t\treturn new BPMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"socialmf\":\n\t\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"trustmf\":\n\t\t\t\treturn new TrustMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"sorec\":\n\t\t\t\treturn new SoRec(trainMatrix, testMatrix, fold);\n\t\t\tcase \"soreg\":\n\t\t\t\treturn new SoReg(trainMatrix, testMatrix, fold);\n\t\t\tcase \"rste\":\n\t\t\t\treturn new RSTE(trainMatrix, testMatrix, fold);\n\t\t\tcase \"trustsvd\":\n\t\t\t\treturn new TrustSVD(trainMatrix, testMatrix, fold);\n\n\t\t\t\t/* item ranking */\n\t\t\tcase \"climf\":\n\t\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"fismrmse\":\n\t\t\t\treturn new FISMrmse(trainMatrix, testMatrix, fold);\n\t\t\tcase \"fism\":\n\t\t\tcase \"fismauc\":\n\t\t\t\treturn new FISMauc(trainMatrix, testMatrix, fold);\n\t\t\tcase \"rankals\":\n\t\t\t\treturn new RankALS(trainMatrix, testMatrix, fold);\n\t\t\tcase \"ranksgd\":\n\t\t\t\treturn new RankSGD(trainMatrix, testMatrix, fold);\n\t\t\tcase \"wrmf\":\n\t\t\t\treturn new WRMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"bpr\":\n\t\t\t\treturn new BPR(trainMatrix, testMatrix, fold);\n\t\t\tcase \"gbpr\":\n\t\t\t\treturn new GBPR(trainMatrix, testMatrix, fold);\n\t\t\tcase \"sbpr\":\n\t\t\t\treturn new SBPR(trainMatrix, testMatrix, fold);\n\t\t\tcase \"slim\":\n\t\t\t\treturn new SLIM(trainMatrix, testMatrix, fold);\n\n\t\t\t\t/* extension */\n\t\t\tcase \"nmf\":\n\t\t\t\treturn new NMF(trainMatrix, testMatrix, fold);\n\t\t\tcase \"hybrid\":\n\t\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\t\tcase \"slopeone\":\n\t\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\t\t\tcase \"pd\":\n\t\t\t\treturn new PD(trainMatrix, testMatrix, fold);\n\t\t\tcase \"ar\":\n\t\t\t\treturn new AR(trainMatrix, testMatrix, fold);\n\t\t\tcase \"prankd\":\n\t\t\t\treturn new PRankD(trainMatrix, testMatrix, fold);\n\n\t\t\tdefault:\n\t\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1403,
    "type": "Return",
    "comment": "@return property value or null if no property was found",
    "code": "protected Object getPropertyValue(String name, Class type) {\n    if (getReference().isReadableProperty(name) && getReference().getPropertyType(name).equals(type)) {\n        return getReference().getPropertyValue(name);\n    } else {\n        try {\n            Field field = getReference().getWrappedClass().getField(name);\n            if (Modifier.isStatic(field.getModifiers()) && Modifier.isPublic(field.getModifiers()) && field.getType().equals(type)) {\n                return field.get(getReference().getWrappedInstance());\n            }\n        } catch (NoSuchFieldException e) {\n        } catch (IllegalAccessException e) {\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return property value or null if no property or static field was found"
  },
  {
    "id": 1404,
    "type": "Return",
    "comment": "@return GGFS exception.",
    "code": "    public static GridGgfsException cast(String msg, IOException e) {\n        if (e instanceof FileNotFoundException)\n            return new GridGgfsFileNotFoundException(e);\n        else if (e instanceof ParentNotDirectoryException)\n            return new GridGgfsParentNotDirectoryException(msg, e);\n        else if (e instanceof PathIsNotEmptyDirectoryException)\n            return new GridGgfsDirectoryNotEmptyException(e);\n        else if (e instanceof PathExistsException)\n            return new IgniteFsPathAlreadyExistsException(msg, e);\n        else\n            return new GridGgfsException(msg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1405,
    "type": "Return",
    "comment": "@return the iterable children Axis of this node.",
    "code": "public Axis children() {\n    return new Axis(this) {\n\n        @Override\n        public Iterator<Node> iterator(final ContentRange range, final boolean includeText) {\n            return new ChildrenAndText(range, includeText);\n        }\n    };\n}",
    "label": 1,
    "rec": "@return the iterable children Axis of this parent."
  },
  {
    "id": 1406,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage getValueMessage() {\n\t\tlogger.debug(\"Creating new message for application command METER_GET for node {}\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData,\n\t\t\t\tSerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Get);\n\t\tbyte[] newPayload = { (byte) this.getNode().getNodeId(), 2, (byte) getCommandClass().getKey(),\n\t\t\t\t(byte) METER_GET };\n\t\tresult.setMessagePayload(newPayload);\n\t\treturn result;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1407,
    "type": "Return",
    "comment": "@return The {@link ModelClass} converted from the cursor",
    "code": "public TModel getItem(long position) {\n    throwIfCursorClosed();\n    TModel model = null;\n    if (cacheModels) {\n        model = modelCache.get(position);\n        if (model == null && cursor.moveToPosition((int) position)) {\n            model = SqlUtils.convertToModel(true, table, cursor);\n            modelCache.addModel(position, model);\n        }\n    } else if (cursor.moveToPosition((int) position)) {\n        model = SqlUtils.convertToModel(true, table, cursor);\n    }\n    return model;\n}",
    "label": 1,
    "rec": "@return The {@link TModel} converted from the cursor"
  },
  {
    "id": 1408,
    "type": "Return",
    "comment": "@return the userInfo",
    "code": "    public String getUserInfo() {\n    \treturn userInfo;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1409,
    "type": "Return",
    "comment": "@return true if a builtin function was found",
    "code": "protected Expression buildForBuiltInFunction(ParserRuleContext ctx, String functionName, ArrayList<ParameterExpression> paramExpressions) {\n    try {\n        if (functions.contains(functionName)) {\n            return null;\n        }\n        Expression lsf = handleLanguageSpecificFunction(ctx, functionName, paramExpressions);\n        if (lsf != null) {\n            setFileLineColumn(lsf, ctx);\n            return lsf;\n        }\n        BuiltinFunctionExpression bife = BuiltinFunctionExpression.getBuiltinFunctionExpression(ctx, functionName, paramExpressions, currentFile);\n        if (bife != null) {\n            return bife;\n        }\n        ParameterizedBuiltinFunctionExpression pbife = ParameterizedBuiltinFunctionExpression.getParamBuiltinFunctionExpression(ctx, functionName, paramExpressions, currentFile);\n        if (pbife != null) {\n            return pbife;\n        }\n        DataExpression dbife = DataExpression.getDataExpression(ctx, functionName, paramExpressions, currentFile, errorListener);\n        if (dbife != null) {\n            return dbife;\n        }\n    } catch (Exception e) {\n        notifyErrorListeners(STR + functionName + STR + e.getMessage(), ctx.start);\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return expression if found otherwise null"
  },
  {
    "id": 1410,
    "type": "Return",
    "comment": "@return Affinity nodes.",
    "code": "    public List<GridNode> get(int part) {\n        assert part >= 0 && part < assignment.size() : \"Affinity partition is out of range\" +\n            \" [part=\" + part + \", partitions=\" + assignment.size() + ']';\n\n        return assignment.get(part);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1411,
    "type": "Return",
    "comment": "@return the icon default color",
    "code": "public int getColor() {\n    return mIconBrush.getColorForCurrentState();\n}",
    "label": 1,
    "rec": "@return the icon color"
  },
  {
    "id": 1412,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private Frame reBalance(final Frame fr, boolean local) {\n    final int chunks = (int)Math.min( 4 * H2O.NUMCPUS * (local ? 1 : H2O.CLOUD.size()), fr.numRows());\n    if (fr.anyVec().nChunks() > chunks) {\n      Log.info(\"Dataset already contains \" + fr.anyVec().nChunks() + \" chunks. No need to rebalance.\");\n      return fr;\n    }\n    if (!quiet_mode) Log.info(\"ReBalancing dataset into (at least) \" + chunks + \" chunks.\");\n//      return MRUtils.shuffleAndBalance(fr, chunks, seed, local, shuffle_training_data);\n    Key newKey = fr._key != null ? Key.make(fr._key.toString() + \".balanced\") : Key.make();\n    newKey = Key.makeUserHidden(newKey);\n    RebalanceDataSet rb = new RebalanceDataSet(fr, newKey, chunks);\n    H2O.submitTask(rb);\n    rb.join();\n    return UKV.get(newKey);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1413,
    "type": "Return",
    "comment": "@return Returns greater than zero when float1 > float2, zero when float1 == float2, and less than zero when float1 < float2",
    "code": "public static int compare(float float1, float float2) {\n    int f1, f2;\n    int NaNbits = Float.floatToIntBits(Float.NaN);\n    if ((f1 = Float.floatToIntBits(float1)) == NaNbits) {\n        if (Float.floatToIntBits(float2) == NaNbits) {\n            return NUM;\n        }\n        return NUM;\n    }\n    if ((f2 = Float.floatToIntBits(float2)) == NaNbits) {\n        return -NUM;\n    }\n    if (float1 == float2) {\n        if (f1 == f2) {\n            return NUM;\n        }\n        return f1 > f2 ? NUM : -NUM;\n    }\n    return float1 > float2 ? NUM : -NUM;\n}",
    "label": 1,
    "rec": "@return Returns greater than zero when float1 is greater than float2, zero when float1 equals float2, and less than zero when float1 is less than float2"
  },
  {
    "id": 1414,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String login(@PathVariable(\"channel\") String channel, String returnUrl, HttpServletRequest request,\n            HttpServletResponse response) {\n        OauthGateway oauthGateway = oauthComponent.get(channel);\n        SysSite site = siteComponent.getSite(request.getServerName());\n        if (null != oauthComponent && oauthGateway.enabled(site.getId())) {\n            String state = UUID.randomUUID().toString();\n            RequestUtils.addCookie(request.getContextPath(), response, STATE_COOKIE_NAME, state, null, null);\n            RequestUtils.addCookie(request.getContextPath(), response, RETURN_URL, returnUrl, null, null);\n            return UrlBasedViewResolver.REDIRECT_URL_PREFIX + oauthGateway.getAuthorizeUrl(site.getId(), state);\n        }\n        return UrlBasedViewResolver.REDIRECT_URL_PREFIX + site.getDynamicPath();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1415,
    "type": "Return",
    "comment": "@return the id of the inserted statistics marker, or -1 on error",
    "code": "public long insertWaypoint(WaypointType type) throws Exception {\n    if (trackRecordingService == null) {\n        throw new IllegalStateException(STR);\n    }\n    try {\n        long waypointId = trackRecordingService.insertWaypoint(type);\n        if (waypointId >= NUM) {\n            Toast.makeText(this, R.string.status_statistics_inserted, Toast.LENGTH_LONG).show();\n            return waypointId;\n        } else {\n            Toast.makeText(this, R.string.error_unable_to_insert_marker, Toast.LENGTH_LONG).show();\n            throw new Exception(STR);\n        }\n    } catch (Exception e) {\n        Toast.makeText(this, R.string.error_unable_to_insert_marker, Toast.LENGTH_LONG).show();\n        throw e;\n    }\n}",
    "label": 1,
    "rec": "@return Id of the inserted statistics marker."
  },
  {
    "id": 1416,
    "type": "Return",
    "comment": "@return null if an access token was obtained, otherwise a challenge is returned",
    "code": "    protected KeycloakChallenge resolveCode(String code) {\n        // abort if not HTTPS\n        if (realmInfo.isSslRequired() && !isRequestSecure()) {\n            log.error(\"SSL is required\");\n            return challenge(StatusCodes.FORBIDDEN);\n        }\n\n        log.info(\"checking state cookie for after code\");\n        KeycloakChallenge challenge = checkStateCookie();\n        if (challenge != null) return challenge;\n\n        AccessTokenResponse tokenResponse = null;\n        String redirectUri = stripOauthParametersFromRedirect();\n        try {\n            tokenResponse = TokenGrantRequest.invoke(realmInfo, code, redirectUri);\n        } catch (TokenGrantRequest.HttpFailure failure) {\n            log.error(\"failed to turn code into token\");\n            log.error(\"status from server: \" + failure.getStatus());\n            if (failure.getStatus() == StatusCodes.BAD_REQUEST && failure.getError() != null) {\n                log.error(\"   \" + failure.getError());\n            }\n            return challenge(StatusCodes.FORBIDDEN);\n\n        } catch (IOException e) {\n            log.error(\"failed to turn code into token\");\n            return challenge(StatusCodes.FORBIDDEN);\n        }\n\n        tokenString = tokenResponse.getToken();\n        try {\n            token = RSATokenVerifier.verifyToken(tokenString, realmInfo.getMetadata().getRealmKey(), realmInfo.getMetadata().getRealm());\n            log.debug(\"Token Verification succeeded!\");\n        } catch (VerificationException e) {\n            log.error(\"failed verification of token\");\n            return challenge(StatusCodes.FORBIDDEN);\n        }\n        log.info(\"successful authenticated\");\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1417,
    "type": "Return",
    "comment": "@return the updated sequenceBatch.",
    "code": "public BatchDescriptor next(final BatchDescriptor batchDescriptor) {\n    if (null == gatingSequences) {\n        throw new NullPointerException(STR);\n    }\n    final long sequence = claimStrategy.incrementAndGet(batchDescriptor.getSize(), gatingSequences);\n    batchDescriptor.setEnd(sequence);\n    return batchDescriptor;\n}",
    "label": 1,
    "rec": "@return the updated batchDescriptor."
  },
  {
    "id": 1418,
    "type": "Return",
    "comment": "@return invocation",
    "code": "    public InvocationImpl toInvocation() {\n        if (method == null) {\n            List<Class> argTypes = new LinkedList<Class>();\n            for (Object arg : args) {\n                if (arg == null) {\n                    argTypes.add(Object.class);\n                } else {\n                    argTypes.add(arg.getClass());\n                }\n            }\n            \n            try {\n                method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n            } catch (Exception e) {\n                throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n            }\n        }\n        \n        InvocationImpl i = new InvocationImpl(mock, new SerializableMethod(method), args, sequenceNumber, null);\n        if (verified) {\n            i.markVerified();\n        }\n        return i;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1419,
    "type": "Return",
    "comment": "@return The {@link com.android.sdklib.SdkManager.LayoutlibVersion}, or {@code null} if both the api and revision are unspecified.",
    "code": "@Nullable\npublic LayoutlibVersion getLayoutlibVersion() {\n    if (mLayoutlibVersion.getFirst() != LAYOUTLIB_API_NOT_SPECIFIED || mLayoutlibVersion.getSecond() != LAYOUTLIB_REV_NOT_SPECIFIED) {\n        return new LayoutlibVersion(mLayoutlibVersion.getFirst(), mLayoutlibVersion.getSecond());\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return The {@link LayoutlibVersion}, or {@code null} if both the api and revision are unspecified."
  },
  {
    "id": 1420,
    "type": "Return",
    "comment": "@return the weighting to be used for route calculation",
    "code": "    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, TurnCostProvider turnCostProvider) {\n        String weightingStr = toLowerCase(hintsMap.getWeighting());\n        Weighting weighting = null;\n\n        if (\"shortest\".equalsIgnoreCase(weightingStr)) {\n            weighting = new ShortestWeighting(encoder, turnCostProvider);\n        } else if (\"fastest\".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {\n            if (encoder.supports(PriorityWeighting.class))\n                weighting = new PriorityWeighting(encoder, hintsMap, turnCostProvider);\n            else\n                weighting = new FastestWeighting(encoder, hintsMap, turnCostProvider);\n        } else if (\"curvature\".equalsIgnoreCase(weightingStr)) {\n            if (encoder.supports(CurvatureWeighting.class))\n                weighting = new CurvatureWeighting(encoder, hintsMap, turnCostProvider);\n\n        } else if (\"short_fastest\".equalsIgnoreCase(weightingStr)) {\n            weighting = new ShortFastestWeighting(encoder, hintsMap, turnCostProvider);\n        }\n\n        if (weighting == null)\n            throw new IllegalArgumentException(\"weighting \" + weightingStr + \" not supported\");\n\n        return weighting;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1421,
    "type": "Return",
    "comment": "@return RowExpander child of the table, or null",
    "code": "public RowExpansion getRowExpansion() {\n    for (UIComponent kid : getChildren()) if (kid instanceof RowExpansion)\n        return (RowExpansion) kid;\n    return null;\n}",
    "label": 1,
    "rec": "@return RowExpansion child of the table, or null"
  },
  {
    "id": 1422,
    "type": "Return",
    "comment": "@return  True in case either combiner or reducer exists.",
    "code": "    public boolean hasCombinerOrReducer() {\n        return hasCombiner() || hasReducer();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1423,
    "type": "Return",
    "comment": "@return {@link MRInputConfigurer}",
    "code": "public MRInputConfigBuilder generateSplitsInAM(boolean value) {\n    generateSplitsInAM = value;\n    return this;\n}",
    "label": 1,
    "rec": "@return {@link org.apache.tez.mapreduce.input.MRInput.MRInputConfigBuilder}"
  },
  {
    "id": 1424,
    "type": "Return",
    "comment": "@return Affinity cached function.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        CacheAffinityFunction f = (CacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        CacheAffinityKeyMapper m = (CacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(n, cacheName));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1425,
    "type": "Return",
    "comment": "@return Disco spi.",
    "code": "public T2<String, Map<String, Object>> discoverySpi() {\n    return discoSpi;\n}",
    "label": 1,
    "rec": "@return Discovery SPI."
  },
  {
    "id": 1426,
    "type": "Return",
    "comment": "@return SVMLightPArser instance or null",
    "code": "  public static PSetupGuess guessSetup(byte [] bits){\n    InputStream is = new ByteArrayInputStream(bits);\n    XlsParser p = new XlsParser();\n    CustomInspectDataOut dout = new CustomInspectDataOut();\n    try{p.streamParse(is, dout);}catch(Exception e){}\n    return new PSetupGuess(new ParserSetup(ParserType.XLS,CsvParser.AUTO_SEP,dout._ncols, dout._header,dout._header?dout.data()[0]:null,false),dout._nlines,dout._invalidLines,dout.data(),null);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1427,
    "type": "Return",
    "comment": "@return an aggregated AuthenticationInfo instance representing authentication info across all the successfully consulted realms.",
    "code": "    protected Account doMultiRealmAuthentication( Collection<? extends Realm> realms, AuthenticationToken token ) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        strategy.beforeAllAttempts( realms, token );\n        \n        Account aggregatedInfo = createAggregatedAccount( token );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for( Realm realm : realms) {\n\n            strategy.beforeAttempt( realm, token );\n\n            if( realm.supports( token.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                Account realmInfo = null;\n                Throwable t = null;\n                try {\n                    realmInfo = realm.getAccount( token );\n                } catch ( Throwable throwable ) {\n                    t = throwable;\n                    if ( log.isTraceEnabled() ) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace( msg, t );\n                    }\n                }\n\n                strategy.afterAttempt( realm, token, realmInfo, t );\n\n                // If non-null account is returned, then the realm was able to authenticate the\n                // user - so merge the account with any accumulated before:\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account successfully authenticated using realm of type [\" +\n                            realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + token.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        strategy.afterAllAttempts( token, aggregatedInfo );\n\n        return aggregatedInfo;\n    }\n",
    "label": 1,
    "rec": "@return an aggregated Account instance representing account data across all the successfully consulted realms."
  },
  {
    "id": 1428,
    "type": "Return",
    "comment": "@return Services configuration.",
    "code": "    protected ServiceConfiguration[] services() {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1429,
    "type": "Return",
    "comment": "@return true to allow window-ids which aren't generated by CODI, false otherwise",
    "code": "@ConfigEntry\npublic boolean isUnknownWindowIdsAllowed() {\n    return true;\n}",
    "label": 1,
    "rec": "@return <code>true</code> to allow all windowIds already present in window.name. <code>false</code> to only allow window-ids which are generated by CODI"
  },
  {
    "id": 1430,
    "type": "Return",
    "comment": "@return inner product with a given sparse vector",
    "code": "\tpublic double inner(SparseVector vec) {\n\t\tdouble res = 0;\n\t\tfor (int idx : this.getIndex()) {\n\t\t\tif (vec.contains(idx))\n\t\t\t\tres += get(idx) * vec.get(idx);\n\t\t}\n\n\t\treturn res;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1431,
    "type": "Return",
    "comment": "@return path on the build agent to the repo",
    "code": "@Nullable\nprivate String setupMavenLocalRepo() throws IOException, InterruptedException {\n    if (StringUtils.isEmpty(step.getMavenLocalRepo())) {\n        return null;\n    } else {\n        String expandedPath = envOverride.expand(env.expand(step.getMavenLocalRepo()));\n        FilePath repoPath = new FilePath(ws, expandedPath);\n        repoPath.mkdirs();\n        return repoPath.getRemote();\n    }\n}",
    "label": 1,
    "rec": "@return path on the build agent to the repo or {@code null} if not defined"
  },
  {
    "id": 1432,
    "type": "Return",
    "comment": "@return Affinity assignment.",
    "code": "    public List<List<ClusterNode>> assignment() {\n        return assignment;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1433,
    "type": "Return",
    "comment": "@return a collection view of the entity copies contained in this EventCache",
    "code": "public Collection values() {\n    return Collections.unmodifiableCollection(entityToCopyMap.values());\n}",
    "label": 1,
    "rec": "@return an unmodifiable set view of the entity copies contained in this EventCache"
  },
  {
    "id": 1434,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage setMessage(BigDecimal setpoint) {\n\t\tfor (SetpointType setpointType : this.setpointTypes) {\n\t\t\treturn setMessage(setpointType, setpoint);\n\t\t}\n\t\t\n\t\t// in case there are no supported setpoint types, get them.\n\t\treturn this.getSupportedMessage();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1435,
    "type": "Return",
    "comment": "@return Space name.",
    "code": "    public String space(String schemaName) {\n        assert schemaName != null;\n\n        Schema schema = schemas.get(schemaName);\n\n        // For the compatibility with conversion from \"\"\"\" to \"\" inside h2 lib\n        if (schema == null) {\n            assert schemaName.isEmpty() || schemaName.charAt(0) != ESC_CH;\n\n            schema = schemas.get(escapeName(schemaName, true));\n        }\n\n        return schema.spaceName;\n    }\n",
    "label": 1,
    "rec": "@return Space name. Could be null."
  },
  {
    "id": 1436,
    "type": "Return",
    "comment": "@return the joint probability P(o, s | H) given the model H.",
    "code": "    public double p(O[] o, int[] s) {\n        return MathEx.exp(logp(o, s));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1437,
    "type": "Return",
    "comment": "@return quickfix for replacing dot call with safe (?.) call",
    "code": "public static ReplaceCallFix toSafeCall() {\n    return new ReplaceCallFix(true);\n}",
    "label": 1,
    "rec": "@return quickfix for replacing dot call with toSafe (?.) call"
  },
  {
    "id": 1438,
    "type": "Return",
    "comment": "@return Cached value.",
    "code": "    @Nullable public V get(K key, boolean deserializePortable)\n        throws IgniteCheckedException {\n        return getAllAsync(F.asList(key), deserializePortable).get().get(key);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1439,
    "type": "Return",
    "comment": "@return SharedObjectDescription[] to determine replica descriptions for each receiver. A null return value indicates that no replicas are to be created. If the returned array is not null, then it <b>must</b> be of same length as the receivers parameter.",
    "code": "protected RemoteSharedObjectDescription[] getReplicaDescriptions(ID[] receivers) {\n    RemoteSharedObjectDescription[] descriptions = null;\n    if (receivers == null || receivers.length == NUM) {\n        descriptions = new RemoteSharedObjectDescription[NUM];\n        descriptions[NUM] = getReplicaDescription((receivers == null) ? null : receivers[NUM]);\n    } else {\n        descriptions = new RemoteSharedObjectDescription[receivers.length];\n        for (int i = NUM; i < receivers.length; i++) {\n            descriptions[i] = getReplicaDescription(receivers[i]);\n        }\n    }\n    return descriptions;\n}",
    "label": 1,
    "rec": "@return RemoteSharedObjectDescriptions[] to determine replica descriptions for each receiver. A null return value indicates that no replicas are to be created. If the returned array is not null, then it <b>must</b> be of same length as the receivers parameter."
  },
  {
    "id": 1440,
    "type": "Return",
    "comment": "@return a  ProtectionResource",
    "code": "    public ProtectionResource protection(final String accessToken) {\n        return new ProtectionResource(this.http, this.serverConfiguration, configuration, new TokenCallable(http, configuration, serverConfiguration) {\n            @Override\n            public String call() {\n                return accessToken;\n            }\n\n            @Override\n            protected boolean isRetry() {\n                return false;\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1441,
    "type": "Return",
    "comment": "@return the method",
    "code": "public Constructor getConstructor(final Class klass, final int methodHash) {\n    if (klass == null)\n        throw new IllegalArgumentException(STR);\n    if (methodHash < NUM)\n        throw new IllegalArgumentException(STR);\n    try {\n        if (!m_constructors.containsKey(klass)) {\n            createMethodRepository(klass);\n        }\n    } catch (Exception e) {\n        throw new WrappedRuntimeException(e);\n    }\n    Constructor constructor;\n    try {\n        constructor = (Constructor) ((TIntObjectHashMap) m_constructors.get(klass)).get(methodHash);\n    } catch (Throwable e1) {\n        initialize();\n        try {\n            constructor = (Constructor) ((TIntObjectHashMap) m_constructors.get(klass)).get(methodHash);\n        } catch (Exception e) {\n            throw new WrappedRuntimeException(e);\n        }\n    }\n    return constructor;\n}",
    "label": 1,
    "rec": "@return the constructor"
  },
  {
    "id": 1442,
    "type": "Return",
    "comment": "@return  true if node segment is 'server'.",
    "code": "    public static GridPredicate<ClusterNode> serverNode() {\n        return new GridPredicate<ClusterNode>() {\n            @Override public boolean apply(ClusterNode node) {\n                return \"server\".equals(node.attribute(\"segment\"));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1443,
    "type": "Return",
    "comment": "@return the mDisabledIdList",
    "code": "public DisabledId[] getmDisabledIdList() {\n    return mDisabledIdMap;\n}",
    "label": 1,
    "rec": "@return the mDisabledIdMap"
  },
  {
    "id": 1444,
    "type": "Return",
    "comment": "@return Future for evict attempt.",
    "code": "    private IgniteInternalFuture<Boolean> tryEvictAsync(boolean updateSeq) {\n        if (map.isEmpty() && state.compareAndSet(RENTING, EVICTED, 0, 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"Evicted partition: \" + this);\n\n            clearSwap();\n\n            if (cctx.isDrEnabled())\n                cctx.dr().partitionEvicted(id);\n\n            cctx.dataStructures().onPartitionEvicted(id);\n\n            rent.onDone();\n\n            ((GridDhtPreloader<K, V>)cctx.preloader()).onPartitionEvicted(this, updateSeq);\n\n            clearDeferredDeletes();\n\n            return new GridFinishedFuture<>(cctx.kernalContext(), true);\n        }\n\n        return cctx.closures().callLocalSafe(new GPC<Boolean>() {\n            @Override public Boolean call() {\n                return tryEvict(true);\n            }\n        }, /*system pool*/ true);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1445,
    "type": "Return",
    "comment": "@return Hashtable of aliases.",
    "code": "protected static Map<String, Object> initAliases(InputStream in) {\n    Map<String, Object> aliases = new HashMap<String, Object>(NUM);\n    try {\n        BufferedReader br;\n        try {\n            br = new BufferedReader(new InputStreamReader(in, STR));\n        } catch (UnsupportedEncodingException e) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n        while (true) {\n            String line = br.readLine();\n            if (line == null) {\n                break;\n            }\n            Tokenizer tokenizer = new Tokenizer(line);\n            String master = tokenizer.getString(STR);\n            if (master != null) {\n                aliases.put(master.toLowerCase(), master);\n                parseloop: while (true) {\n                    String alias = tokenizer.getString(STR);\n                    if (alias == null) {\n                        break parseloop;\n                    }\n                    String lowerCaseAlias = alias.toLowerCase();\n                    Object storedMaster = aliases.get(lowerCaseAlias);\n                    if (storedMaster == null) {\n                        aliases.put(lowerCaseAlias, master);\n                    } else if (storedMaster instanceof String) {\n                        List<String> newMaster = new ArrayList<String>();\n                        newMaster.add((String) storedMaster);\n                        newMaster.add(master);\n                        aliases.put(lowerCaseAlias, newMaster);\n                    } else {\n                        @SuppressWarnings(STR)\n                        List<String> newMaster = ((List<String>) storedMaster);\n                        newMaster.add(master);\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        if (Debug.DEBUG_GENERAL) {\n            Debug.printStackTrace(e);\n        }\n    }\n    return aliases;\n}",
    "label": 1,
    "rec": "@return Map of aliases."
  },
  {
    "id": 1446,
    "type": "Return",
    "comment": "@return a callable object",
    "code": "    public static Callable<Object> callable(Runnable task) {\n        if (task == null) {\n            throw new NullPointerException();\n        }\n        return new RunnableAdapter<Object>(task, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1447,
    "type": "Return",
    "comment": "@return The Request object for the page",
    "code": "protected HttpServletResponse getResponse() {\n    if (this._response != null) {\n        return this._response;\n    } else {\n        return IWContext.getInstance().getResponse();\n    }\n}",
    "label": 1,
    "rec": "@return The esponse object for the page"
  },
  {
    "id": 1448,
    "type": "Return",
    "comment": "@return A list of all plugins loaded",
    "code": "    public Plugin[] loadPlugins(File directory) {\n        List<Plugin> result = new ArrayList<Plugin>();\n        File[] files = directory.listFiles();\n\n        for (File file : files) {\n            Plugin plugin = null;\n\n            try {\n                plugin = loadPlugin(file);\n            } catch (InvalidPluginException ex) {\n                Logger.getLogger(PluginManager.class.getName()).log(Level.SEVERE, \"Could not load \" + file.getPath() + \" in \" + directory.getPath(), ex);\n            }\n            \n            if (plugin != null) {\n                result.add(plugin);\n            }\n        }\n\n        return result.toArray(new Plugin[result.size()]);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1449,
    "type": "Return",
    "comment": "@return <code>false</code> if timeout was reached before latch opens; <code>true</code> if latch is open or opens while we are waiting.",
    "code": "public Completion await(long timeout, TimeUnit unit) throws InterruptedException {\n    if (sync.tryAcquireSharedNanos(NUM, unit.toNanos(timeout)))\n        return new Completion();\n    else\n        return null;\n}",
    "label": 1,
    "rec": "@return <code>null</code> if timeout was reached before latch opens; <code>Completion</code> object if latch is open or opens while we are waiting."
  },
  {
    "id": 1450,
    "type": "Return",
    "comment": "@return The input list",
    "code": "    public List<ItemStack> getIngredientList() {\n        ArrayList<ItemStack> result = new ArrayList<ItemStack>(ingredients.size());\n        for (ItemStack ingredient : ingredients) {\n            result.add(ingredient.clone());\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1451,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forManifest() {\n    return forManifest(forClassLoader());\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 1452,
    "type": "Return",
    "comment": "@return  True if updates should be done individually.",
    "code": "    protected boolean isSingleUpdate(GridCacheContext<K, V> cacheCtx) {\n        return storeEnabled && !implicit() && cacheCtx.store().configured() &&\n            !cacheCtx.config().isBatchUpdateOnCommit();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1453,
    "type": "Return",
    "comment": "@return Pairs of game names and friendly names",
    "code": "public HashMap<Integer, SteamGame> getGames() throws SteamCondenserException {\n    if (this.games == null) {\n        this.fetchGames();\n    }\n    return this.games;\n}",
    "label": 1,
    "rec": "@return array The games this user owns"
  },
  {
    "id": 1454,
    "type": "Return",
    "comment": "@return Types configuration.",
    "code": "    public Collection<PortableTypeConfiguration> getTypeConfigurations() {\n        return typeCfgs;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1455,
    "type": "Return",
    "comment": "@return string representation of the given info that can be used in exceptions and logging.",
    "code": "    protected String displayName( Account account) {\n        Object  p = account.getPrincipal();\n        if ( p != null ) {\n            return p.toString();\n        } else {\n            return account.toString();\n        }\n    }\n",
    "label": 1,
    "rec": "@return String representation of the given account that can be used in exceptions and logging."
  },
  {
    "id": 1456,
    "type": "Return",
    "comment": "@return Nodes to send requests to.",
    "code": "    private List<ClusterNode> nodes(KeyCacheObject key) throws IgniteCheckedException {\n        GridAffinityProcessor aff = ctx.affinity();\n\n        List<ClusterNode> res = null;\n\n        if (!allowOverwrite())\n            res = aff.mapKeyToPrimaryAndBackups(cacheName, key);\n        else {\n            ClusterNode node = aff.mapKeyToNode(cacheName, key);\n\n            if (node != null)\n                res = Collections.singletonList(node);\n        }\n\n        if (F.isEmpty(res))\n            throw new ClusterTopologyServerNotFoundException(\"Failed to find server node for cache (all affinity \" +\n                \"nodes have left the grid or cache was stopped): \" + cacheName);\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1457,
    "type": "Return",
    "comment": "@return true if at least one binding was denied.",
    "code": "Set<TeamBinding> checkAspectPermissionDenial(Collection<TeamBinding> teamsForBase) {\n    Set<TeamBinding> deniedTeams = new HashSet<TeamBinding>();\n    for (TeamBinding teamForBase : teamsForBase) {\n        AspectBinding aspectBinding = teamForBase.getAspectBinding();\n        String aspectBundleName = aspectBinding.aspectPlugin;\n        if (aspectBinding.hasBeenDenied) {\n            deniedTeams.add(teamForBase);\n        } else {\n            if (!checkForcedExports(aspectBinding)) {\n                deniedTeams.add(teamForBase);\n                stopAspectBundle(aspectBinding, aspectBundleName, STR);\n            } else if (!checkTeamBinding(aspectBundleName, aspectBinding.basePluginName, teamForBase)) {\n                deniedTeams.add(teamForBase);\n                stopAspectBundle(aspectBinding, aspectBundleName, STR);\n            }\n        }\n    }\n    return deniedTeams;\n}",
    "label": 1,
    "rec": "@return the set of denied teams"
  },
  {
    "id": 1458,
    "type": "Return",
    "comment": "@return a  SocketAddress suitable for binding, or else  null.",
    "code": "  protected ClientTransportFactory buildTransportFactory() {\n    assertEventLoopAndChannelType();\n\n    ProtocolNegotiator negotiator;\n    if (protocolNegotiatorFactory != null) {\n      negotiator = protocolNegotiatorFactory.buildProtocolNegotiator();\n    } else {\n      SslContext localSslContext = sslContext;\n      if (negotiationType == NegotiationType.TLS && localSslContext == null) {\n        try {\n          localSslContext = GrpcSslContexts.forClient().build();\n        } catch (SSLException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n      negotiator = createProtocolNegotiatorByType(negotiationType, localSslContext);\n    }\n\n    return new NettyTransportFactory(\n        negotiator, channelFactory, channelOptions,\n        eventLoopGroupPool, ALLOCATOR_POOL, flowControlWindow, maxInboundMessageSize(),\n        maxHeaderListSize, keepAliveTimeNanos, keepAliveTimeoutNanos, keepAliveWithoutCalls,\n        transportTracerFactory, localSocketPicker, useGetForSafeMethods);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1459,
    "type": "Return",
    "comment": "@return The {@link org.milyn.delivery.ContentDeliveryUnit}.",
    "code": "public ContentHandler getContentDeliveryUnit() {\n    return contentDeliveryUnit;\n}",
    "label": 1,
    "rec": "@return The {@link ContentHandler}."
  },
  {
    "id": 1460,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    private Object readResolve() throws ObjectStreamException {\n        return cctx.grid().affinity(cctx.cache().name());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1461,
    "type": "Return",
    "comment": "@return inner product with a given sparse vector",
    "code": "public double inner(DenseVector vec) {\n    double res = NUM;\n    for (int idx : this.getIndex()) res += get(idx) * vec.get(idx);\n    return res;\n}",
    "label": 1,
    "rec": "@return inner product with a given dense vector"
  },
  {
    "id": 1462,
    "type": "Return",
    "comment": "@return Identity predicate.",
    "code": "    public static IgnitePredicate<Boolean> identityPredicate() {\n        return IDENTITY_PRED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1463,
    "type": "Return",
    "comment": "@return the encrypted fragment",
    "code": "private byte[] encryptFragment(byte[] plaintextFragment) throws GeneralSecurityException {\n    if (session == null) {\n        return plaintextFragment;\n    }\n    byte[] encryptedFragment = plaintextFragment;\n    CipherSuite cipherSuite = session.getWriteState().getCipherSuite();\n    LOGGER.log(Level.FINER, STR, session.getWriteState());\n    switch(cipherSuite.getCipherType()) {\n        case NULL:\n            break;\n        case AEAD:\n            encryptedFragment = encryptAEAD(plaintextFragment);\n            break;\n        case BLOCK:\n            encryptedFragment = encryptBlockCipher(plaintextFragment);\n            break;\n        case STREAM:\n            break;\n        default:\n            break;\n    }\n    return encryptedFragment;\n}",
    "label": 1,
    "rec": "@return the (encrypted) TLSCiphertext.fragment"
  },
  {
    "id": 1464,
    "type": "Return",
    "comment": "@return content statistics",
    "code": "    public CmsContentStatistics contentClicks(Long id) {\n        if (CommonUtils.notEmpty(id)) {\n            CmsContentStatistics contentStatistics = contentCache.get(id);\n            if (null == contentStatistics) {\n                contentStatistics = new CmsContentStatistics(id, 1, 0, 0, contentService.getEntity(id));\n            } else {\n                contentStatistics.setClicks(contentStatistics.getClicks() + 1);\n            }\n            List<CmsContentStatistics> list = contentCache.put(id, contentStatistics);\n            if (CommonUtils.notEmpty(list)) {\n                contentService.updateStatistics(list);\n            }\n            return contentStatistics;\n        } else {\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1465,
    "type": "Return",
    "comment": "@return true if the left position of the view is to the left of the twenty five percent of the parent width.",
    "code": "@Override\npublic boolean isNextToLeftBound() {\n    return (getView().getRight() - getMarginRight()) < getParentView().getWidth() * NUM;\n}",
    "label": 1,
    "rec": "@return true if the right position of the view is to the left of sixty percent of the parent width."
  },
  {
    "id": 1466,
    "type": "Return",
    "comment": "@return resulting ciphertext.",
    "code": "  public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSecurityException {\n    byte[] ciphertext = cipher.encrypt(plaintext);\n    byte[] aadLengthInBits = Arrays.copyOf(ByteBuffer.allocate(8).putLong(8L * aad.length).array(),\n        8);\n    byte[] macValue = mac.computeMac(SubtleUtil.concat(aad, ciphertext, aadLengthInBits));\n    return SubtleUtil.concat(ciphertext, macValue);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1467,
    "type": "Return",
    "comment": "@return An {@link IFile} (new instance of {@link ExternalFileDecorator}).",
    "code": "public synchronized static IFile createFile(String pathString) {\n    if (File.separatorChar != STR) {\n        pathString = pathString.replace(STR, STR);\n    }\n    return new ExternalFileWrapper(pathString);\n}",
    "label": 1,
    "rec": "@return An {@link IFile} (new instance of {@link ExternalFileWrapper})."
  },
  {
    "id": 1468,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String recycle(Long[] ids, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysSite site = getSite(request);\n        if (CommonUtils.notEmpty(ids)) {\n            for (CmsContent entity : service.getEntitys(ids)) {\n                if (entity.isDisabled() && site.getId() == entity.getSiteId()) {\n                    if (CommonUtils.notEmpty(entity.getParentId())) {\n                        service.updateChilds(entity.getParentId(), 1);\n                    }\n                }\n            }\n            service.recycle(site.getId(), ids);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"recycle.content\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), StringUtils.join(ids, ',')));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1469,
    "type": "Return",
    "comment": "@return returns the number of servers that are serving the table",
    "code": "private TreeMap<Text, TableInfo> scanOneMetaRegion(TableInfo t, Text tableName) throws IOException {\n    HRegionInterface server = getHRegionConnection(t.serverAddress);\n    TreeMap<Text, TableInfo> servers = new TreeMap<Text, TableInfo>();\n    for (int tries = NUM; servers.size() == NUM && tries < this.numRetries; tries++) {\n        long scannerId = -NUM;\n        try {\n            scannerId = server.openScanner(t.regionInfo.regionName, META_COLUMNS, tableName);\n            DataInputBuffer inbuf = new DataInputBuffer();\n            while (true) {\n                HRegionInfo regionInfo = null;\n                String serverAddress = null;\n                HStoreKey key = new HStoreKey();\n                LabelledData[] values = server.next(scannerId, key);\n                if (values.length == NUM) {\n                    if (servers.size() == NUM) {\n                        throw new NoSuchElementException(STR + tableName + STR);\n                    }\n                    break;\n                }\n                byte[] bytes = null;\n                TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n                for (int i = NUM; i < values.length; i++) {\n                    bytes = new byte[values[i].getData().getSize()];\n                    System.arraycopy(values[i].getData().get(), NUM, bytes, NUM, bytes.length);\n                    results.put(values[i].getLabel(), bytes);\n                }\n                regionInfo = new HRegionInfo();\n                bytes = results.get(COL_REGIONINFO);\n                inbuf.reset(bytes, bytes.length);\n                regionInfo.readFields(inbuf);\n                if (!regionInfo.tableDesc.getName().equals(tableName)) {\n                    break;\n                }\n                if (regionInfo.offLine) {\n                    throw new IllegalStateException(STR + tableName);\n                }\n                bytes = results.get(COL_SERVER);\n                if (bytes == null || bytes.length == NUM) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(STR + regionInfo.toString());\n                    }\n                    servers.clear();\n                    break;\n                }\n                serverAddress = new String(bytes, UTF8_ENCODING);\n                servers.put(regionInfo.startKey, new TableInfo(regionInfo, new HServerAddress(serverAddress)));\n            }\n        } finally {\n            if (scannerId != -NUM) {\n                try {\n                    server.close(scannerId);\n                } catch (Exception e) {\n                    LOG.warn(e);\n                }\n            }\n        }\n        if (servers.size() == NUM && tries == this.numRetries - NUM) {\n            throw new NoServerForRegionException(STR + tableName + STR + this.numRetries + STR);\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + tableName + STR);\n        }\n        try {\n            Thread.sleep(this.clientTimeout);\n        } catch (InterruptedException e) {\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + tableName);\n        }\n    }\n    return servers;\n}",
    "label": 1,
    "rec": "@return returns a map of startingRow to TableInfo"
  },
  {
    "id": 1470,
    "type": "Return",
    "comment": "@return The schema of this file or all its subfiles",
    "code": "    private static Schema getSchemaFromPath(FileSystem fs, Path path) {\n\n        try {\n            if(fs.isFile(path)) {\n                BufferedInputStream inStream = null;\n                try {\n                    inStream = new BufferedInputStream(fs.open(path));\n                } catch(IOException e1) {\n                    throw new RuntimeException(\"Unable to open \" + path, e1);\n                }\n                GenericDatumReader datum = new GenericDatumReader();\n\n                DataFileStream reader = null;\n                try {\n                    reader = new DataFileStream(inStream, datum);\n                } catch(IOException e) {\n                    throw new RuntimeException(\"Invalid avro format, path \" + path, e);\n                }\n                return reader.getSchema();\n            } else {\n                FileStatus[] statuses = null;\n                if(fs.isDirectory(path)) {\n                    // this is a directory, get schemas from all subfiles\n                    statuses = fs.listStatus(path);\n                    if(statuses == null || statuses.length == 0)\n                        throw new IllegalArgumentException(\"No files in directory \" + path);\n                } else {\n                    // this is wildcard path, get schemas from all matched files\n                    statuses = fs.globStatus(path);\n                    if(statuses == null || statuses.length == 0)\n                        throw new IllegalArgumentException(\"No matches for path pattern \" + path);\n                }\n                List<Schema> schemas = new ArrayList<Schema>();\n                for(FileStatus status: statuses) {\n                    if(!HadoopUtils.shouldPathBeIgnored(status.getPath())) {\n                        schemas.add(getSchemaFromPath(fs, status.getPath()));\n                    }\n                }\n\n                // now check that all the schemas are the same\n                if(schemas.size() > 0) {\n                    Schema schema = schemas.get(0);\n                    for(int i = 1; i < schemas.size(); i++)\n                        if(!schema.equals(schemas.get(i)))\n                            throw new IllegalArgumentException(\"The directory \"\n                                                               + path\n                                                               + \" contains heterogenous schemas: found both '\"\n                                                               + schema + \"' and '\"\n                                                               + schemas.get(i) + \"'.\");\n\n                    return schema;\n                } else {\n                    throw new IllegalArgumentException(\"No valid metadata file found for path \" + path);\n                }\n            }\n        } catch(Exception e) {\n            throw new RuntimeException(\"Error getting schema for path \" + path, e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1471,
    "type": "Return",
    "comment": "@return Copy of given root holder.",
    "code": "    private long rootHolder() {\n        return newNode(null, 1, null, 0L, 0L, 0L);\n    }\n",
    "label": 1,
    "rec": "@return New root holder."
  },
  {
    "id": 1472,
    "type": "Return",
    "comment": "@return the realm to be retrieved.",
    "code": "    public Realm getRealm( String realmName ) {\n        return realmMap.get( realmName );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1473,
    "type": "Return",
    "comment": "@return de-serialized object from Json or empty object if the response doesn't have a body.",
    "code": "@Override\nprotected T parseResponse(HttpResponse response) throws HttpResponseException, IOException {\n    final StatusLine statusLine = response.getStatusLine();\n    String responseBody = response.getEntity() != null ? EntityUtils.toString(response.getEntity()) : STR;\n    if (statusLine.getStatusCode() >= NUM) {\n        logger.error(String.format(STR, statusLine.getStatusCode()));\n        throw new HttpResponseException(statusLine.getStatusCode(), responseBody);\n    }\n    final HttpEntity entity = response.getEntity();\n    if (null == entity || entity.getContentLength() >= Integer.MAX_VALUE) {\n        logger.error(STR);\n        return null;\n    }\n    return new ObjectMapper().readValue(EntityUtils.toString(entity), this.typeOfclass);\n}",
    "label": 1,
    "rec": "@return de-serialized object from Json or null if the response doesn't have a body."
  },
  {
    "id": 1474,
    "type": "Return",
    "comment": "@return Collection of nodes.",
    "code": "        Collection<ClusterNode> remoteCacheNodes(final long topVer) {\n            return filter(topVer, rmtNodesWithCaches);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1475,
    "type": "Return",
    "comment": "@return true if the resource exists, false otherwise.",
    "code": "public static int executeReadCommand(IThreadContext tc, Configuration output, String path, Map<String, List<String>> queryParameters) throws ManifoldCFException {\n    if (path.equals(STR)) {\n        return apiReadJobs(tc, output);\n    } else if (path.startsWith(STR)) {\n        Long jobID = new Long(path.substring(STR.length()));\n        return apiReadJob(tc, output, jobID);\n    } else if (path.startsWith(STR)) {\n        int firstSeparator = STR.length();\n        String connectionName = decodeAPIPathElement(path.substring(firstSeparator));\n        return apiReadRepositoryConnectionHistory(tc, output, connectionName, queryParameters);\n    } else if (path.startsWith(STR)) {\n        int firstSeparator = STR.length();\n        int secondSeparator = path.indexOf(STR, firstSeparator);\n        if (secondSeparator == -NUM) {\n            createErrorNode(output, STR);\n            return READRESULT_NOTFOUND;\n        }\n        String connectionType = path.substring(firstSeparator, secondSeparator);\n        String connectionName = decodeAPIPathElement(path.substring(secondSeparator + NUM));\n        if (connectionType.equals(STR)) {\n            return apiReadOutputConnectionStatus(tc, output, connectionName);\n        } else if (connectionType.equals(STR)) {\n            return apiReadAuthorityConnectionStatus(tc, output, connectionName);\n        } else if (connectionType.equals(STR)) {\n            return apiReadRepositoryConnectionStatus(tc, output, connectionName);\n        } else {\n            createErrorNode(output, STR + connectionType + STR);\n            return READRESULT_NOTFOUND;\n        }\n    } else if (path.startsWith(STR)) {\n        int firstSeparator = STR.length();\n        int secondSeparator = path.indexOf(STR, firstSeparator);\n        if (secondSeparator == -NUM) {\n            createErrorNode(output, STR);\n            return READRESULT_NOTFOUND;\n        }\n        int thirdSeparator = path.indexOf(STR, secondSeparator + NUM);\n        if (thirdSeparator == -NUM) {\n            createErrorNode(output, STR);\n            return READRESULT_NOTFOUND;\n        }\n        String connectionType = path.substring(firstSeparator, secondSeparator);\n        String connectionName = decodeAPIPathElement(path.substring(secondSeparator + NUM, thirdSeparator));\n        String command = path.substring(thirdSeparator + NUM);\n        if (connectionType.equals(STR)) {\n            return apiReadOutputConnectionInfo(tc, output, connectionName, command);\n        } else if (connectionType.equals(STR)) {\n            return apiReadRepositoryConnectionInfo(tc, output, connectionName, command);\n        } else {\n            createErrorNode(output, STR + connectionType + STR);\n            return READRESULT_NOTFOUND;\n        }\n    } else if (path.equals(STR)) {\n        return apiReadJobStatuses(tc, output);\n    } else if (path.startsWith(STR)) {\n        Long jobID = new Long(path.substring(STR.length()));\n        return apiReadJobStatus(tc, output, jobID);\n    } else if (path.startsWith(STR)) {\n        Long jobID = new Long(path.substring(STR.length()));\n        return apiReadJobStatusNoCounts(tc, output, jobID);\n    } else if (path.equals(STR)) {\n        return apiReadOutputConnections(tc, output);\n    } else if (path.startsWith(STR)) {\n        String connectionName = decodeAPIPathElement(path.substring(STR.length()));\n        return apiReadOutputConnection(tc, output, connectionName);\n    } else if (path.equals(STR)) {\n        return apiReadAuthorityConnections(tc, output);\n    } else if (path.startsWith(STR)) {\n        String connectionName = decodeAPIPathElement(path.substring(STR.length()));\n        return apiReadAuthorityConnection(tc, output, connectionName);\n    } else if (path.equals(STR)) {\n        return apiReadRepositoryConnections(tc, output);\n    } else if (path.startsWith(STR)) {\n        String connectionName = decodeAPIPathElement(path.substring(STR.length()));\n        return apiReadRepositoryConnection(tc, output, connectionName);\n    } else if (path.equals(STR)) {\n        return apiReadOutputConnectors(tc, output);\n    } else if (path.equals(STR)) {\n        return apiReadAuthorityConnectors(tc, output);\n    } else if (path.equals(STR)) {\n        return apiReadRepositoryConnectors(tc, output);\n    } else {\n        createErrorNode(output, STR);\n        return READRESULT_NOTFOUND;\n    }\n}",
    "label": 1,
    "rec": "@return read status - either found, not found, or bad args"
  },
  {
    "id": 1476,
    "type": "Return",
    "comment": "@return An array of Method's. May be of length 0 but not null.",
    "code": "\tpublic static Method[] getMethods(Class<?> clazz, String... methodNames) {\n\t\treturn WhiteboxImpl.getMethods(clazz, methodNames);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1477,
    "type": "Return",
    "comment": "@return the same, but with any query string concealed",
    "code": "public static String sanitize(URL url) {\n    try {\n        URI orig = url.toURI();\n        return new URI(orig.getScheme(), orig.getUserInfo() != null ? STR : null, orig.getHost(), orig.getPort(), orig.getPath(), orig.getQuery() != null ? STR : null, orig.getFragment()).toString();\n    } catch (URISyntaxException x) {\n        assert false : x;\n        return url.toString();\n    }\n}",
    "label": 1,
    "rec": "@return the same, but with any {@link URL#getQuery} and/or {@link URL#getUserInfo} concealed"
  },
  {
    "id": 1478,
    "type": "Return",
    "comment": "@return constructed address",
    "code": "    public static Address fromPubKeyHash(NetworkParameters params, byte[] hash160) {\n        return new Address(params, false, hash160);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1479,
    "type": "Return",
    "comment": "@return aggregates for each global metric type.",
    "code": "public List<Metric> computeConsumptionTotals() throws StorageException {\n    List<Metric> counts = FluentIterable.from(Arrays.asList(MetricType.values())).transform(TO_METRIC).toList();\n    for (ITaskConfig task : getTasks(Query.unscoped().active())) {\n        for (Metric count : counts) {\n            count.accumulate(task);\n        }\n    }\n    return counts;\n}",
    "label": 1,
    "rec": "@return aggregates for each metric type."
  },
  {
    "id": 1480,
    "type": "Return",
    "comment": "@return Started grid.",
    "code": "    protected Grid startGrid(String gridName, GridSpringResourceContext ctx) throws Exception {\n        return GridGainEx.start(optimize(getConfiguration(gridName)), ctx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1481,
    "type": "Return",
    "comment": "@return true if the user directory is treated as the root.",
    "code": "public Boolean getUserDirIsRoot(final FileSystemOptions opts) {\n    return getBoolean(opts, USER_DIR_IS_ROOT, Boolean.TRUE);\n}",
    "label": 1,
    "rec": "@return <code>true</code> if VFS treats the user directory as the root directory. Defaults to <code>true</code>."
  },
  {
    "id": 1482,
    "type": "Return",
    "comment": "@return Whether to convert string to UTF8 bytes.",
    "code": "    public boolean isConvertString() {\n        return convertStrings;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1483,
    "type": "Return",
    "comment": "@return GGFS configuration.",
    "code": "    public IgfsConfiguration ggfsConfiguration() {\n        IgfsConfiguration cfg = new IgfsConfiguration();\n\n        cfg.setName(ggfsName);\n        cfg.setBlockSize(ggfsBlockSize);\n        cfg.setDataCacheName(ggfsDataCacheName);\n        cfg.setMetaCacheName(ggfsMetaCacheName);\n        cfg.setFragmentizerEnabled(false);\n\n        return cfg;\n    }\n",
    "label": 1,
    "rec": "@return IGFS configuration."
  },
  {
    "id": 1484,
    "type": "Return",
    "comment": "@return the criteria builder",
    "code": "    public Criteria and(String key) {\n        return new Criteria(this.criteriaChain, PathCompiler.compile(key));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1485,
    "type": "Return",
    "comment": "@return an ArgumentListBuilder containing the arguments for the TF tool.",
    "code": "public MaskedArgumentListBuilder getBriefHistoryArguments(Calendar fromTimestamp, Calendar toTimestamp) {\n    return getHistoryArguments(fromTimestamp, toTimestamp, STR);\n}",
    "label": 1,
    "rec": "@return arguments for the \"history /format:brief\" command"
  },
  {
    "id": 1486,
    "type": "Return",
    "comment": "@return Edition.",
    "code": "    private static GridProductEdition editionFromString(String edition) {\n        switch (edition) {\n            case \"datagrid\":\n                return DATA_GRID;\n\n            case \"hadoop\":\n                return HADOOP;\n\n            case \"streaming\":\n                return STREAMING;\n\n            case \"mongo\":\n                return MONGO;\n\n            case \"platform\":\n                return PLATFORM;\n        }\n\n        throw new GridRuntimeException(\"Failed to determine GridGain edition: \" + edition);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1487,
    "type": "Return",
    "comment": "@return true if queue is over its set budget(s)",
    "code": "public boolean isOverBudget() {\n    return (sessionBudget > NUM && (totalExpenditure - expenditureAtLastActivation) > sessionBudget) || (this.totalBudget >= NUM && this.totalExpenditure >= this.totalBudget);\n}",
    "label": 1,
    "rec": "@return true if queue is over either of its set budget(s)"
  },
  {
    "id": 1488,
    "type": "Return",
    "comment": "@return File info of renamed entry.",
    "code": "    public IgfsFileInfo move(IgfsPath srcPath, IgfsPath dstPath) throws IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                assert validTxState(false);\n\n                // 1. First get source and destination path IDs.\n                List<IgniteUuid> srcPathIds = fileIds(srcPath);\n                List<IgniteUuid> dstPathIds = fileIds(dstPath);\n\n                final Set<IgniteUuid> allIds = new TreeSet<>(PATH_ID_SORTING_COMPARATOR);\n\n                allIds.addAll(srcPathIds);\n\n                final IgniteUuid dstLeafId = dstPathIds.get(dstPathIds.size() - 1);\n\n                if (dstLeafId == null) {\n                    // Delete null entry for the unexisting destination element:\n                    dstPathIds.remove(dstPathIds.size() - 1);\n                }\n\n                allIds.addAll(dstPathIds);\n\n                if (allIds.remove(null)) {\n                    throw new IgfsPathNotFoundException(\"Failed to perform move because some path component was \" +\n                            \"not found. [src=\" + srcPath + \", dst=\" + dstPath + ']');\n                }\n\n                // 2. Start transaction.\n                IgniteInternalTx tx = metaCache.txStartEx(PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    // 3. Obtain the locks.\n                    final Map<IgniteUuid, IgfsFileInfo> allInfos = lockIds(allIds);\n\n                    // 4. Verify integrity of source directory.\n                    if (!verifyPathIntegrity(srcPath, srcPathIds, allInfos)) {\n                        throw new IgfsPathNotFoundException(\"Failed to perform move because source directory \" +\n                            \"structure changed concurrently [src=\" + srcPath + \", dst=\" + dstPath + ']');\n                    }\n\n                    // 5. Verify integrity of destination directory.\n                    final IgfsPath dstDirPath = dstLeafId != null ? dstPath : dstPath.parent();\n\n                    if (!verifyPathIntegrity(dstDirPath, dstPathIds, allInfos)) {\n                        throw new IgfsPathNotFoundException(\"Failed to perform move because destination directory \" +\n                            \"structure changed concurrently [src=\" + srcPath + \", dst=\" + dstPath + ']');\n                    }\n\n                    // 6. Calculate source and destination targets which will be changed.\n                    IgniteUuid srcTargetId = srcPathIds.get(srcPathIds.size() - 2);\n                    IgfsFileInfo srcTargetInfo = allInfos.get(srcTargetId);\n                    String srcName = srcPath.name();\n\n                    IgniteUuid dstTargetId;\n                    IgfsFileInfo dstTargetInfo;\n                    String dstName;\n\n                    if (dstLeafId != null) {\n                        // Destination leaf exists. Check if it is an empty directory.\n                        IgfsFileInfo dstLeafInfo = allInfos.get(dstLeafId);\n\n                        assert dstLeafInfo != null;\n\n                        if (dstLeafInfo.isDirectory()) {\n                            // Destination is a directory.\n                            dstTargetId = dstLeafId;\n                            dstTargetInfo = dstLeafInfo;\n                            dstName = srcPath.name();\n                        }\n                        else {\n                            // Error, destination is existing file.\n                            throw new IgfsPathAlreadyExistsException(\"Failed to perform move \" +\n                                \"because destination points to \" +\n                                \"existing file [src=\" + srcPath + \", dst=\" + dstPath + ']');\n                        }\n                    }\n                    else {\n                        // Destination leaf doesn't exist, so we operate on parent.\n                        dstTargetId = dstPathIds.get(dstPathIds.size() - 1);\n                        dstTargetInfo = allInfos.get(dstTargetId);\n                        dstName = dstPath.name();\n                    }\n\n                    assert dstTargetInfo != null;\n                    assert dstTargetInfo.isDirectory();\n\n                    // 7. Last check: does destination target already have listing entry with the same name?\n                    if (dstTargetInfo.listing().containsKey(dstName)) {\n                        throw new IgfsPathAlreadyExistsException(\"Failed to perform move because destination already \" +\n                            \"contains entry with the same name existing file [src=\" + srcPath +\n                            \", dst=\" + dstPath + ']');\n                    }\n\n                    // 8. Actual move: remove from source parent and add to destination target.\n                    IgfsListingEntry entry = srcTargetInfo.listing().get(srcName);\n\n                    id2InfoPrj.invoke(srcTargetId, new UpdateListing(srcName, entry, true));\n                    id2InfoPrj.invoke(dstTargetId, new UpdateListing(dstName, entry, false));\n\n                    tx.commit();\n\n                    IgfsPath realNewPath = new IgfsPath(dstDirPath, dstName);\n\n                    IgfsFileInfo moved = allInfos.get(srcPathIds.get(srcPathIds.size() - 1));\n\n                    // Set the new path to the info to simplify event creation:\n                    return IgfsFileInfo.builder(moved).path(realNewPath).build();\n                }\n                finally {\n                    tx.close();\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to perform move because Grid is stopping [srcPath=\" +\n                srcPath + \", dstPath=\" + dstPath + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1489,
    "type": "Return",
    "comment": "@return Session spi.",
    "code": "public T2<String, Map<String, Object>> secureSessionSpi() {\n    return sesSpi;\n}",
    "label": 1,
    "rec": "@return Secure Session SPI."
  },
  {
    "id": 1490,
    "type": "Return",
    "comment": "@return unmodifiable Set of keys",
    "code": "  public Set<String> keys() {\n    if (isEmpty()) {\n      return Collections.emptySet();\n    }\n    Set<String> ks = new HashSet<String>(size);\n    for (int i = 0; i < size; i++) {\n      ks.add(new String(name(i), 0 /* hibyte */));\n    }\n    // immutable in case we decide to change the implementation later.\n    return Collections.unmodifiableSet(ks);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1491,
    "type": "Return",
    "comment": "@return Found Client-Object or null, if there isn't pet with such name.",
    "code": "public static Client searchPetName(String petName) throws SearchException {\n    if (clients.isEmpty()) {\n        throw new SearchException(STR);\n    } else {\n        for (Client client : clients) {\n            if (client.getPetName().equals(petName)) {\n                return client;\n            }\n        }\n        throw new SearchException(STR);\n    }\n}",
    "label": 1,
    "rec": "@return Found Client-Object."
  },
  {
    "id": 1492,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private static ComputeJob job(final Runnable r) {\n        A.notNull(r, \"job\");\n\n        if (r instanceof ComputeJobMasterLeaveAware)\n            return new C4(r);\n        else {\n            return new ComputeJobAdapter() {\n                @Nullable @Override public Object execute() {\n                    r.run();\n\n                    return null;\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1493,
    "type": "Return",
    "comment": "@return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters (including '=') isn't divideable by 4. (I.e. definitely corrupted).",
    "code": "public static String decode(String base64) {\n    StringBuilder sb = new StringBuilder(base64);\n    sb.append(Strings.dup(STR, NUM - base64.length() % NUM - NUM));\n    byte[] decode = Base64.decode(sb.toString().replace(STR, STR).replace(STR, STR));\n    if (decode == null || decode.length == NUM) {\n        return STR;\n    }\n    return new String(decode);\n}",
    "label": 1,
    "rec": "@return URL "
  },
  {
    "id": 1494,
    "type": "Return",
    "comment": "@return a string representing the current timestamp, or null",
    "code": "    protected String getDateString() {\n        if (suppressDate) {\n            return null;\n        } else if (dateFormat != null) {\n            return dateFormat.format(new Date());\n        } else {\n            return new Date().toString();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1495,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "    public static Collection<URL> forJavaClassPath() {\n        Collection<URL> urls = new ArrayList<URL>();\n        String javaClassPath = System.getProperty(\"java.class.path\");\n        if (javaClassPath != null) {\n            for (String path : javaClassPath.split(File.pathSeparator)) {\n                try {\n                    urls.add(new File(path).toURI().toURL());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return distinctUrls(urls);\n    }\n",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 1496,
    "type": "Return",
    "comment": "@return Committed transactions starting from the given version (non-inclusive).",
    "code": "    public Collection<GridCacheVersion> rolledbackVersions(GridCacheVersion min) {\n        ConcurrentNavigableMap<GridCacheVersion, Boolean> tail\n            = completedVers.tailMap(min, true);\n\n        return F.isEmpty(tail) ? Collections.<GridCacheVersion>emptyList() : copyOf(tail, false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1497,
    "type": "Return",
    "comment": "@return the value corresponding to <code>key</code> or null",
    "code": "public final V get(K key) throws NoSuchKeyException {\n    expungeStaleEntries();\n    SoftReference<V> ref = map.get(key);\n    if (ref != null) {\n        V val = ref.get();\n        if (!ref.isEnqueued()) {\n            return val;\n        }\n    }\n    throw new NoSuchKeyException(STR);\n}",
    "label": 1,
    "rec": "@return the value corresponding to <code>key</code> (may be null)"
  },
  {
    "id": 1498,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            IgniteBiTuple<String, Object> t = stash.get();\n\n            Object ctgrR = t.get2();\n\n            IgniteLogger log = IgnitionEx.localIgnite().log();\n\n            return ctgrR != null ? log.getLogger(ctgrR) : log;\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1499,
    "type": "Return",
    "comment": "@return an {@link OpcXmlDataTypeCodec}, or {@code null} if none was found.",
    "code": "@Nullable\ndefault OpcUaXmlDataTypeCodec<?> getXmlCodec(String namespaceUri, String description) {\n    DataTypeCodec codec = getCodec(namespaceUri, description);\n    if (codec instanceof OpcUaXmlDataTypeCodec) {\n        return (OpcUaXmlDataTypeCodec<?>) codec;\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return an {@link OpcUaXmlDataTypeCodec}, or {@code null} if none was found."
  },
  {
    "id": 1500,
    "type": "Return",
    "comment": "@return  true if current OS was sufficiently tested -  false otherwise.",
    "code": "    public static boolean isSufficientlyTestedOs() {\n        return\n            win7 ||\n                win8 ||\n                win81 ||\n                winXp ||\n                winVista ||\n                mac ||\n                linux ||\n                solaris;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1501,
    "type": "Return",
    "comment": "@return Returns the mslCopyingResourceSet.",
    "code": "public CopyingResourceSet getMslCopyingResourceSet() {\n    return copyingResourceSet;\n}",
    "label": 1,
    "rec": "@return Returns the CopyingResourceSet."
  },
  {
    "id": 1502,
    "type": "Return",
    "comment": "@return deleted nodes",
    "code": "    public int simplify(PointList points) {\n        int deleted = simplify(points, 0, points.size() - 1);\n        // compress list: move points into EMPTY slots\n        int freeIndex = -1;\n        for (int currentIndex = 0; currentIndex < points.size(); currentIndex++) {\n            if (Double.isNaN(points.latitude(currentIndex))) {\n                if (freeIndex < 0)\n                    freeIndex = currentIndex;\n                continue;\n            }\n\n            if (freeIndex < 0)\n                continue;\n            points.set(freeIndex, points.latitude(currentIndex), points.longitude(currentIndex));\n            // find next free index\n            int max = currentIndex;\n            for (int searchIndex = freeIndex; searchIndex < max; searchIndex++) {\n                if (Double.isNaN(points.latitude(searchIndex))) {\n                    freeIndex = searchIndex;\n                    break;\n                }\n            }\n        }\n        points.setSize(points.size() - deleted);\n        return deleted;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1503,
    "type": "Return",
    "comment": "@return The entity type for relation/association.",
    "code": "private String getType(String propertyName, String explicitTargetEntity, ElementKind expectedElementKind) {\n    for (Element elem : element.getEnclosedElements()) {\n        if (!expectedElementKind.equals(elem.getKind())) {\n            continue;\n        }\n        TypeMirror mirror;\n        String name = elem.getSimpleName().toString();\n        if (ElementKind.METHOD.equals(elem.getKind())) {\n            name = StringUtil.getPropertyName(name);\n            mirror = ((ExecutableElement) elem).getReturnType();\n        } else {\n            mirror = elem.asType();\n        }\n        if (name == null || !name.equals(propertyName)) {\n            continue;\n        }\n        if (explicitTargetEntity != null) {\n            return explicitTargetEntity;\n        }\n        switch(mirror.getKind()) {\n            case INT:\n                {\n                    return STR;\n                }\n            case LONG:\n                {\n                    return STR;\n                }\n            case BOOLEAN:\n                {\n                    return STR;\n                }\n            case BYTE:\n                {\n                    return STR;\n                }\n            case SHORT:\n                {\n                    return STR;\n                }\n            case CHAR:\n                {\n                    return STR;\n                }\n            case FLOAT:\n                {\n                    return STR;\n                }\n            case DOUBLE:\n                {\n                    return STR;\n                }\n            case DECLARED:\n                {\n                    return mirror.toString();\n                }\n            case TYPEVAR:\n                {\n                    return mirror.toString();\n                }\n        }\n    }\n    context.logMessage(Diagnostic.Kind.WARNING, STR + propertyName + STR + getQualifiedName() + STR + accessTypeInfo.getDefaultAccessType());\n    return null;\n}",
    "label": 1,
    "rec": "@return The entity type for this property or {@code null} if the property with the name and the matching access type does not exist."
  },
  {
    "id": 1504,
    "type": "Return",
    "comment": "@return Set ID.",
    "code": "    IgniteUuid id() {\n        return id;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1505,
    "type": "Return",
    "comment": "@return the instances",
    "code": "    public List<SecurityGroup> describeSecurityGroups(String... groupNames) {\n        AmazonEC2 ec2Client = ec2Client();\n        DescribeSecurityGroupsRequest request = new DescribeSecurityGroupsRequest();\n\n        if (groupNames == null || groupNames.length == 0) {\n            LOGGER.info(String.format(\"Getting all EC2 security groups in region %s.\", region));\n        } else {\n            LOGGER.info(String.format(\"Getting EC2 security groups for %d names in region %s.\", groupNames.length,\n                    region));\n            request.withGroupNames(groupNames);\n        }\n\n        DescribeSecurityGroupsResult result;\n        try {\n            result = ec2Client.describeSecurityGroups(request);\n        } catch (AmazonServiceException e) {\n            if (e.getErrorCode().equals(\"InvalidGroup.NotFound\")) {\n                LOGGER.info(\"Got InvalidGroup.NotFound error for security groups; returning empty list\");\n                return Collections.emptyList();\n            }\n            throw e;\n        }\n\n        List<SecurityGroup> securityGroups = result.getSecurityGroups();\n        LOGGER.info(String.format(\"Got %d EC2 security groups in region %s.\", securityGroups.size(), region));\n        return securityGroups;\n    }\n",
    "label": 1,
    "rec": "@return a list of matching groups"
  },
  {
    "id": 1506,
    "type": "Return",
    "comment": "@return todoroo cursor. PLEASE CLOSE THIS CURSOR!",
    "code": "    private TodorooCursor<Task> getTasksWithReminders(Property<?>... properties) {\n        return taskDao.query(Query.select(properties).where(Criterion.and(\n                TaskCriteria.isActive(),\n                TaskApiDao.TaskCriteria.ownedByMe(),\n                Criterion.or(Task.REMINDER_FLAGS.gt(0), Task.REMINDER_PERIOD.gt(0)))));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1507,
    "type": "Return",
    "comment": "@return PartitionUpdaterParam the partition parameter of the update udf",
    "code": "public PartitionUpdateParam getPartParam() {\n    return partParam;\n}",
    "label": 1,
    "rec": "@return PartitionUpdateParam the partition parameter of the update udf"
  },
  {
    "id": 1508,
    "type": "Return",
    "comment": "@return try / catch blocks of given method",
    "code": "    public List<BuilderTryBlock> getTryBlocks(String methodSignature) {\n        dexifyClassIfNecessary(methodSignature);\n\n        return methodSignatureToTryBlocks.get(methodSignature);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1509,
    "type": "Return",
    "comment": "@return an HttpEntity containing all request parameters",
    "code": "public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {\n    if (streamParams.isEmpty() && fileParams.isEmpty()) {\n        return createFormEntity();\n    } else {\n        return createMultipartEntity(progressHandler);\n    }\n}",
    "label": 1,
    "rec": "@return HttpEntity resulting HttpEntity to be included along with {@link org.apache.http.client.methods.HttpEntityEnclosingRequestBase}"
  },
  {
    "id": 1510,
    "type": "Return",
    "comment": "@return Client protocol.",
    "code": "    private static ClientProtocol createProtocol(String addr, Configuration conf) throws IOException {\n        return new HadoopClientProtocol(conf, client(addr));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1511,
    "type": "Return",
    "comment": "@return 3 data bytes (within lower 24 bits of the int) decoded, if succesful; or -1 to indicate that there is not enough data",
    "code": "private boolean decodePartial() throws IllegalArgumentException {\n    do {\n        while (mCurrSegmentPtr >= mCurrSegmentEnd) {\n            if (!nextSegment()) {\n                return false;\n            }\n        }\n        int ch = mCurrSegment[mCurrSegmentPtr++];\n        int bits;\n        if (ch > NUM || (bits = BASE64_BY_CHAR[ch]) < NUM) {\n            throw reportInvalidChar(ch);\n        }\n        mLeftoverData = (mLeftoverData << NUM) | bits;\n        ++mLeftoverCount;\n    } while (mLeftoverCount < NUM);\n    mIncompleteOutputLen = NUM;\n    mIncompleteOutputData = mLeftoverData;\n    mLeftoverCount = NUM;\n    return true;\n}",
    "label": 1,
    "rec": "@return True if we managed to decode a full triplet; false if there wasn't enough data for decoding"
  },
  {
    "id": 1512,
    "type": "Return",
    "comment": "@return Started grid.",
    "code": "    public static Grid start() throws GridException {\n        return start((GridResourceContext)null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1513,
    "type": "Return",
    "comment": "@return a Locale object created with the users preferred locale (language)",
    "code": "public ICRole getUsersPreferredRole(User user) {\n    ICRole role = null;\n    if (user != null) {\n        role = user.getPreferredRole();\n    }\n    return role;\n}",
    "label": 1,
    "rec": "@return a ICRole object created with the users preferred role"
  },
  {
    "id": 1514,
    "type": "Return",
    "comment": "@return the ScimUser added",
    "code": "\tpublic ScimUser addUser(UaaUser user) {\n\t\tScimUser scimUser = getScimUser(user);\n\t\tList<ScimUser> users = scimUserProvisioning.retrieveUsers(\"userName eq '\" + user.getUsername() + \"'\");\n\t\tif (users.isEmpty()) {\n\t\t\tlogger.info(\"Registering new user account: \" + user);\n\t\t\t// TODO: send a message or raise an event that can be used to inform the user of his new password\n\t\t\tscimUser = scimUserProvisioning.createUser(scimUser, user.getPassword());\n\t\t} else {\n\t\t\tif (!override) {\n\t\t\t\tlogger.debug(\"Not registering existing user: \" + user);\n\t\t\t\t// We don't update existing accounts - use the ScimUserProvisioning for that\n\t\t\t} else {\n\t\t\t\tString id = users.iterator().next().getId();\n\t\t\t\tscimUserProvisioning.updateUser(id, scimUser);\n\t\t\t\tscimUserProvisioning.changePassword(id, null, user.getPassword());\n\t\t\t}\n\t\t}\n\t\tif (scimGroupProvisioning != null && membershipManager != null) {\n\t\t\tSet<Group> groups = scimUser.getGroups();\n\t\t\tfor (Group g : groups) {\n\t\t\t\taddToGroup(scimUser, g.display);\n\t\t\t}\n\t\t}\n\t\treturn scimUser;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1515,
    "type": "Return",
    "comment": "@return a filter that will accept any String that contains the specified CharSequence",
    "code": "public static Predicate<String> startsWith(String startsWith) {\n    return new StartsWithFilter(startsWith);\n}",
    "label": 1,
    "rec": "@return a predicate that will accept any String that contains the specified CharSequence"
  },
  {
    "id": 1516,
    "type": "Return",
    "comment": "@return Client configuration.",
    "code": "    private ConnectorConfiguration config() {\n        return ctx.config().getConnectorConfiguration();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1517,
    "type": "Return",
    "comment": "@return The server array.",
    "code": "public static List<String> findDNS() {\n    List<String> res = null;\n    for (DNSServerLookupMechanism mechanism : LOOKUP_MECHANISMS) {\n        res = mechanism.getDnsServerAddresses();\n        if (res == null) {\n            continue;\n        }\n        assert (!res.isEmpty());\n        Iterator<String> it = res.iterator();\n        while (it.hasNext()) {\n            String potentialDnsServer = it.next();\n            if (!InetAddressUtil.isIpAddress(potentialDnsServer)) {\n                LOGGER.warning(STR + mechanism.getName() + STR + potentialDnsServer + STR);\n                it.remove();\n            } else if (blacklistedDnsServers.contains(potentialDnsServer)) {\n                LOGGER.fine(STR + mechanism.getName() + STR + potentialDnsServer + STR);\n                it.remove();\n            }\n        }\n        if (!res.isEmpty()) {\n            break;\n        } else {\n            LOGGER.warning(STR + mechanism.getName() + STR);\n        }\n    }\n    return res;\n}",
    "label": 1,
    "rec": "@return A list of DNS server IP addresses configured for this system."
  },
  {
    "id": 1518,
    "type": "Return",
    "comment": "@return true if the element and method should be generated",
    "code": "    public boolean generateUpdateByPrimaryKeySelective() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        if (ListUtilities.removeGeneratedAlwaysColumns(introspectedTable.getNonPrimaryKeyColumns()).isEmpty()) {\n            return false;\n        }\n        \n        boolean rc = tableConfiguration.isUpdateByPrimaryKeyStatementEnabled()\n                && introspectedTable.hasPrimaryKeyColumns()\n                && (introspectedTable.hasBLOBColumns() || introspectedTable\n                        .hasBaseColumns());\n\n        return rc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1519,
    "type": "Return",
    "comment": "@return Name of the file backup.",
    "code": "public static String createBackup(final String fullFileName) {\n    String retValue = fullFileName;\n    File f = new File(fullFileName);\n    File f2 = new File(fullFileName);\n    if (f.exists()) {\n        for (int n = NUM; f2.exists(); n++) {\n            f2 = new File(fullFileName + BACKUP_EXTENSION + n);\n        }\n        if (f.renameTo(f2)) {\n            retValue = f2.getAbsolutePath();\n        } else {\n            retValue = null;\n        }\n    }\n    return retValue;\n}",
    "label": 1,
    "rec": "@return Name of backup file. <code>fullFileName</code> if the file doesn't exist (no backup is made). <code>null</code> if it could not create a backup file."
  },
  {
    "id": 1520,
    "type": "Return",
    "comment": "@return Input stream.",
    "code": "    protected IgniteFsInputStream read() throws Exception {\n        return ggfs.open(FILE);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1521,
    "type": "Return",
    "comment": "@return a set of {@code n} {@link Share} instances",
    "code": "public Set<Part> split(ByteString secret) {\n    checkNotNull(secret, STR);\n    final byte[][] values = new byte[n][secret.size()];\n    for (int i = NUM; i < secret.size(); i++) {\n        final byte[] p = GF256.generate(random, k - NUM, secret.getByte(i));\n        for (int x = NUM; x <= n; x++) {\n            values[x - NUM][i] = GF256.eval(p, (byte) x);\n        }\n    }\n    final Set<Part> parts = new HashSet<>(n);\n    for (int i = NUM; i < values.length; i++) {\n        parts.add(Part.of(i + NUM, ByteString.of(values[i])));\n    }\n    return Collections.unmodifiableSet(parts);\n}",
    "label": 1,
    "rec": "@return a set of {@code n} {@link Part} instances"
  },
  {
    "id": 1522,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    private Object readResolve() throws ObjectStreamException {\n        return prj.message();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1523,
    "type": "Return",
    "comment": "@return the id of the homepage for the user if it is set, else -1 Finds the homepage set for the user, if none is set it checks on the homepage set for the users primary group, else it returns -1",
    "code": "public int getHomePageIDForUser(User user) {\n    IWMainApplicationSettings settings = this.getIWApplicationContext().getIWMainApplication().getSettings();\n    String forwardPage = settings.getProperty(IWAuthenticator.PROPERTY_FORWARD_PAGE_URI);\n    int homePageID = user.getHomePageID();\n    if (homePageID > NUM) {\n        return homePageID;\n    }\n    ICRole preferredRole = user.getPreferredRole();\n    Collection<Integer> homepages = new ArrayList<Integer>();\n    Collection<Integer> homePagesOfPreferredRole = new ArrayList<Integer>();\n    Collection<Group> groups = user.getParentGroups();\n    for (Group group : groups) {\n        if (group.getHomePageID() > NUM) {\n            Integer pageID = new Integer(group.getHomePageID());\n            if (!homepages.contains(pageID)) {\n                if (preferredRole != null) {\n                    Collection<ICRole> allRolesForGroup = this.getIWApplicationContext().getIWMainApplication().getAccessController().getAllRolesForGroup(group);\n                    if (!ListUtil.isEmpty(allRolesForGroup) && allRolesForGroup.contains(preferredRole)) {\n                        homePagesOfPreferredRole.add(pageID);\n                    }\n                }\n                homepages.add(pageID);\n            }\n        }\n    }\n    if (!ListUtil.isEmpty(homepages) && homepages.size() == NUM) {\n        return ((Integer) (homepages.iterator().next())).intValue();\n    }\n    if (!ListUtil.isEmpty(homePagesOfPreferredRole)) {\n        if (homePagesOfPreferredRole.size() == NUM) {\n            return ((Integer) (homePagesOfPreferredRole.iterator().next())).intValue();\n        }\n    }\n    if (forwardPage != null && (!ListUtil.isEmpty(homePagesOfPreferredRole) || !ListUtil.isEmpty(homepages))) {\n        try {\n            ICPageHome pageHome = (ICPageHome) IDOLookup.getHome(ICPage.class);\n            ICPage page = pageHome.findExistingByUri(forwardPage, this.getIWApplicationContext().getDomain().getID());\n            return ((Integer) page.getPrimaryKey()).intValue();\n        } catch (IDOLookupException e) {\n            e.printStackTrace();\n        } catch (FinderException fe) {\n            fe.printStackTrace();\n        }\n    } else {\n        if (!ListUtil.isEmpty(homePagesOfPreferredRole)) {\n            return ((Integer) (homePagesOfPreferredRole.iterator().next())).intValue();\n        }\n        Group primary = user.getPrimaryGroup();\n        if (primary != null) {\n            int homePageId = primary.getHomePageID();\n            if (homePageId > NUM) {\n                return homePageId;\n            }\n        }\n        if (!ListUtil.isEmpty(homepages)) {\n            return ((Integer) (homepages.iterator().next())).intValue();\n        }\n    }\n    return -NUM;\n}",
    "label": 1,
    "rec": "@return the URI of the page"
  },
  {
    "id": 1524,
    "type": "Return",
    "comment": "@return value of the given bit in the mapping matrix",
    "code": "  boolean readModule(int row, int column, int numRows, int numColumns) {\n    // Adjust the row and column indices based on boundary wrapping\n    if (row < 0) {\n      row += numRows;\n      column += 4 - ((numRows + 4) & 0x07);\n    }\n    if (column < 0) {\n      column += numColumns;\n      row += 4 - ((numColumns + 4) & 0x07);\n    }\n    readMappingMatrix.set(column, row);\n    return mappingBitMatrix.get(column, row);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1525,
    "type": "Return",
    "comment": "@return {@code KeyData} with a new {@code GcpKmsAeadKey} proto",
    "code": "@Override\npublic KeyData newKeyData(ByteString serializedKeyFormat) throws GeneralSecurityException {\n    KmsAeadKey key = (KmsAeadKey) newKey(serializedKeyFormat);\n    return KeyData.newBuilder().setTypeUrl(TYPE_URL).setValue(key.toByteString()).setKeyMaterialType(KeyData.KeyMaterialType.REMOTE).build();\n}",
    "label": 1,
    "rec": "@return {@code KeyData} with a new {@code KmsAeadKey} proto"
  },
  {
    "id": 1526,
    "type": "Return",
    "comment": "@return Unwrapped object.",
    "code": "    public Object unwrapPortableIfNeeded(Object o, boolean keepPortable) {\n        if (keepPortable || !config().isPortableEnabled())\n            return o;\n\n        return unwrapPortable(o);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1527,
    "type": "Return",
    "comment": "@return Flux stream containing simulated wind speed data",
    "code": "@Override\npublic Flux<Payload> requestStream(Payload payload) {\n    String streamName = payload.getDataUtf8();\n    if (DATA_STREAM_NAME.equals(streamName)) {\n        return Flux.from(dataPublisher);\n    }\n    return Flux.error(new IllegalArgumentException(streamName));\n}",
    "label": 1,
    "rec": "@return Flux stream containing simulated measurement data"
  },
  {
    "id": 1528,
    "type": "Return",
    "comment": "@return a read context",
    "code": "    public static DocumentContext parse(InputStream json) {\n        return new JsonContext().parse(json);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1529,
    "type": "Return",
    "comment": "@return edgePointer which is edgeId * edgeEntrySize",
    "code": "protected int internalEdgeAdd(int fromNodeId, int toNodeId, double dist, int flags) {\n    int newOrExistingEdge = nextEdge();\n    connectNewEdge(fromNodeId, newOrExistingEdge);\n    connectNewEdge(toNodeId, newOrExistingEdge);\n    writeEdge(newOrExistingEdge, fromNodeId, toNodeId, EMPTY_LINK, EMPTY_LINK, dist, flags);\n    return newOrExistingEdge;\n}",
    "label": 1,
    "rec": "@return edgeIdPointer which is edgeId * edgeEntrySize"
  },
  {
    "id": 1530,
    "type": "Return",
    "comment": "@return distributed id queue",
    "code": "    public DistributedIdQueue<T>      buildIdQueue()\n    {\n        return new DistributedIdQueue<T>\n        (\n            client,\n            consumer,\n            serializer,\n            queuePath,\n            factory,\n            executor,\n            Integer.MAX_VALUE,\n            false,\n            lockPath,\n            maxItems,\n            putInBackground,\n            finalFlushMs\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1531,
    "type": "Return",
    "comment": "@return the class object for the type of action bean bound to the url, or null if no bean is bound to that url",
    "code": "public Class<? extends ActionBean> getActionBeanType(String path) {\n    return this.formBeans.get(getUrlBindingFromPath(path));\n}",
    "label": 1,
    "rec": "@return the Class object for the type of action bean that will respond if a request is made using the path specified or null if no ActionBean matches."
  },
  {
    "id": 1532,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static char eq(char value) {\n        reportMatcher(new Equals(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1533,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastCompletedBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastCompletedBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 1534,
    "type": "Return",
    "comment": "@return Lifecycle bean.",
    "code": "    private GridLifecycleBean lifecycleBean(final Object[] keys) {\n        return new GridLifecycleBean() {\n            @GridInstanceResource\n            private Ignite ignite;\n\n            @Override public void onLifecycleEvent(GridLifecycleEventType evt) throws GridException {\n                switch (evt) {\n                    case AFTER_GRID_START: {\n                        GridCache<Object, MyValue> c1 = ignite.cache(\"one\");\n                        GridCache<Object, MyValue> c2 = ignite.cache(\"two\");\n\n                        if (!ignite.name().contains(\"Test0\")) {\n                            info(\"Keys already in cache:\");\n\n                            for (Object k : c1.keySet())\n                                info(\"Cache1: \" + k.toString());\n\n                            for (Object k : c2.keySet())\n                                info(\"Cache2: \" + k.toString());\n\n                            return;\n                        }\n\n                        info(\"Populating cache data...\");\n\n                        int i = 0;\n\n                        for (Object key : keys) {\n                            c1.put(key, new MyValue(value(key)));\n\n                            if (i++ % 2 == 0)\n                                c2.put(key, new MyValue(value(key)));\n                        }\n\n                        assert c1.size() == keys.length : \"Invalid cache1 size [size=\" + c1.size() +\n                            \", entries=\" + c1.entrySet() + ']';\n                        assert c2.size() == keys.length / 2 : \"Invalid cache2 size [size=\" + c2.size() +\n                            \", entries=\" + c2.entrySet() + ']';\n\n                        break;\n                    }\n\n                    case BEFORE_GRID_START:\n                    case BEFORE_GRID_STOP:\n                    case AFTER_GRID_STOP: {\n                        info(\"Lifecycle event: \" + evt);\n\n                        break;\n                    }\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1535,
    "type": "Return",
    "comment": "@return The actual sampling period at which a sensor can sample data. This value is a fraction of {@link #getExpectedSamplingPeriodUs()}.",
    "code": "public int getMaximumExpectedSamplingPeriodUs() {\n    int sensorReportingMode = mSensor.getReportingMode();\n    if (sensorReportingMode != Sensor.REPORTING_MODE_CONTINUOUS) {\n        return Integer.MAX_VALUE;\n    }\n    int expectedSamplingPeriodUs = getExpectedSamplingPeriodUs();\n    return (int) (expectedSamplingPeriodUs / MAXIMUM_EXPECTED_SAMPLING_FREQUENCY_MULTIPLIER);\n}",
    "label": 1,
    "rec": "@return The maximum acceptable actual sampling period of this sensor. For continuous sensors, this is higher than {@link #getExpectedSamplingPeriodUs()} because sensors are allowed to run up to 10% slower than requested. For sensors with other reporting modes, this is the maximum integer {@link Integer#MAX_VALUE} as they can report no events for long periods of time."
  },
  {
    "id": 1536,
    "type": "Return",
    "comment": "@return Local node.",
    "code": "    private ClusterNode localNode() {\n        if (locNode == null)\n            locNode = ggfsCtx.kernalContext().discovery().localNode();\n\n        return locNode;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1537,
    "type": "Return",
    "comment": "@return list of files to compact",
    "code": "private List<HStoreFile> getFilesToCompact() {\n    List<HStoreFile> filesToCompact = null;\n    this.lock.obtainWriteLock();\n    try {\n        filesToCompact = new ArrayList<HStoreFile>(this.storefiles.values());\n        Collections.reverse(filesToCompact);\n    } finally {\n        this.lock.releaseWriteLock();\n    }\n    return filesToCompact;\n}",
    "label": 1,
    "rec": "@return list of files to compact sorted so most recent comes first."
  },
  {
    "id": 1538,
    "type": "Return",
    "comment": "@return the Charset recognized.",
    "code": "    private Charset guessEncoding() {\n        // if the file has a Byte Order Marker, we can assume the file is in UTF-xx\n        // otherwise, the file would not be human readable\n        if (hasUTF8Bom()) {\n            return Charset.forName(\"UTF-8\");\n        }\n        if (hasUTF16LEBom()) {\n            return Charset.forName(\"UTF-16LE\");\n        }\n        if (hasUTF16BEBom()) {\n            return Charset.forName(\"UTF-16BE\");\n        }\n        \n        if (hasXMLHeader()) {\n            try {\n                XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader(new ByteArrayInputStream(buffer));\n                String encoding = xmlStreamReader.getCharacterEncodingScheme();\n\n                if (encoding != null) {\n                    Charset xmlCharset = Charset.forName(encoding.trim().toUpperCase());\n                    \n                    Logger.getLogger(\"\").log(Level.INFO, \"Detected encoding {0} in XML file\", xmlCharset.name());\n                    return xmlCharset;\n                }\n            } catch (Exception ex) {\n                //Could not find charset, keep normal process\n                Logger.getLogger(\"\").log(Level.WARNING, ex.getMessage());\n            }\n        }\n\n        // if a byte has its most significant bit set, the file is in UTF-8 or in the default encoding\n        // otherwise, the file is in US-ASCII\n        boolean highOrderBit = false;\n\n        // if the file is in UTF-8, high order bytes must have a certain value, in order to be valid\n        // if it's not the case, we can assume the encoding is the default encoding of the system\n        boolean validU8Char = true;\n\n        // TODO the buffer is not read up to the end, but up to length - 6\n\n        int length = buffer.length;\n        int i = 0;\n        while (i < length - 6) {\n            byte b0 = buffer[i];\n            byte b1 = buffer[i + 1];\n            byte b2 = buffer[i + 2];\n            byte b3 = buffer[i + 3];\n            byte b4 = buffer[i + 4];\n            byte b5 = buffer[i + 5];\n            if (b0 < 0) {\n                // a high order bit was encountered, thus the encoding is not US-ASCII\n                // it may be either an 8-bit encoding or UTF-8\n                highOrderBit = true;\n                // a two-bytes sequence was encoutered\n                if (isTwoBytesSequence(b0)) {\n                    // there must be one continuation byte of the form 10xxxxxx,\n                    // otherwise the following characteris is not a valid UTF-8 construct\n                    if (!isContinuationChar(b1)) {\n                        validU8Char = false;\n                    } else {\n                        i++;\n                    }\n                } // a three-bytes sequence was encoutered\n                else if (isThreeBytesSequence(b0)) {\n                    // there must be two continuation bytes of the form 10xxxxxx,\n                    // otherwise the following characteris is not a valid UTF-8 construct\n                    if (!(isContinuationChar(b1) && isContinuationChar(b2))) {\n                        validU8Char = false;\n                    } else {\n                        i += 2;\n                    }\n                } // a four-bytes sequence was encoutered\n                else if (isFourBytesSequence(b0)) {\n                    // there must be three continuation bytes of the form 10xxxxxx,\n                    // otherwise the following characteris is not a valid UTF-8 construct\n                    if (!(isContinuationChar(b1) && isContinuationChar(b2) && isContinuationChar(b3))) {\n                        validU8Char = false;\n                    } else {\n                        i += 3;\n                    }\n                } // a five-bytes sequence was encoutered\n                else if (isFiveBytesSequence(b0)) {\n                    // there must be four continuation bytes of the form 10xxxxxx,\n                    // otherwise the following characteris is not a valid UTF-8 construct\n                    if (!(isContinuationChar(b1) && isContinuationChar(b2) && isContinuationChar(b3) && isContinuationChar(b4))) {\n                        validU8Char = false;\n                    } else {\n                        i += 4;\n                    }\n                } // a six-bytes sequence was encoutered\n                else if (isSixBytesSequence(b0)) {\n                    // there must be five continuation bytes of the form 10xxxxxx,\n                    // otherwise the following characteris is not a valid UTF-8 construct\n                    if (!(isContinuationChar(b1) && isContinuationChar(b2) && isContinuationChar(b3) && isContinuationChar(b4) && isContinuationChar(b5))) {\n                        validU8Char = false;\n                    } else {\n                        i += 5;\n                    }\n                } else {\n                    validU8Char = false;\n                }\n            }\n            if (!validU8Char) {\n                break;\n            }\n            i++;\n        }\n        // if no byte with an high order bit set, the encoding is US-ASCII\n        // (it might have been UTF-7, but this encoding is usually internally used only by mail systems)\n        if (!highOrderBit) {\n            // returns the default charset rather than US-ASCII if the enforce8Bit flag is set.\n            if (this.enforce8Bit) {\n                return this.defaultCharset;\n            } else {\n                return Charset.forName(\"US-ASCII\");\n            }\n        }\n        // if no invalid UTF-8 were encountered, we can assume the encoding is UTF-8,\n        // otherwise the file would not be human readable\n        if (validU8Char) {\n            return Charset.forName(\"UTF-8\");\n        }\n        // finally, if it's not UTF-8 nor US-ASCII, let's assume the encoding is the default encoding\n        return this.defaultCharset;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1539,
    "type": "Return",
    "comment": "@return  True if node is not client node and pass given filter. TODO: GG-11010 review usages + CachePredicate usages.",
    "code": "    public static boolean affinityNode(ClusterNode node, IgnitePredicate<ClusterNode> filter) {\n        return !node.isDaemon() && !clientNode(node) && filter.apply(node);\n    }\n",
    "label": 1,
    "rec": "@return  True if node is not client node and pass given filter."
  },
  {
    "id": 1540,
    "type": "Return",
    "comment": "@return HystrixThreadPoolKey instance that is interned (cached) so a given name will always retrieve the same instance.",
    "code": "        public static HystrixThreadPoolKey asKey(String name) {\n            HystrixThreadPoolKey k = intern.get(name);\n            if (k == null) {\n                k = new HystrixThreadPoolKeyDefault(name);\n                intern.putIfAbsent(name, k);\n            }\n            return k;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1541,
    "type": "Return",
    "comment": "@return returns cookie value (or null if cookie with given key does not exist)",
    "code": "public Optional<String> readCookie(String key) {\n    return Arrays.stream(request.getCookies()).filter(c -> key.equals(c.getName())).map(Cookie::getValue).findFirst();\n}",
    "label": 1,
    "rec": "@return returns cookie value"
  },
  {
    "id": 1542,
    "type": "Return",
    "comment": "@return the current zoom value",
    "code": "    public float getZoom() {\n        return mCameraController.getZoomValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1543,
    "type": "Return",
    "comment": "@return The steps as a JSONArray.",
    "code": "public static JSONArray convertToJSON(String steps) {\n    JSONArray ja = new JSONArray();\n    steps = steps.trim();\n    if (TextUtils.isEmpty(steps)) {\n        return ja;\n    }\n    try {\n        for (String s : steps.split(STR)) {\n            float f = Float.parseFloat(s);\n            if (f <= NUM) {\n                return null;\n            }\n            int i = (int) f;\n            if (i == f) {\n                ja.put(i);\n            } else {\n                ja.put(f);\n            }\n        }\n    } catch (NumberFormatException e) {\n        return null;\n    } catch (JSONException e) {\n        return null;\n    }\n    return ja;\n}",
    "label": 1,
    "rec": "@return The steps as a JSONArray or null if the steps are not valid."
  },
  {
    "id": 1544,
    "type": "Return",
    "comment": "@return stubbable object that allows stubbing with throwable",
    "code": "    public static StubberFoo doReturn(Object toBeReturned) {\n        return doAnswer(new Returns(toBeReturned));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1545,
    "type": "Return",
    "comment": "@return RMSEs with first 1, 2, ..., regression trees.",
    "code": "    public double[][] test(DataFrame data) {\n        DataFrame x = formula.x(data);\n\n        int n = x.nrows();\n        int ntrees = trees.length;\n        double[][] prediction = new double[ntrees][n];\n\n        for (int j = 0; j < n; j++) {\n            Tuple xi = x.get(j);\n            double base = b;\n            for (int i = 0; i < ntrees; i++) {\n                prediction[i][j] = base + shrinkage * trees[i].predict(xi);\n                base = prediction[i][j];\n            }\n        }\n\n        return prediction;\n    }\n",
    "label": 1,
    "rec": "@return the predictions with first 1, 2, ..., regression trees."
  },
  {
    "id": 1546,
    "type": "Return",
    "comment": "@return this",
    "code": "        public Builder runSafeService(Executor runSafeService)\n        {\n            this.runSafeService = runSafeService;\n            return this;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1547,
    "type": "Return",
    "comment": "@return the {@link org.apache.tez.runtime.api.TezRootInputInitializerContext} for the input",
    "code": "public final InputInitializerContext getContext() {\n    return this.initializerContext;\n}",
    "label": 1,
    "rec": "@return the {@link org.apache.tez.runtime.api.InputInitializerContext} for the initializer"
  },
  {
    "id": 1548,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    public static char readChar(long ptr, int off) {\n        long addr = ptr + off;\n\n        return BIG_ENDIAN ? GridUnsafe.getCharLE(addr) : GridUnsafe.getChar(addr);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1549,
    "type": "Return",
    "comment": "@return {@code BuilderMethod} for methodDescriptor or null if not found",
    "code": "public BuilderMethod getMethod(String methodSignature) {\n    dexifyClassIfNecessary(methodSignature);\n    return methodSignatureToMethod.get(methodSignature);\n}",
    "label": 1,
    "rec": "@return {@code BuilderMethod} for methodSignature or null if not found"
  },
  {
    "id": 1550,
    "type": "Return",
    "comment": "@return next newly created key using the child derivation function",
    "code": "    public DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolean create) {\n        ImmutableList<ChildNumber> absolutePath = relativePath\n                ? ImmutableList.<ChildNumber>builder().addAll(rootPath).addAll(path).build()\n                : ImmutableList.copyOf(path);\n        if (!keys.containsKey(absolutePath)) {\n            checkArgument(create, \"No key found for {} path {}.\", relativePath ? \"relative\" : \"absolute\", path);\n            checkArgument(absolutePath.size() > 0, \"Can't derive the master key: nothing to derive from.\");\n            DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), relativePath, true);\n            putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1)));\n        }\n        return keys.get(absolutePath);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1551,
    "type": "Return",
    "comment": "@return the matching binding provider or null if no binding provider could be found",
    "code": "\tprivate boolean executeCommand(String itemName, Type command) {\n\t\tfinal RFXComBindingProvider provider = findFirstMatchingBindingProvider(itemName);\n\t\tif (provider == null) {\n\t\t\tlogger.warn(\n\t\t\t\t\t\"Cannot execute command because no binding provider was found for itemname '{}'\",\n\t\t\t\t\titemName);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!provider.isInBinding(itemName)) {\n\t\t\tlogger.debug(\n\t\t\t\t\t\"Received command (item='{}', state='{}', class='{}')\",\n\t\t\t\t\tnew Object[] { itemName, command.toString(),\n\t\t\t\t\t\t\tcommand.getClass().toString() });\n\t\t\tRFXComSerialConnector connector = RFXComConnection\n\t\t\t\t\t.getCommunicator();\n\n\t\t\tif (connector == null) {\n\t\t\t\tlogger.warn(\"RFXCom controller is not initialized!\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!connector.isConnected()) {\n\t\t\t\tlogger.warn(\"RFXCom controller is not connected\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn executeCommand0(itemName, command, provider, connector);\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\n\t\t\t\t\t\"Provider is not in binding '{}'\",\n\t\t\t\t\tprovider.toString());\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "@return true if the command was successfully sent, false otherwise"
  },
  {
    "id": 1552,
    "type": "Return",
    "comment": "@return Resolver.",
    "code": "    private IgniteFsStringDelimiterRecordResolver resolver(String... delims) {\n        return new IgniteFsStringDelimiterRecordResolver(UTF8, delims);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1553,
    "type": "Return",
    "comment": "@return output lop of maxpool operation with same parameters as this hop",
    "code": "private Lop getMaxPoolOutputLop() throws HopsException, LopsException {\n    if (op == ConvOp.MAX_POOLING_BACKWARD || op == ConvOp.AVG_POOLING_BACKWARD) {\n        ConvOp opType = (op == ConvOp.MAX_POOLING_BACKWARD) ? ConvOp.MAX_POOLING : ConvOp.AVG_POOLING;\n        Hop inputImage = getInput().get(NUM);\n        for (Hop tmpParent : inputImage.getParent()) {\n            if (!(tmpParent instanceof ConvolutionOp))\n                continue;\n            ConvolutionOp parent = (ConvolutionOp) tmpParent;\n            if (parent.getOp() == opType && isPoolingParametersEqualAndKnown(parent._cachedParams, _cachedParams)) {\n                return parent.constructLops();\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return output lop of max_pool/avg_pool operation with same parameters as this hop"
  },
  {
    "id": 1554,
    "type": "Return",
    "comment": "@return Default affinity key mapper.",
    "code": "    public CacheAffinityKeyMapper defaultAffMapper() {\n        return cacheObjCtx.defaultAffMapper();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1555,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder executionType(ExecutionType pExecutionType) {\n    this.executionType = pExecutionType;\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 1556,
    "type": "Return",
    "comment": "@return Maximum total number of reads of the owning cache.",
    "code": "    public long maximumReads() {\n        if (maxReads == null) {\n            maxReads = Long.MIN_VALUE;\n\n            for (VisorCacheMetrics metric : metrics.values())\n                maxReads = Math.max(maxReads, metric.reads());\n        }\n\n        return maxReads;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1557,
    "type": "Return",
    "comment": "@return An Observable that emits a list of {@link WebService}",
    "code": "public Observable<List<SyncUrl>> getWebServices() {\n    return Observable.create(subscriber -> {\n        final List<SyncUrl> syncUrls = cupboard().withDatabase(getReadableDatabase()).query(SyncUrl.class).list();\n        if (syncUrls != null) {\n            subscriber.onNext(syncUrls);\n            subscriber.onCompleted();\n        } else {\n            subscriber.onError(new WebServiceNotFoundException());\n        }\n    });\n}",
    "label": 1,
    "rec": "@return An Observable that emits a list of {@link SyncUrl}"
  },
  {
    "id": 1558,
    "type": "Return",
    "comment": "@return a reference to the GemfireOperations used to interact with GemFire.",
    "code": "\tpublic GemfireOperations getTemplate() {\n\t\treturn this.template;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1559,
    "type": "Return",
    "comment": "@return TccTransactionCacheManager",
    "code": "public static HmilyTransactionCacheManager getInstance() {\n    return TCC_TRANSACTION_CACHE_MANAGER;\n}",
    "label": 1,
    "rec": "@return HmilyTransactionCacheManager"
  },
  {
    "id": 1560,
    "type": "Return",
    "comment": "@return Move up row.",
    "code": "        private L insert(BPlusIO<L> io, ByteBuffer buf, int idx, int lvl)\n            throws IgniteCheckedException {\n            int maxCnt = io.getMaxCount(buf);\n            int cnt = io.getCount(buf);\n\n            if (cnt == maxCnt) // Need to split page.\n                return insertWithSplit(io, buf, idx, lvl);\n\n            insertSimple(io, buf, idx);\n\n            return null;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1561,
    "type": "Return",
    "comment": "@return List of CompilerError objects",
    "code": "protected static List<CompilerMessage> parseModernStream(BufferedReader input) throws IOException {\n    List<CompilerMessage> messages = new ArrayList<CompilerMessage>();\n    String type = null;\n    String file = null;\n    int lineNr = -NUM;\n    StringBuilder messageBuffer = new StringBuilder();\n    for (String line = input.readLine(); line != null; line = input.readLine()) {\n        Matcher matcher = LINE_PATTERN.matcher(line);\n        if (matcher.matches()) {\n            addMessageIfFound(messages, type, file, lineNr, messageBuffer.toString());\n            matcher.group(NUM);\n            type = matcher.group(NUM);\n            file = matcher.group(NUM);\n            String lineNumberString = matcher.group(NUM);\n            if (lineNumberString != null) {\n                lineNr = Integer.parseInt(lineNumberString);\n            } else {\n                lineNr = -NUM;\n            }\n            messageBuffer = new StringBuilder();\n        } else {\n            if (!SEPARATOR.equals(line) && line.trim().length() > NUM) {\n                messageBuffer.append(EOL).append(line);\n            }\n        }\n    }\n    addMessageIfFound(messages, type, file, lineNr, messageBuffer.toString());\n    return messages;\n}",
    "label": 1,
    "rec": "@return List of CompilerMessage objects"
  },
  {
    "id": 1562,
    "type": "Return",
    "comment": "@return a null which the caller can use to clear the reference to that instance.",
    "code": "  public SslContextProvider<K> release(final SslContextProvider<K> value) {\n    checkNotNull(value, \"value\");\n    K key = value.getSource();\n    return releaseInternal(key, value);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1563,
    "type": "Return",
    "comment": "@return the definition model",
    "code": "public static AspectWerkzDefinition loadDefinitionAsResource() {\n    InputStream stream = getDefinitionInputStream();\n    if (stream == null)\n        throw new RuntimeException(STR);\n    return AspectWerkzDefinition.loadDefinitionAsStream(stream);\n}",
    "label": 1,
    "rec": "@return the definition"
  },
  {
    "id": 1564,
    "type": "Return",
    "comment": "@return true if the change attempt was successful, false if not. If the change was not successful,  #getValue() will return the updated value",
    "code": "    public boolean trySetValue(byte[] newValue) throws Exception\n    {\n        Preconditions.checkState(state.get() == State.STARTED, \"not started\");\n\n        try\n        {\n            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);\n            stat.setVersion(stat.getVersion() + 1);\n            value = Arrays.copyOf(newValue, newValue.length);\n            return true;\n        }\n        catch ( KeeperException.BadVersionException ignore )\n        {\n            // ignore\n        }\n\n        readValue();\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1565,
    "type": "Return",
    "comment": "@return the skip phrase or null if we don't find it",
    "code": "private String checkSkipBuildInString(Map<Pattern, String> patterns, String string) {\n    if (!patterns.isEmpty() && StringUtils.isNotBlank(string)) {\n        for (Map.Entry<Pattern, String> e : patterns.entrySet()) {\n            if (e.getKey().matcher(string).matches()) {\n                return e.getValue();\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the skip value or null if we don't find it"
  },
  {
    "id": 1566,
    "type": "Return",
    "comment": "@return Whether the specified request has been approved by the current user.",
    "code": "\tpublic boolean isApproved(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n\t\tif (useTokenServices && super.isApproved(authorizationRequest, userAuthentication)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!userAuthentication.isAuthenticated()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn authorizationRequest.isApproved()\n\t\t\t\t|| (authorizationRequest.getResponseTypes().contains(\"token\") && autoApproveClients\n\t\t\t\t\t\t.contains(authorizationRequest.getClientId()));\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1567,
    "type": "Return",
    "comment": "@return Basic scope object",
    "code": "public IBasicScope getBasicScope(ScopeType type, String name) {\n    boolean skipTypeCheck = ScopeType.UNDEFINED.equals(type);\n    if (skipTypeCheck) {\n        for (IBasicScope child : keySet()) {\n            if (name.equals(child.getName())) {\n                log.debug(STR, child);\n                return child;\n            }\n        }\n    } else {\n        for (IBasicScope child : keySet()) {\n            if (child.getType().equals(type) && name.equals(child.getName())) {\n                log.debug(STR, child);\n                return child;\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return scope"
  },
  {
    "id": 1568,
    "type": "Return",
    "comment": "@return Runnable that can be executed in a different thread with the same projection as for current thread.",
    "code": "    public Runnable projectSafe(final Runnable r) {\n        assert r != null;\n\n        // Have to get projection per call used by calling thread to use it in a new thread.\n        final CacheOperationContext opCtx = operationContextPerCall();\n\n        if (opCtx == null)\n            return r;\n\n        return new GPR() {\n            @Override public void run() {\n                CacheOperationContext old = operationContextPerCall();\n\n                operationContextPerCall(opCtx);\n\n                try {\n                    r.run();\n                }\n                finally {\n                    operationContextPerCall(old);\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1569,
    "type": "Return",
    "comment": "@return {@link Actor}",
    "code": "private static ActivityObject buildActor(com.google.api.services.plus.model.Activity.Actor gPlusActor) {\n    ActivityObject actor = new ActivityObject();\n    actor.setDisplayName(gPlusActor.getDisplayName());\n    actor.setId(formatId(String.valueOf(gPlusActor.getId())));\n    actor.setUrl(gPlusActor.getUrl());\n    Image image = new Image();\n    com.google.api.services.plus.model.Activity.Actor.Image googlePlusImage = gPlusActor.getImage();\n    if (googlePlusImage != null) {\n        image.setUrl(googlePlusImage.getUrl());\n    }\n    actor.setImage(image);\n    return actor;\n}",
    "label": 1,
    "rec": "@return {@link ActivityObject}"
  },
  {
    "id": 1570,
    "type": "Return",
    "comment": "@return number of OnNext emissions by a streaming fallback",
    "code": "    public int getNumberFallbackEmissions() {\n        return executionResult.getEventCounts().getCount(HystrixEventType.FALLBACK_EMIT);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1571,
    "type": "Return",
    "comment": "@return g if this is not the final layer of an auto-encoder, otherwise return the difference between the output (auto-encoder output layer activation) and the target (input layer activation)",
    "code": "  protected float autoEncoderError(int row) {\n    assert (_minfo.get_params().autoencoder && _index == _minfo.get_params().hidden.length);\n    assert (params.loss == Loss.MeanSquare);\n    return (_input._a.get(row) - _a.get(row));\n  }\n",
    "label": 1,
    "rec": "@return difference between the output (auto-encoder output layer activation) and the target (input layer activation)"
  },
  {
    "id": 1572,
    "type": "Return",
    "comment": "@return the shared index informer",
    "code": "      public TList list(ListOptions params, String namespace, OperationContext context) throws KubernetesClientException {\n        BaseOperation<T, TList, ?, ?> listBaseOperation = baseOperation.newInstance(context.withNamespace(namespace));\n        listBaseOperation.setType(apiTypeClass);\n        listBaseOperation.setListType(apiListTypeClass);\n\n        return listBaseOperation.list();\n      }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1573,
    "type": "Return",
    "comment": "@return average variance between counters and pattern",
    "code": "  static int patternMatchVariance(int[] counters, int[] pattern) {\n    int numCounters = counters.length;\n    int total = 0;\n    int patternLength = 0;\n    for (int i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Integer.MAX_VALUE;\n    }\n    // We're going to fake floating-point math in integers. We just need to use more bits.\n    // Scale up patternLength so that intermediate values below like scaledCounter will have\n    // more \"significant digits\"\n    patternLength <<= INTEGER_MATH_SHIFT;\n    int patternRatio = patternLength / total;\n\n    int totalVariance = 0;\n    for (int x = 0; x < numCounters; x++) {\n      int scaledCounter = counters[x] * patternRatio;\n      int width = pattern[x] << INTEGER_MATH_SHIFT;\n      totalVariance += scaledCounter > width ? scaledCounter - width : width - scaledCounter;\n    }\n    return (totalVariance << 8) / patternLength;\n  }\n",
    "label": 1,
    "rec": "@return ratio of total variance between counters and pattern compared to total pattern size, where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means the total variance between counters and patterns equals the pattern length, higher values mean even more variance"
  },
  {
    "id": 1574,
    "type": "Return",
    "comment": "@return Transactions configuration.",
    "code": "    public TransactionsConfiguration getTransactionsConfiguration() {\n        return txCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1575,
    "type": "Return",
    "comment": "@return an  org.jsecurity.authc.Account instance containing information retrieved from LDAP that can be used to build an  org.jsecurity.authc.Account instance to return.",
    "code": "    protected AuthorizingAccount queryForLdapAccount( Object principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principal instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        List<String> roleNames;\n\n        try {\n\n            roleNames = getRoleNamesForUser(username, ldapContext);\n\n        } finally {\n\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizingAccount( roleNames, null );\n    }\n",
    "label": 1,
    "rec": "@return the Account for the given Subject principal."
  },
  {
    "id": 1576,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "        private Result removeFromLeaf(long leafId, Page leaf, long backId, long fwdId) throws IgniteCheckedException {\n            // Init parameters.\n            this.pageId = leafId;\n            this.page = leaf;\n            this.backId = backId;\n            this.fwdId = fwdId;\n\n            if (backId == 0)\n                return doRemoveFromLeaf();\n\n            // Lock back page before the remove, we'll need it for merges.\n            Page back = page(backId);\n\n            try {\n                return writePage(backId, back, lockBackAndRemoveFromLeaf, this, 0);\n            }\n            finally {\n                if (canRelease(backId, back, 0))\n                    back.close();\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1577,
    "type": "Return",
    "comment": "@return the String representation of this {@link ByteString}",
    "code": "@Override\npublic String toString() {\n    final int NUM_BYTES = NUM;\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    sb.append(length());\n    if (_bytes.length > NUM) {\n        sb.append(STR);\n        for (int i = NUM; i < Math.min(_bytes.length, NUM_BYTES); i++) {\n            sb.append(String.format(STR, (int) _bytes[i] & NUM));\n        }\n        if (_bytes.length > NUM_BYTES * NUM) {\n            sb.append(STR);\n        }\n        for (int i = Math.max(NUM_BYTES, _bytes.length - NUM_BYTES); i < _bytes.length; i++) {\n            sb.append(String.format(STR, (int) _bytes[i] & NUM));\n        }\n    }\n    sb.append(STR);\n    return sb.toString();\n}",
    "label": 1,
    "rec": "@return a summary representation of this {@link ByteString}"
  },
  {
    "id": 1578,
    "type": "Return",
    "comment": "@return Affinity.",
    "code": "    private CacheAffinity<Object> affinity(int idx) {\n        return grid(idx).affinity(null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1579,
    "type": "Return",
    "comment": "@return true if type is a member of the union.",
    "code": "public boolean contains(String memberKey) {\n    return _memberKeyToIndexMap.containsKey(memberKey);\n}",
    "label": 1,
    "rec": "@return true if maps to an existing member of the union, false otherwise."
  },
  {
    "id": 1580,
    "type": "Return",
    "comment": "@return true iff the process has been started",
    "code": "  public boolean isStarted() {\n    return this.startupLatch.getCount() == 0L;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1581,
    "type": "Return",
    "comment": "@return The newly created Peer object. Use  com.google.bitcoin.core.Peer#getConnectionOpenFuture() if you want a future which completes when the connection is open, or null if the peer could not be connected.",
    "code": "    public Peer connectTo(InetSocketAddress address) {\n        PeerAddress peerAddress = new PeerAddress(address);\n        backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));\n        return connectTo(peerAddress, true);\n    }\n",
    "label": 1,
    "rec": "@return The newly created Peer object or null if the peer could not be connected. Use  com.google.bitcoin.core.Peer#getConnectionOpenFuture() if you want a future which completes when the connection is open."
  },
  {
    "id": 1582,
    "type": "Return",
    "comment": "@return Entry (never  null).",
    "code": "    public GridCacheEntryEx entryEx(KeyCacheObject key, boolean touch) {\n        GridCacheEntryEx e = entry0(key, ctx.affinity().affinityTopologyVersion(), true, touch);\n\n        assert e != null;\n\n        return e;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1583,
    "type": "Return",
    "comment": "@return Afinity key.",
    "code": "        public Object key(boolean useColocatedData) {\n            return useColocatedData ? new AffinityKey<>(id, orderId) : id;\n        }\n",
    "label": 1,
    "rec": "@return Key."
  },
  {
    "id": 1584,
    "type": "Return",
    "comment": "@return Cache instance for given name.",
    "code": "    private IgniteCache startJCache(String cacheName, boolean failIfNotStarted) throws IgniteCheckedException {\n        IgniteInternalFuture<?> fut = startCacheAsync(cacheName, failIfNotStarted);\n\n        if (fut != null) {\n            fut.get();\n\n            String masked = maskNull(cacheName);\n\n            IgniteCache cache = jCacheProxies.get(masked);\n\n            if (cache == null && failIfNotStarted)\n                throw new IllegalArgumentException(\"Cache is not started: \" + cacheName);\n\n            return cache;\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1585,
    "type": "Return",
    "comment": "@return String buffer appended by flag if it's presented in bit set.",
    "code": "    private StringBuilder addFlag(StringBuilder sb, int flags, int mask, String flagName) {\n        if ((flags & mask) > 0)\n            sb.append(sb.length() > 0 ? \",\" : \"\").append(flagName);\n\n        return sb;\n    }\n",
    "label": 1,
    "rec": "@return String builder appended by flag if it's presented in bit set."
  },
  {
    "id": 1586,
    "type": "Return",
    "comment": "@return the command class.",
    "code": "\tpublic ZWaveCommandClass resolveCommandClass(CommandClass commandClass, int endpointId)\n\t{\n\t\tif (commandClass == null)\n\t\t\treturn null;\n\t\t\n\t\tZWaveMultiInstanceCommandClass multiInstanceCommandClass = (ZWaveMultiInstanceCommandClass)supportedCommandClasses.get(CommandClass.MULTI_INSTANCE);\n\t\t\n\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 2) {\n\t\t\tZWaveEndpoint endpoint = multiInstanceCommandClass.getEndpoint(endpointId);\n\t\t\t\n\t\t\tif (endpoint != null) { \n\t\t\t\tZWaveCommandClass result = endpoint.getCommandClass(commandClass);\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t} \n\t\t}\n\t\t\n\t\tZWaveCommandClass result = getCommandClass(commandClass);\n\t\t\n\t\tif (result == null)\n\t\t\treturn result;\n\t\t\n\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 1 &&\n\t\t\t\tresult.getInstances() >= endpointId)\n\t\t\treturn result;\n\t\t\n\t\treturn endpointId == 0 ? result : null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1587,
    "type": "Return",
    "comment": "@return the uuid of the new root",
    "code": "public List<MetadataBlock> reRoot(UUID rootBlockIdent, MetadataBlock targetBlock, MetadataBlock newTargetBlock) {\n    neo4JStorage.pathsFromTo(rootBlockIdent, targetBlock.ident);\n    return Arrays.asList(MetadataBlock.emptyRandomBlock());\n}",
    "label": 1,
    "rec": "@return the new blocks required to create the new path, including the newly elected root block as last element of the list"
  },
  {
    "id": 1588,
    "type": "Return",
    "comment": "@return Transactions interface implementation.",
    "code": "    public GridTransactions transactions() {\n        return transactions;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1589,
    "type": "Return",
    "comment": "@return true if a the throwableToInspect corresponds to or is caused by the throwableClassToLookFor",
    "code": "public static boolean recursiveClassEquals(Throwable throwableToInspect, Class... throwableClassesToLookFor) {\n    for (Class clazz : throwableClassesToLookFor) {\n        Class classToInspect = throwableToInspect.getClass();\n        while (classToInspect != null) {\n            if (classToInspect.equals(clazz)) {\n                return true;\n            }\n            classToInspect = classToInspect.getSuperclass();\n        }\n    }\n    Throwable cause = throwableToInspect.getCause();\n    return cause != null && recursiveClassEquals(cause, throwableClassesToLookFor);\n}",
    "label": 1,
    "rec": "@return true if a the throwableToInspect corresponds to or is caused by any of the throwableClassesToLookFor"
  },
  {
    "id": 1590,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte not(byte first) {\n        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1591,
    "type": "Return",
    "comment": "@return a resolved {@link Maybe} representation of a given lifecycle, targeting the given event",
    "code": "public static <E> CompletableSource resolveScopeFromLifecycle(Observable<E> lifecycle, final E endEvent) {\n    @Nullable\n    Comparator<E> comparator = null;\n    if (endEvent instanceof Comparable) {\n        comparator = (Comparator<E>) COMPARABLE_COMPARATOR;\n    }\n    return resolveScopeFromLifecycle(lifecycle, endEvent, comparator);\n}",
    "label": 1,
    "rec": "@return a resolved {@link Completable} representation of a given lifecycle, targeting the given event"
  },
  {
    "id": 1592,
    "type": "Return",
    "comment": "@return Globally unique ID of this event.",
    "code": "    public IgniteUuid id() {\n        return id;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1593,
    "type": "Return",
    "comment": "@return {@link org.apache.stratos.messaging.domain.instance.context.InstanceContext} object if object found and removed, null if otherwise.",
    "code": "private Instance removeInstanceFrom(Iterator<Instance> iterator, String instanceId) {\n    while (iterator.hasNext()) {\n        Instance activeInstance = iterator.next();\n        if (activeInstance == null) {\n            iterator.remove();\n            continue;\n        }\n        if (instanceId.equals(activeInstance.getInstanceId())) {\n            iterator.remove();\n            return activeInstance;\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return {@link org.apache.stratos.messaging.domain.instance.Instance} object if object found and removed, null if otherwise."
  },
  {
    "id": 1594,
    "type": "Return",
    "comment": "@return cumulative count of threads executed",
    "code": "    public long getCumulativeCountThreadsExecuted() {\n        return getCumulativeCount(HystrixRollingNumberEvent.THREAD_EXECUTION);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1595,
    "type": "Return",
    "comment": "@return true if dispatch was successful, false otherwise",
    "code": "\t\tpublic boolean dispatch(Msg msg, String port) {\n\t\t\tbyte cmd  = 0x00;\n\t\t\tbyte cmd1 = 0x00;\n\t\t\tboolean isConsumed = false;\n\t\t\tint key = -1;\n\t\t\ttry {\n\t\t\t\tcmd  = msg.getByte(\"Cmd\");\n\t\t\t\tcmd1 = msg.getByte(\"command1\");\n\t\t\t} catch (FieldException e) {\n\t\t\t\tlogger.debug(\"no command found, dropping msg {}\", msg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (handleAllLinkMessage(msg, port)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (msg.isAckOfDirect()) {\n\t\t\t\t// in the case of direct ack, the cmd1 code is useless.\n\t\t\t\t// you have to know what message was sent before to\n\t\t\t\t// interpret the reply message\n\t\t\t\tif (m_feature.getQueryStatus() == DeviceFeature.QueryStatus.QUERY_PENDING\n\t\t\t\t\t\t&& cmd == 0x50) {\n\t\t\t\t\t// must be a reply to our message, tweak the cmd1 code!\n\t\t\t\t\tlogger.trace(\"changing key to 0x19 for msg {}\", msg);\n\t\t\t\t\tkey = 0x19; // we have installed a handler under that command number\n\t\t\t\t\tisConsumed = true;\n\t\t\t\t} else {\n\t\t\t\t\tkey = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkey = (cmd1 & 0xFF);\n\t\t\t}\n\t\t\tif (key != -1 || m_feature.isStatusFeature()) {\n\t\t\t\tMessageHandler h = m_feature.getMsgHandlers().get(key);\n\t\t\t\tif (h == null) h = m_feature.getDefaultMsgHandler();\n\t\t\t\tlogger.trace(\"{}:{}->{} DIRECT: {}\", m_feature.getDevice().getAddress(), m_feature.getName(),\n\t\t\t\t\t\th.getClass().getSimpleName(), msg);\n\t\t\t\th.handleMessage(-1, cmd1, msg, m_feature, port);\n\t\t\t}\n\t\t\tif (isConsumed) {\n\t\t\t\tm_feature.setQueryStatus(DeviceFeature.QueryStatus.QUERY_ANSWERED);\n\t\t\t}\n\t\t\treturn isConsumed;\n\t\t}\n",
    "label": 1,
    "rec": "@return true if this message was found to be a reply to a direct message, and was claimed by one of the handlers"
  },
  {
    "id": 1596,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteFuture<GridCacheTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteFuture<GridCacheTxEx<K, V>> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteFuture<GridCacheTx>)(IgniteFuture)prep;\n\n            return new GridFinishedFuture<GridCacheTx>(cctx.kernalContext(), this);\n        }\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (GridCacheTxOptimisticException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (GridException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listenAsync(new CI1<IgniteFuture<GridCacheTxEx<K, V>>>() {\n                @Override public void apply(IgniteFuture<GridCacheTxEx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (GridCacheTxOptimisticException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (GridException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1597,
    "type": "Return",
    "comment": "@return the fcth instance from lire",
    "code": "@Deprecated\npublic net.semanticmetadata.lire.imageanalysis.FCTH getFcth() {\n    return (net.semanticmetadata.lire.imageanalysis.FCTH) getLireFeature();\n}",
    "label": 1,
    "rec": "@return the FCTH Lire feature object"
  },
  {
    "id": 1598,
    "type": "Return",
    "comment": "@return true if this object contains enough information to retrieve a token",
    "code": "    public boolean isValid() {\n        if (grantType==null) {\n            return false;\n        }\n        switch (grantType) {\n            case CLIENT_CREDENTIALS:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret\n                    )\n                );\n            case PASSWORD:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password\n                    )\n                );\n            case PASSWORD_WITH_PASSCODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        passcode\n                    )\n                );\n            case AUTHORIZATION_CODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri\n                    )\n                );\n            case AUTHORIZATION_CODE_WITH_TOKEN:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri,\n                        authCodeAPIToken\n                    )\n                );\n            default: return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1599,
    "type": "Return",
    "comment": "@return <tt>true</tt> if the supplied object is a <code>GateEditPart</code>; otherwise <tt>false</tt>.",
    "code": "protected boolean isGateEditPart(Object object) {\n    return object instanceof BorderItemEditPart && ((BorderItemEditPart) object).getMainFigure() instanceof BorderItemFigure;\n}",
    "label": 1,
    "rec": "@return <tt>true</tt> if the supplied object is a <code>BorderItemEditPart</code>; otherwise <tt>false</tt>."
  },
  {
    "id": 1600,
    "type": "Return",
    "comment": "@return response builder",
    "code": "    public ResponseBuilder withSpeech(String speechText) {\n        return withSpeech(speechText, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1601,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forWebInfLib(final ServletContext servletContext) {\n    final Collection<URL> urls = new ArrayList<URL>();\n    for (Object urlString : servletContext.getResourcePaths(STR)) {\n        try {\n            urls.add(servletContext.getResource((String) urlString));\n        } catch (MalformedURLException e) {\n        }\n    }\n    return distinctUrls(urls);\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 1602,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteInternalFuture<IgniteInternalTx<K, V>> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteInternalFuture<IgniteInternalTx>)(IgniteInternalFuture)prep;\n\n            return new GridFinishedFuture<IgniteInternalTx>(cctx.kernalContext(), this);\n        }\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (IgniteTxOptimisticCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listenAsync(new CI1<IgniteInternalFuture<IgniteInternalTx<K, V>>>() {\n                @Override public void apply(IgniteInternalFuture<IgniteInternalTx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (IgniteTxOptimisticCheckedException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (IgniteCheckedException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1603,
    "type": "Return",
    "comment": "@return the Collection of File produced",
    "code": "    public File[] build() throws IOException, InterruptedException {\n        if (classScanner.getClasses().isEmpty()) {\n            return null;\n        }\n\n        LinkedList<File> outputFiles = new LinkedList<File>();\n        Map<String, LinkedList<Class>> map = new LinkedHashMap<String, LinkedList<Class>>();\n        for (Class c : classScanner.getClasses()) {\n            if (Loader.getEnclosingClass(c) != c) {\n                continue;\n            }\n            Loader.ClassProperties p = Loader.loadProperties(c, properties, false);\n            String libraryName = outputName != null ? outputName : p.getProperty(\"loader.library\", \"\");\n            if (libraryName.length() == 0) {\n                continue;\n            }\n            LinkedList<Class> classList = map.get(libraryName);\n            if (classList == null) {\n                map.put(libraryName, classList = new LinkedList<Class>());\n            }\n            classList.add(c);\n        }\n        for (String libraryName : map.keySet()) {\n            LinkedList<Class> classList = map.get(libraryName);\n            Class[] classArray = classList.toArray(new Class[classList.size()]);\n            File f = generateAndCompile(classArray, libraryName);\n            if (f != null) {\n                outputFiles.add(f);\n                if (copylibs) {\n                    // Do not copy library files from inherit properties ...\n                    Loader.ClassProperties p = Loader.loadProperties(classArray, properties, false);\n                    LinkedList<String> preloads = new LinkedList<String>();\n                    preloads.addAll(p.get(\"loader.preload\"));\n                    preloads.addAll(p.get(\"compiler.link\"));\n                    // ... but we should use all the inherited paths!\n                    p = Loader.loadProperties(classArray, properties, true);\n\n                    File directory = f.getParentFile();\n                    for (String s : preloads) {\n                        URL[] urls = Loader.findLibrary(null, p, s);\n                        File fi;\n                        try {\n                            fi = new File(urls[0].toURI());\n                        } catch (Exception e) {\n                            continue;\n                        }\n                        File fo = new File(directory, fi.getName());\n                        if (fi.exists() && !outputFiles.contains(fo)) {\n                            System.out.println(\"Copying library file: \" + fi);\n                            FileInputStream fis = new FileInputStream(fi);\n                            FileOutputStream fos = new FileOutputStream(fo);\n                            byte[] buffer = new byte[1024];\n                            int length;\n                            while ((length = fis.read(buffer)) != -1) {\n                                fos.write(buffer, 0, length);\n                            }\n                            fos.close();\n                            fis.close();\n                            outputFiles.add(fo);\n                        }\n                    }\n                }\n            }\n        }\n\n        File[] files = outputFiles.toArray(new File[outputFiles.size()]);\n        if (jarPrefix != null && files.length > 0) {\n            File jarFile = new File(jarPrefix + \"-\" + properties.get(\"platform.name\") + \".jar\");\n            File d = jarFile.getParentFile();\n            if (d != null && !d.exists()) {\n                d.mkdir();\n            }\n            createJar(jarFile, outputDirectory == null ? classScanner.getClassLoader().getPaths() : null, files);\n        }\n        return files;\n    }\n",
    "label": 1,
    "rec": "@return the array of File produced"
  },
  {
    "id": 1604,
    "type": "Return",
    "comment": "@return The sha1 hash of the input bytes",
    "code": "    public static byte[] sha1(byte[] input) {\n        try {\n            MessageDigest digest = (MessageDigest) SHA1_PROTOTYPE.clone();\n            return digest.digest(input);\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1605,
    "type": "Return",
    "comment": "@return the ServletResponse bound to the thread, or null if there isn't one bound.",
    "code": "    public static ServletResponse getServletResponse() {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if( response == null ) {\n            throw new IllegalStateException( \"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE );\n        }\n        return response;\n    }\n",
    "label": 1,
    "rec": "@return the ServletResponse bound to the thread. Never returns null."
  },
  {
    "id": 1606,
    "type": "Return",
    "comment": "@return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC. May be null if no amount is specified",
    "code": "    public Coin getAmount() {\n        return (Coin) parameterMap.get(FIELD_AMOUNT);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1607,
    "type": "Return",
    "comment": "@return an array of booleans indicating the configuration of the passed @UnsafeAdapterConfiguration instance",
    "code": "public static int[] getRequestedConfiguration(UnsafeAdapterConfiguration config) {\n    final int[] requested = new int[PROP_SIZE];\n    requested[NUM] = config.unsafe() ? NUM : NUM;\n    requested[NUM] = config.memTracking() ? NUM : NUM;\n    requested[NUM] = config.memAlignment() ? NUM : NUM;\n    requested[NUM] = config.offHeap() ? NUM : NUM;\n    requested[NUM] = config.apAllocSize();\n    return requested;\n}",
    "label": 1,
    "rec": "@return an array of ints indicating the configuration of the passed @UnsafeAdapterConfiguration instance"
  },
  {
    "id": 1608,
    "type": "Return",
    "comment": "@return returns true on success.",
    "code": "    public boolean createNew(TYPE item) {\n        long newRow = database.insert(table.name,\n                AbstractModel.ID_PROPERTY.name, item.getMergedValues());\n        boolean result = newRow >= 0;\n        if(result) {\n            item.markSaved();\n            item.setId(newRow);\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1609,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)",
    "code": "  private Frame reBalance(final Frame fr, boolean local) {\n    int cores = 0;\n    for( H2ONode node : H2O.CLOUD._memary ) {\n      if (local) cores = Math.max(cores, node._heartbeat._num_cpus);\n      else cores += node._heartbeat._num_cpus;\n    }\n    final int chunks = 4*cores;\n    if (force_load_balance && chunks < fr.numRows()) {\n//      return MRUtils.shuffleAndBalance(fr, chunks, seed, local, shuffle_training_data) : fr;\n      Key newKey = fr._key != null ? Key.make(fr._key.toString() + \".balanced\") : Key.make();\n      RebalanceDataSet rb = new RebalanceDataSet(fr, newKey, chunks);\n      H2O.submitTask(rb);\n      rb.join();\n      Frame rebalanced = UKV.get(newKey);\n      return rebalanced;\n    }\n    else return fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks"
  },
  {
    "id": 1610,
    "type": "Return",
    "comment": "@return Cache configuration for atomic data structures.",
    "code": "        private static CacheConfiguration atomicsSystemCache(AtomicConfiguration cfg, boolean client) {\n            CacheConfiguration ccfg = new CacheConfiguration();\n\n            ccfg.setName(CU.ATOMICS_CACHE_NAME);\n            ccfg.setAtomicityMode(TRANSACTIONAL);\n            ccfg.setSwapEnabled(false);\n            ccfg.setPreloadMode(SYNC);\n            ccfg.setWriteSynchronizationMode(FULL_SYNC);\n            ccfg.setCacheMode(cfg.getCacheMode());\n\n            if (cfg.getCacheMode() == PARTITIONED) {\n                ccfg.setBackups(cfg.getBackups());\n\n                ccfg.setDistributionMode(client ? NEAR_ONLY : NEAR_PARTITIONED);\n            }\n            else\n                ccfg.setDistributionMode(client ? NEAR_ONLY : PARTITIONED_ONLY);\n\n            return ccfg;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1611,
    "type": "Return",
    "comment": "@return the current value",
    "code": "@Override\npublic AtomicValue<T> increment() throws Exception {\n    return worker(numberHelper().one());\n}",
    "label": 1,
    "rec": "@return value info"
  },
  {
    "id": 1612,
    "type": "Return",
    "comment": "@return  True if key is in the map.",
    "code": "        boolean containsKey(K k) {\n            KeyCacheObject cacheKey = ctx.toCacheKeyObject(k);\n\n            GridCacheEntryEx e = ctx.cache().peekEx(cacheKey);\n\n            try {\n                return e != null && !e.obsolete() &&\n                    (!e.deleted() || e.lockedByThread()) &&\n                    F.isAll(e, filter);\n            }\n            catch (GridCacheEntryRemovedException ignore) {\n                return false;\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1613,
    "type": "Return",
    "comment": "@return hashtable of configurations with keys or null if there are no containing sub configs",
    "code": "public final ConcurrentHashMap<String, GenericConfiguration> getSubConfigs() {\n    return subconfigs;\n}",
    "label": 1,
    "rec": "@return map of configurations with keys or null if there are no containing sub configs"
  },
  {
    "id": 1614,
    "type": "Return",
    "comment": "@return Integer value.",
    "code": "    public byte readByteVolatile(long ptr) {\n        return GridUnsafe.getByteVolatile(null, ptr);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1615,
    "type": "Return",
    "comment": "@return the mShownHeader",
    "code": "public boolean isShownHeader() {\n    return mShowHeader;\n}",
    "label": 1,
    "rec": "@return the mShowHeader"
  },
  {
    "id": 1616,
    "type": "Return",
    "comment": "@return all framework class names",
    "code": "    public Set<String> getFrameworkClassNames() {\n        if (frameworkClassNames == null) {\n            frameworkClassNames = classNameToSmaliFile.keySet().stream()\n                    .filter(smaliFileFactory::isFrameworkClass)\n                    .collect(Collectors.toSet());\n        }\n\n        return frameworkClassNames;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1617,
    "type": "Return",
    "comment": "@return Boolean reply, true if the key exists, otherwise false",
    "code": "public Long exists(final String... keys) {\n    checkIsInMultiOrPipeline();\n    client.exists(keys);\n    return client.getIntegerReply();\n}",
    "label": 1,
    "rec": "@return Integer reply, specifically: an integer greater than 0 if one or more keys were removed 0 if none of the specified key existed"
  },
  {
    "id": 1618,
    "type": "Return",
    "comment": "@return Method execution result.",
    "code": "    public Object gridify(ProceedingJoinPoint joinPnt) throws Throwable {\n        Method mtd = ((MethodSignature) joinPnt.getSignature()).getMethod();\n\n        Gridify ann = mtd.getAnnotation(Gridify.class);\n\n        assert ann != null : \"Intercepted method does not have gridify annotation.\";\n\n        // Since annotations in Java don't allow 'null' as default value\n        // we have accept an empty string and convert it here.\n        // NOTE: there's unintended behavior when user specifies an empty\n        // string as intended grid name.\n        // NOTE: the 'ann.gridName() == null' check is added to mitigate\n        // annotation bugs in some scripting languages (e.g. Groovy).\n        String gridName = F.isEmpty(ann.gridName()) ? null : ann.gridName();\n\n        if (G.state(gridName) != STARTED)\n            throw new GridException(\"Grid is not locally started: \" + gridName);\n\n        // Initialize defaults.\n        GridifyArgument arg = new GridifyArgumentAdapter(mtd.getDeclaringClass(), mtd.getName(),\n                mtd.getParameterTypes(), joinPnt.getArgs(), joinPnt.getTarget());\n\n        if (!ann.interceptor().equals(GridifyInterceptor.class)) {\n            // Check interceptor first.\n            if (!ann.interceptor().newInstance().isGridify(ann, arg))\n                return joinPnt.proceed();\n        }\n\n        if (!ann.taskClass().equals(GridifyDefaultTask.class) && !ann.taskName().isEmpty()) {\n            throw new GridException(\"Gridify annotation must specify either Gridify.taskName() or \" +\n                \"Gridify.taskClass(), but not both: \" + ann);\n        }\n\n        try {\n            Grid grid = G.grid(gridName);\n\n            // If task class was specified.\n            if (!ann.taskClass().equals(GridifyDefaultTask.class)) {\n                return grid.compute().withTimeout(ann.timeout()).execute(\n                    (Class<? extends GridComputeTask<GridifyArgument, Object>>)ann.taskClass(), arg);\n            }\n\n            // If task name was not specified.\n            if (ann.taskName().isEmpty()) {\n                return grid.compute().withTimeout(ann.timeout()).execute(new GridifyDefaultTask(\n                    joinPnt.getSignature().getDeclaringType()), arg);\n            }\n\n            // If task name was specified.\n            return grid.compute().withTimeout(ann.timeout()).execute(ann.taskName(), arg);\n        }\n        catch (Throwable e) {\n            for (Class<?> ex : ((MethodSignature) joinPnt.getSignature()).getMethod().getExceptionTypes()) {\n                // Descend all levels down.\n                Throwable cause = e.getCause();\n\n                while (cause != null) {\n                    if (ex.isAssignableFrom(cause.getClass()))\n                        throw cause;\n\n                    cause = cause.getCause();\n                }\n\n                if (ex.isAssignableFrom(e.getClass()))\n                    throw e;\n            }\n\n            throw new GridifyRuntimeException(\"Undeclared exception thrown: \" + e.getMessage(), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1619,
    "type": "Return",
    "comment": "@return The format for the decimal format for this series",
    "code": "NumberFormat getFormat() {\n    return format;\n}",
    "label": 1,
    "rec": "@return The number format for this series"
  },
  {
    "id": 1620,
    "type": "Return",
    "comment": "@return Integer reply, specifically, the number of elements inside the list after the push operation.",
    "code": "    public Long lpush(final byte[] key, final byte[] string) {\n        checkIsInMulti();\n        client.lpush(key, string);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1621,
    "type": "Return",
    "comment": "@return Filename of the file downloaded, or null if unsuccessful",
    "code": "public File getFormFromUrl(URL u, File downloadDirectory) throws IOException {\n    String filename = u.getFile();\n    filename = filename.substring(filename.lastIndexOf(STR) + NUM);\n    if (filename.matches(SharedConstants.VALID_FILENAME)) {\n        Log.i(Constants.TAG, STR + filename);\n        return getFileFromUrl(u, downloadDirectory);\n    } else {\n        Log.i(Constants.TAG, STR + filename);\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return Pointer to the file downloaded, or null if unsuccessful"
  },
  {
    "id": 1622,
    "type": "Return",
    "comment": "@return  Class.forName(typeName, false)",
    "code": "    static Class putMemberOffset(String typeName, String member, int offset) throws ClassNotFoundException {\n        try {\n            Class<?> c = Class.forName(typeName.replace('/', '.'), false, Loader.class.getClassLoader());\n            if (member != null) {\n                putMemberOffset(c.asSubclass(Pointer.class), member, offset);\n            }\n            return c;\n        } catch (ClassNotFoundException e) {\n            logger.warn(\"Loader.putMemberOffset(): \" + e);\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1623,
    "type": "Return",
    "comment": "@return A ConfigurationModel instance",
    "code": "private ConfigurationDTO buildConfigurationModel() throws AnnotationRequired {\n    if (!finder.isAnnotationPresent(Configure.class)) {\n        return null;\n    }\n    ConfigurationDTO configuration = new ConfigurationDTO();\n    configuration.setConfigurationClass(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setKeywords(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setFailureStrategy(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setPendingStepStrategy(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setParanamer(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStoryControls(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStepCollector(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStepdocReporter(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStepFinder(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStepMonitor(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStepPatternParser(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStoryLoader(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStoryParser(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStoryPathResolver(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setStoryReporterBuilder(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setViewGenerator(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setParameterConverters(parameterConverters());\n    configuration.setParameterControls(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    configuration.setPathCalculator(finder.getAnnotatedValue(Configure.class, Class.class, STR).getName());\n    return configuration;\n}",
    "label": 1,
    "rec": "@return A ConfigurationDTO instance"
  },
  {
    "id": 1624,
    "type": "Return",
    "comment": "@return image",
    "code": "    protected Bitmap getImage(final User user) {\n        File avatarFile = new File(avatarDir, Integer.toString(user.getId()));\n\n        if (!avatarFile.exists() || avatarFile.length() == 0)\n            return null;\n\n        Bitmap bitmap = BitmapFactory.decodeFile(avatarFile.getAbsolutePath());\n        if (bitmap != null)\n            return Image.roundCorners(bitmap, cornerRadius);\n\n        avatarFile.delete();\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1625,
    "type": "Return",
    "comment": "@return False if we cannot afford this send, true otherwise.",
    "code": "    public BigInteger completeTx(SendRequest req, boolean enforceDefaultReferenceClientFeeRelayRules) {\n        lock.lock();\n        try {\n            Preconditions.checkArgument(!req.completed, \"Given SendRequest has already been completed.\");\n            // Calculate the amount of value we need to import.\n            BigInteger value = BigInteger.ZERO;\n            for (TransactionOutput output : req.tx.getOutputs()) {\n                value = value.add(output.getValue());\n            }\n            BigInteger totalOutput = value;\n\n            log.info(\"Completing send tx with {} outputs totalling {} (not including fees)\",\n                    req.tx.getOutputs().size(), bitcoinValueToFriendlyString(value));\n\n            // If any inputs have already been added, we don't need to get their value from wallet\n            BigInteger totalInput = BigInteger.ZERO;\n            for (TransactionInput input : req.tx.getInputs())\n                if (input.getConnectedOutput() != null)\n                    totalInput = totalInput.add(input.getConnectedOutput().getValue());\n                else\n                    log.warn(\"SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.\");\n            value = value.subtract(totalInput);\n\n            List<TransactionInput> originalInputs = new ArrayList(req.tx.getInputs());\n\n            // We need to know if we need to add an additional fee because one of our values are smaller than 0.01 BTC\n            boolean needAtLeastReferenceFee = false;\n            if (enforceDefaultReferenceClientFeeRelayRules) {\n                for (TransactionOutput output : req.tx.getOutputs())\n                    if (output.getValue().compareTo(Utils.CENT) < 0) {\n                        needAtLeastReferenceFee = true;\n                        break;\n                    }\n            }\n\n            // Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us\n            // with the actual outputs that'll be used to gather the required amount of value. In this way, users\n            // can customize coin selection policies.\n            //\n            // Note that this code is poorly optimized: the spend candidates only alter when transactions in the wallet\n            // change - it could be pre-calculated and held in RAM, and this is probably an optimization worth doing.\n            // Note that output.isMine(this) needs to test the keychain which is currently an array, so it's\n            // O(candidate outputs ^ keychain.size())! There's lots of low hanging fruit here.\n            LinkedList<TransactionOutput> candidates = calculateSpendCandidates(true);\n            Address changeAddress = req.changeAddress;\n            int minSize = 0;\n            // There are 3 possibilities for what adding change might do:\n            // 1) No effect\n            // 2) Causes increase in fee (change < 0.01 COINS)\n            // 3) Causes the transaction to have a dust output or change < fee increase (ie change will be thrown away)\n            // If we get either of the last 2, we keep note of what the inputs looked like at the time and move try to\n            // add inputs as we go up the list (keeping track of minimum inputs for each category).  At the end, we pick\n            // the best input set as the one which generates the lowest total fee.\n            BigInteger additionalValueForNextCategory = null;\n            CoinSelection selection3 = null;\n            CoinSelection selection2 = null; TransactionOutput selection2Change = null;\n            CoinSelection selection1 = null; TransactionOutput selection1Change = null;\n            while (true) {\n                req.tx.clearInputs();\n                for (TransactionInput input : originalInputs)\n                    req.tx.addInput(input);\n\n                BigInteger fees = req.fee.add(BigInteger.valueOf(minSize/1000).multiply(req.feePerKb));\n                if (needAtLeastReferenceFee && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)\n                    fees = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;\n\n                BigInteger valueNeeded = value.add(fees);\n                if (additionalValueForNextCategory != null)\n                    valueNeeded = valueNeeded.add(additionalValueForNextCategory);\n                BigInteger additionalValueSelected = additionalValueForNextCategory;\n\n                // Of the coins we could spend, pick some that we actually will spend.\n                CoinSelection selection = coinSelector.select(valueNeeded, candidates);\n                // Can we afford this?\n                if (selection.valueGathered.compareTo(valueNeeded) < 0)\n                    break;\n                checkState(selection.gathered.size() > 0 || originalInputs.size() > 0);\n\n                // We keep track of an upper bound on transaction size to calculate fees that need added\n                // Note that the difference between the upper bound and lower bound is usually small enough that it\n                // will be very rare that we pay a fee we do not need to\n                int size = 0;\n\n                // We can't be sure a selection is valid until we check fee per kb at the end, so we just store them here temporarily\n                boolean eitherCategory2Or3 = false;\n                boolean isCategory3 = false;\n\n                BigInteger change = selection.valueGathered.subtract(valueNeeded);\n                if (additionalValueSelected != null)\n                    change = change.add(additionalValueSelected);\n\n                TransactionOutput changeOutput = null;\n                // If change is < 0.01 BTC, we will need to have at least minfee to be accepted by the network\n                if (enforceDefaultReferenceClientFeeRelayRules && !change.equals(BigInteger.ZERO) &&\n                        change.compareTo(Utils.CENT) < 0 && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0) {\n                    // This solution may fit into category 2, but it may also be category 3, we'll check that later\n                    eitherCategory2Or3 = true;\n                    additionalValueForNextCategory = Utils.CENT;\n                    // If the change is smaller than the fee we want to add, this will be negative\n                    change = change.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(fees));\n                }\n\n                if (change.compareTo(BigInteger.ZERO) > 0) {\n                    // The value of the inputs is greater than what we want to send. Just like in real life then,\n                    // we need to take back some coins ... this is called \"change\". Add another output that sends the change\n                    // back to us. The address comes either from the request or getChangeAddress() as a default..\n                    if (changeAddress == null)\n                        changeAddress = getChangeAddress();\n                    changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);\n                    // If the change output would result in this transaction being rejected as dust, just drop the change and make it a fee\n                    if (enforceDefaultReferenceClientFeeRelayRules && Transaction.MIN_NONDUST_OUTPUT.compareTo(change) >= 0) {\n                        // This solution definitely fits in category 3\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(\n                                                         Transaction.MIN_NONDUST_OUTPUT.add(BigInteger.ONE));\n                    } else {\n                        size += changeOutput.bitcoinSerialize().length + VarInt.sizeOf(req.tx.getOutputs().size()) - VarInt.sizeOf(req.tx.getOutputs().size() - 1);\n                        // This solution is either category 1 or 2\n                        if (!eitherCategory2Or3) // must be category 1\n                            additionalValueForNextCategory = null;\n                    }\n                } else {\n                    if (eitherCategory2Or3) {\n                        // This solution definitely fits in category 3 (we threw away change because it was smaller than MIN_TX_FEE)\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);\n                    }\n                }\n\n                for (TransactionOutput output : selection.gathered) {\n                    req.tx.addInput(output);\n                    // If the scriptBytes don't default to none, our size calculations will be thrown off\n                    checkState(req.tx.getInput(req.tx.getInputs().size()-1).getScriptBytes().length == 0);\n                    try {\n                        if (output.getScriptPubKey().isSentToAddress()) {\n                            // Send-to-address spends usually take maximum pubkey.length (as it may be compressed or not) + 75 bytes\n                            size += this.findKeyFromPubHash(output.getScriptPubKey().getPubKeyHash()).getPubKey().length + 75;\n                        } else if (output.getScriptPubKey().isSentToRawPubKey())\n                            size += 74; // Send-to-pubkey spends usually take maximum 74 bytes to spend\n                        else\n                            throw new RuntimeException(\"Unknown output type returned in coin selection\");\n                    } catch (ScriptException e) {\n                        // If this happens it means an output script in a wallet tx could not be understood. That should never\n                        // happen, if it does it means the wallet has got into an inconsistent state.\n                        throw new RuntimeException(e);\n                    }\n                }\n\n                // Estimate transaction size and loop again if we need more fee per kb\n                size += req.tx.bitcoinSerialize().length;\n                if (size/1000 > minSize/1000 && req.feePerKb.compareTo(BigInteger.ZERO) > 0) {\n                    minSize = size;\n                    // We need more fees anyway, just try again with the same additional value\n                    additionalValueForNextCategory = additionalValueSelected;\n                    continue;\n                }\n\n                if (isCategory3) {\n                    if (selection3 == null)\n                        selection3 = selection;\n                } else if (eitherCategory2Or3) {\n                    // If we are in selection2, we will require at least CENT additional. If we do that, there is no way\n                    // we can end up back here because CENT additional will always get us to 1\n                    checkState(selection2 == null);\n                    checkState(additionalValueForNextCategory.equals(Utils.CENT));\n                    selection2 = selection;\n                    selection2Change = checkNotNull(changeOutput); // If we get no change in category 2, we are actually in category 3\n                } else {\n                    // Once we get a category 1 (change kept), we should break out of the loop because we can't do better\n                    checkState(selection1 == null);\n                    checkState(additionalValueForNextCategory == null);\n                    selection1 = selection;\n                    selection1Change = changeOutput;\n                }\n\n                if (additionalValueForNextCategory != null) {\n                    if (additionalValueSelected != null)\n                        checkState(additionalValueForNextCategory.compareTo(additionalValueSelected) > 0);\n                    continue;\n                }\n                break;\n            }\n\n            req.tx.clearInputs();\n            for (TransactionInput input : originalInputs)\n                req.tx.addInput(input);\n\n            if (selection3 == null && selection2 == null && selection1 == null) {\n                log.warn(\"Insufficient value in wallet for send\");\n                // TODO: Should throw an exception here.\n                return null;\n            }\n\n            BigInteger lowestFee = null;\n            CoinSelection bestCoinSelection = null;\n            TransactionOutput bestChangeOutput = null;\n            if (selection1 != null) {\n                if (selection1Change != null)\n                    lowestFee = selection1.valueGathered.subtract(selection1Change.getValue());\n                else\n                    lowestFee = selection1.valueGathered;\n                bestCoinSelection = selection1;\n                bestChangeOutput = selection1Change;\n            }\n\n            if (selection2 != null) {\n                BigInteger fee = selection2.valueGathered.subtract(checkNotNull(selection2Change).getValue());\n                if (lowestFee == null || fee.compareTo(lowestFee) < 0) {\n                    lowestFee = fee;\n                    bestCoinSelection = selection2;\n                    bestChangeOutput = selection2Change;\n                }\n            }\n\n            if (selection3 != null) {\n                if (lowestFee == null || selection3.valueGathered.compareTo(lowestFee) < 0) {\n                    bestCoinSelection = selection3;\n                    bestChangeOutput = null;\n                }\n            }\n\n            for (TransactionOutput output : bestCoinSelection.gathered)\n                req.tx.addInput(output);\n\n            totalInput = totalInput.add(bestCoinSelection.valueGathered);\n\n            req.tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);\n\n            if (bestChangeOutput != null) {\n                req.tx.addOutput(bestChangeOutput);\n                totalOutput = totalOutput.add(bestChangeOutput.getValue());\n                log.info(\"  with {} coins change\", bitcoinValueToFriendlyString(bestChangeOutput.getValue()));\n            }\n\n            //TODO: Shuffle inputs for some anonymity\n\n            // Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.\n            try {\n                req.tx.signInputs(Transaction.SigHash.ALL, this, req.aesKey);\n            } catch (ScriptException e) {\n                // If this happens it means an output script in a wallet tx could not be understood. That should never\n                // happen, if it does it means the wallet has got into an inconsistent state.\n                throw new RuntimeException(e);\n            }\n\n            // Check size.\n            int size = req.tx.bitcoinSerialize().length;\n            if (size > Transaction.MAX_STANDARD_TX_SIZE) {\n                // TODO: Throw an exception here.\n                log.error(\"Transaction could not be created without exceeding max size: {} vs {}\", size,\n                          Transaction.MAX_STANDARD_TX_SIZE);\n                return null;\n            }\n\n            // Label the transaction as being self created. We can use this later to spend its change output even before\n            // the transaction is confirmed.\n            req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);\n\n            req.completed = true;\n            log.info(\"  completed {} with {} inputs\", req.tx.getHashAsString(), req.tx.getInputs().size());\n            return totalInput.subtract(totalOutput);\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@return Either the total fee paid (assuming all existing inputs had a connected output) or null if we cannot afford the transaction."
  },
  {
    "id": 1626,
    "type": "Return",
    "comment": "@return the current hdr value",
    "code": "    public Hdr getHdr() {\n        return mCameraEngine.getHdr();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1627,
    "type": "Return",
    "comment": "@return The custom expression",
    "code": "protected Optional<String> getCustomExpression(String customExpressionId) {\n    Optional<String> optionalCustomExpression = this.getDescription().getCustomExpressions().stream().filter(eefCustomExpression -> {\n        return customExpressionId != null && customExpressionId.equals(eefCustomExpression.getIdentifier());\n    }).map(EEFCustomExpression::getCustomExpression).findFirst();\n    return optionalCustomExpression;\n}",
    "label": 1,
    "rec": "@return An optional with the custom expression or an empty optional if none could be found"
  },
  {
    "id": 1628,
    "type": "Return",
    "comment": "@return true - allow the request chain to continue in this default implementation",
    "code": "    public boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n\n        if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"appliedPaths property is null or empty.  This Filter will passthrough immediately.\");\n            }\n            return true;\n        }\n\n        for (String path : this.appliedPaths.keySet()) {\n            // If the path does match, then pass on to the subclass implementation for specific checks\n            //(first match 'wins'):\n            if (pathsMatch(path, request)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Current requestURI matches pattern [\" + path + \"].  Performing onPreHandle check...\");\n                }\n                Object config = this.appliedPaths.get(path);\n                return onPreHandle(request, response, config);\n            }\n        }\n\n        //no path matched, allow the request to go through:\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1629,
    "type": "Return",
    "comment": "@return The Id of the current user. If there is one associated with the current context. If there is none the method returns -1.",
    "code": "public int getCurrentUserId() {\n    com.idega.user.data.User user = getCurrentUser();\n    return ((Integer) user.getPrimaryKey()).intValue();\n}",
    "label": 1,
    "rec": "@return The Id of the current user. If there is one associated with the current context."
  },
  {
    "id": 1630,
    "type": "Return",
    "comment": "@return Target.",
    "code": "    protected Object targetWithUserClassLoader() throws Exception {\n        // Notice that we use another resource naming because file has path.\n        ClassLoader tstClsLdr = new GridTestClassLoader(\n            Collections.singletonMap(\"org/apache/ignite/gridify/test_resource.properties\", \"param1=2\"),\n            getClass().getClassLoader(),\n            TestAopTarget.class.getName(), TestAopTargetInterface.class.getName());\n\n        return tstClsLdr.loadClass(\"org.apache.ignite.gridify.TestAopTarget\").newInstance();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1631,
    "type": "Return",
    "comment": "@return All context button menu entries, which are executable.",
    "code": "private List<SapphireActionHandler> getExecutableMenuEntries() {\n    List<SapphireActionHandler> activeHandlers = getSapphireAction().getActiveHandlers();\n    List<SapphireActionHandler> menuEntries = new ArrayList<SapphireActionHandler>();\n    for (SapphireActionHandler handler : activeHandlers) {\n        if (handler.isEnabled()) {\n            menuEntries.add(handler);\n        }\n    }\n    return menuEntries;\n}",
    "label": 1,
    "rec": "@return All action handlers, which are executable."
  },
  {
    "id": 1632,
    "type": "Return",
    "comment": "@return An instance of default no-name grid. This method never returns  null.",
    "code": "    public static Ignite ignite() throws IgniteIllegalStateException {\n        return IgnitionEx.grid();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1633,
    "type": "Return",
    "comment": "@return A nonnull, possibly empty list of stage/parallel branch start node IDs, innermost first.",
    "code": "@Nonnull\npublic static List<FlowNode> getEnclosingStagesAndParallels(FlowNode node) {\n    List<FlowNode> enclosingBlocks = new ArrayList<>();\n    for (FlowNode enclosing : node.getEnclosingBlocks()) {\n        if (enclosing != null && enclosing.getAction(LabelAction.class) != null) {\n            if ((enclosing instanceof StepStartNode && ((StepStartNode) enclosing).getDescriptor() instanceof StageStep.DescriptorImpl) || (enclosing.getAction(ThreadNameAction.class) != null)) {\n                enclosingBlocks.add(enclosing);\n            }\n        }\n    }\n    return enclosingBlocks;\n}",
    "label": 1,
    "rec": "@return A nonnull, possibly empty list of stage/parallel branch start nodes, innermost first."
  },
  {
    "id": 1634,
    "type": "Return",
    "comment": "@return Future.",
    "code": "    private GridFuture<GridRestResponse> handleRequest(final GridRestRequest req) {\n        if (startLatch.getCount() > 0) {\n            try {\n                startLatch.await();\n            }\n            catch (InterruptedException e) {\n                return new GridFinishedFuture<>(ctx, new GridException(\"Failed to handle request \" +\n                    \"(protocol handler was interrupted when awaiting grid start).\", e));\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Received request from client: \" + req);\n\n        try {\n            authenticate(req);\n        }\n        catch (GridException e) {\n            return new GridFinishedFuture<>(ctx, new GridRestResponse(STATUS_AUTH_FAILED,\n                e.getMessage()));\n        }\n\n        interceptRequest(req);\n\n        GridRestCommandHandler hnd = handlers.get(req.command());\n\n        GridFuture<GridRestResponse> res = hnd == null ? null : hnd.handleAsync(req);\n\n        if (res == null)\n            return new GridFinishedFuture<>(ctx,\n                new GridException(\"Failed to find registered handler for command: \" + req.command()));\n\n        return res.chain(new C1<GridFuture<GridRestResponse>, GridRestResponse>() {\n            @Override public GridRestResponse apply(GridFuture<GridRestResponse> f) {\n                GridRestResponse res;\n\n                try {\n                    res = f.get();\n                }\n                catch (Exception e) {\n                    LT.error(log, e, \"Failed to handle request: \" + req.command());\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Failed to handle request [req=\" + req + \", e=\" + e + \"]\");\n\n                    res = new GridRestResponse(STATUS_FAILED, e.getMessage());\n                }\n\n                assert res != null;\n\n                if (ctx.isEnterprise()) {\n                    try {\n                        res.sessionTokenBytes(updateSessionToken(req));\n                    }\n                    catch (GridException e) {\n                        U.warn(log, \"Cannot update response session token: \" + e.getMessage());\n                    }\n                }\n\n                interceptResponse(res, req);\n\n                return res;\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1635,
    "type": "Return",
    "comment": "@return reference to the newly minted {@link PartialRestResponse} object.",
    "code": "public RestLiResponse build() {\n    if (_record instanceof IdResponse) {\n        final IdResponse<?> idResponse = (IdResponse<?>) _record;\n        final Object key = idResponse.getId();\n        if (key != null) {\n            final ProtocolVersion protocolVersion = ProtocolVersionUtil.extractProtocolVersion(_headers);\n            _headers.put(HeaderUtil.getIdHeaderName(protocolVersion), URIParamUtils.encodeKeyForHeader(key, protocolVersion));\n        }\n    }\n    return new RestLiResponse(_status, _record, _headers, _cookies);\n}",
    "label": 1,
    "rec": "@return reference to the newly minted {@link RestLiResponse} object."
  },
  {
    "id": 1636,
    "type": "Return",
    "comment": "@return distributed queue",
    "code": "    public DistributedQueue<T>      buildQueue()\n    {\n        return new DistributedQueue<T>\n        (\n            client,\n            consumer,\n            serializer,\n            queuePath,\n            factory,\n            executor,\n            Integer.MAX_VALUE,\n            false,\n            lockPath\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1637,
    "type": "Return",
    "comment": "@return either the concatenation of first name and last name, or the email address if neither first nor last name are specified, or the user's unique identifier if the user is {@link #isUnknown() unknown}, or <code>super.toString()</code> if the instance is uninitialized, but never <code>null</code>.",
    "code": "public String getDisplayName() {\n    StringBuilder sb = new StringBuilder();\n    if (hasFirstname()) {\n        sb.append(firstname);\n    }\n    if (hasLastname()) {\n        if (sb.length() > NUM) {\n            sb.append(STR);\n        }\n        sb.append(lastname);\n    }\n    if (sb.length() == NUM && hasEmail()) {\n        sb.append(email);\n    }\n    if (sb.length() == NUM && userId != null) {\n        sb.append(userId);\n    }\n    if (sb.length() == NUM) {\n        sb.append(STR);\n    }\n    return sb.toString();\n}",
    "label": 1,
    "rec": "@return either the concatenation of {@link #getFirstname() first name} and {@link #getLastname() last name}, or the {@link {@link #getEmail()} email address}, or the {@link #getUserId() userId} of the user in that sequence. For an {@link #isUnknown() unknown user} always the userId is returned. If not even a userId is known, <tt>\"Anonymous\"</tt> is returned."
  },
  {
    "id": 1638,
    "type": "Return",
    "comment": "@return Key.",
    "code": "    private Integer keyForNode(GridNode node, int type) {\n        GridCache<Integer, Integer> cache = grid(0).cache(null);\n\n        if (cache.configuration().getCacheMode() == LOCAL)\n            return ++lastKey;\n\n        if (cache.configuration().getCacheMode() == REPLICATED && type == NOT_PRIMARY_AND_BACKUP)\n            return ++lastKey;\n\n        for (int key = lastKey + 1; key < (lastKey + 10_000); key++) {\n            switch (type) {\n                case NOT_PRIMARY_AND_BACKUP: {\n                    if (!cache.affinity().isPrimaryOrBackup(node, key)) {\n                        lastKey = key;\n\n                        return key;\n                    }\n\n                    break;\n                }\n\n                case PRIMARY: {\n                    if (cache.affinity().isPrimary(node, key)) {\n                        lastKey = key;\n\n                        return key;\n                    }\n\n                    break;\n                }\n\n                case BACKUP: {\n                    if (cache.affinity().isBackup(node, key)) {\n                        lastKey = key;\n\n                        return key;\n                    }\n\n                    break;\n                }\n\n                default:\n                    fail();\n            }\n        }\n\n        throw new IllegalStateException(\"Failed to find key.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1639,
    "type": "Return",
    "comment": "@return true - allow the request chain to continue in this default implementation",
    "code": "    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n\n        if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"appliedPaths property is null or empty.  This Filter will passthrough immediately.\");\n            }\n            return true;\n        }\n\n        for (String path : this.appliedPaths.keySet()) {\n            // If the path does match, then pass on to the subclass implementation for specific checks\n            //(first match 'wins'):\n            if (pathsMatch(path, request)) {\n                log.trace(\"Current requestURI matches pattern '{}'.  Determining filter chain execution...\", path);\n                Object config = this.appliedPaths.get(path);\n                return isFilterChainContinued(request, response, path, config);\n            }\n        }\n\n        //no path matched, allow the request to go through:\n        return true;\n    }\n",
    "label": 1,
    "rec": "@return  true if the filter chain is allowed to continue to execute,  false if a subclass has handled the request explicitly."
  },
  {
    "id": 1640,
    "type": "Return",
    "comment": "@return true if the element and method should be generated",
    "code": "    public boolean generateSelectByExampleWithBLOBs() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        return tableConfiguration.isSelectByExampleStatementEnabled()\n                && introspectedTable.hasBLOBColumns();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1641,
    "type": "Return",
    "comment": "@return The Player who placed the fire block, if not ignited by a player returns null",
    "code": "public Player getPlayer() {\n    if (ignitingEntity instanceof Player) {\n        return (Player) ignitingEntity;\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return The Player that placed/ignited the fire block, or null if not ignited by a Player."
  },
  {
    "id": 1642,
    "type": "Return",
    "comment": "@return Collection entries which will be fired.",
    "code": "        public Collection<CacheContinuousQueryEntry> collectEntries(CacheContinuousQueryEntry entry) {\n            assert entry != null;\n\n            List<CacheContinuousQueryEntry> entries;\n\n            synchronized (pendingEvts) {\n                // Received first event.\n                if (curTop == AffinityTopologyVersion.NONE) {\n                    lastFiredEvt = entry.updateCounter();\n\n                    curTop = entry.topologyVersion();\n\n                    return F.asList(entry);\n                }\n\n                if (curTop.compareTo(entry.topologyVersion()) < 0) {\n                    if (entry.updateCounter() == 1L && !entry.isBackup()) {\n                        entries = new ArrayList<>(pendingEvts.size());\n\n                        for (CacheContinuousQueryEntry evt : pendingEvts.values()) {\n                            if (evt != HOLE && !evt.isFiltered())\n                                entries.add(evt);\n                        }\n\n                        pendingEvts.clear();\n\n                        curTop = entry.topologyVersion();\n\n                        lastFiredEvt = entry.updateCounter();\n\n                        entries.add(entry);\n\n                        return entries;\n                    }\n\n                    curTop = entry.topologyVersion();\n                }\n\n                // Check duplicate.\n                if (entry.updateCounter() > lastFiredEvt) {\n                    pendingEvts.put(entry.updateCounter(), entry);\n\n                    // Put filtered events.\n                    if (entry.filteredEvents() != null) {\n                        for (long cnrt : entry.filteredEvents()) {\n                            if (cnrt > lastFiredEvt)\n                                pendingEvts.put(cnrt, HOLE);\n                        }\n                    }\n                }\n                else {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Skip duplicate continuous query message: \" + entry);\n\n                    return Collections.emptyList();\n                }\n\n                if (pendingEvts.isEmpty())\n                    return Collections.emptyList();\n\n                Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pendingEvts.entrySet().iterator();\n\n                entries = new ArrayList<>();\n\n                if (pendingEvts.size() >= MAX_BUFF_SIZE) {\n                    for (int i = 0; i < MAX_BUFF_SIZE - (MAX_BUFF_SIZE / 10); i++) {\n                        Map.Entry<Long, CacheContinuousQueryEntry> e = iter.next();\n\n                        if (e.getValue() != HOLE && !e.getValue().isFiltered())\n                            entries.add(e.getValue());\n\n                        lastFiredEvt = e.getKey();\n\n                        iter.remove();\n                    }\n                }\n                else {\n                    // Elements are consistently.\n                    while (iter.hasNext()) {\n                        Map.Entry<Long, CacheContinuousQueryEntry> e = iter.next();\n\n                        if (e.getKey() == lastFiredEvt + 1) {\n                            ++lastFiredEvt;\n\n                            if (e.getValue() != HOLE && !e.getValue().isFiltered())\n                                entries.add(e.getValue());\n\n                            iter.remove();\n                        }\n                        else\n                            break;\n                    }\n                }\n            }\n\n            return entries;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1643,
    "type": "Return",
    "comment": "@return {@link MockitoGenericMetadata} representing this generic return type.",
    "code": "public GenericMetadataSupport resolveGenericReturnType(Method method) {\n    Type genericReturnType = method.getGenericReturnType();\n    if (genericReturnType instanceof Class) {\n        return new NotGenericReturnTypeSupport(genericReturnType);\n    }\n    if (genericReturnType instanceof ParameterizedType) {\n        return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n    }\n    if (genericReturnType instanceof TypeVariable) {\n        return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n    }\n    throw new MockitoException(STR + genericReturnType.getClass().getCanonicalName() + STR + method.toGenericString() + STR + genericReturnType);\n}",
    "label": 1,
    "rec": "@return {@link GenericMetadataSupport} representing this generic return type."
  },
  {
    "id": 1644,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "        private int doRemoveFromLeaf() throws IgniteCheckedException {\n            assert page != null;\n\n            return writePage(pageId, page, removeFromLeaf, this, 0);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1645,
    "type": "Return",
    "comment": "@return the address of the buffer given",
    "code": "public static long getDirectBufferAddress(Buffer buf) {\n    if (!(buf instanceof DirectBuffer)) {\n        return NUM;\n    }\n    return ((DirectBuffer) buf).getEffectiveAddress().toLong();\n}",
    "label": 1,
    "rec": "@return the address of the buffer given, or zero if the buffer is not a direct Buffer."
  },
  {
    "id": 1646,
    "type": "Return",
    "comment": "@return Unmarshalled value.",
    "code": "    private CacheObject unmarshalOffheap(boolean tmp) throws IgniteCheckedException {\n        assert cctx.offheapTiered() && valPtr != 0;\n\n        if (cctx.portableEnabled())\n            return (CacheObject)cctx.portable().unmarshal(valPtr, !tmp);\n\n        long ptr = valPtr;\n\n        boolean plainByteArr = UNSAFE.getByte(ptr++) != 0;\n\n        int size = UNSAFE.getInt(ptr);\n\n        byte[] res = U.copyMemory(ptr + 4, size);\n\n        if (plainByteArr)\n            return (V)res;\n\n        IgniteUuid valClsLdrId = U.readGridUuid(ptr + 4 + size);\n\n        ClassLoader ldr = valClsLdrId != null ? cctx.deploy().getClassLoader(valClsLdrId) :\n            cctx.deploy().localLoader();\n\n        return cctx.marshaller().unmarshal(res, ldr);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1647,
    "type": "Return",
    "comment": "@return the new payload length",
    "code": "private TranslatedPayloadMetaData translateSingleFramePayloadLength(ByteBuffer buffer, Opcode optcode, int oldPayloadlength, int maxpacketsize, int realpacketsize) throws InvalidFrameException, IncompleteException, LimitExceededException {\n    int payloadlength = oldPayloadlength;\n    if (optcode == Opcode.PING || optcode == Opcode.PONG || optcode == Opcode.CLOSING) {\n        log.trace(STR);\n        throw new InvalidFrameException(STR);\n    }\n    if (payloadlength == NUM) {\n        realpacketsize += NUM;\n        translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);\n        byte[] sizebytes = new byte[NUM];\n        sizebytes[NUM] = buffer.get();\n        sizebytes[NUM] = buffer.get();\n        payloadlength = new BigInteger(sizebytes).intValue();\n    } else {\n        realpacketsize += NUM;\n        translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);\n        byte[] bytes = new byte[NUM];\n        for (int i = NUM; i < NUM; i++) {\n            bytes[i] = buffer.get();\n        }\n        long length = new BigInteger(bytes).longValue();\n        translateSingleFrameCheckLengthLimit(length);\n        payloadlength = (int) length;\n    }\n    return new TranslatedPayloadMetaData(payloadlength, realpacketsize);\n}",
    "label": 1,
    "rec": "@return the new payload data containing new payload length and new packet size"
  },
  {
    "id": 1648,
    "type": "Return",
    "comment": "@return cumulative count of threads executed",
    "code": "    public long getCumulativeCountThreadsExecuted() {\n        return getCumulativeCount(HystrixRollingNumberEvent.THREAD_EXECUTION);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1649,
    "type": "Return",
    "comment": "@return the new storage",
    "code": "public static Graph clone(Graph g, GraphStorage outGraph) {\n    return g.copyTo(outGraph.create(g.nodes()));\n}",
    "label": 1,
    "rec": "@return the graph outGraph"
  },
  {
    "id": 1650,
    "type": "Return",
    "comment": "@return intent",
    "code": "    public Intent create(final String uri) {\n        int issueNumber = issueMatcher.getNumber(uri);\n        if (issueNumber > 0)\n            return createIssueIntent(uri, issueNumber);\n\n        String gistId = gistMatcher.getId(uri);\n        if (gistId != null)\n            return createGistIntent(uri, gistId);\n\n        CommitMatch commitMatch = commitMatcher.getCommit(uri);\n        if (commitMatch != null)\n            return createCommitIntent(uri, commitMatch);\n\n        String login = userMatcher.getLogin(uri);\n        if (isValidLogin(login))\n            return createUserIntent(login);\n\n        Intent intent = new Intent(ACTION_VIEW, Uri.parse(uri));\n        intent.addCategory(CATEGORY_BROWSABLE);\n        return intent;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1651,
    "type": "Return",
    "comment": "@return Deserialized ByteArrayOutputStream",
    "code": "static BytesWritable fromCSVBuffer(String s) throws IOException {\n    if (s.charAt(NUM) != STR) {\n        throw new IOException(STR);\n    }\n    if (s.length() == NUM) {\n        return new BytesWritable();\n    }\n    int blen = (s.length() - NUM) / NUM;\n    byte[] barr = new byte[blen];\n    for (int idx = NUM; idx < blen; idx++) {\n        char c1 = s.charAt(NUM * idx + NUM);\n        char c2 = s.charAt(NUM * idx + NUM);\n        barr[idx] = Byte.parseByte(STR + c1 + c2, NUM);\n    }\n    return new BytesWritable(barr);\n}",
    "label": 1,
    "rec": "@return Deserialized BytesWritable"
  },
  {
    "id": 1652,
    "type": "Return",
    "comment": "@return the allowRefresh",
    "code": "    public boolean isAllowRefresh() {\n\t\tif (grantTypes != null) {\n\t\t\treturn getAuthorizedGrantTypes().contains(\"refresh_token\");\n\t\t} else {\n\t\t\treturn false; // if there are no grants, we can't be refreshing them, can we?\n\t\t}\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1653,
    "type": "Return",
    "comment": "@return a {@link PagedCollection}.",
    "code": "public ResourceCollection<Transaction> search(String query) {\n    return search(query, NUM);\n}",
    "label": 1,
    "rec": "@return a {@link ResourceCollection}."
  },
  {
    "id": 1654,
    "type": "Return",
    "comment": "@return Collection of alive cache nodes.",
    "code": "    public Collection<ClusterNode> aliveRemoteNodesWithCaches(long topVer) {\n        return resolveDiscoCache(null, topVer).aliveRemoteNodesWithCaches(topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1655,
    "type": "Return",
    "comment": "@return a predicate that will accept any String that contains the specified CharSequence",
    "code": "public static Predicate<String> contains(CharSequence contains) {\n    return new ContainsPredicate(contains);\n}",
    "label": 1,
    "rec": "@return the newly created Predicate"
  },
  {
    "id": 1656,
    "type": "Return",
    "comment": "@return If key has been removed.",
    "code": "        boolean removeKey(K k) {\n            try {\n                return ctx.grid().cache(ctx.name()).remove(k, CU.<K, V>empty());\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteException(\"Failed to remove cache entry for key: \" + k, e);\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1657,
    "type": "Return",
    "comment": "@return <code>true</code> if native-zlib is loaded and initialized, else <code>false</code>",
    "code": "public static boolean isNativeZlibLoaded(Configuration conf) {\n    return nativeZlibLoaded && conf.getBoolean(STR, true);\n}",
    "label": 1,
    "rec": "@return <code>true</code> if native-zlib is loaded & initialized and can be loaded for this job, else <code>false</code>"
  },
  {
    "id": 1658,
    "type": "Return",
    "comment": "@return data from fetch and store it in memory and persister",
    "code": "    public Observable<Parsed> fetch(@Nonnull final Key key) {\n        return Observable.defer(new Func0<Observable<Parsed>>() {\n            @Nullable\n            @Override\n            public Observable<Parsed> call() {\n                return fetchAndPersist(key);\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1659,
    "type": "Return",
    "comment": "@return the copy-entity mappings",
    "code": "public Map invertMap() {\n    return Collections.unmodifiableMap(copyToEntityMap);\n}",
    "label": 1,
    "rec": "@return an unmodifiable map view of the copy-entity mappings"
  },
  {
    "id": 1660,
    "type": "Return",
    "comment": "@return Multi bulk reply",
    "code": "  public Set<byte[]> keys(final byte[] pattern) {\n    checkIsInMulti();\n    client.keys(pattern);\n    return SetFromList.of(client.getBinaryMultiBulkReply());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1661,
    "type": "Return",
    "comment": "@return the howlProperties",
    "code": "public Properties getInputStorageDriverProperties() {\n    return hcatProperties;\n}",
    "label": 1,
    "rec": "@return the hcatProperties"
  },
  {
    "id": 1662,
    "type": "Return",
    "comment": "@return the node",
    "code": "    public static PathAndNode getPathAndNode(String path)\n    {\n        PathUtils.validatePath(path);\n        int i = path.lastIndexOf(PATH_SEPARATOR);\n        if ( i < 0 )\n        {\n            return new PathAndNode(path, \"\");\n        }\n        if ( (i + 1) >= path.length() )\n        {\n            return new PathAndNode(PATH_SEPARATOR, \"\");\n        }\n        String node = path.substring(i + 1);\n        String parentPath = (i > 0) ? path.substring(0, i) : PATH_SEPARATOR;\n        return new PathAndNode(parentPath, node);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1663,
    "type": "Return",
    "comment": "@return the username/password pair submitted by the user for the given header value and request.",
    "code": "    protected String[] getPrincipalsAndCredentials( String authorizationHeader, ServletRequest request ) {\n        if ( authorizationHeader == null ) {\n            return null;\n        }\n        String[] authTokens = authorizationHeader.split(\" \");\n        if ( authTokens == null || authTokens.length < 2 ) {\n            return null;\n        }\n        return getPrincipalsAndCredentials(authTokens[0], authTokens[1]);\n    }\n",
    "label": 1,
    "rec": "@return the username (index 0)/password pair (index 1) submitted by the user for the given header value and request."
  },
  {
    "id": 1664,
    "type": "Return",
    "comment": "@return the weighting to be used for route calculation",
    "code": "    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )\n    {\n        String weighting = weightingMap.getWeighting().toLowerCase();\n\n        if (\"shortest\".equalsIgnoreCase(weighting))\n        {\n            return new ShortestWeighting(encoder);\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty())\n        {\n            if (encoder.supports(PriorityWeighting.class))\n                return new PriorityWeighting(encoder, weightingMap);\n            else\n                return new FastestWeighting(encoder, weightingMap);\n        } else if (\"curvature\".equalsIgnoreCase(weighting))\n        {\n            if (encoder.supports(CurvatureWeighting.class))\n                return new CurvatureWeighting(encoder, weightingMap, ghStorage);\n            else\n                return new FastestWeighting(encoder, weightingMap);\n        }\n\n        throw new UnsupportedOperationException(\"weighting \" + weighting + \" not supported\");\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1665,
    "type": "Return",
    "comment": "@return key integer value or defaultValue if key is absent or does not have int value",
    "code": "public int getInt(int key, int defaultValue) {\n    if (key < NUM)\n        Context.codeBug();\n    int index = findIndex(key);\n    if (NUM <= index) {\n        if (ivaluesShift != NUM) {\n            return keys[ivaluesShift + index];\n        }\n        return NUM;\n    }\n    return defaultValue;\n}",
    "label": 1,
    "rec": "@return key integer value or defaultValue if key is absent"
  },
  {
    "id": 1666,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static int leq(int value) {\n        return reportMatcher(new LessOrEqual<Integer>(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1667,
    "type": "Return",
    "comment": "@return list of known services",
    "code": "public Set<Class<?>> getKnownServices() {\n    synchronized (providers) {\n        return ImmutableSet.<Class<?>>copyOf(providers.keySet());\n    }\n}",
    "label": 1,
    "rec": "@return a copy of the set of known services"
  },
  {
    "id": 1668,
    "type": "Return",
    "comment": "@return File info of renamed entry.",
    "code": "    public IgfsFileInfo move(IgfsPath srcPath, IgfsPath dstPath) throws IgniteCheckedException {\n        if (busyLock.enterBusy()) {\n            try {\n                validTxState(false);\n\n                // Prepare path IDs.\n                IgfsPathIds srcPathIds = pathIds(srcPath);\n                IgfsPathIds dstPathIds = pathIds(dstPath);\n\n                // Source path must exists.\n                if (!srcPathIds.allExists())\n                    throw new IgfsPathNotFoundException(\"Failed to perform move because source path is not \" +\n                        \"found: \" + srcPath);\n\n                // At this point we need to understand name of resulting entry. It will be either destination leaf\n                // or source leaf depending on existence.\n                String dstName;\n\n                if (dstPathIds.lastExists())\n                    //  Full destination path exists -> use source name.\n                    dstName = srcPathIds.lastPart();\n                else {\n                    if (dstPathIds.lastParentExists()) {\n                        // Destination path doesn't exists -> use destination name.\n                        dstName = dstPathIds.lastPart();\n\n                        dstPathIds = dstPathIds.parent();\n                    }\n                    else\n                        // Destination parent is not found either -> exception.\n                        throw new IgfsPathNotFoundException(\"Failed to perform move because destination path is not \" +\n                            \"found: \" + dstPath.parent());\n                }\n\n                // Lock participating IDs.\n                final Set<IgniteUuid> lockIds = new TreeSet<>(PATH_ID_SORTING_COMPARATOR);\n\n                srcPathIds.addExistingIds(lockIds);\n                dstPathIds.addExistingIds(lockIds);\n\n                IgniteInternalTx tx = startTx();\n\n                try {\n                    // Obtain the locks.\n                    final Map<IgniteUuid, IgfsFileInfo> lockInfos = lockIds(lockIds);\n\n                    // Verify integrity of source and destination paths.\n                    if (!srcPathIds.verifyIntegrity(lockInfos))\n                        throw new IgfsPathNotFoundException(\"Failed to perform move because source directory \" +\n                            \"structure changed concurrently [src=\" + srcPath + \", dst=\" + dstPath + ']');\n\n                    if (!dstPathIds.verifyIntegrity(lockInfos))\n                        throw new IgfsPathNotFoundException(\"Failed to perform move because destination directory \" +\n                            \"structure changed concurrently [src=\" + srcPath + \", dst=\" + dstPath + ']');\n\n                    // Addiional check: is destination directory?\n                    IgfsFileInfo dstParentInfo = lockInfos.get(dstPathIds.lastId());\n\n                    if (dstParentInfo.isFile())\n                        throw new IgfsPathAlreadyExistsException(\"Failed to perform move because destination points \" +\n                            \"to existing file [src=\" + srcPath + \", dst=\" + dstPath + ']');\n\n                    // Additional check: does destination already has child with the same name?\n                    if (dstParentInfo.hasChild(dstName))\n                        throw new IgfsPathAlreadyExistsException(\"Failed to perform move because destination already \" +\n                            \"contains entry with the same name existing file [src=\" + srcPath +\n                            \", dst=\" + dstPath + ']');\n\n                    // Actual move: remove from source parent and add to destination target.\n                    IgfsFileInfo srcParentInfo = lockInfos.get(srcPathIds.lastParentId());\n\n                    IgfsFileInfo srcInfo = lockInfos.get(srcPathIds.lastId());\n                    String srcName = srcPathIds.lastPart();\n                    IgfsListingEntry srcEntry = srcParentInfo.listing().get(srcName);\n\n                    transferEntry(srcEntry, srcParentInfo.id(), srcName, dstParentInfo.id(), dstName);\n\n                    tx.commit();\n\n                    IgfsPath newPath = new IgfsPath(dstPathIds.path(), dstName);\n\n                    // Set the new path to the info to simplify event creation:\n                    return IgfsFileInfo.builder(srcInfo).path(newPath).build();\n                }\n                finally {\n                    tx.close();\n                }\n            }\n            finally {\n                busyLock.leaveBusy();\n            }\n        }\n        else\n            throw new IllegalStateException(\"Failed to perform move because Grid is stopping [srcPath=\" +\n                srcPath + \", dstPath=\" + dstPath + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1669,
    "type": "Return",
    "comment": "@return <code>o</code> itself if it is an element type, otherwise the registered metamodel type if <code>o</code> is an <code>EObject</code> or an <code>EClass</code>.",
    "code": "public IElementType getElementType(Object o) {\n    if (o instanceof EClass) {\n        return getElementType((EClass) o);\n    } else if (o instanceof EObject) {\n        return getElementType((EObject) o);\n    } else if (o instanceof IElementType) {\n        return (IElementType) o;\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return <code>o</code> itself if it is an element type, otherwise returns the registered metamodel type"
  },
  {
    "id": 1670,
    "type": "Return",
    "comment": "@return this fragment",
    "code": "    public ItemListFragment<E> setListShown(final boolean shown) {\n        return setListShown(shown, true);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1671,
    "type": "Return",
    "comment": "@return true if the string is whitespace-only",
    "code": "public static boolean isWhitespace(final String str) {\n    if (STR.equals(str) || STR.equals(str)) {\n        return false;\n    }\n    final String trimStr = str.trim();\n    if (isEmpty(trimStr)) {\n        return true;\n    }\n    if (trimStr.length() == NUM) {\n        if (STR.equals(str)) {\n            return true;\n        } else if (STR.equals(str) || STR.equals(str)) {\n            return true;\n        }\n        return Character.isWhitespace(trimStr.charAt(NUM));\n    }\n    return false;\n}",
    "label": 1,
    "rec": "@return true if the string is a whitespace character"
  },
  {
    "id": 1672,
    "type": "Return",
    "comment": "@return Observable that emits RxBleConnectionState that matches BluetoothGatt's state. Does NOT emit errors even if status != GATT_SUCCESS.",
    "code": "    public Observable<RxBleConnectionState> getOnConnectionStateChange() {\n        return connectionStatePublishSubject.asObservable().observeOn(callbackScheduler);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1673,
    "type": "Return",
    "comment": "@return a new dense vector with results of {@code c = a - b}",
    "code": "public DenseVector minus(Vector vector) {\n    DenseVector resultVector = new VectorBasedDenseVector(cardinality());\n    for (VectorEntry vectorEntry : vector) {\n        int index = vectorEntry.index();\n        resultVector.set(index, get(index) - vectorEntry.get());\n    }\n    return resultVector;\n}",
    "label": 1,
    "rec": "@return a new Vector"
  },
  {
    "id": 1674,
    "type": "Return",
    "comment": "@return array: labels/view",
    "code": "    public JSONObject labelsCreate(long idDashboard, String title) throws ApiServiceException, IOException {\n        return callAuthenticated(\"labels/create.json\",\n                \"token\", token,\n                \"id_dashboard\", idDashboard,\n                \"title\", title);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1675,
    "type": "Return",
    "comment": "@return the number of days for a timestamp difference",
    "code": "protected static int days(long diff) {\n    return (int) TimeUnit.MILLISECONDS.toDays(diff);\n}",
    "label": 1,
    "rec": "@return number of days for a given time difference"
  },
  {
    "id": 1676,
    "type": "Return",
    "comment": "@return CharacterSetECI representing ECI of given value, or null if it is legal but unsupported",
    "code": "  public static CharacterSetECI getCharacterSetECIByValue(int value) {\n    if (value < 0 || value >= 900) {\n      throw new IllegalArgumentException(\"Bad ECI value: \" + value);\n    }\n    return VALUE_TO_ECI.get(value);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1677,
    "type": "Return",
    "comment": "@return the new char array backed by a buffer or an array",
    "code": "    public static CharIndexer create(final CharPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new CharRawIndexer(pointer, sizes, strides)\n                                             : new CharBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            char[] array = new char[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new CharArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new char indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 1678,
    "type": "Return",
    "comment": "@return Secondary file system.",
    "code": "    public Igfs getSecondaryFileSystem() {\n        return secondaryFs;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1679,
    "type": "Return",
    "comment": "@return an instance of {@link ProxyHost} or {@code null} if no proxy is to be used.",
    "code": "public ProxyHostEx toProxyHost(final String hostToProxy) {\n    final ProxyHostEx proxyHost;\n    if (this.hostName != null) {\n        final boolean shouldProxy = shouldProxy(hostToProxy, noProxyHostPatterns);\n        if (shouldProxy) {\n            proxyHost = new ProxyHostEx(hostName, port, proxyUser, proxySecret);\n        } else {\n            proxyHost = null;\n        }\n    } else {\n        proxyHost = null;\n    }\n    return proxyHost;\n}",
    "label": 1,
    "rec": "@return an instance of {@link ProxyHostEx} or {@code null} if no proxy is to be used."
  },
  {
    "id": 1680,
    "type": "Return",
    "comment": "@return Gaussian RBF functions with parameter learned from data.",
    "code": "    public static RBF<double[]>[] fit(double[][] x, int k, int p) {\n        if (p < 1 || p >= k) {\n            throw new IllegalArgumentException(\"Invalid number of nearest neighbors: \" + p);\n        }\n\n        KMeans kmeans = new KMeans(x, k, 10);\n        double[][] centers = kmeans.centroids();\n\n        EuclideanDistance distance = new EuclideanDistance();\n        double[] width = estimateWidth(centers, distance, p);\n        GaussianRadialBasis[] basis = gaussian(width);\n        return of(centers, basis, distance);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1681,
    "type": "Return",
    "comment": "@return a non-empty list of individual requests",
    "code": "private IndividualRequestMap extractIndividualRequests(RestRequest restRequest) {\n    validateHeaders(restRequest);\n    DataMap data = DataMapUtils.readMap(restRequest);\n    MultiplexedRequestContent multiplexedRequestContent = DataTemplateUtil.wrap(data, MultiplexedRequestContent.class);\n    IndividualRequestMap individualRequests = multiplexedRequestContent.getRequests();\n    int totalCount = totalRequestCount(individualRequests);\n    if (totalCount == NUM) {\n        throw new IllegalArgumentException(STR);\n    }\n    if (totalCount > _maximumRequestsNumber) {\n        throw new IllegalArgumentException(STR + _maximumRequestsNumber + STR + totalCount);\n    }\n    return individualRequests;\n}",
    "label": 1,
    "rec": "@return a non-empty map of individual requests"
  },
  {
    "id": 1682,
    "type": "Return",
    "comment": "@return  True if queue has been changed by this call.",
    "code": "    private boolean touch(EvictableEntry<K, V> entry) {\n        Node<EvictableEntry<K, V>> node = entry.meta();\n\n        // Entry has not been enqueued yet.\n        if (node == null) {\n            while (true) {\n                node = queue.offerLastx(entry);\n\n                if (entry.putMetaIfAbsent(node) != null) {\n                    // Was concurrently added, need to clear it from queue.\n                    queue.unlinkx(node);\n\n                    // Queue has not been changed.\n                    return false;\n                }\n                else if (node.item() != null) {\n                    if (!entry.isCached()) {\n                        // Was concurrently evicted, need to clear it from queue.\n                        queue.unlinkx(node);\n\n                        return false;\n                    }\n\n                    memSize.add(entry.size());\n\n                    return true;\n                }\n                // If node was unlinked by concurrent shrink() call, we must repeat the whole cycle.\n                else if (!entry.removeMeta(node))\n                    return false;\n                else {\n                    memSize.add(-entry.size());\n\n                    return true;\n                }\n            }\n        }\n\n        // Entry is already in queue.\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1683,
    "type": "Return",
    "comment": "@return the return from Object",
    "code": "    public ZuulFilterResult runFilter() {\n        ZuulFilterResult zr = new ZuulFilterResult(ExecutionStatus.DISABLED);\n        if (!filterDisabled.get()) {\n            if (shouldFilter()) {\n                Tracer t = TracerFactory.instance().startMicroTracer(\"ZUUL::\" + this.getClass().getSimpleName());\n                try {\n                    Object res = run();\n                    zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS);\n                } catch (Throwable e) {\n                    t.setName(\"ZUUL::\" + this.getClass().getSimpleName() + \" failed\");\n                    zr = new ZuulFilterResult(ExecutionStatus.FAILED);\n                    zr.setException(e);\n                } finally {\n                    t.stopAndLog();\n                }\n            } else {\n                zr = new ZuulFilterResult(ExecutionStatus.SKIPPED);\n            }\n        }\n        return zr;\n    }\n",
    "label": 1,
    "rec": "@return the return from ZuulFilterResult"
  },
  {
    "id": 1684,
    "type": "Return",
    "comment": "@return Grid configuration for specified node type.",
    "code": "    static IgniteConfiguration getConfig(String type) {\n        String path = NODE_CFG.get(type);\n\n        if (path == null)\n            throw new IllegalArgumentException(\"Unsupported node type: \" + type);\n\n        URL url = U.resolveGridGainUrl(path);\n\n        BeanFactory ctx = new FileSystemXmlApplicationContext(url.toString());\n\n        return (IgniteConfiguration)ctx.getBean(\"grid.cfg\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1685,
    "type": "Return",
    "comment": "@return the propertiesEditionComponent",
    "code": "public IPropertiesEditionComponent getPropertiesEditionComponent() {\n    return parentPropertiesEditionComponent;\n}",
    "label": 1,
    "rec": "@return the parent PropertiesEditionComponent"
  },
  {
    "id": 1686,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "        private int lockTail(long pageId, Page page, long backId, long fwdId, int lvl) throws IgniteCheckedException {\n            assert tail != null;\n\n            // Init parameters for the handlers.\n            this.pageId = pageId;\n            this.page = page;\n            this.fwdId = fwdId;\n            this.backId = backId;\n\n            if (backId == 0) // Back page ID is provided only when the last move was to the right.\n                return doLockTail(lvl);\n\n            Page back = page(backId);\n\n            try {\n                return writePage(backId, back, lockBackAndTail, this, lvl);\n            }\n            finally {\n                if (canRelease(backId, back, lvl))\n                    back.close();\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1687,
    "type": "Return",
    "comment": "@return Returns an array of all the users that were selected in the panel.",
    "code": "public List<String> getSelectedUsers() {\n    Object[] tmp = users.getSelectedValues();\n    List<String> susers = new ArrayList<String>();\n    for (int i = NUM; i < tmp.length; i++) {\n        susers.add(tmp[i].toString());\n    }\n    return susers;\n}",
    "label": 1,
    "rec": "@return Returns a list of all the users that were selected in the panel."
  },
  {
    "id": 1688,
    "type": "Return",
    "comment": "@return Assembled ODBC request.",
    "code": "    public OdbcRequest decode(byte[] msg) {\n        assert msg != null;\n\n        BinaryInputStream stream = new BinaryHeapInputStream(msg);\n\n        BinaryReaderExImpl reader = new BinaryReaderExImpl(null, stream, null, true);\n\n        byte cmd = reader.readByte();\n\n        // This is a special case because we can not decode protocol messages until\n        // we has not confirmed that the remote client uses the same protocol version.\n        if (!verConfirmed) {\n            if (cmd == OdbcRequest.HANDSHAKE)\n            {\n                long longVersion = reader.readLong();\n\n                OdbcHandshakeRequest res = new OdbcHandshakeRequest(longVersion);\n\n                OdbcProtocolVersion version = res.version();\n\n                if (version.isUnknown())\n                    return res;\n\n                if (version.isDistributedJoinsSupported()) {\n                    res.distributedJoins(reader.readBoolean());\n                    res.enforceJoinOrder(reader.readBoolean());\n                }\n\n                return res;\n            }\n            else\n                throw new IgniteException(\"Unexpected ODBC command \" +\n                        \"(first message is not a handshake request): [cmd=\" + cmd + ']');\n        }\n\n        OdbcRequest res;\n\n        switch (cmd) {\n            case OdbcRequest.EXECUTE_SQL_QUERY: {\n                String cache = reader.readString();\n                String sql = reader.readString();\n                int argsNum = reader.readInt();\n\n                Object[] params = new Object[argsNum];\n\n                for (int i = 0; i < argsNum; ++i)\n                    params[i] = reader.readObjectDetached();\n\n                res = new OdbcQueryExecuteRequest(cache, sql, params);\n\n                break;\n            }\n\n            case OdbcRequest.FETCH_SQL_QUERY: {\n                long queryId = reader.readLong();\n                int pageSize = reader.readInt();\n\n                res = new OdbcQueryFetchRequest(queryId, pageSize);\n\n                break;\n            }\n\n            case OdbcRequest.CLOSE_SQL_QUERY: {\n                long queryId = reader.readLong();\n\n                res = new OdbcQueryCloseRequest(queryId);\n\n                break;\n            }\n\n            case OdbcRequest.GET_COLUMNS_META: {\n                String cache = reader.readString();\n                String table = reader.readString();\n                String column = reader.readString();\n\n                res = new OdbcQueryGetColumnsMetaRequest(cache, table, column);\n\n                break;\n            }\n\n            case OdbcRequest.GET_TABLES_META: {\n                String catalog = reader.readString();\n                String schema = reader.readString();\n                String table = reader.readString();\n                String tableType = reader.readString();\n\n                res = new OdbcQueryGetTablesMetaRequest(catalog, schema, table, tableType);\n\n                break;\n            }\n\n            default:\n                throw new IgniteException(\"Unknown ODBC command: [cmd=\" + cmd + ']');\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1689,
    "type": "Return",
    "comment": "@return the {@code Subject} instance that represents the user and session data for the newly authenticated user.",
    "code": "protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) {\n    Map<String, Object> context = new HashMap<String, Object>();\n    context.put(SubjectFactory.AUTHENTICATED, Boolean.TRUE);\n    context.put(SubjectFactory.AUTHENTICATION_TOKEN, token);\n    context.put(SubjectFactory.AUTHENTICATION_INFO, info);\n    if (existing != null) {\n        context.put(SubjectFactory.SUBJECT, existing);\n    }\n    return createSubject(context);\n}",
    "label": 1,
    "rec": "@return the {@code Subject} instance that represents the context and session data for the newly authenticated subject."
  },
  {
    "id": 1690,
    "type": "Return",
    "comment": "@return handle to  Camera that was opened",
    "code": "  public static Camera open() {\n    return open(-1);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1691,
    "type": "Return",
    "comment": "@return the main evaluation context, also to be used by the REPL",
    "code": "private static ATObject loadMainCode() {\n    String startupCode = null;\n    NATObject mainEvalScope = null;\n    if (_EVAL_ARG_ != null) {\n        startupCode = _EVAL_ARG_;\n        mainEvalScope = new NATObject();\n    } else if (_FILE_ARG_ != null) {\n        File main = new File(_FILE_ARG_);\n        if (!main.exists()) {\n            abort(STR + main.getName());\n        } else {\n            try {\n                startupCode = Evaluator.loadContentOfFile(main);\n            } catch (IOException e) {\n                abort(STR + e.getMessage());\n            }\n            mainEvalScope = NATNamespace.createFileScopeFor(new NATNamespace(STR + main.getName(), main));\n        }\n    } else {\n        mainEvalScope = new NATObject();\n    }\n    _globalContext = new NATContext(mainEvalScope, mainEvalScope, mainEvalScope.getDynamicParent());\n    if (startupCode != null) {\n        return parseAndEval(startupCode, _FILE_ARG_ == null ? STR : _FILE_ARG_, _globalContext);\n    } else\n        return NATNil._INSTANCE_;\n}",
    "label": 1,
    "rec": "@return the result of evaluating the main initialization file or the -e option; null if no main file or -e option were specified."
  },
  {
    "id": 1692,
    "type": "Return",
    "comment": "@return true if it extends",
    "code": "\tpublic boolean isExtendedBy(final PaymentIntent other)\n\t{\n\t\t// TODO memo\n\t\treturn equalsAmount(other) && equalsAddress(other);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1693,
    "type": "Return",
    "comment": "@return {@code true} if the environment does not specify any labels.",
    "code": "public boolean isUnspecified() {\n    return labels.isEmpty() && variables.isEmpty();\n}",
    "label": 1,
    "rec": "@return {@code true} if the environment does not specify any labels nor environment variables."
  },
  {
    "id": 1694,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(CompRowMatrix[] data, int fold) throws Exception {\n\n\t\tCompRowMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\tString socialPath = cf.getPath(\"dataset.social\");\n\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\t\tcase \"globalavg\":\n\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"useravg\":\n\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"itemavg\":\n\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"random\":\n\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"constant\":\n\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"mostpop\":\n\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\t\tcase \"userknn\":\n\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"itemknn\":\n\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"slopeone\":\n\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\t\tcase \"regsvd\":\n\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\tcase \"biasedmf\":\n\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\tcase \"svd++\":\n\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"pmf\":\n\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\tcase \"climf\":\n\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\tcase \"socialmf\":\n\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold, socialPath);\n\t\tcase \"aaai-basemf\":\n\t\t\treturn new BaseMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dmf\":\n\t\t\treturn new DMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-basenm\":\n\t\t\treturn new BaseNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dnm\":\n\t\t\treturn new DNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-drm\":\n\t\t\treturn new DRM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-drmplus\":\n\t\t\treturn new DRMPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"hybrid\":\n\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\tdefault:\n\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1695,
    "type": "Return",
    "comment": "@return the iterator or {@code null} no restrictions apply",
    "code": "@SuppressWarnings(STR)\npublic Iterator<Integer> iterator() {\n    if (ranges == null) {\n        return Collections.emptyIterator();\n    }\n    IteratorChain chain = new IteratorChain();\n    for (IntRange range : ranges) {\n        chain.addIterator(range.iterator());\n    }\n    return chain;\n}",
    "label": 1,
    "rec": "@return the iterator"
  },
  {
    "id": 1696,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    public static String doReadString(BinaryInputStream in) {\n        if (!in.hasArray()) {\n            byte[] arr = doReadByteArray(in);\n\n            if (USE_STR_SERIALIZATION_VER_2)\n                return utf8BytesToStr(arr, 0, arr.length);\n            else\n                return new String(arr, UTF_8);\n        }\n\n        int strLen = in.readInt();\n\n        int pos = in.position();\n\n        // String will copy necessary array part for us.\n        String res;\n\n        if (USE_STR_SERIALIZATION_VER_2) {\n            res = utf8BytesToStr(in.array(), pos, strLen);\n        }\n        else {\n            res = new String(in.array(), pos, strLen, UTF_8);\n        }\n\n        in.position(pos + strLen);\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1697,
    "type": "Return",
    "comment": "@return  True if backed set has been changed by this call.",
    "code": "    private boolean touch(EvictableEntry<K, V> entry) {\n        Holder<K, V> holder = entry.meta();\n\n        // Entry has not been add yet to backed queue..\n        if (holder == null) {\n            while (true) {\n                holder = new Holder<>(entry, orderCnt.incrementAndGet());\n\n                set.add(holder);\n\n                if (entry.putMetaIfAbsent(holder) != null) {\n                    // Was concurrently added, need to remove it from queue.\n                    removeHolder(holder);\n\n                    // Set has not been changed.\n                    return false;\n                }\n                else if (holder.order > 0) {\n                    if (!entry.isCached()) {\n                        // Was concurrently evicted, need to remove it from queue.\n                        removeHolder(holder);\n\n                        return false;\n                    }\n\n                    memSize.add(entry.size());\n\n                    return true;\n                }\n                // If holder was removed by concurrent shrink() call, we must repeat the whole cycle.\n                else if (!entry.removeMeta(holder))\n                    return false;\n                else {\n                    memSize.add(-entry.size());\n\n                    return true;\n                }\n            }\n        }\n\n        // Entry is already in queue.\n        return false;\n    }\n",
    "label": 1,
    "rec": "@return  True if backed queue has been changed by this call."
  },
  {
    "id": 1698,
    "type": "Return",
    "comment": "@return Previous value.",
    "code": "    @Nullable public V getAndPut(final K key, final V val, @Nullable final CacheEntryPredicate[] filter)\n        throws IgniteCheckedException\n    {\n        boolean statsEnabled = ctx.config().isStatisticsEnabled();\n\n        long start = statsEnabled ? System.nanoTime() : 0L;\n\n        A.notNull(key, \"key\", val, \"val\");\n\n        if (keyCheck)\n            validateCacheKey(key);\n\n        validateCacheValue(val);\n\n        V prevVal = syncOp(new SyncOp<V>(true) {\n            @Override public V op(IgniteTxLocalAdapter tx) throws IgniteCheckedException {\n                return (V)tx.putAsync(ctx, key, val, true, filter).get().value();\n            }\n\n            @Override public String toString() {\n                return \"put [key=\" + key + \", val=\" + val + \", filter=\" + Arrays.toString(filter) + ']';\n            }\n        });\n\n        if (statsEnabled)\n            metrics0().addPutAndGetTimeNanos(System.nanoTime() - start);\n\n        return prevVal;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1699,
    "type": "Return",
    "comment": "@return HystrixRuntimeException or HystrixBadRequestException",
    "code": "    protected RuntimeException decomposeException(Exception e) {\n        if (e instanceof IllegalStateException) {\n            return (IllegalStateException) e;\n        }\n        if (e instanceof HystrixBadRequestException) {\n            return (HystrixBadRequestException) e;\n        }\n        if (e.getCause() instanceof HystrixBadRequestException) {\n            return (HystrixBadRequestException) e.getCause();\n        }\n        if (e instanceof HystrixRuntimeException) {\n            return (HystrixRuntimeException) e;\n        }\n        // if we have an exception we know about we'll throw it directly without the wrapper exception\n        if (e.getCause() instanceof HystrixRuntimeException) {\n            return (HystrixRuntimeException) e.getCause();\n        }\n        // we don't know what kind of exception this is so create a generic message and throw a new HystrixRuntimeException\n        String message = getLogMessagePrefix() + \" failed while executing.\";\n        logger.debug(message, e); // debug only since we're throwing the exception and someone higher will do something with it\n        return new HystrixRuntimeException(FailureType.COMMAND_EXCEPTION, this.getClass(), message, e, null);\n    }\n",
    "label": 1,
    "rec": "@return HystrixRuntimeException, HystrixBadRequestException or IllegalStateException"
  },
  {
    "id": 1700,
    "type": "Return",
    "comment": "@return true if injection occurred, false otherwise",
    "code": "    private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n        return nextStrategy != null && nextStrategy.process(field, fieldOwner, mockCandidates);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1701,
    "type": "Return",
    "comment": "@return an array with all edge section points",
    "code": "private static ArrayList<KVector> getPoints(final ElkEdgeSection section) {\n    int n = section.getBendPoints().size() + NUM;\n    ArrayList<KVector> points = new ArrayList<KVector>(n);\n    points.add(new KVector(section.getStartX(), section.getStartY()));\n    section.getBendPoints().stream().forEach(bendPoint -> points.add(new KVector(bendPoint.getX(), bendPoint.getY())));\n    points.add(new KVector(section.getEndX(), section.getEndY()));\n    int i = NUM;\n    while (i < points.size() - NUM) {\n        KVector p1 = points.get(i - NUM);\n        KVector p2 = points.get(i);\n        KVector p3 = points.get(i + NUM);\n        if ((p1.x == p2.x && p2.x == p3.x) || (p1.y == p2.y && p2.y == p3.y)) {\n            points.remove(i);\n        } else {\n            ++i;\n        }\n    }\n    return points;\n}",
    "label": 1,
    "rec": "@return an array with all needed edge section points"
  },
  {
    "id": 1702,
    "type": "Return",
    "comment": "@return true if a match is found, false otherwise.",
    "code": "    public static boolean matches(String text, String pattern) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n\n        if (!pattern.contains(WILDCARD)) {\n            return text.equals(pattern);\n        }\n\n        pattern = pattern.replaceAll(\"\\\\*\", \".*\");\n        Scanner s = new Scanner(text);\n        s.useDelimiter(pattern);\n        boolean matchesWildcard = !s.hasNext();\n        s.close();\n\n        return matchesWildcard;\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1703,
    "type": "Return",
    "comment": "@return Query object for chaining methods.",
    "code": "public Select where(String selection, String... args) {\n    this.selection = selection;\n    this.selectionArgs = args;\n    return this;\n}",
    "label": 1,
    "rec": "@return Select object for chaining methods."
  },
  {
    "id": 1704,
    "type": "Return",
    "comment": "@return true if the change attempt was successful, false if not. If the change was not successful,  #getValue() will return the updated value",
    "code": "    public boolean trySetValue(VersionedValue<byte[]> previous, byte[] newValue) throws Exception\n    {\n        Preconditions.checkState(state.get() == State.STARTED, \"not started\");\n\n        VersionedValue<byte[]> current = currentValue.get();\n        if ( previous.getVersion() != current.getVersion() || !Arrays.equals(previous.getValue(), current.getValue()) )\n        {\n            return false;\n        }\n\n        try\n        {\n            Stat result = client.setData().withVersion(previous.getVersion()).forPath(path, newValue);\n            updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));\n            return true;\n        }\n        catch ( KeeperException.BadVersionException ignore )\n        {\n            // ignore\n        }\n\n        readValue();\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1705,
    "type": "Return",
    "comment": "@return the  ExecutorService to be used to execute  SpiceRequest instances or null if you prefer to use the default  ExecutorService of RoboSpice.",
    "code": "    protected ExecutorService getExecutorService() {\n        ExecutorService executorService;\n        int threadCount = getThreadCount();\n        if ( threadCount <= 0 ) {\n            throw new IllegalArgumentException( \"Thread count must be >= 1\" );\n        } else if ( threadCount == 1 ) {\n            executorService = Executors.newSingleThreadExecutor();\n        } else {\n            executorService = Executors.newFixedThreadPool( threadCount, new ThreadFactory() {\n\n                public Thread newThread( Runnable r ) {\n                    return new Thread( r );\n                }\n            } );\n        }\n        return executorService;\n    }\n",
    "label": 1,
    "rec": "@return the  ExecutorService to be used to execute  SpiceRequest instances."
  },
  {
    "id": 1706,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String disable(Long id, HttpServletRequest request, HttpSession session, ModelMap model) {\n        SysAppClient entity = service.getEntity(id);\n        if (null != entity) {\n            SysSite site = siteComponent.getSite(request.getServerName());\n            if (ControllerUtils.verifyNotEquals(\"siteId\", site.getId(), entity.getSiteId(), model)) {\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n            service.updateStatus(id, true);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"disable.appclient\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1707,
    "type": "Return",
    "comment": "@return the same as gethelp(80)",
    "code": "public String getHelp() {\n    return (getHelp(DEFAULT_SCREENWIDTH, DEFAULT_PARAM_HELP_SEPARATOR));\n}",
    "label": 1,
    "rec": "@return the same as gethelp(80, \"\\n\")"
  },
  {
    "id": 1708,
    "type": "Return",
    "comment": "@return true if pull request, false otherwise",
    "code": "    public static boolean isPullRequest(final Issue issue) {\n        return issue != null && issue.pullRequest != null\n                && !TextUtils.isEmpty(issue.pullRequest.html_url);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1709,
    "type": "Return",
    "comment": "@return this array",
    "code": "public int remove(long... values) {\n    _check();\n    int removed = NUM;\n    if (values != null && values.length > NUM) {\n        for (long v : values) {\n            _remove(binarySearch(v));\n        }\n    }\n    return removed;\n}",
    "label": 1,
    "rec": "@return the number of removed values"
  },
  {
    "id": 1710,
    "type": "Return",
    "comment": "@return Partition.",
    "code": "    public int partition(Object key) {\n        GridAffinityAssignmentCache aff0 = aff;\n\n        boolean keyObj = key instanceof KeyCacheObject;\n\n        if (key instanceof KeyCacheObject) {\n            int part = ((KeyCacheObject)key).partition();\n\n            if (part != -1)\n                return part;\n        }\n\n        if (aff0 == null)\n            throw new IgniteException(FAILED_TO_FIND_CACHE_ERR_MSG + cctx.name());\n\n        int p = affFunction.partition(affinityKey(key));\n\n        if (keyObj)\n            ((KeyCacheObject)key).partition(p);\n\n        return p;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1711,
    "type": "Return",
    "comment": "@return the corresponding email address from the directory, or null if none can be found.",
    "code": "protected String findMailAddressFor(String userName) {\n    if (configuration.isValid()) {\n        Matcher matcher = configuration.getUserNamePattern().matcher(userName);\n        if (matcher.matches()) {\n            int groupCount = matcher.groupCount();\n            Object[] parts = new String[groupCount + NUM];\n            for (int i = NUM; i < groupCount; i++) {\n                parts[i] = matcher.group(i + NUM);\n            }\n            return String.format(configuration.getEmailAddressPattern(), parts);\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the corresponding email address"
  },
  {
    "id": 1712,
    "type": "Return",
    "comment": "@return Regex pattern for JSON.",
    "code": "    private String stringPattern(String res, boolean success) {\n        return \"\\\\{\\\\\\\"error\\\\\\\":\\\\\\\"\" + (!success ? \".+\" : \"\") + \"\\\\\\\"\\\\,\" +\n            \"\\\\\\\"response\\\\\\\":\\\\\\\"\" + res + \"\\\\\\\"\\\\,\" +\n            \"\\\\\\\"sessionToken\\\\\\\":\\\\\\\"\" + (securityEnabled() && success ? \".+\" : \"\") + \"\\\\\\\",\" +\n            \"\\\\\\\"successStatus\\\\\\\":\" + (success ? 0 : 1) + \"\\\\}\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1713,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder collapsedRequests(Collection<HystrixCollapser.CollapsedRequest<Object, Object>> pCollapsedRequests) {\n    this.collapsedRequests = pCollapsedRequests;\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 1714,
    "type": "Return",
    "comment": "@return Collection of futures.",
    "code": "    public Collection<IgniteInternalFuture<T>> futures() {\n        synchronized (sync) {\n            if(futs == null)\n                return Collections.emptyList();\n\n            if (futs instanceof IgniteInternalFuture)\n                return Collections.singletonList((IgniteInternalFuture<T>)futs);\n\n            return new ArrayList<>((Collection<IgniteInternalFuture<T>>)futs);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1715,
    "type": "Return",
    "comment": "@return GitHub repos, returns an empty list if not found",
    "code": "public static JSONArray getGitHubRepos(final String githubUserId) {\n    try {\n        final HttpResponse res = HttpRequest.get(STR + githubUserId).connectionTimeout(NUM).timeout(NUM).header(STR, Solos.USER_AGENT).send();\n        if (HttpServletResponse.SC_OK != res.statusCode()) {\n            return null;\n        }\n        res.charset(STR);\n        final JSONObject result = new JSONObject(res.bodyText());\n        if (NUM != result.optInt(Keys.STATUS_CODE)) {\n            return null;\n        }\n        final JSONObject data = result.optJSONObject(Common.DATA);\n        final JSONArray ret = data.optJSONArray(STR);\n        return ret;\n    } catch (final Exception e) {\n        LOGGER.log(Level.ERROR, STR, e);\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return GitHub repos, returns {@code null} if not found"
  },
  {
    "id": 1716,
    "type": "Return",
    "comment": "@return true if the input string is indeed hex or empty. False if the input string is non-hex or null.",
    "code": "  static boolean isHexWepKey(CharSequence wepKey) {\n    if (wepKey == null) {\n      return false;\n    }\n    int length = wepKey.length();\n    // WEP-40, WEP-104, and some vendors using 256-bit WEP (WEP-232?)\n    return (length == 10 || length == 26 || length == 58) && HEX_DIGITS.matcher(wepKey).matches();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1717,
    "type": "Return",
    "comment": "@return A {@see WorkbenchModuleResource}associated with the current ModuleCore with its sourcePath equivalent to aResource",
    "code": "public ComponentType createModuleType(String aModuleTypeId) {\n    if (isReadOnly)\n        throwAttemptedReadOnlyModification();\n    ComponentType moduleType = MODULE_FACTORY.createModuleType();\n    moduleType.setModuleTypeId(aModuleTypeId);\n    return moduleType;\n}",
    "label": 1,
    "rec": "@return A {@see ComponentResource}associated with the current ModuleCore with its sourcePath equivalent to aResource"
  },
  {
    "id": 1718,
    "type": "Return",
    "comment": "@return  true if successful.",
    "code": "    private boolean deleteRecursive(File f, boolean deleteIfExists) {\n        BasicFileAttributes attrs;\n\n        try {\n            attrs = Files.readAttributes(f.toPath(), BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n        }\n        catch (IOException ignore) {\n            return deleteIfExists && !f.exists();\n        }\n\n        if (!attrs.isDirectory() || attrs.isSymbolicLink())\n            return f.delete() || (deleteIfExists && !f.exists());\n\n        File[] entries = f.listFiles();\n\n        if (entries != null) {\n            for (File entry : entries) {\n                boolean res = deleteRecursive(entry, true);\n\n                if (!res)\n                    return false;\n            }\n        }\n\n        return f.delete() || (deleteIfExists && !f.exists());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1719,
    "type": "Return",
    "comment": "@return true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.",
    "code": "    public boolean matches(Method method, Class targetClass) {\n        return ((method.getAnnotation(RequiresPermissions.class) != null) ||\n                (method.getAnnotation(RequiresRoles.class) != null) ||\n                (method.getAnnotation(RequiresUser.class) != null) ||\n                (method.getAnnotation(RequiresGuest.class) != null ) ||\n                (method.getAnnotation(RequiresAuthentication.class) != null ));\n    }\n",
    "label": 1,
    "rec": "@return true if the method has a JSecurity annotation, false otherwise."
  },
  {
    "id": 1720,
    "type": "Return",
    "comment": "@return New instance of CacheOperationContext with specific subject id.",
    "code": "    public CacheOperationContext forSubjectId(UUID subjId) {\n        return new CacheOperationContext(\n            skipStore,\n            subjId,\n            keepPortable,\n            expiryPlc,\n            noRetries);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1721,
    "type": "Return",
    "comment": "@return the locale key.",
    "code": "public static Locale getLocale() {\n    return locale;\n}",
    "label": 1,
    "rec": "@return the locale."
  },
  {
    "id": 1722,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static long or(long first, long second) {\n        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1723,
    "type": "Return",
    "comment": "@return Whether reconnect failed.",
    "code": "    private boolean joinTopology(boolean recon) throws GridSpiException {\n        if (!recon)\n            stats.onJoinStarted();\n\n        Collection<InetSocketAddress> addrs = null;\n\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                while (addrs == null || addrs.isEmpty()) {\n                    addrs = resolvedAddresses();\n\n                    if (!F.isEmpty(addrs)) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Resolved addresses from IP finder: \" + addrs);\n                    }\n                    else {\n                        U.warn(log, \"No addresses registered in the IP finder (will retry in 2000ms): \" + ipFinder);\n\n                        U.sleep(2000);\n                    }\n                }\n\n                Iterator<InetSocketAddress> it = addrs.iterator();\n\n                while (it.hasNext() && !Thread.currentThread().isInterrupted()) {\n                    InetSocketAddress addr = it.next();\n\n                    Socket sock = null;\n\n                    try {\n                        long ts = U.currentTimeMillis();\n\n                        GridBiTuple<Socket, UUID> t = initConnection(addr);\n\n                        sock = t.get1();\n\n                        UUID rmtNodeId = t.get2();\n\n                        stats.onClientSocketInitialized(U.currentTimeMillis() - ts);\n\n                        locNode.clientRouterNodeId(rmtNodeId);\n\n                        GridTcpDiscoveryAbstractMessage msg = recon ?\n                            new GridTcpDiscoveryClientReconnectMessage(locNodeId, rmtNodeId, lastMsgId) :\n                            new GridTcpDiscoveryJoinRequestMessage(locNode, null);\n\n                        msg.client(true);\n\n                        writeToSocket(sock, msg);\n\n                        int res = readReceipt(sock, ackTimeout);\n\n                        switch (res) {\n                            case RES_OK:\n                                this.sock = sock;\n\n                                sockRdr = new SocketReader(rmtNodeId, new MessageWorker(recon));\n                                sockRdr.start();\n\n                                if (U.await(joinLatch, netTimeout, MILLISECONDS)) {\n                                    GridSpiException joinErr0 = joinErr;\n\n                                    if (joinErr0 != null)\n                                        throw joinErr0;\n\n                                    if (reconFailed) {\n                                        if (log.isDebugEnabled())\n                                            log.debug(\"Failed to reconnect, will try to rejoin [locNode=\" +\n                                                locNode + ']');\n\n                                        U.closeQuiet(sock);\n\n                                        U.interrupt(sockRdr);\n                                        U.join(sockRdr, log);\n\n                                        this.sock = null;\n\n                                        return false;\n                                    }\n\n                                    if (log.isDebugEnabled())\n                                        log.debug(\"Successfully connected to topology [sock=\" + sock + ']');\n\n                                    hbSender = new HeartbeatSender();\n                                    hbSender.start();\n\n                                    stats.onJoinFinished();\n\n                                    return true;\n                                }\n                                else {\n                                    U.warn(log, \"Join process timed out (will try other address) [sock=\" + sock +\n                                        \", timeout=\" + netTimeout + ']');\n\n                                    U.closeQuiet(sock);\n\n                                    U.interrupt(sockRdr);\n                                    U.join(sockRdr, log);\n\n                                    it.remove();\n\n                                    break;\n                                }\n\n                            case RES_CONTINUE_JOIN:\n                            case RES_WAIT:\n                                U.closeQuiet(sock);\n\n                                break;\n\n                            default:\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Received unexpected response to join request: \" + res);\n\n                                U.closeQuiet(sock);\n                        }\n                    }\n                    catch (GridInterruptedException ignored) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Joining thread was interrupted.\");\n\n                        return false;\n                    }\n                    catch (IOException | GridException e) {\n                        if (log.isDebugEnabled())\n                            U.error(log, \"Failed to establish connection with address: \" + addr, e);\n\n                        U.closeQuiet(sock);\n\n                        it.remove();\n                    }\n                }\n\n                if (addrs.isEmpty()) {\n                    U.warn(log, \"Failed to connect to any address from IP finder (will retry to join topology \" +\n                        \"in 2000ms): \" + addrs);\n\n                    U.sleep(2000);\n                }\n            }\n            catch (GridInterruptedException ignored) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Joining thread was interrupted.\");\n            }\n        }\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "@return Whether joined successfully."
  },
  {
    "id": 1724,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    @Nullable protected CacheObject unswap(boolean needVal, boolean checkExpire)\n        throws IgniteCheckedException, GridCacheEntryRemovedException {\n        if (!cctx.isSwapOrOffheapEnabled())\n            return null;\n\n        assert !detached() : this;\n\n        boolean obsolete = false;\n        boolean deferred = false;\n        GridCacheVersion ver0 = null;\n\n        synchronized (this) {\n            checkObsolete();\n\n            if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {\n                GridCacheSwapEntry e;\n\n                if (cctx.offheapTiered()) {\n                    e = cctx.swap().readOffheapPointer(this);\n\n                    if (log.isTraceEnabled()) {\n                        if (e != null) {\n                            log.trace(\"Read offheap pointer [key=\" + key +\n                                \", entry=\" + System.identityHashCode(this) +\n                                \", ptr=\" + e.offheapPointer() +\n                                ']');\n                        }\n                        else {\n                            log.trace(\"Read offheap pointer [key=\" + key +\n                                \", entry=\" + System.identityHashCode(this) +\n                                \", val=\" + null +\n                                ']');\n                        }\n                    }\n\n                    if (e != null) {\n                        if (e.offheapPointer() > 0) {\n                            offHeapPointer(e.offheapPointer());\n\n                            flags |= IS_OFFHEAP_PTR_MASK;\n\n                            if (needVal) {\n                                CacheObject val = cctx.fromOffheap(e.offheapPointer(), false);\n\n                                e.value(val);\n                            }\n                        }\n                        else // Read from swap.\n                            offHeapPointer(0);\n                    }\n                }\n                else {\n                    e = cctx.swap().readAndRemove(this);\n\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"unswap readAndRemove [key=\" + key +\n                            \", entry=\" + System.identityHashCode(this) +\n                            \", found=\" + (e != null) +\n                            ']');\n                    }\n                }\n\n                flags |= IS_UNSWAPPED_MASK;\n\n                // If there is a value.\n                if (e != null) {\n                    long delta = checkExpire ? (e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis()) : 0;\n\n                    CacheObject val = e.value();\n\n                    val = cctx.kernalContext().cacheObjects().prepareForCache(val, cctx);\n\n                    // Set unswapped value.\n                    update(val, e.expireTime(), e.ttl(), e.version(), false);\n\n                    // Must update valPtr again since update() will reset it.\n                    if (cctx.offheapTiered() && e.offheapPointer() > 0)\n                        offHeapPointer(e.offheapPointer());\n\n                    if (delta >= 0)\n                        return val;\n                    else {\n                        CacheObject expiredVal = rawGetOrUnmarshal(false);\n\n                        if (onExpired(expiredVal, null)) {\n                            if (cctx.deferredDelete()) {\n                                deferred = true;\n                                ver0 = ver;\n                            }\n                            else\n                                obsolete = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (obsolete) {\n            onMarkedObsolete();\n\n            cctx.cache().removeEntry(this);\n        }\n\n        if (deferred) {\n            assert ver0 != null;\n\n            cctx.onDeferredDelete(this, ver0);\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1725,
    "type": "Return",
    "comment": "@return The id of the new {@link BatchFileEntry}.",
    "code": "public String addFile(String index, InputStream is, String name, String mime) throws IOException {\n    String mimeType = mime;\n    if (mimeType == null) {\n        mimeType = STR;\n    }\n    Blob blob = Blobs.createBlob(is, mime);\n    blob.setFilename(name);\n    String fileEntryKey = key + STR + index;\n    BatchManager bm = Framework.getService(BatchManager.class);\n    bm.getTransientStore().putBlobs(fileEntryKey, Collections.singletonList(blob));\n    bm.getTransientStore().putParameter(fileEntryKey, CHUNKED_PARAM_NAME, String.valueOf(false));\n    bm.getTransientStore().putParameter(key, index, fileEntryKey);\n    return fileEntryKey;\n}",
    "label": 1,
    "rec": "@return The key of the new {@link BatchFileEntry}."
  },
  {
    "id": 1726,
    "type": "Return",
    "comment": "@return new  com.netflix.hystrix.AbstractCommand.ExecutionResult with events added",
    "code": "        public ExecutionResult addEvents(HystrixEventType... events) {\n            return new ExecutionResult(getUpdatedList(this.events, events), startTimestamp, executionLatency, userThreadLatency, failedExecutionException, executionException, numEmissions, numFallbackEmissions, numCollapsed);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1727,
    "type": "Return",
    "comment": "@return an EventProcessor wrapped in a Offerable",
    "code": "public static <E> Offerable<E> toOfferableSafe(final Procedure<E> processor) {\n    return new Procedure2OfferableSafe<E>(processor);\n}",
    "label": 1,
    "rec": "@return an Procedure wrapped in a Offerable"
  },
  {
    "id": 1728,
    "type": "Return",
    "comment": "@return Accessor.",
    "code": "    public static BinaryFieldAccessor create(Field field, int id) {\n        BinaryWriteMode mode = PortableUtils.mode(field.getType());\n\n        switch (mode) {\n            case P_BYTE:\n                return new BytePrimitiveAccessor(field, id);\n\n            case P_BOOLEAN:\n                return new BooleanPrimitiveAccessor(field, id);\n\n            case P_SHORT:\n                return new ShortPrimitiveAccessor(field, id);\n\n            case P_CHAR:\n                return new CharPrimitiveAccessor(field, id);\n\n            case P_INT:\n                return new IntPrimitiveAccessor(field, id);\n\n            case P_LONG:\n                return new LongPrimitiveAccessor(field, id);\n\n            case P_FLOAT:\n                return new FloatPrimitiveAccessor(field, id);\n\n            case P_DOUBLE:\n                return new DoublePrimitiveAccessor(field, id);\n\n            case BYTE:\n            case BOOLEAN:\n            case SHORT:\n            case CHAR:\n            case INT:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n            case DECIMAL:\n            case STRING:\n            case UUID:\n            case DATE:\n            case TIMESTAMP:\n            case BYTE_ARR:\n            case SHORT_ARR:\n            case INT_ARR:\n            case LONG_ARR:\n            case FLOAT_ARR:\n            case DOUBLE_ARR:\n            case CHAR_ARR:\n            case BOOLEAN_ARR:\n            case DECIMAL_ARR:\n            case STRING_ARR:\n            case UUID_ARR:\n            case DATE_ARR:\n            case TIMESTAMP_ARR:\n            case ENUM_ARR:\n            case OBJECT_ARR:\n            case PORTABLE_OBJ:\n            case PORTABLE:\n            case EXTERNALIZABLE:\n                return new DefaultFinalClassAccessor(field, id, mode, false);\n\n            default:\n                return new DefaultFinalClassAccessor(field, id, mode, !U.isFinal(field.getType()));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1729,
    "type": "Return",
    "comment": "@return random name",
    "code": "public static String randMatrixName() {\n    return randString(Constants.RANDOM, NUM);\n}",
    "label": 1,
    "rec": "@return random matrix name"
  },
  {
    "id": 1730,
    "type": "Return",
    "comment": "@return Operation context.",
    "code": "    public CacheOperationContext setNoRetries(boolean noRetries) {\n        return new CacheOperationContext(\n            skipStore,\n            subjId,\n            keepBinary,\n            expiryPlc,\n            noRetries,\n            dataCenterId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1731,
    "type": "Return",
    "comment": "@return {@link LifecycleProvider} for the whole application.",
    "code": "public static LifecycleOwner get() {\n    return sInstance;\n}",
    "label": 1,
    "rec": "@return {@link LifecycleOwner} for the whole application."
  },
  {
    "id": 1732,
    "type": "Return",
    "comment": "@return Services configuration.",
    "code": "    protected ManagedServiceConfiguration[] services() {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1733,
    "type": "Return",
    "comment": "@return Offset.",
    "code": "    private boolean findFieldById(int id) {\n        assert dataStart != start;\n\n        if (footerLen == 0)\n            return false;\n\n        if (userType) {\n            int order;\n\n            if (matching) {\n                // Trying to get field order speculatively.\n                int expOrder = matchingOrder++;\n\n                int realId = schema.fieldId(expOrder);\n\n                if (realId == id) {\n                    if (expOrder == 0)\n                        streamPosition(dataStart);\n\n                    return true;\n                }\n                else {\n                    // Mismatch detected, no need for further speculations.\n                    matching = false;\n\n                    order = schema.order(id);\n                }\n            }\n            else\n                order = schema.order(id);\n\n            return trySetUserFieldPosition(order);\n        }\n        else\n            return trySetSystemFieldPosition(id);\n    }\n",
    "label": 1,
    "rec": "@return  True if field was found and stream was positioned accordingly."
  },
  {
    "id": 1734,
    "type": "Return",
    "comment": "@return Task input.",
    "code": "    private GridHadoopTaskInput createInput(GridHadoopTaskContext ctx, boolean locCombiner) throws GridException {\n        switch (ctx.taskInfo().type()) {\n            case SETUP:\n            case MAP:\n            case COMMIT:\n            case ABORT:\n                return null;\n\n            case COMBINE:\n                if (locCombiner) {\n                    assert local != null;\n\n                    return local.input((Comparator<Object>)job.combineGroupComparator());\n                }\n\n            default:\n                return createInput(ctx);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1735,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long expFwdId, final int lvl)\n        throws IgniteCheckedException {\n        try (Page page = page(pageId)) {\n            int res;\n\n            for (;;) {\n                // Init args.\n                g.pageId = pageId;\n                g.expFwdId = expFwdId;\n\n                res = readPage(page, search, g, lvl);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.expFwdId != expFwdId || expFwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.expFwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false;\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        throw new IllegalStateException(\"Invalid result: \" + res);\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@return  true If retry."
  },
  {
    "id": 1736,
    "type": "Return",
    "comment": "@return the salt used to hash the credentials, or  null if no salt was used or credentials were not hashed at all.",
    "code": "    public ByteSource getCredentialsSalt() {\n        return credentialsSalt;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1737,
    "type": "Return",
    "comment": "@return A new Toml instance. Empty if no value is found for key.",
    "code": "@SuppressWarnings(STR)\npublic Toml getTable(String key) {\n    Map<String, Object> map = (Map<String, Object>) get(key);\n    return map != null ? new Toml(null, map) : null;\n}",
    "label": 1,
    "rec": "@return A new Toml instance or <code>null</code> if no value is found for key."
  },
  {
    "id": 1738,
    "type": "Return",
    "comment": "@return  True if cache contains given key.",
    "code": "    protected boolean containsKey(IgniteCache cache, Object key) throws Exception {\n        return offheapTiered(cache) ? cache.localPeek(key, CachePeekMode.OFFHEAP) != null : cache.containsKey(key);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1739,
    "type": "Return",
    "comment": "@return the list of modules",
    "code": "public ModuleMultimap getModules() {\n    return moduleListMap.get();\n}",
    "label": 1,
    "rec": "@return the module list map"
  },
  {
    "id": 1740,
    "type": "Return",
    "comment": "@return the weight from the landmark to the specified node. Where the landmark integer is not a node ID but the internal index of the landmark array.",
    "code": "    int getFromWeight(int landmarkIndex, int node) {\n        int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + FROM_OFFSET)\n                & 0x0000FFFF;\n        if (res == SHORT_INFINITY)\n            // TODO can happen if endstanding oneway\n            // we should set a 'from' value to SHORT_MAX if the 'to' value was already set to find real bugs\n            // and what to return? Integer.MAX_VALUE i.e. convert to Double.pos_infinity upstream?\n            return SHORT_MAX;\n        // throw new IllegalStateException(\"Do not call getFromWeight for wrong landmark[\" + landmarkIndex + \"]=\" + landmarkIDs[landmarkIndex] + \" and node \" + node);\n        // TODO if(res == MAX) fallback to beeline approximation!?\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1741,
    "type": "Return",
    "comment": "@return A JDBC connection",
    "code": "public Connection borrowConnection() throws DynaSqlException {\n    try {\n        return getDataSource().getConnection();\n    } catch (SQLException ex) {\n        throw new DynaSqlException(STR, ex);\n    }\n}",
    "label": 1,
    "rec": "@return The connection"
  },
  {
    "id": 1742,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static double and(double first, double second) {\n        return LastArguments.instance().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1743,
    "type": "Return",
    "comment": "@return an iterator over the error message strings.",
    "code": "public Iterable<String> getErrors() {\n    return _errorList;\n}",
    "label": 1,
    "rec": "@return an iterable collection of error message strings."
  },
  {
    "id": 1744,
    "type": "Return",
    "comment": "@return verification mode",
    "code": "    public static VerificationMode atLeast(int minNumberOfInvocations) {\n        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1745,
    "type": "Return",
    "comment": "@return The {@link ConditionEvaluator}, or null if no condition is specified.",
    "code": "public ExpressionEvaluator getConditionEvaluator() {\n    return expressionEvaluator;\n}",
    "label": 1,
    "rec": "@return The {@link org.milyn.expression.ExpressionEvaluator}, or null if no condition is specified."
  },
  {
    "id": 1746,
    "type": "Return",
    "comment": "@return  True if task is Visor task.",
    "code": "    private boolean visorTask(String taskCls) {\n        return taskCls.startsWith(VISOR_TASK_PREFIX);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1747,
    "type": "Return",
    "comment": "@return the total free memory size of the OS. 0 if there is an error.",
    "code": "long getOsTotalFreeMemorySize() {\n    if (!Files.isRegularFile(Paths.get(MEM_INFO_FILE))) {\n        return NUM;\n    }\n    List<String> lines;\n    try {\n        lines = Files.readAllLines(Paths.get(MEM_INFO_FILE), StandardCharsets.UTF_8);\n    } catch (IOException e) {\n        String errMsg = STR + MEM_INFO_FILE;\n        logger.error(errMsg, e);\n        return NUM;\n    }\n    return getOsTotalFreeMemorySizeFromStrings(lines);\n}",
    "label": 1,
    "rec": "@return the total free memory size of the OS. 0 if there is an error or the OS doesn't support this memory check."
  },
  {
    "id": 1748,
    "type": "Return",
    "comment": "@return styled text",
    "code": "    public List<CharSequence> get(final String file) {\n        if (TextUtils.isEmpty(file)) {\n            return Collections.emptyList();\n        }\n        List<CharSequence> lines = diffs.get(file);\n        return lines != null ? lines : Collections.emptyList();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1749,
    "type": "Return",
    "comment": "@return an annotation processor for the given annotation types, or <tt>null</tt> if the types are not supported or the processor cannot be created",
    "code": "public AnnotationProcessor getProcessorFor(Set<AnnotationTypeDeclaration> atds, AnnotationProcessorEnvironment env) {\n    return new JdbcControlAnnotationProcessor(env);\n}",
    "label": 1,
    "rec": "@return an JdbcControlAnnotationProcessor"
  },
  {
    "id": 1750,
    "type": "Return",
    "comment": "@return rolling max active threads",
    "code": "    public long getRollingMaxActiveThreads() {\n        //TODO This should get fixed, either by adding a metric stream that can produce this value, or by\n        //changing the problem into getting the whole distribution via sampling (not just the max as in this method)\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1751,
    "type": "Return",
    "comment": "@return accuracies with first 1, 2, ..., decision trees.",
    "code": "    public int[][] test(DataFrame data) {\n        DataFrame x = formula.x(data);\n\n        int n = x.size();\n        int ntrees = trees.length;\n        int[][] prediction = new int[ntrees][n];\n\n        if (k == 2) {\n            for (int j = 0; j < n; j++) {\n                Tuple xj = x.get(j);\n                double base = 0;\n                for (int i = 0; i < ntrees; i++) {\n                    base += alpha[i] * trees[i].predict(xj);\n                    prediction[i][j] = base > 0 ? 1 : 0;\n                }\n            }\n        } else {\n            double[] p = new double[k];\n            for (int j = 0; j < n; j++) {\n                Tuple xj = x.get(j);\n                Arrays.fill(p, 0);\n                for (int i = 0; i < ntrees; i++) {\n                    p[trees[i].predict(xj)] += alpha[i];\n                    prediction[i][j] = MathEx.whichMax(p);\n                }\n            }\n        }\n        \n        return prediction;\n    }\n",
    "label": 1,
    "rec": "@return the predictions with first 1, 2, ..., decision trees."
  },
  {
    "id": 1752,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    public static Object value(int idx, DataMode mode) {\n        if (mode == null)\n            mode = DataMode.SERIALIZABLE;\n\n        switch (mode) {\n            case SERIALIZABLE:\n                return new SerializableObject(idx);\n            case CUSTOM_SERIALIZABLE:\n                return new CustomSerializableObject(idx);\n            case EXTERNALIZABLE:\n                return new ExternalizableObject(idx);\n            case PLANE_OBJECT:\n                return new PlaneObject(idx);\n            case BINARILIZABLE:\n                return new BinarylizableObject(idx);\n            default:\n                throw new IllegalArgumentException(\"mode: \" + mode);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1753,
    "type": "Return",
    "comment": "@return the integer reference",
    "code": "public long put(String name) {\n    if (name == null || name.isEmpty()) {\n        return NUM;\n    }\n    if (name.equals(lastName)) {\n        return lastIndex;\n    }\n    byte[] bytes = getBytes(name);\n    long oldPointer = bytePointer;\n    names.ensureCapacity(bytePointer + NUM + bytes.length);\n    byte[] sizeBytes = new byte[] { (byte) bytes.length };\n    names.setBytes(bytePointer, sizeBytes, sizeBytes.length);\n    bytePointer++;\n    names.setBytes(bytePointer, bytes, bytes.length);\n    bytePointer += bytes.length;\n    if (bytePointer < NUM) {\n        throw new IllegalStateException(STR);\n    }\n    lastName = name;\n    lastIndex = oldPointer;\n    return oldPointer;\n}",
    "label": 1,
    "rec": "@return the byte pointer to the name"
  },
  {
    "id": 1754,
    "type": "Return",
    "comment": "@return A PluginRequest object with a status",
    "code": "    public PluginResult execute(String action, JSONArray data, String callbackId) {\n        PluginResult result = null;\n        if (NOTIFY.equals(action)) {\n            try {\n                String tag = data.getString(0);\n                String title = data.getString(1);\n                String body = data.getString(2);\n                Log.d(\"NotificationPlugin\", \"Notification: \" + tag + \", \" + title + \", \" + body);\n                showNotification(tag, title, body);\n                result = new PluginResult(Status.OK);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \"\n                        + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else if (CLEAR.equals(action)){\n            try {\n                String tag = data.getString(0);\n                Log.d(\"NotificationPlugin\", \"Notification cancel: \" + tag);\n                clearNotification(tag);\n            } catch (JSONException jsonEx) {\n                Log.d(\"NotificationPlugin\", \"Got JSON Exception \" + jsonEx.getMessage());\n                result = new PluginResult(Status.JSON_EXCEPTION);\n            }\n        } else {\n            result = new PluginResult(Status.INVALID_ACTION);\n            Log.d(\"NotificationPlugin\", \"Invalid action : \"+action+\" passed\");\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1755,
    "type": "Return",
    "comment": "@return The id of the {@link BatchFileEntry}.",
    "code": "public String addChunk(String index, InputStream is, int chunkCount, int chunkIndex, String fileName, String mimeType, long fileSize) throws IOException {\n    BatchManager bm = Framework.getService(BatchManager.class);\n    Blob blob = Blobs.createBlob(is);\n    String fileEntryKey = key + STR + index;\n    BatchFileEntry fileEntry = getFileEntry(index);\n    if (fileEntry == null) {\n        fileEntry = new BatchFileEntry(fileEntryKey, chunkCount, fileName, mimeType, fileSize);\n        bm.getTransientStore().putParameters(fileEntryKey, fileEntry.getParams());\n        bm.getTransientStore().putParameter(key, index, fileEntryKey);\n    }\n    fileEntry.addChunk(chunkIndex, blob);\n    return fileEntryKey;\n}",
    "label": 1,
    "rec": "@return The key of the {@link BatchFileEntry}."
  },
  {
    "id": 1756,
    "type": "Return",
    "comment": "@return IO policy for the given cache.",
    "code": "    public byte ioPolicy() {\n        return plc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1757,
    "type": "Return",
    "comment": "@return Returns all methods in the same class which are setters",
    "code": "public Collection<MethodInfo> getSiblingSetters() {\n    return newArrayList(filter(classInfo.getSetters(), notSelf));\n}",
    "label": 1,
    "rec": "@return Returns all methods in the same class which are setters, other than this setter"
  },
  {
    "id": 1758,
    "type": "Return",
    "comment": "@return File id already stored in meta cache or  null if passed file info was stored.",
    "code": "    private IgniteUuid putIfAbsentNonTx(IgniteUuid parentId, String fileName, GridGgfsFileInfo newFileInfo)\n        throws GridException {\n        if (log.isDebugEnabled())\n            log.debug(\"Locking parent id [parentId=\" + parentId + \", fileName=\" + fileName + \", newFileInfo=\" +\n                newFileInfo + ']');\n\n        validTxState(true);\n\n        // Lock only parent file ID.\n        GridGgfsFileInfo parentInfo = info(parentId);\n\n        assert validTxState(true);\n\n        if (parentInfo == null)\n            throw new GridGgfsFileNotFoundException(\"Failed to lock parent directory (not found): \" + parentId);\n\n        if (!parentInfo.isDirectory())\n            throw new GridGgfsInvalidPathException(\"Parent file is not a directory: \" + parentInfo);\n\n        Map<String, GridGgfsListingEntry> parentListing = parentInfo.listing();\n\n        assert parentListing != null;\n\n        GridGgfsListingEntry entry = parentListing.get(fileName);\n\n        assert validTxState(true);\n\n        if (entry != null)\n            return entry.fileId();\n\n        IgniteUuid fileId = newFileInfo.id();\n\n        if (!id2InfoPrj.putxIfAbsent(fileId, newFileInfo))\n            throw new GridGgfsException(\"Failed to add file details into cache: \" + newFileInfo);\n\n        assert metaCache.get(parentId) != null;\n\n        id2InfoPrj.transform(parentId, new UpdateListing(fileName, new GridGgfsListingEntry(newFileInfo), false));\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1759,
    "type": "Return",
    "comment": "@return a dense matrix with user-user or item-item coefficients",
    "code": "\tprotected UpperSymmMetrix buildCorrs(boolean isUser) {\n\t\tLogs.debug(\"Build {} similarity matrix ...\", isUser ? \"user\" : \"item\");\n\n\t\tint numCount = isUser ? numUsers : numItems;\n\t\tUpperSymmMetrix corrs = new UpperSymmMetrix(numCount);\n\t\t\n\t\tfor (int i = 0; i < numCount; i++) {\n\t\t\tSparseVector iv = isUser ? MatrixUtils.row(trainMatrix, i) : MatrixUtils.col(trainMatrix, i);\n\t\t\tList<Integer> items = Lists.toList(iv.getIndex());\n\t\t\tif (items.size() == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = i + 1; j < numCount; j++) {\n\t\t\t\tSparseVector jv = isUser ? MatrixUtils.row(trainMatrix, j) : MatrixUtils.col(trainMatrix, j);\n\n\t\t\t\tdouble sim = compCorr(iv, jv, items);\n\n\t\t\t\tif (sim != 0.0)\n\t\t\t\t\tcorrs.set(i, j, sim);\n\t\t\t}\n\t\t}\n\n\t\treturn corrs;\n\t}\n",
    "label": 1,
    "rec": "@return a upper symmetric matrix with user-user or item-item coefficients"
  },
  {
    "id": 1760,
    "type": "Return",
    "comment": "@return Collection entries which will be fired.",
    "code": "        public Collection<CacheContinuousQueryEntry> collectEntries(CacheContinuousQueryEntry entry) {\n            assert entry != null;\n\n            if (entry.topologyVersion() == null) { // Possible if entry is sent from old node.\n                assert entry.updateCounter() == 0L : entry;\n\n                return F.asList(entry);\n            }\n\n            List<CacheContinuousQueryEntry> entries;\n\n            synchronized (pendingEvts) {\n                // Received first event.\n                if (curTop == AffinityTopologyVersion.NONE) {\n                    lastFiredEvt = entry.updateCounter();\n\n                    curTop = entry.topologyVersion();\n\n                    return F.asList(entry);\n                }\n\n                if (curTop.compareTo(entry.topologyVersion()) < 0) {\n                    if (entry.updateCounter() == 1L && !entry.isBackup()) {\n                        entries = new ArrayList<>(pendingEvts.size());\n\n                        for (CacheContinuousQueryEntry evt : pendingEvts.values()) {\n                            if (evt != HOLE && !evt.isFiltered())\n                                entries.add(evt);\n                        }\n\n                        pendingEvts.clear();\n\n                        curTop = entry.topologyVersion();\n\n                        lastFiredEvt = entry.updateCounter();\n\n                        entries.add(entry);\n\n                        return entries;\n                    }\n\n                    curTop = entry.topologyVersion();\n                }\n\n                // Check duplicate.\n                if (entry.updateCounter() > lastFiredEvt) {\n                    pendingEvts.put(entry.updateCounter(), entry);\n\n                    // Put filtered events.\n                    if (entry.filteredEvents() != null) {\n                        for (long cnrt : entry.filteredEvents()) {\n                            if (cnrt > lastFiredEvt)\n                                pendingEvts.put(cnrt, HOLE);\n                        }\n                    }\n                }\n                else {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Skip duplicate continuous query message: \" + entry);\n\n                    return Collections.emptyList();\n                }\n\n                if (pendingEvts.isEmpty())\n                    return Collections.emptyList();\n\n                Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pendingEvts.entrySet().iterator();\n\n                entries = new ArrayList<>();\n\n                if (pendingEvts.size() >= MAX_BUFF_SIZE) {\n                    for (int i = 0; i < MAX_BUFF_SIZE - (MAX_BUFF_SIZE / 10); i++) {\n                        Map.Entry<Long, CacheContinuousQueryEntry> e = iter.next();\n\n                        if (e.getValue() != HOLE && !e.getValue().isFiltered())\n                            entries.add(e.getValue());\n\n                        lastFiredEvt = e.getKey();\n\n                        iter.remove();\n                    }\n                }\n                else {\n                    // Elements are consistently.\n                    while (iter.hasNext()) {\n                        Map.Entry<Long, CacheContinuousQueryEntry> e = iter.next();\n\n                        if (e.getKey() == lastFiredEvt + 1) {\n                            ++lastFiredEvt;\n\n                            if (e.getValue() != HOLE && !e.getValue().isFiltered())\n                                entries.add(e.getValue());\n\n                            iter.remove();\n                        }\n                        else\n                            break;\n                    }\n                }\n            }\n\n            return entries;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1761,
    "type": "Return",
    "comment": "@return Map of javabean properties, associated to JMethod[getter,setter]",
    "code": "protected Collection<Property> lookupJavaBeanPropertyAccessors(JClassType type) {\n    Map<String, Property> properties = new HashMap<String, Property>();\n    JMethod[] methods = type.getMethods();\n    for (JMethod method : methods) {\n        if (!method.isPublic() || method.isStatic()) {\n            continue;\n        }\n        if (method.getName().startsWith(STR) && method.getParameters().length == NUM) {\n            String name = Introspector.decapitalize(method.getName().substring(NUM));\n            Property property = properties.get(name);\n            if (property == null) {\n                property = new Property(name);\n                properties.put(name, property);\n            }\n            property.setter = method;\n        } else if (method.getName().startsWith(STR) && method.getParameters().length == NUM) {\n            String name = Introspector.decapitalize(method.getName().substring(NUM));\n            Property property = properties.get(name);\n            if (property == null) {\n                property = new Property(name);\n                properties.put(name, property);\n            }\n            property.getter = method;\n        } else if (method.getName().startsWith(STR) && method.getParameters().length == NUM) {\n            String name = Introspector.decapitalize(method.getName().substring(NUM));\n            Property property = properties.get(name);\n            if (property == null) {\n                property = new Property(name);\n                properties.put(name, property);\n            }\n            property.getter = method;\n        }\n    }\n    return properties.values();\n}",
    "label": 1,
    "rec": "@return Collection of javabean properties"
  },
  {
    "id": 1762,
    "type": "Return",
    "comment": "@return Hash.",
    "code": "        static int hash(long ptr, GridUnsafeMemory mem) {\n            return mem.readInt(ptr + HEADER_HASH_OFF);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1763,
    "type": "Return",
    "comment": "@return index of first bit that is set, starting from the given index, or size if none are set",
    "code": "  public int getNextSet(int from) {\n    if (from >= size) {\n      return size;\n    }\n    int bitsOffset = from >> 5;\n    int currentBits = bits[bitsOffset];\n    // mask off lesser bits first\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    while (currentBits == 0) {\n      if (++bitsOffset == bits.length) {\n        return size;\n      }\n      currentBits = bits[bitsOffset];\n    }\n    int result = (bitsOffset << 5) + Integer.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  }\n",
    "label": 1,
    "rec": "@return index of first bit that is set, starting from the given index, or size if none are set at or beyond this given index"
  },
  {
    "id": 1764,
    "type": "Return",
    "comment": "@return Mode.",
    "code": "    private static Mode mode(Class<?> cls) {\n        assert cls != null;\n\n        if (cls == byte.class || cls == Byte.class)\n            return Mode.BYTE;\n        else if (cls == short.class || cls == Short.class)\n            return Mode.SHORT;\n        else if (cls == int.class || cls == Integer.class)\n            return Mode.INT;\n        else if (cls == long.class || cls == Long.class)\n            return Mode.LONG;\n        else if (cls == float.class || cls == Float.class)\n            return Mode.FLOAT;\n        else if (cls == double.class || cls == Double.class)\n            return Mode.DOUBLE;\n        else if (cls == char.class || cls == Character.class)\n            return Mode.CHAR;\n        else if (cls == boolean.class || cls == Boolean.class)\n            return Mode.BOOLEAN;\n        else if (cls == BigDecimal.class)\n            return Mode.DECIMAL;\n        else if (cls == String.class)\n            return Mode.STRING;\n        else if (cls == UUID.class)\n            return Mode.UUID;\n        else if (cls == Timestamp.class || cls == Date.class)\n            return Mode.DATE;\n        else if (cls == byte[].class)\n            return Mode.BYTE_ARR;\n        else if (cls == short[].class)\n            return Mode.SHORT_ARR;\n        else if (cls == int[].class)\n            return Mode.INT_ARR;\n        else if (cls == long[].class)\n            return Mode.LONG_ARR;\n        else if (cls == float[].class)\n            return Mode.FLOAT_ARR;\n        else if (cls == double[].class)\n            return Mode.DOUBLE_ARR;\n        else if (cls == char[].class)\n            return Mode.CHAR_ARR;\n        else if (cls == boolean[].class)\n            return Mode.BOOLEAN_ARR;\n        else if (cls == BigDecimal[].class)\n            return Mode.DECIMAL_ARR;\n        else if (cls == String[].class)\n            return Mode.STRING_ARR;\n        else if (cls == UUID[].class)\n            return Mode.UUID_ARR;\n        else if (cls == Date[].class)\n            return Mode.DATE_ARR;\n        else if (cls.isArray())\n            return cls.getComponentType().isEnum() ? Mode.ENUM_ARR : Mode.OBJ_ARR;\n        else if (cls == PortableObjectImpl.class)\n            return Mode.PORTABLE_OBJ;\n        else if (PortableMarshalAware.class.isAssignableFrom(cls))\n            return Mode.PORTABLE;\n        else if (Externalizable.class.isAssignableFrom(cls))\n            return Mode.EXTERNALIZABLE;\n        else if (Map.Entry.class.isAssignableFrom(cls))\n            return Mode.MAP_ENTRY;\n        else if (Collection.class.isAssignableFrom(cls))\n            return Mode.COL;\n        else if (Map.class.isAssignableFrom(cls))\n            return Mode.MAP;\n        else if (cls == PortableObjectImpl.class)\n            return Mode.PORTABLE_OBJ;\n        else if (cls.isEnum())\n            return Mode.ENUM;\n        else if (cls == Class.class)\n            return Mode.CLASS;\n        else\n            return Mode.OBJECT;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1765,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private static Frame reBalance(final Frame fr, long seed, boolean local, boolean force_load_balance, boolean shuffle_training_data) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 1766,
    "type": "Return",
    "comment": "@return Key cache object.",
    "code": "    protected KeyCacheObject toCacheKeyObject0(Object obj, boolean userObj) {\n        if (!userObj)\n            return new KeyCacheObjectImpl(obj, null);\n\n        return new UserKeyCacheObjectImpl(obj);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1767,
    "type": "Return",
    "comment": "@return true if the left position of the view is to the right of the twenty five percent of the parent width.",
    "code": "@Override\npublic boolean isNextToRightBound() {\n    return (getView().getRight() - getMarginRight()) > getParentView().getWidth() * NUM;\n}",
    "label": 1,
    "rec": "@return true if the right position of the view is to the right of the one hundred twenty five five percent of the parent view width."
  },
  {
    "id": 1768,
    "type": "Return",
    "comment": "@return true if all the values are ok to use; false otherwise.",
    "code": "  public boolean valid() {\n    return ((_systemIdleTicks >= 0) && (_systemTotalTicks >= 0) && (_processTotalTicks >= 0) &&\n            (_processNumOpenFds >= 0));\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1769,
    "type": "Return",
    "comment": "@return string The accuracy of the player with this weapon",
    "code": "public float getAccuracy() {\n    return this.accuracy;\n}",
    "label": 1,
    "rec": "@return The accuracy of the player with this weapon"
  },
  {
    "id": 1770,
    "type": "Return",
    "comment": "@return the weighting to be used for route calculation",
    "code": "    public Weighting createWeighting( String weightingStr, FlagEncoder encoder )\n    {\n        // ignore case\n        Weighting weighting;\n        weightingStr = weightingStr.toLowerCase();\n        if (\"fastest\".equals(weightingStr))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                weighting = new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                weighting = new FastestWeighting(encoder);\n        } else\n            weighting = new ShortestWeighting();\n\n        if (hasTurnCosts())\n            weighting = new TurnWeighting(weighting, encoder);\n\n        return weighting;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1771,
    "type": "Return",
    "comment": "@return The secondary storage cost, in bytes to be written and read.",
    "code": "public long getSecondaryStorageCost() {\n    return diskCost;\n}",
    "label": 1,
    "rec": "@return The disk cost, in bytes to be written and read."
  },
  {
    "id": 1772,
    "type": "Return",
    "comment": "@return Discovery event.",
    "code": "    public IgniteDiscoveryEvent discoveryEvent() {\n        return discoEvt;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1773,
    "type": "Return",
    "comment": "@return amount of money actually sent.",
    "code": "    public ListenableFuture<BigInteger> incrementPayment(BigInteger size) throws ValueOutOfRangeException, IllegalStateException {\n        lock.lock();\n        try {\n            if (state() == null || !connectionOpen || step != InitStep.CHANNEL_OPEN)\n                throw new IllegalStateException(\"Channel is not fully initialized/has already been closed\");\n            if (increasePaymentFuture != null)\n                throw new IllegalStateException(\"Already incrementing paying, wait for previous payment to complete.\");\n\n            PaymentChannelClientState.IncrementedPayment payment = state().incrementPaymentBy(size);\n            Protos.UpdatePayment.Builder updatePaymentBuilder = Protos.UpdatePayment.newBuilder()\n                    .setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()))\n                    .setClientChangeValue(state.getValueRefunded().longValue());\n\n            increasePaymentFuture = SettableFuture.create();\n            increasePaymentFuture.addListener(new Runnable() {\n                @Override\n                public void run() {\n                    lock.lock();\n                    increasePaymentFuture = null;\n                    lock.unlock();\n                }\n            }, MoreExecutors.sameThreadExecutor());\n\n            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()\n                    .setUpdatePayment(updatePaymentBuilder)\n                    .setType(Protos.TwoWayChannelMessage.MessageType.UPDATE_PAYMENT)\n                    .build());\n            lastPaymentActualAmount = payment.amount;\n            return increasePaymentFuture;\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@return a future that completes when the server acknowledges receipt and acceptance of the payment."
  },
  {
    "id": 1774,
    "type": "Return",
    "comment": "@return a prepared statement",
    "code": "    public PreparedStatement prepareQuery(String sql) throws SQLException {\n        Connection connection = connectionForReading();\n        if (connection == null) {\n            throw new SQLException(\"can't connect to source \" + url);\n        }\n        logger().debug(\"preparing statement with SQL {}\", sql);\n        int type =\n            \"TYPE_FORWARD_ONLY\".equals(context.getResultSetType()) ? ResultSet.TYPE_FORWARD_ONLY :\n            \"TYPE_SCROLL_SENSITIVE\".equals(context.getResultSetType()) ? ResultSet.TYPE_SCROLL_SENSITIVE :\n            \"TYPE_SCROLL_INSENSITIVE\".equals(context.getResultSetType()) ? ResultSet.TYPE_SCROLL_INSENSITIVE :\n                ResultSet.TYPE_FORWARD_ONLY;\n        int concurrency = \"CONCUR_READ_ONLY\".equals(context.getResultSetConcurrency()) ?\n                ResultSet.CONCUR_READ_ONLY : ResultSet.CONCUR_UPDATABLE;\n        return connection.prepareStatement(sql, type, concurrency);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1775,
    "type": "Return",
    "comment": "@return a byte array containing the line",
    "code": "public static int readLine(LineReader lineReader, Text out) throws IOException {\n    out.clear();\n    return lineReader.readLine(out);\n}",
    "label": 1,
    "rec": "@return number of bytes read"
  },
  {
    "id": 1776,
    "type": "Return",
    "comment": "@return Runnable that can be executed in a different thread with the same projection as for current thread.",
    "code": "    public Runnable projectSafe(final Runnable r) {\n        assert r != null;\n\n        // Have to get projection per call used by calling thread to use it in a new thread.\n        final CacheProjectionContext prj = projectionPerCall();\n\n        if (prj == null)\n            return r;\n\n        return new GPR() {\n            @Override public void run() {\n                CacheProjectionContext oldPrj = projectionPerCall();\n\n                projectionPerCall(prj);\n\n                try {\n                    r.run();\n                }\n                finally {\n                    projectionPerCall(oldPrj);\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1777,
    "type": "Return",
    "comment": "@return  True if active.",
    "code": "    private Set<ClusterNode> activated() {\n        Set<ClusterNode> activatedNodes;\n\n        Snapshot snapshot = topSnap.get();\n\n        if (snapshot.topVer.equals(AffinityTopologyVersion.ZERO))\n            activatedNodes = new HashSet<>(discoveredActivatedNodes);\n        else {\n            assert snapshot.discoCache != null;\n\n            activatedNodes = new HashSet<>(snapshot.discoCache.activatedNodes);\n        }\n\n        return activatedNodes;\n    }\n",
    "label": 1,
    "rec": "@return Activated nodes for latest topology version."
  },
  {
    "id": 1778,
    "type": "Return",
    "comment": "@return Page ID.",
    "code": "    public FullPageId take(BPlusTree<?,?> client, ReuseBag bag) throws IgniteCheckedException {\n        if (trees == null)\n            return null;\n\n        ReuseTree tree = tree(client);\n\n        // Remove and return page at min possible position.\n        FullPageId res = tree.removeCeil(MIN, bag);\n\n        assert res != null || tree.size() == 0; // TODO remove\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1779,
    "type": "Return",
    "comment": "@return The log likelihood of the correct answer as estimated by the current model. This will always be <= 0 and larger (closer to 0) indicates better accuracy. In order to simplify code that maintains running averages, we bound this value at -100.",
    "code": "public double logLikelihood(int actual, Vector data) {\n    if (numCategories() == NUM) {\n        double p = classifyScalar(data);\n        if (actual > NUM) {\n            return Math.max(MIN_LOG_LIKELIHOOD, Math.log(p));\n        } else {\n            return Math.max(MIN_LOG_LIKELIHOOD, Math.log1p(-p));\n        }\n    } else {\n        Vector p = classify(data);\n        if (actual > NUM) {\n            return Math.max(MIN_LOG_LIKELIHOOD, Math.log(p.get(actual - NUM)));\n        } else {\n            return Math.max(MIN_LOG_LIKELIHOOD, Math.log1p(-p.zSum()));\n        }\n    }\n}",
    "label": 1,
    "rec": "@return The log likelihood of the correct answer as estimated by the current model. This will always be <= 0 and larger (closer to 0) indicates better accuracy. In order to simplify code that maintains eunning averages, we bound this value at -100."
  },
  {
    "id": 1780,
    "type": "Return",
    "comment": "@return issue or null if not in store",
    "code": "    public Issue getIssue(Repo repository, int number) {\n        ItemReferences<Issue> repoIssues = repos.get(InfoUtils.createRepoId(repository));\n        return repoIssues != null ? repoIssues.get(number) : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1781,
    "type": "Return",
    "comment": "@return text encoded within the QR Code",
    "code": "  public DecoderResult decode(BitMatrix bits) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion();\n    ErrorCorrectionLevel ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    String text = DecodedBitStreamParser.decode(resultBytes, version);\n    return new DecoderResult(resultBytes, text);\n  }\n",
    "label": 1,
    "rec": "@return text and bytes encoded within the QR Code"
  },
  {
    "id": 1782,
    "type": "Return",
    "comment": "@return Previous value.",
    "code": "    @Nullable public V getAndPut(final K key, final V val, @Nullable final CacheEntryPredicate filter)\n        throws IgniteCheckedException\n    {\n        boolean statsEnabled = ctx.config().isStatisticsEnabled();\n\n        long start = statsEnabled ? System.nanoTime() : 0L;\n\n        A.notNull(key, \"key\", val, \"val\");\n\n        if (keyCheck)\n            validateCacheKey(key);\n\n        V prevVal = syncOp(new SyncOp<V>(true) {\n            @Override public V op(IgniteTxLocalAdapter tx) throws IgniteCheckedException {\n                return (V)tx.putAsync(ctx, null, key, val, true, filter).get().value();\n            }\n\n            @Override public String toString() {\n                return \"put [key=\" + key + \", val=\" + val + \", filter=\" + filter + ']';\n            }\n        });\n\n        if (statsEnabled)\n            metrics0().addPutAndGetTimeNanos(System.nanoTime() - start);\n\n        return prevVal;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1783,
    "type": "Return",
    "comment": "@return the property value, as an object.",
    "code": "public static final String getProperty(String s) {\n    String rval = System.getProperty(s);\n    if (rval == null)\n        rval = localProperties.getProperty(s);\n    return rval;\n}",
    "label": 1,
    "rec": "@return the property value, as a string."
  },
  {
    "id": 1784,
    "type": "Return",
    "comment": "@return batch size",
    "code": "    public int getShardSizePercentile(double percentile) {\n        return 0;\n        //return rollingCollapserUsageDistributionStream.getLatestBatchSizePercentile(percentile);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1785,
    "type": "Return",
    "comment": "@return The address read",
    "code": "@Processor\n@InvalidateConnectionOn(exception = NotAuthenticatedException.class)\npublic Address readAddress(String objectId) {\n    return (Address) read(ServiceSourceCollection.Addresses, objectId);\n}",
    "label": 1,
    "rec": "@return an instance of {@link org.mule.module.servicesource.model.Address}"
  },
  {
    "id": 1786,
    "type": "Return",
    "comment": "@return balance",
    "code": "\tpublic static double getMoney(String name) throws UserDoesNotExistException\n\t{\n\t\tUser user = getUserByName(name);\n\t\tif (user == null)\n\t\t{\n\t\t\tthrow new UserDoesNotExistException(name);\n\t\t}\n\t\treturn user.getMoney().doubleValue();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1787,
    "type": "Return",
    "comment": "@return priceSMA console",
    "code": "public InputPort<Object> getConsole(String name, String nodeName, DAG dag) {\n    String serverAddr = System.getenv(STR);\n    if (serverAddr != null) {\n        HttpOutputOperator<Object> oper = dag.addOperator(name, new HttpOutputOperator<Object>());\n        oper.setResourceURL(URI.create(STR + serverAddr + STR + nodeName));\n        return oper.input;\n    }\n    ConsoleOutputOperator oper = dag.addOperator(name, ConsoleOutputOperator.class);\n    return oper.input;\n}",
    "label": 1,
    "rec": "@return console input port"
  },
  {
    "id": 1788,
    "type": "Return",
    "comment": "@return null if group already exists. or new Group",
    "code": "    public Group createGroup(String groupName) {\n    \tif (groupName.startsWith(\"g:\")) {\n        \tGroup newGroup = new Group(groupName);\n        \treturn GroupManager.getGlobalGroups().addGroup(newGroup);\n        }\n    \t\n    \tif (this.groups.containsKey(groupName.toLowerCase())) {\n            return null;\n        }\n        \n    \tGroup newGroup = new Group(this, groupName);\n        this.addGroup(newGroup);\n        haveGroupsChanged = true;\n        return newGroup;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1789,
    "type": "Return",
    "comment": "@return  Repository or null if unparseable",
    "code": "    public static Repo getRepository(Uri uri) {\n        List<String> segments = uri.getPathSegments();\n        if (segments == null)\n            return null;\n        if (segments.size() < 2)\n            return null;\n\n        String repoOwner = segments.get(0);\n        if (!RepositoryUtils.isValidOwner(repoOwner))\n            return null;\n\n        String repoName = segments.get(1);\n        if (!RepositoryUtils.isValidRepo(repoName))\n            return null;\n\n        Repo repository = new Repo();\n        User owner = new User();\n        owner.login = repoOwner;\n        repository.name = repoName;\n        repository.owner = owner;\n        return repository;\n    }\n",
    "label": 1,
    "rec": "@return  Repo or null if unparseable"
  },
  {
    "id": 1790,
    "type": "Return",
    "comment": "@return an options map, or null if camera was not opened",
    "code": "    public CameraOptions getCameraOptions() {\n        return mCameraEngine.getCameraOptions();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1791,
    "type": "Return",
    "comment": "@return PointcutType of expression (or null)",
    "code": "private Set determineTypeFromAST() {\n    return (Set) root.jjtAccept(TYPE_VISITOR, m_namespace);\n}",
    "label": 1,
    "rec": "@return Set of PointcutType of expression"
  },
  {
    "id": 1792,
    "type": "Return",
    "comment": "@return Value of result.",
    "code": "    protected R result() {\n        return (R)res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1793,
    "type": "Return",
    "comment": "@return a {@link LifecycleScopeProvider} against this view.",
    "code": "public static ScopeProvider from(View view) {\n    if (view == null) {\n        throw new NullPointerException(STR);\n    }\n    return new ViewScopeProvider(view);\n}",
    "label": 1,
    "rec": "@return a {@link ScopeProvider} against this view."
  },
  {
    "id": 1794,
    "type": "Return",
    "comment": "@return the transform matrix",
    "code": "    public float[] getTransform() {\n        return mTextureDrawer.getTextureTransform();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1795,
    "type": "Return",
    "comment": "@return reference to the result stream, or null of only a writer was set.",
    "code": "public OutputStream getOutputStream() throws StreamException {\n    if (outputStream != null) {\n        closeStartTag();\n        flushBuffer();\n        return outputStream;\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return the output stream, or {@code null} if this serializer is not writing to an output stream (but to a {@link Writer} e.g.)"
  },
  {
    "id": 1796,
    "type": "Return",
    "comment": "@return Registered transaction synchronizations",
    "code": "    public Collection<IgniteTxSynchronization> synchronizations() {\n        return Collections.unmodifiableList(new LinkedList<>(syncs));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1797,
    "type": "Return",
    "comment": "@return Message object that contains only the filtered fields from {@code msg}. If all fields are filtered (none discarded), returns the same {@code msg} object. If no fields are filtered (all discarded), returns {@code null} or a default instance of {@code msg}'s message type depending on the value of {@code clearEmpty}",
    "code": "@Nullable\npublic static <M extends Message> M filter(M msg, boolean clearEmpty, Predicate<FieldDescriptor> predicate) {\n    int i = NUM;\n    for (Map.Entry<FieldDescriptor, Object> entry : msg.getAllFields().entrySet()) {\n        FieldDescriptor fd = entry.getKey();\n        if (!predicate.apply(fd)) {\n            return filterFrom(msg, clearEmpty, predicate, i);\n        }\n        ++i;\n    }\n    return msg;\n}",
    "label": 1,
    "rec": "@return Message with the retained fieldsfrom {@code msg}. If some fields are retained and others discarded, returns a new message object. If all fields are retained, returns the same {@code msg} object. If all fields are discarded, returns {@code null} if {@code clearEmpty==true} or a default instance of {@code msg}'s message type if {@code clearEmpty==false}"
  },
  {
    "id": 1798,
    "type": "Return",
    "comment": "@return Node.",
    "code": "    private ClusterNode randomNode(Random rnd) {\n        int idx = rnd.nextInt(nodes.size());\n\n        return nodes.get(idx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1799,
    "type": "Return",
    "comment": "@return Observable that never emits onNexts.",
    "code": "    public Observable<RxBleConnectionState> getOnConnectionStateChange() {\n        return connectionStatePublishSubject;\n    }\n",
    "label": 1,
    "rec": "@return Observable that emits RxBleConnectionState that matches BluetoothGatt's state. Does NOT emit errors even if status != GATT_SUCCESS."
  },
  {
    "id": 1800,
    "type": "Return",
    "comment": "@return tag statistics",
    "code": "    public ClickStatistics searchTag(Long id) {\n        if (CommonUtils.notEmpty(id)) {\n            ClickStatistics clickStatistics = tagCache.get(id);\n            if (null == clickStatistics) {\n                clickStatistics = new ClickStatistics(id, null, 1, 0, null);\n            } else {\n                clickStatistics.addClicks();\n            }\n            List<ClickStatistics> list = tagCache.put(id, clickStatistics);\n            if (CommonUtils.notEmpty(list)) {\n                tagService.updateStatistics(list);\n            }\n            return clickStatistics;\n        } else {\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1801,
    "type": "Return",
    "comment": "@return Afinity key.",
    "code": "        public Object key(boolean useColocatedData) {\n            return useColocatedData ? new AffinityKey<>(id, refOrderId) : id;\n        }\n",
    "label": 1,
    "rec": "@return Key."
  },
  {
    "id": 1802,
    "type": "Return",
    "comment": "@return  True if synchronoous preloading.",
    "code": "    private boolean isSync(IgniteCache<?, ?> c) {\n        return c.getConfiguration(CacheConfiguration.class).getRebalanceMode() == SYNC;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1803,
    "type": "Return",
    "comment": "@return a resolved {@link Maybe} representation of a given provider",
    "code": "public static <E> CompletableSource resolveScopeFromLifecycle(final LifecycleScopeProvider<E> provider, final boolean checkEndBoundary) throws OutsideScopeException {\n    E lastEvent = provider.peekLifecycle();\n    CorrespondingEventsFunction<E> eventsFunction = provider.correspondingEvents();\n    if (lastEvent == null) {\n        throw new LifecycleNotStartedException();\n    }\n    E endEvent;\n    try {\n        endEvent = eventsFunction.apply(lastEvent);\n    } catch (Exception e) {\n        if (checkEndBoundary && e instanceof LifecycleEndedException) {\n            Consumer<? super OutsideScopeException> handler = AutoDisposePlugins.getOutsideScopeHandler();\n            if (handler != null) {\n                try {\n                    handler.accept((LifecycleEndedException) e);\n                    return Completable.complete();\n                } catch (Exception e1) {\n                    return Completable.error(e1);\n                }\n            }\n            throw e;\n        }\n        return Completable.error(e);\n    }\n    return resolveScopeFromLifecycle(provider.lifecycle(), endEvent);\n}",
    "label": 1,
    "rec": "@return a resolved {@link CompletableSource} representation of a given provider"
  },
  {
    "id": 1804,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String show(Long id, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysSite site = getSite(request);\n        CmsWord entity = service.getEntity(id);\n        if (null != entity) {\n            if (ControllerUtils.verifyNotEquals(\"siteId\", site.getId(), entity.getSiteId(), model)) {\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n            service.updateStatus(id, false);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"show.word\", RequestUtils.getIpAddress(request), CommonUtils.getDate(),\n                    JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1805,
    "type": "Return",
    "comment": "@return value in case property value is set and field is readable. If null or not readable (transient, static), return s null.",
    "code": "public Object getValue(Object object) {\n    return propagation.getValue(object);\n}",
    "label": 1,
    "rec": "@return property's value"
  },
  {
    "id": 1806,
    "type": "Return",
    "comment": "@return boolean indicating if the camera is recording a video",
    "code": "    public boolean isTakingVideo() {\n        return mCameraEngine.isTakingVideo();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1807,
    "type": "Return",
    "comment": "@return the height of the best chain as claimed by peer.",
    "code": "public long getBestHeight() {\n    return peerVersionMessage.bestHeight + blocksAnnounced;\n}",
    "label": 1,
    "rec": "@return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since."
  },
  {
    "id": 1808,
    "type": "Return",
    "comment": "@return  True if 'fast finish' path can be used for transaction completion.",
    "code": "    private boolean fastFinish() {\n        return writeMap().isEmpty() && ((optimistic() && !serializable()) || readMap().isEmpty());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1809,
    "type": "Return",
    "comment": "@return Array of {@link BasicPHPWizardPageExtended} pages, or <code>null</code> if no pages where contributed.",
    "code": "public static IWizardPage[] getPages(String id) {\n    final List elementsList = (List) instance.pages.get(id);\n    if (elementsList != null) {\n        final List pagesList = new LinkedList();\n        SafeRunner.run(new SafeRunnable(STR + EXTENSION_POINT) {\n\n            public void run() throws Exception {\n                Iterator i = elementsList.iterator();\n                while (i.hasNext()) {\n                    IConfigurationElement element = (IConfigurationElement) i.next();\n                    pagesList.add(element.createExecutableExtension(CLASS_ATTRIBUTE));\n                }\n            }\n        });\n        return (IWizardPage[]) pagesList.toArray(new IWizardPage[pagesList.size()]);\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return Array of {@link IWizardPage} pages, or <code>null</code> if no pages where contributed."
  },
  {
    "id": 1810,
    "type": "Return",
    "comment": "@return see description",
    "code": "    private ParsedCodeContext samlIdpInitiatedSSO(final String clientUrlName) {\n        event.event(EventType.LOGIN);\n        CacheControlUtil.noBackButtonCacheControlHeader();\n        Optional<ClientModel> oClient = this.realmModel.getClients().stream()\n          .filter(c -> Objects.equals(c.getAttribute(SamlProtocol.SAML_IDP_INITIATED_SSO_URL_NAME), clientUrlName))\n          .findFirst();\n\n        if (! oClient.isPresent()) {\n            event.error(Errors.CLIENT_NOT_FOUND);\n            return ParsedCodeContext.response(redirectToErrorPage(Response.Status.BAD_REQUEST, Messages.CLIENT_NOT_FOUND));\n        }\n\n        LoginProtocolFactory factory = (LoginProtocolFactory) session.getKeycloakSessionFactory().getProviderFactory(LoginProtocol.class, SamlProtocol.LOGIN_PROTOCOL);\n        SamlService samlService = (SamlService) factory.createProtocolEndpoint(realmModel, event);\n        ResteasyProviderFactory.getInstance().injectProperties(samlService);\n        AuthenticationSessionModel authSession = samlService.getOrCreateLoginSessionForIdpInitiatedSso(session, realmModel, oClient.get(), null);\n        if (authSession == null) {\n            event.error(Errors.INVALID_REDIRECT_URI);\n            return ParsedCodeContext.response(redirectToErrorPage(Response.Status.BAD_REQUEST, Messages.INVALID_REDIRECT_URI));\n        }\n\n        return ParsedCodeContext.clientSessionCode(new ClientSessionCode<>(session, this.realmModel, authSession));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1811,
    "type": "Return",
    "comment": "@return a {@link KeyManager} for the given {@code typeUrl} (if found). <p>TODO(przydatek): find a way for verifying the primitive type.",
    "code": "public static <P> KeyManager<P> getKeyManager(String typeUrl) throws GeneralSecurityException {\n    return getKeyManagerInternal(typeUrl, null);\n}",
    "label": 1,
    "rec": "@return a {@link KeyManager} for the given {@code typeUrl} (if found)."
  },
  {
    "id": 1812,
    "type": "Return",
    "comment": "@return Task future.",
    "code": "    ComputeTaskInternalFuture<R> getTaskFuture() {\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1813,
    "type": "Return",
    "comment": "@return the result from the previous invocation",
    "code": "public Object proceed() throws Throwable {\n    return m_controller.proceed(this);\n}",
    "label": 1,
    "rec": "@return the result from the next invocation"
  },
  {
    "id": 1814,
    "type": "Return",
    "comment": "@return valid token on success, null on failure",
    "code": "    public static String validateAuthToken(Context c, String token) throws GoogleTasksException {\n        GoogleAccountManager accountManager = new GoogleAccountManager(ContextManager.getContext());\n\n        GtasksService testService = new GtasksService(token);\n        try {\n            testService.ping();\n            return token;\n        } catch (IOException i) { //If fail, token may have expired -- get a new one and return that\n            String accountName = Preferences.getStringValue(GtasksPreferenceService.PREF_USER_NAME);\n            Account a = accountManager.getAccountByName(accountName);\n            if (a == null) {\n                throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountNotFound, accountName));\n            }\n\n            accountManager.invalidateAuthToken(token);\n            AccountManagerFuture<Bundle> future = accountManager.manager.getAuthToken(a, GtasksService.AUTH_TOKEN_TYPE, false, null, null);\n\n            try {\n                if (future.getResult().containsKey(AccountManager.KEY_AUTHTOKEN)) {\n                    Bundle result = future.getResult();\n                    token = result.getString(AccountManager.KEY_AUTHTOKEN);\n                    testService = new GtasksService(token);\n                    try { //Make sure the new token works--if not, we may have network problems\n                        testService.ping();\n                        return token;\n                    } catch (IOException i2) {\n                        i2.printStackTrace();\n                        String manufacturer = android.os.Build.MANUFACTURER.toLowerCase();\n                        if (!manufacturer.contains(\"samsung\")) { // Try with the notifyAuthFailure set to true in case it was that that broke things\n                            accountManager.invalidateAuthToken(token);\n                            future = accountManager.manager.getAuthToken(a, GtasksService.AUTH_TOKEN_TYPE, true, null, null);\n                            try {\n                                if (future.getResult().containsKey(AccountManager.KEY_AUTHTOKEN)) {\n                                    result = future.getResult();\n                                    token = result.getString(AccountManager.KEY_AUTHTOKEN);\n                                    testService = new GtasksService(token);\n                                    try {\n                                        testService.ping();\n                                        return token;\n                                    } catch (IOException i3) {\n                                        i3.printStackTrace();\n                                        throw new GoogleTasksException(c.getString(R.string.gtasks_error_authRefresh));\n                                    }\n                                } else {\n                                    throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountManager));\n                                }\n                            } catch (Exception e) {\n                                throw new GoogleTasksException(e.getLocalizedMessage());\n                            }\n                        } else {\n                            throw new GoogleTasksException(c.getString(R.string.gtasks_error_authRefresh));\n                        }\n                    }\n                } else {\n                    throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountManager));\n                }\n            } catch (Exception e) {\n                throw new GoogleTasksException(e.getLocalizedMessage());\n            }\n\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1815,
    "type": "Return",
    "comment": "@return TreePath of the current mouse location",
    "code": "public DefaultMutableTreeNode getCurrentPath() {\n    DefaultMutableTreeNode node;\n    node = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();\n    if (!node.isLeaf()) {\n        node = null;\n    }\n    return node;\n}",
    "label": 1,
    "rec": "@return the selected leaf node"
  },
  {
    "id": 1816,
    "type": "Return",
    "comment": "@return the new trimmed array",
    "code": "  private static int[] trimArray(int[] array, int size) {\n    if (size < 0) {\n      throw new IllegalArgumentException();\n    }\n    if (size == 0) {\n      return NO_ERRORS;\n    }\n    int[] a = new int[size];\n    System.arraycopy(array, 0, a, 0, size);\n    return a;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1817,
    "type": "Return",
    "comment": "@return the service URL that is being used",
    "code": "public String getServiceUrl() {\n    return serviceUrl;\n}",
    "label": 1,
    "rec": "@return the service HTTP URL that is being used"
  },
  {
    "id": 1818,
    "type": "Return",
    "comment": "@return Affinity.",
    "code": "    private AffinityFunction affinity(GridCache<Integer, ?> cache) {\n        return cache.configuration().getAffinity();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1819,
    "type": "Return",
    "comment": "@return the number of metrics in the collection after this operation completes",
    "code": "public synchronized int append(IMetric... metrics) {\n    for (IMetric metric : metrics) {\n        _append(metric);\n    }\n    return size;\n}",
    "label": 1,
    "rec": "@return the number of bytes in the collection after this operation completes"
  },
  {
    "id": 1820,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    private CacheConfiguration cacheConfiguration() {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setCacheMode(PARTITIONED);\n        cfg.setBackups(1);\n        cfg.setAtomicityMode(TRANSACTIONAL);\n        cfg.setDistributionMode(NEAR_PARTITIONED);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1821,
    "type": "Return",
    "comment": "@return a printable, displayable, portable, transmittable representation of the object, beginning with <code>{</code> &nbsp;<small>(left brace)</small> and ending with <code>}</code>&nbsp;<small>(right brace)</small>.",
    "code": "public String toString() {\n    return STR;\n}",
    "label": 1,
    "rec": "@return The string \"null\"."
  },
  {
    "id": 1822,
    "type": "Return",
    "comment": "@return the new  State in accordance to  dataType. Will never be  null.",
    "code": "\tprivate State createState(Object propertyValue) {\n\t\tif(propertyValue == null) {\n\t\t\treturn UnDefType.NULL;\n\t\t}\n\n\t\tClass<?> dataType = propertyValue.getClass();\n\n\t\tif (Date.class.isAssignableFrom(dataType)) {\n\t\t\tCalendar calendar = Calendar.getInstance();\n\t\t\tcalendar.setTime((Date) propertyValue);\n\t\t\treturn new DateTimeType(calendar);\n\t\t} else if (BigDecimal.class.isAssignableFrom(dataType)) {\n\t\t\treturn new DecimalType((BigDecimal) propertyValue);\n\t\t} else if (Boolean.class.isAssignableFrom(dataType)) {\n\t\t\tif((Boolean) propertyValue) {\n\t\t\t\treturn OnOffType.ON;\n\t\t\t} else {\n\t\t\t\treturn OnOffType.OFF;\n\t\t\t}\n\t\t} else {\n\t\t\treturn new StringType(propertyValue.toString());\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1823,
    "type": "Return",
    "comment": "@return an immutable {@code Set} instance containing those elements, minus duplicates",
    "code": "@GwtCompatible(serializable = false)\npublic static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(E anElement, E... otherElements) {\n    return new ImmutableSet.ImmutableEnumSet<E>(EnumSet.of(anElement, otherElements));\n}",
    "label": 1,
    "rec": "@return an immutable set containing those elements, minus duplicates"
  },
  {
    "id": 1824,
    "type": "Return",
    "comment": "@return New message.",
    "code": "    private static GridTcpCommunicationMessageAdapter create0(byte type) {\n        switch (type) {\n            case 0:\n                return new GridJobCancelRequest();\n\n            case 1:\n                return new GridJobExecuteRequest();\n\n            case 2:\n                return new GridJobExecuteResponse();\n\n            case 3:\n                return new GridJobSiblingsRequest();\n\n            case 4:\n                return new GridJobSiblingsResponse();\n\n            case 5:\n                return new GridTaskCancelRequest();\n\n            case 6:\n                return new GridTaskSessionRequest();\n\n            case 7:\n                return new GridCheckpointRequest();\n\n            case 8:\n                return new GridIoMessage();\n\n            case 9:\n                return new GridIoUserMessage();\n\n            case 10:\n                return new GridDeploymentInfoBean();\n\n            case 11:\n                return new GridDeploymentRequest();\n\n            case 12:\n                return new GridDeploymentResponse();\n\n            case 13:\n                return new GridEventStorageMessage();\n\n            case 14:\n                return new GridCacheDgcRequest();\n\n            case 15:\n                return new GridCacheDgcResponse();\n\n            case 16:\n                return new GridCacheEvictionRequest();\n\n            case 17:\n                return new GridCacheEvictionResponse();\n\n            case 18:\n                return new GridCacheOptimisticCheckPreparedTxRequest();\n\n            case 19:\n                return new GridCacheOptimisticCheckPreparedTxResponse();\n\n            case 20:\n                return new GridCachePessimisticCheckCommittedTxRequest();\n\n            case 21:\n                return new GridCachePessimisticCheckCommittedTxResponse();\n\n            case 22:\n                return new GridDistributedLockRequest();\n\n            case 23:\n                return new GridDistributedLockResponse();\n\n            case 24:\n                return new GridDistributedTxFinishRequest();\n\n            case 25:\n                return new GridDistributedTxFinishResponse();\n\n            case 26:\n                return new GridDistributedTxPrepareRequest();\n\n            case 27:\n                return new GridDistributedTxPrepareResponse();\n\n            case 28:\n                return new GridDistributedUnlockRequest();\n\n            case 29:\n                return new GridDhtLockRequest();\n\n            case 30:\n                return new GridDhtLockResponse();\n\n            case 31:\n                return new GridDhtTxFinishRequest();\n\n            case 32:\n                return new GridDhtTxFinishResponse();\n\n            case 33:\n                return new GridDhtTxPrepareRequest();\n\n            case 34:\n                return new GridDhtTxPrepareResponse();\n\n            case 35:\n                return new GridDhtUnlockRequest();\n\n            case 36:\n                return new GridDhtAtomicDeferredUpdateResponse();\n\n            case 37:\n                return new GridDhtAtomicUpdateRequest();\n\n            case 38:\n                return new GridDhtAtomicUpdateResponse();\n\n            case 39:\n                return new GridNearAtomicUpdateRequest();\n\n            case 40:\n                return new GridNearAtomicUpdateResponse();\n\n            case 41:\n                return new GridDhtForceKeysRequest();\n\n            case 42:\n                return new GridDhtForceKeysResponse();\n\n            case 43:\n                return new GridDhtPartitionDemandMessage();\n\n            case 44:\n                return new GridDhtPartitionSupplyMessage();\n\n            case 45:\n                return new GridDhtPartitionsFullMessage();\n\n            case 46:\n                return new GridDhtPartitionsSingleMessage();\n\n            case 47:\n                return new GridDhtPartitionsSingleRequest();\n\n            case 48:\n                return new GridNearGetRequest();\n\n            case 49:\n                return new GridNearGetResponse();\n\n            case 50:\n                return new GridNearLockRequest();\n\n            case 51:\n                return new GridNearLockResponse();\n\n            case 52:\n                return new GridNearTxFinishRequest();\n\n            case 53:\n                return new GridNearTxFinishResponse();\n\n            case 54:\n                return new GridNearTxPrepareRequest();\n\n            case 55:\n                return new GridNearTxPrepareResponse();\n\n            case 56:\n                return new GridNearUnlockRequest();\n\n            case 57:\n                return new GridCacheQueryRequest();\n\n            case 58:\n                return new GridCacheQueryResponse();\n\n            case 59:\n                return new GridClockDeltaSnapshotMessage();\n\n            case 60:\n                return new GridContinuousMessage();\n\n            case 61:\n                return new GridDataLoadRequest();\n\n            case 62:\n                return new GridDataLoadResponse();\n\n            case 63:\n                return new GridDrInternalRequest();\n\n            case 64:\n                return new GridDrInternalResponse();\n\n            case 65:\n                return new GridGgfsAckMessage();\n\n            case 66:\n                return new GridGgfsBlockKey();\n\n            case 67:\n                return new GridGgfsBlocksMessage();\n\n            case 68:\n                return new GridGgfsDeleteMessage();\n\n            case 69:\n                return new GridGgfsFileAffinityRange();\n\n            case 70:\n                return new GridGgfsFragmentizerRequest();\n\n            case 71:\n                return new GridGgfsFragmentizerResponse();\n\n            case 72:\n                return new GridGgfsSyncMessage();\n\n            case 73:\n                return new GridTaskResultRequest();\n\n            case 74:\n                return new GridTaskResultResponse();\n\n            case 75:\n                return new GridStreamerCancelRequest();\n\n            case 76:\n                return new GridStreamerExecutionRequest();\n\n            case 77:\n                return new GridStreamerResponse();\n\n            case 78:\n                return new GridJobStealingRequest();\n\n            case 79:\n                return new GridDhtAffinityAssignmentRequest<>();\n\n            case 80:\n                return new GridDhtAffinityAssignmentResponse<>();\n\n            default:\n                return createCustom(type);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1825,
    "type": "Return",
    "comment": "@return the mesos implementation instance",
    "code": "public static synchronized Mesos getInstance(MesosCloud key) {\n    if (!clouds.containsKey(key)) {\n        clouds.put(key, new MesosImpl());\n    }\n    return clouds.get(key);\n}",
    "label": 1,
    "rec": "@return the mesos implementation instance for the cloud instances (since there might be more than one"
  },
  {
    "id": 1826,
    "type": "Return",
    "comment": "@return True if the clusters are congruent (equal number of partitions, equal number of nodes and same partition ids",
    "code": "    private boolean areTwoClustersEqual(final Cluster lhs, final Cluster rhs) {\n        // There is no way for us to support pushing to multiple clusters with\n        // different numbers of partitions from a single BnP job.\n        if (lhs.getNumberOfPartitions() != rhs.getNumberOfPartitions())\n            return false;\n\n        if (buildPrimaryReplicasOnly) {\n            // In 'build.primary.replicas.only' mode, we can support pushing to\n            // clusters with different number of nodes and different partition\n            // assignments.\n            return true;\n        }\n\n        // Otherwise, we need every corresponding node in each cluster to be identical.\n        if (!lhs.getNodeIds().equals(rhs.getNodeIds()))\n            return false;\n        for (Node lhsNode: lhs.getNodes()) {\n            Node rhsNode = rhs.getNodeById(lhsNode.getId());\n            if (!rhsNode.getPartitionIds().equals(lhsNode.getPartitionIds())) {\n                return false;\n            }\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1827,
    "type": "Return",
    "comment": "@return Integer reply, \"0\" if the key exists, otherwise \"1\"",
    "code": "    public Boolean exists(final byte[] key) {\n        checkIsInMulti();\n        client.exists(key);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 1,
    "rec": "@return Integer reply, \"1\" if the key exists, otherwise \"0\""
  },
  {
    "id": 1828,
    "type": "Return",
    "comment": "@return Affinity info for current topology version.",
    "code": "        private AffinityInfo cache() throws IgniteCheckedException {\n            return affinityCache(cacheName, new AffinityTopologyVersion(topologyVersion()));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1829,
    "type": "Return",
    "comment": "@return The {@see WorkbenchModule}referenced by aModuleURI",
    "code": "public WorkbenchComponent findWorkbenchModuleByModuleURI(URI aModuleURI) throws UnresolveableURIException {\n    ModuleURIUtil.ensureValidFullyQualifiedModuleURI(aModuleURI);\n    String projectName = aModuleURI.segment(ModuleURIUtil.ModuleURI.PROJECT_NAME_INDX);\n    String moduleName = aModuleURI.segment(ModuleURIUtil.ModuleURI.MODULE_NAME_INDX);\n    if (structuralModel.getProject().getName().equals(projectName)) {\n        return findWorkbenchModuleByDeployName(moduleName);\n    }\n    return getDependentModuleCore(aModuleURI).findWorkbenchModuleByDeployName(moduleName);\n}",
    "label": 1,
    "rec": "@return The {@see WorkbenchComponent}referenced by aModuleURI"
  },
  {
    "id": 1830,
    "type": "Return",
    "comment": "@return Started grid.",
    "code": "    public static Ignite start() throws IgniteCheckedException {\n        return IgnitionEx.start();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1831,
    "type": "Return",
    "comment": "@return Old value of the field, if any; null if there was no old value.",
    "code": "public ArrayNode set(int index, JsonNode value) {\n    if (value == null) {\n        value = nullNode();\n    }\n    if (index < NUM || index >= _children.size()) {\n        throw new IndexOutOfBoundsException(STR + index + STR + size());\n    }\n    _children.set(index, value);\n    return this;\n}",
    "label": 1,
    "rec": "@return This node after adding/replacing property value (to allow chaining)"
  },
  {
    "id": 1832,
    "type": "Return",
    "comment": "@return  True if cross-cache transaction can include this new cache.",
    "code": "    public boolean txCompatible(IgniteInternalTx<K, V> tx, Iterable<Integer> activeCacheIds, GridCacheContext<K, V> cacheCtx) {\n        if (cacheCtx.system() ^ tx.system())\n            return false;\n\n        for (Integer cacheId : activeCacheIds) {\n            GridCacheContext<K, V> activeCacheCtx = cacheContext(cacheId);\n\n            // Check that caches have the same store.\n            if (activeCacheCtx.store().store() != cacheCtx.store().store())\n                return false;\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1833,
    "type": "Return",
    "comment": "@return The newly created Peer object. Use {@link com.google.bitcoin.core.Peer#getConnectionOpenFuture()} if you want a future which completes when the connection is open, or null if the peer could not be connected.",
    "code": "@Nullable\npublic Peer connectTo(InetSocketAddress address) {\n    PeerAddress peerAddress = new PeerAddress(address);\n    backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));\n    return connectTo(peerAddress, true);\n}",
    "label": 1,
    "rec": "@return The newly created Peer object or null if the peer could not be connected. Use {@link com.google.bitcoin.core.Peer#getConnectionOpenFuture()} if you want a future which completes when the connection is open."
  },
  {
    "id": 1834,
    "type": "Return",
    "comment": "@return Affinity nodes for this cache.",
    "code": "    public Collection<ClusterNode> affinityNodes() {\n        return grid(0).cluster().nodes();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1835,
    "type": "Return",
    "comment": "@return the java options string.",
    "code": "protected List<String> getJavaOptsProperty(Function<String, String> mapper) {\n    return configurationGenerator.getJavaOpts(mapper);\n}",
    "label": 1,
    "rec": "@return the Java options."
  },
  {
    "id": 1836,
    "type": "Return",
    "comment": "@return Version of the value for the successful put",
    "code": "    public Version putWithCustomTimeout(CompositeVoldemortRequest<K, V> requestWrapper) {\n        validateTimeout(requestWrapper.getRoutingTimeoutInMs());\n        List<Versioned<V>> versionedValues;\n        long startTime = System.currentTimeMillis();\n        String keyHexString = \"\";\n        if(logger.isDebugEnabled()) {\n            ByteArray key = (ByteArray) requestWrapper.getKey();\n            keyHexString = RestUtils.getKeyHexString(key);\n            logger.debug(\"PUT requested for key: \" + keyHexString + \" , for store: \"\n                         + this.storeName + \" at time(in ms): \" + startTime\n                         + \" . Nested GET and PUT VERSION requests to follow ---\");\n        }\n\n        // We use the full timeout for doing the Get. In this, we're being\n        // optimistic that the subsequent put might be faster such that all the\n        // steps might finish within the alloted time\n        requestWrapper.setResolveConflicts(true);\n        versionedValues = getWithCustomTimeout(requestWrapper);\n        Versioned<V> versioned = getItemOrThrow(requestWrapper.getKey(), null, versionedValues);\n\n        long endTime = System.currentTimeMillis();\n        if(versioned == null)\n            versioned = Versioned.value(requestWrapper.getRawValue(), new VectorClock());\n        else\n            versioned.setObject(requestWrapper.getRawValue());\n\n        // This should not happen unless there's a bug in the\n        // getWithCustomTimeout\n        long timeLeft = requestWrapper.getRoutingTimeoutInMs() - (endTime - startTime);\n        if(timeLeft <= 0) {\n            throw new StoreTimeoutException(\"PUT request timed out\");\n        }\n        CompositeVersionedPutVoldemortRequest<K, V> putVersionedRequestObject = new CompositeVersionedPutVoldemortRequest<K, V>(requestWrapper.getKey(),\n                                                                                                                                versioned,\n                                                                                                                                timeLeft);\n        putVersionedRequestObject.setRequestOriginTimeInMs(requestWrapper.getRequestOriginTimeInMs());\n        Version result = putVersionedWithCustomTimeout(putVersionedRequestObject);\n        long endTimeInMs = System.currentTimeMillis();\n        if(logger.isDebugEnabled()) {\n            logger.debug(\"PUT response recieved for key: \" + keyHexString + \" , for store: \"\n                         + this.storeName + \" at time(in ms): \" + endTimeInMs);\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1837,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forManifest(final URL url) {\n    final Collection<URL> result = new ArrayList<URL>();\n    result.add(url);\n    try {\n        final String part = cleanPath(url);\n        File jarFile = new File(part);\n        JarFile myJar = new JarFile(part);\n        URL validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), part);\n        if (validUrl != null) {\n            result.add(validUrl);\n        }\n        final Manifest manifest = myJar.getManifest();\n        if (manifest != null) {\n            final String classPath = manifest.getMainAttributes().getValue(new Attributes.Name(STR));\n            if (classPath != null) {\n                for (String jar : classPath.split(STR)) {\n                    validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), jar);\n                    if (validUrl != null) {\n                        result.add(validUrl);\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n    }\n    return distinctUrls(result);\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 1838,
    "type": "Return",
    "comment": "@return how many tasks are matched by this query",
    "code": "    public int count(Query query) {\n        return taskDao.count(query);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1839,
    "type": "Return",
    "comment": "@return Unsafe URI for the current configuration.",
    "code": "public String buildUnsafe() {\n    return new StringBuilder(host).append(STR).append(PREFIX_UNSAFE).append(STR).append(assembleConfig()).append(target).toString();\n}",
    "label": 1,
    "rec": "@return Unsafe URL for the current configuration."
  },
  {
    "id": 1840,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String publishPlace(String path, HttpServletRequest request, HttpSession session, ModelMap model) {\n        try {\n            SysSite site = siteComponent.getSite(request.getServerName());\n            if (CommonUtils.notEmpty(path) && site.isUseSsi()) {\n                CmsPlaceMetadata metadata = metadataComponent\n                        .getPlaceMetadata(siteComponent.getWebTemplateFilePath(site, TemplateComponent.INCLUDE_DIRECTORY + path));\n                templateComponent.staticPlace(site, path, metadata);\n                logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                        LogLoginService.CHANNEL_WEB_MANAGER, \"static\", RequestUtils.getIpAddress(request), CommonUtils.getDate(),\n                        path));\n            }\n            return CommonConstants.TEMPLATE_DONE;\n        } catch (IOException | TemplateException e) {\n            model.addAttribute(CommonConstants.ERROR, e.getMessage());\n            log.error(e.getMessage(), e);\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1841,
    "type": "Return",
    "comment": "@return Test suite.",
    "code": "    public static TestSuite suite() throws Exception {\n        return suite(null);\n    }\n",
    "label": 1,
    "rec": "@return IgniteCache test suite."
  },
  {
    "id": 1842,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Set<Facing> getSupportedFacing() {\n        return Collections.unmodifiableSet(supportedFacing);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1843,
    "type": "Return",
    "comment": "@return an immutable {@code Set} instance containing those elements, minus duplicates",
    "code": "@GwtCompatible(serializable = false)\npublic static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements) {\n    Iterator<E> iterator = elements.iterator();\n    if (!iterator.hasNext()) {\n        return ImmutableSet.of();\n    }\n    if (elements instanceof EnumSet) {\n        EnumSet<E> enumSetClone = EnumSet.copyOf((EnumSet<E>) elements);\n        return new ImmutableSet.ImmutableEnumSet<E>(enumSetClone);\n    }\n    E first = iterator.next();\n    EnumSet<E> set = EnumSet.of(first);\n    while (iterator.hasNext()) {\n        set.add(iterator.next());\n    }\n    return new ImmutableSet.ImmutableEnumSet<E>(set);\n}",
    "label": 1,
    "rec": "@return an immutable set containing those elements, minus duplicates"
  },
  {
    "id": 1844,
    "type": "Return",
    "comment": "@return the source instance as byte array.",
    "code": "\tprivate static byte[] getAsByteArray(Object source) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\n\t\tif (source instanceof String) {\n\t\t\treturn ((String) source).getBytes(StandardCharsets.UTF_8);\n\t\t}\n\n\t\tif (source instanceof byte[]) {\n\t\t\treturn (byte[]) source;\n\t\t}\n\n\t\tif (source instanceof Bytes) {\n\t\t\treturn ((Bytes) source).get();\n\t\t}\n\n\t\tthrow new ConversionException(String.format(\n\t\t\t\t\"Unsupported payload type '%s'. Expected 'String', 'Bytes', or 'byte[]'\",\n\t\t\t\tsource.getClass()), null);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1845,
    "type": "Return",
    "comment": "@return The previous column",
    "code": "public String getPreviousColumn() {\n    return _previousColumnName;\n}",
    "label": 1,
    "rec": "@return The name of the previous column"
  },
  {
    "id": 1846,
    "type": "Return",
    "comment": "@return Putx operation future.",
    "code": "            @Override public IgniteInternalFuture<Boolean> op(IgniteTxLocalAdapter tx) {\n                return tx.removeAllAsync(ctx, Collections.singletonList(key), null, false, filter).chain(\n                    (IgniteClosure<IgniteInternalFuture<GridCacheReturn>, Boolean>)RET2FLAG);\n            }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1847,
    "type": "Return",
    "comment": "@return the relevant channel descriptor",
    "code": "public ChannelN getChannel(int channelNumber) {\n    synchronized (this.monitor) {\n        ChannelN ch = _channelMap.get(channelNumber);\n        if (ch == null)\n            throw new UnknownChannelException(channelNumber);\n        return ch;\n    }\n}",
    "label": 1,
    "rec": "@return the channel on this connection with number <code><b>channelNumber</b></code>"
  },
  {
    "id": 1848,
    "type": "Return",
    "comment": "@return broker-socket-address that serves given topic",
    "code": "    public CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadata(TopicName topicName) {\n        String format = topicName.isV2() ? \"admin/v2/%s/partitions\" : \"admin/%s/partitions\";\n        return httpClient.get(String.format(format, topicName.getLookupName()), PartitionedTopicMetadata.class);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1849,
    "type": "Return",
    "comment": "@return the full path of the file, or the library name, loaded (but  if (!loadLibraries || cls == null)  return null; )",
    "code": "    public static String loadLibrary(URL[] urls, String libnameversion) {\n        if (!loadLibraries) {\n            return null;\n        }\n\n        // If we do not already have the native library file ...\n        String filename = loadedLibraries.get(libnameversion);\n        if (filename != null) {\n            return filename;\n        }\n\n        File tempFile = null;\n        UnsatisfiedLinkError loadError = null;\n        try {\n            for (URL url : urls) {\n                File file;\n                try {\n                    // ... if the URL is not already a file ...\n                    file = new File(url.toURI());\n                } catch (Exception e) {\n                    if (tempFile != null && tempFile.exists()) {\n                        tempFile.deleteOnExit();\n                    }\n                    // ... then extract it from our resources ...\n                    file = tempFile = extractResource(url, getTempDir(), null, null);\n                }\n                if (file != null && file.exists()) {\n                    filename = file.getAbsolutePath();\n                    try {\n                        // ... and load it!\n                        loadedLibraries.put(libnameversion, filename);\n                        System.load(filename);\n                        return filename;\n                    } catch (UnsatisfiedLinkError e) {\n                        loadError = e;\n                        loadedLibraries.remove(libnameversion);\n                    }\n                }\n            }\n            // ... or as last resort, try to load it via the system.\n            String libname = libnameversion.split(\"@\")[0];\n            loadedLibraries.put(libnameversion, libname);\n            System.loadLibrary(libname);\n            return libname;\n        } catch (UnsatisfiedLinkError e) {\n            loadedLibraries.remove(libnameversion);\n            if (loadError != null) {\n                e.initCause(loadError);\n            }\n            throw e;\n        } catch (IOException ex) {\n            loadedLibraries.remove(libnameversion);\n            if (loadError != null) {\n                ex.initCause(loadError);\n            }\n            Error e = new UnsatisfiedLinkError(ex.toString());\n            e.initCause(ex);\n            throw e;\n        } finally {\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.deleteOnExit();\n            }\n            // But under Windows, it won't get deleted!\n        }\n    }\n",
    "label": 1,
    "rec": "@return the full path of the file loaded, or the library name if unknown (but  if (!loadLibraries)  return null; )"
  },
  {
    "id": 1850,
    "type": "Return",
    "comment": "@return a new structured object",
    "code": "    private IndexableObject newObject() {\n        return new PlainIndexableObject().ignoreNull(shouldIgnoreNull);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1851,
    "type": "Return",
    "comment": "@return the mGroupSettingsList",
    "code": "public List<Group> getGroupSettingsList() {\n    return mGroupList;\n}",
    "label": 1,
    "rec": "@return the mGroupList"
  },
  {
    "id": 1852,
    "type": "Return",
    "comment": "@return Type ID.",
    "code": "    public int typeId(String typeName) {\n        Integer id = predefinedTypeNames.get(SIMPLE_NAME_LOWER_CASE_MAPPER.typeName(typeName));\n\n        if (id != null)\n            return id;\n\n        if (marshCtx.isSystemType(typeName))\n            return typeName.hashCode();\n\n        BinaryInternalMapper mapper = userTypeMapper(typeName);\n\n        return mapper.typeId(typeName);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1853,
    "type": "Return",
    "comment": "@return The regex",
    "code": "protected static String convertRawUriToRegex(String rawUri) {\n    Matcher matcher = PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE.matcher(rawUri);\n    StringBuffer stringBuffer = new StringBuffer();\n    while (matcher.find()) {\n        String namedVariablePartOfRoute = matcher.group(NUM);\n        String namedVariablePartOfORouteReplacedWithRegex;\n        if (namedVariablePartOfRoute != null) {\n            namedVariablePartOfORouteReplacedWithRegex = STR + namedVariablePartOfRoute + STR;\n        } else {\n            namedVariablePartOfORouteReplacedWithRegex = VARIABLE_ROUTES_DEFAULT_REGEX;\n        }\n        matcher.appendReplacement(stringBuffer, namedVariablePartOfORouteReplacedWithRegex);\n    }\n    matcher.appendTail(stringBuffer);\n    return stringBuffer.toString();\n}",
    "label": 1,
    "rec": "@return The converted regex with default matching regex - or the regex specified by the user."
  },
  {
    "id": 1854,
    "type": "Return",
    "comment": "@return  True if synchronous commit is enabled.",
    "code": "    public boolean syncCommit() {\n        return cacheCfg.getWriteSynchronizationMode() == FULL_SYNC;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1855,
    "type": "Return",
    "comment": "@return collection of values, or null if the key is not in the map.",
    "code": "public List<V> get(K key) {\n    return mMap.get(key);\n}",
    "label": 1,
    "rec": "@return list of values, or null if the key is not in the map."
  },
  {
    "id": 1856,
    "type": "Return",
    "comment": "@return Just the apiVersion part without the apiGroup.",
    "code": "  private static String trimVersion(String apiVersion) {\n    if (apiVersion == null) {\n      return null;\n    } else {\n      String[] versionParts = apiVersion.split(\"/\");\n      return versionParts.length > 1 ? versionParts[versionParts.length - 1] : apiVersion;\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1857,
    "type": "Return",
    "comment": "@return Value computed by the transform closure.",
    "code": "    @Nullable private Long transformHeader(EntryProcessor<GridCacheQueueHeaderKey, GridCacheQueueHeader, Long> c)\n        throws IgniteCheckedException {\n        int cnt = 0;\n\n        while (true) {\n            try {\n                return (Long)cache.invoke(queueKey, c);\n            }\n            catch (CachePartialUpdateException e) {\n                if (cnt++ == MAX_UPDATE_RETRIES)\n                    throw e;\n                else {\n                    U.warn(log, \"Failed to update queue header, will retry [err=\" + e + ']');\n\n                    U.sleep(RETRY_DELAY);\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@return Value computed by the entry processor."
  },
  {
    "id": 1858,
    "type": "Return",
    "comment": "@return the error defined by loss function.",
    "code": "    protected double computeOutputError(double[] target, double weight) {\n        Layer outputLayer = outputLayer();\n\n        int units = outputLayer.getOutputUnits();\n        if (target.length != units) {\n            throw new IllegalArgumentException(String.format(\"Invalid target vector size: %d, expected: %d\", target.length, units));\n        }\n\n        ActivationFunction activation = outputLayer.getActivation();\n        double[] output = outputLayer.getOutput();\n        double[] error = outputLayer.getError();\n        double err = 0.0;\n        for (int i = 0; i < units; i++) {\n            double o = output[i];\n            double t = target[i];\n            double g = t - o;\n\n            switch (obj) {\n                case LEAST_MEAN_SQUARES:\n                    err += 0.5 * g * g;\n                    if (activation == ActivationFunction.LOGISTIC_SIGMOID) {\n                        g *= o * (1.0 - o);\n                    }\n                    break;\n\n                case CROSS_ENTROPY:\n                    switch (activation) {\n                        case SOFTMAX:\n                            err -= t * log(o);\n                            break;\n\n                        case LOGISTIC_SIGMOID:\n                            // We have only one output neuron in this case.\n                            err = -t * log(o) - (1.0 - t) * log(1.0 - o);\n                            g *= o * (1.0 - o);\n                            break;\n\n                        default:\n                            throw new IllegalArgumentException(String.format(\"Unsupported activation function %s for objective function %s\", outputLayer.getActivation(), obj));\n                    }\n            }\n\n            error[i] = weight * g;\n        }\n\n        return weight * err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1859,
    "type": "Return",
    "comment": "@return a point which is the new centroid",
    "code": "public SparseVector computeCentroid() {\n    SparseVector result = new SparseVector(pointTotal.size());\n    for (int i = NUM; i < pointTotal.size(); i++) result.set(i, pointTotal.get(i) / numPoints);\n    return result;\n}",
    "label": 1,
    "rec": "@return a SparseVector (required by Mapper) which is the new centroid"
  },
  {
    "id": 1860,
    "type": "Return",
    "comment": "@return true or false if the stream contains GZIP compressed data",
    "code": "    public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {\n        if (inputStream == null)\n            return false;\n\n        byte[] signature = new byte[2];\n        int count = 0;\n        try {\n            while (count < 2) {\n                int readCount = inputStream.read(signature, count, 2 - count);\n                if (readCount < 0) return false;\n                count = count + readCount;\n            }\n        } finally {\n            inputStream.unread(signature, 0, count);\n        }\n        int streamHeader = ((int) signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);\n        return GZIPInputStream.GZIP_MAGIC == streamHeader;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1861,
    "type": "Return",
    "comment": "@return Property instance corresponding to the given path.",
    "code": "    private static ClassProperty buildClassProperty(Class<?> keyCls, Class<?> valCls, String pathStr, Class<?> resType)\n        throws IgniteCheckedException {\n        ClassProperty res = buildClassProperty(true, keyCls, pathStr, resType);\n\n        if (res == null) // We check key before value consistently with PortableProperty.\n            res = buildClassProperty(false, valCls, pathStr, resType);\n\n        if (res == null)\n            throw new IgniteCheckedException(\"Failed to initialize property '\" + pathStr + \"' for \" +\n                \"key class '\" + keyCls + \"' and value class '\" + valCls + \"'. \" +\n                \"Make sure that one of these classes contains respective getter method or field.\");\n\n        return res;\n    }\n",
    "label": 1,
    "rec": "@return Class property."
  },
  {
    "id": 1862,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static int anyInt() {\n        return reportMatcher(Any.ANY).intValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1863,
    "type": "Return",
    "comment": "@return A validation report containing accumulated validation errors",
    "code": "public Status validate(final String value, final Model schema) {\n    return doValidate(value, schema);\n}",
    "label": 1,
    "rec": "@return A status containing error code and description"
  },
  {
    "id": 1864,
    "type": "Return",
    "comment": "@return Regex pattern for JSON.",
    "code": "    private String cacheBulkPattern(boolean res, boolean success) {\n        return \"\\\\{\\\\\\\"affinityNodeId\\\\\\\":\\\\\\\"\\\\\\\"\\\\,\" +\n            \"\\\\\\\"error\\\\\\\":\\\\\\\"\\\\\\\"\\\\,\" +\n            \"\\\\\\\"response\\\\\\\":\" + res + \"\\\\,\" +\n            \"\\\\\\\"sessionToken\\\\\\\":\\\\\\\"\" + (securityEnabled() && success ? \".+\" : \"\") + \"\\\\\\\",\" +\n            \"\\\\\\\"successStatus\\\\\\\":\" + (success ? 0 : 1) + \"\\\\}\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1865,
    "type": "Return",
    "comment": "@return the sum of mapped elements",
    "code": "public double sum() {\n    return reduce(Ops.doubleAdder(), NUM);\n}",
    "label": 1,
    "rec": "@return the sum of elements"
  },
  {
    "id": 1866,
    "type": "Return",
    "comment": "@return the correlation between vectors i and j",
    "code": "\tprotected double correlation(SparseVector iv, SparseVector jv) {\n\t\treturn correlation(iv, jv, cf.getString(\"similarity\"));\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1867,
    "type": "Return",
    "comment": "@return a {@link PagedCollection}.",
    "code": "public ResourceCollection<Customer> all() {\n    return all(NUM);\n}",
    "label": 1,
    "rec": "@return a {@link ResourceCollection}."
  },
  {
    "id": 1868,
    "type": "Return",
    "comment": "@return Started grid.",
    "code": "    public static Ignite start(IgniteConfiguration cfg) throws IgniteCheckedException {\n        return start(cfg, null, true);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1869,
    "type": "Return",
    "comment": "@return  GridServices for this projection.",
    "code": "    public IgniteManaged services() {\n        if (svcs == null) {\n            assert ctx != null;\n\n            svcs = new IgniteManagedImpl(ctx, this, false);\n        }\n\n        return svcs;\n    }\n",
    "label": 1,
    "rec": "@return  org.gridgain.grid.service.IgniteManaged for this projection."
  },
  {
    "id": 1870,
    "type": "Return",
    "comment": "@return the full path of the file loaded, or the library name if unknown (but  if (!isLoadLibraries)  return null; )",
    "code": "    public synchronized static String loadLibrary(URL[] urls, String libnameversion, String ... preloaded) {\n        if (!isLoadLibraries()) {\n            return null;\n        }\n        String[] split = libnameversion.split(\"#\");\n        String libnameversion2 = split[0];\n        if (split.length > 1) {\n            libnameversion2 = split[1];\n        }\n\n        // If we do not already have the native library file ...\n        String filename = loadedLibraries.get(libnameversion2);\n        UnsatisfiedLinkError loadError = null;\n        try {\n            for (URL url : urls) {\n                URI uri = url.toURI();\n                File file = null;\n                try {\n                    // ... and if the URL is not already a file without fragments, etc ...\n                    file = new File(uri);\n                } catch (Exception exc) {\n                    // ... extract it from resources into the cache, if necessary ...\n                    File f = cacheResource(url, filename);\n                    try {\n                        if (f != null) {\n                            file = f;\n                        } else {\n                            // ... else try to load directly as some libraries do not like being renamed ...\n                            try {\n                                file = new File(new URI(uri.toString().split(\"#\")[0]));\n                            } catch (IllegalArgumentException | URISyntaxException e) {\n                                file = new File(uri.getPath());\n                            }\n                        }\n                    } catch (Exception exc2) {\n                        // ... (or give up) and ...\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Failed to access \" + uri + \": \" + exc2);\n                        }\n                    }\n\n                    // ... create symbolic links to previously loaded libraries as needed on Mac,\n                    // at least, and some libraries like MKL on Linux too, ...\n                    if (file != null && preloaded != null) {\n                        File dir = file.getParentFile();\n                        for (String s : preloaded) {\n                            File file2 = new File(s);\n                            File dir2 = file2.getParentFile();\n                            if (dir2 != null && !dir2.equals(dir)) {\n                                File linkFile = new File(dir, file2.getName());\n                                try {\n                                    Path linkPath = linkFile.toPath();\n                                    Path targetPath = file2.toPath();\n                                    if ((!linkFile.exists() || !Files.isSymbolicLink(linkPath) || !Files.readSymbolicLink(linkPath).equals(targetPath))\n                                            && targetPath.isAbsolute() && !targetPath.equals(linkPath)) {\n                                        if (logger.isDebugEnabled()) {\n                                            logger.debug(\"Creating symbolic link \" + linkPath + \" to \" + targetPath);\n                                        }\n                                        linkFile.delete();\n                                        Files.createSymbolicLink(linkPath, targetPath);\n                                    }\n                                } catch (IOException | RuntimeException e) {\n                                    // ... (probably an unsupported operation on Windows, but DLLs never need links,\n                                    // or other (filesystem?) exception: for example,\n                                    // \"sun.nio.fs.UnixException: No such file or directory\" on File.toPath()) ...\n                                    if (logger.isDebugEnabled()) {\n                                        logger.debug(\"Failed to create symbolic link \" + linkFile + \" to \" + file2 + \": \" + e);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (filename != null) {\n                    return filename;\n                } else if (file != null && file.exists()) {\n                    String filename2 = file.getAbsolutePath();\n                    try {\n                        // ... and load it!\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Loading \" + filename2);\n                        }\n                        loadedLibraries.put(libnameversion2, filename2);\n                        System.load(filename2);\n                        return filename2;\n                    } catch (UnsatisfiedLinkError e) {\n                        loadError = e;\n                        loadedLibraries.remove(libnameversion2);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Failed to load \" + filename2 + \": \" + e);\n                        }\n                    }\n                }\n            }\n            if (filename != null) {\n                return filename;\n            } else if (!libnameversion.trim().endsWith(\"#\")) {\n                // ... or as last resort, try to load it via the system.\n                String libname = libnameversion.split(\"#\")[0].split(\"@\")[0];\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Loading library \" + libname);\n                }\n                loadedLibraries.put(libnameversion2, libname);\n                System.loadLibrary(libname);\n                return libname;\n            } else {\n                // But do not load when tagged as a system library\n                return null;\n            }\n        } catch (UnsatisfiedLinkError e) {\n            loadedLibraries.remove(libnameversion2);\n            if (loadError != null && e.getCause() == null) {\n                e.initCause(loadError);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to load for \" + libnameversion + \": \" + e);\n            }\n            throw e;\n        } catch (IOException | URISyntaxException ex) {\n            loadedLibraries.remove(libnameversion2);\n            if (loadError != null && ex.getCause() == null) {\n                ex.initCause(loadError);\n            }\n            Error e = new UnsatisfiedLinkError(ex.toString());\n            e.initCause(ex);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to extract for \" + libnameversion + \": \" + e);\n            }\n            throw e;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1871,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastFailedBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastFailedBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 1872,
    "type": "Return",
    "comment": "@return task template backup file path",
    "code": "    public String getTaskTemplateBackupFilePath(SysSite site, String templatePath) {\n        return taskTemplateBackupFilePath + getFullFileName(site.getId(), templatePath);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1873,
    "type": "Return",
    "comment": "@return an aggregated Account instance representing account data across all the successfully consulted realms.",
    "code": "    protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for (Realm realm : realms) {\n\n            if (realm.supports(token)) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                            \"using realm of type [\" + realm + \"]\");\n                }\n\n                AuthenticationInfo info = null;\n                Throwable t = null;\n                try {\n                    info = realm.getAuthenticationInfo(token);\n                } catch (Throwable throwable) {\n                    t = throwable;\n                    if (log.isTraceEnabled()) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace(msg, t);\n                    }\n                }\n\n                aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);\n\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm + \"] does not support token \" +\n                            \"[\" + token + \"].  Skipping realm.\");\n                }\n            }\n        }\n\n        aggregate = strategy.afterAllAttempts(token, aggregate);\n\n        return aggregate;\n    }\n",
    "label": 1,
    "rec": "@return an aggregated AuthenticationInfo instance representing account data across all the successfully consulted realms."
  },
  {
    "id": 1874,
    "type": "Return",
    "comment": "@return application terms of the Loan object",
    "code": "    public LoanApplicationTerms getLoanApplicationTerms(final ApplicationCurrency applicationCurrency) {\n        LoanProduct loanProduct = loanProduct();\n        // LoanProductRelatedDetail loanProductRelatedDetail =\n        // getLoanRepaymentScheduleDetail();\n        final MonetaryCurrency currency = this.loanRepaymentScheduleDetail.getCurrency();\n\n        final Integer loanTermFrequency = getTermFrequency();\n        final PeriodFrequencyType loanTermPeriodFrequencyType = this.loanRepaymentScheduleDetail.getInterestPeriodFrequencyType();\n        final NthDayType nthDayType = NthDayType.fromInt(this.repaymentFrequencyNthDayType);\n        final DayOfWeekType dayOfWeekType = DayOfWeekType.fromInt(this.repaymentFrequencyDayOfWeekType);\n\n        final Integer numberOfRepayments = this.loanRepaymentScheduleDetail.getNumberOfRepayments();\n        final Integer repaymentEvery = this.loanRepaymentScheduleDetail.getRepayEvery();\n        final PeriodFrequencyType repaymentPeriodFrequencyType = this.loanRepaymentScheduleDetail.getRepaymentPeriodFrequencyType();\n\n        final AmortizationMethod amortizationMethod = this.loanRepaymentScheduleDetail.getAmortizationMethod();\n\n        final InterestMethod interestMethod = this.loanRepaymentScheduleDetail.getInterestMethod();\n        final InterestCalculationPeriodMethod interestCalculationPeriodMethod = this.loanRepaymentScheduleDetail\n                .getInterestCalculationPeriodMethod();\n\n        final BigDecimal interestRatePerPeriod = this.loanRepaymentScheduleDetail.getNominalInterestRatePerPeriod();\n        final PeriodFrequencyType interestRatePeriodFrequencyType = this.loanRepaymentScheduleDetail.getInterestPeriodFrequencyType();\n\n        final BigDecimal annualNominalInterestRate = this.loanRepaymentScheduleDetail.getAnnualNominalInterestRate();\n        final Money principalMoney = this.loanRepaymentScheduleDetail.getPrincipal();\n\n        final LocalDate expectedDisbursementDate = getExpectedDisbursedOnLocalDate();\n        final LocalDate repaymentsStartingFromDate = getExpectedFirstRepaymentOnDate();\n        LocalDate calculatedRepaymentsStartingFromDate = repaymentsStartingFromDate;\n\n        // TODO get calender linked to loan if any exist. As of 17-07-2014,\n        // could not find a link in the database.\n        // skip for now and set the Calender object to null\n        Calendar calendar = null;\n\n        final Integer graceOnPrincipalPayment = this.loanRepaymentScheduleDetail.graceOnPrincipalPayment();\n        final Integer graceOnInterestPayment = this.loanRepaymentScheduleDetail.graceOnInterestPayment();\n        final Integer graceOnInterestCharged = this.loanRepaymentScheduleDetail.graceOnInterestCharged();\n        final LocalDate interestChargedFromDate = getInterestChargedFromDate();\n        final Integer graceOnArrearsAgeing = this.loanRepaymentScheduleDetail.getGraceOnDueDate();\n\n        final Money inArrearsToleranceMoney = this.loanRepaymentScheduleDetail.getInArrearsTolerance();\n        final BigDecimal emiAmount = getFixedEmiAmount();\n        final BigDecimal maxOutstandingBalance = getMaxOutstandingLoanBalance();\n\n        final List<DisbursementData> disbursementData = getDisbursmentData();\n\n        final List<LoanTermVariationsData> loanVariationTermsData = new ArrayList<LoanTermVariationsData>();\n        LoanTermVariationsData data = new LoanTermVariationsData(null,\n                LoanEnumerations.loanvariationType(LoanTermVariationType.EMI_AMOUNT), expectedDisbursementDate, emiAmount);\n        loanVariationTermsData.add(data);\n\n        return LoanApplicationTerms.assembleFrom(applicationCurrency, loanTermFrequency, loanTermPeriodFrequencyType, nthDayType,\n                dayOfWeekType, expectedDisbursementDate, repaymentsStartingFromDate, calculatedRepaymentsStartingFromDate,\n                inArrearsToleranceMoney, this.loanRepaymentScheduleDetail, loanProduct.isMultiDisburseLoan(), emiAmount, disbursementData,\n                maxOutstandingBalance, loanVariationTermsData, interestChargedFromDate,\n                this.loanProduct.getPrincipalThresholdForLastInstalment());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1875,
    "type": "Return",
    "comment": "@return an int representation of the number with no decimal",
    "code": "    public BigInteger getNumber() {\n        BigDecimal bigDecimal = getEnteredNumber().setScale(0, BigDecimal.ROUND_FLOOR);\n        return bigDecimal.toBigIntegerExact();\n    }\n",
    "label": 1,
    "rec": "@return an String representation of the number with no decimal"
  },
  {
    "id": 1876,
    "type": "Return",
    "comment": "@return the largest eigen value.",
    "code": "    public static double eigen(Matrix A, double[] v, double tol) {\n        return PowerIteration.eigen(A, v, tol);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1877,
    "type": "Return",
    "comment": "@return true if {@param footerViewId} is not 0, false otherwise",
    "code": "private boolean hasFooter() {\n    return footerViewId != NUM || footerView != null;\n}",
    "label": 1,
    "rec": "@return true if {@param footerViewId} is not 0 or if {@param footerView} is not null, false otherwise"
  },
  {
    "id": 1878,
    "type": "Return",
    "comment": "@return true if the request was made with a bearer token authorization header; false otherwise.",
    "code": "    protected boolean isBearerTokenRequest(HttpServletRequest request) {\n        String authValue = request.getHeader(AUTHORIZATION_HEADER);\n        return authValue != null && authValue.toLowerCase().startsWith(SCHEME_BEARER);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1879,
    "type": "Return",
    "comment": "@return removed nodes",
    "code": "public int simplify(PointList points) {\n    return simplify(points, NUM, points.size() - NUM);\n}",
    "label": 1,
    "rec": "@return The number removed points"
  },
  {
    "id": 1880,
    "type": "Return",
    "comment": "@return Predicate.",
    "code": "    private GridPredicate<ClusterNode> singleNodePredicate(final int idx) {\n        assert idx >= 0 && idx < NODES_CNT;\n\n        return new GridPredicate<ClusterNode>() {\n            @Override public boolean apply(ClusterNode e) { return grid(idx).localNode().id().equals(e.id()); }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1881,
    "type": "Return",
    "comment": "@return the padding",
    "code": "public String getPadding() {\n    return paddingName;\n}",
    "label": 1,
    "rec": "@return the paddingName"
  },
  {
    "id": 1882,
    "type": "Return",
    "comment": "@return Logging directory.",
    "code": "    private static File logDirectory() throws IgniteCheckedException {\n        return !F.isEmpty(U.IGNITE_LOG_DIR) ? new File(U.IGNITE_LOG_DIR) : U.resolveWorkDirectory(\"log\", false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1883,
    "type": "Return",
    "comment": "@return the ServletRequest bound to the thread, or null if there isn't one bound.",
    "code": "    public static ServletRequest getServletRequest() {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if( request == null ) {\n            throw new IllegalStateException( \"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE );\n        }        \n        return request;\n    }\n",
    "label": 1,
    "rec": "@return the ServletRequest bound to the thread. Never returns null."
  },
  {
    "id": 1884,
    "type": "Return",
    "comment": "@return Peeks value.",
    "code": "    @Nullable public V peek() {\n        try {\n            CacheObject val = cached.peek(GridCachePeekMode.GLOBAL);\n\n            return val != null ? val.<V>value(cached.context(), false) : null;\n        }\n        catch (GridCacheEntryRemovedException e) {\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1885,
    "type": "Return",
    "comment": "@return true if matching activities are enabled",
    "code": "private boolean areActivitiesEnabled(final String itemID) {\n    if (!WorkbenchActivityHelper.isFiltering())\n        return true;\n    IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI.getWorkbench().getActivitySupport();\n    IIdentifier id = workbenchActivitySupport.getActivityManager().getIdentifier(WorkbenchActivityHelper.createUnifiedId(getPluginContribution()));\n    if (id != null && !id.isEnabled()) {\n        return false;\n    }\n    id = workbenchActivitySupport.getActivityManager().getIdentifier(WorkbenchActivityHelper.createUnifiedId(new IPluginContribution() {\n\n        public String getLocalId() {\n            return itemID;\n        }\n\n        public String getPluginId() {\n            return getPluginContribution().getPluginId();\n        }\n    }));\n    if (id != null && !id.isEnabled()) {\n        return false;\n    }\n    return true;\n}",
    "label": 1,
    "rec": "@return true if at least one matching activity is enabled"
  },
  {
    "id": 1886,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "    private int putDown(final Put p, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        assert lvl >= 0 : lvl;\n\n        final Page page = page(pageId);\n\n        try {\n            for (;;) {\n                // Init args.\n                p.pageId = pageId;\n                p.fwdId = fwdId;\n\n                int res = readPage(pageId, page, search, p, lvl);\n\n                switch (res) {\n                    case Put.GO_DOWN:\n                    case Put.GO_DOWN_X:\n                        assert lvl > 0 : lvl;\n                        assert p.pageId != pageId;\n                        assert p.fwdId != fwdId || fwdId == 0;\n\n                        // Need to replace key in inner page. There is no race because we keep tail lock after split.\n                        if (p.needReplaceInner == TRUE) {\n                            p.needReplaceInner = FALSE; // Protect from retries.\n\n                            res = writePage(pageId, page, replace, p, lvl);\n\n                            if (res != Put.FOUND)\n                                return res; // Need to retry.\n\n                            p.needReplaceInner = DONE; // We can have only single matching inner key.\n                        }\n\n                        // Go down recursively.\n                        res = putDown(p, p.pageId, p.fwdId, lvl - 1);\n\n                        if (res == Put.RETRY_ROOT || p.isFinished())\n                            return res;\n\n                        if (res == Put.RETRY)\n                            checkInterrupted();\n\n                        continue; // We have to insert split row to this level or it is a retry.\n\n                    case Put.FOUND: // Do replace.\n                        assert lvl == 0 : \"This replace can happen only at the bottom level.\";\n\n                        // Init args.\n                        p.pageId = pageId;\n                        p.fwdId = fwdId;\n\n                        return writePage(pageId, page, replace, p, lvl);\n\n                    case Put.NOT_FOUND: // Do insert.\n                        assert lvl == p.btmLvl : \"must insert at the bottom level\";\n                        assert p.needReplaceInner == FALSE: p.needReplaceInner + \" \" + lvl;\n\n                        // Init args.\n                        p.pageId = pageId;\n                        p.fwdId = fwdId;\n\n                        return writePage(pageId, page, insert, p, lvl);\n\n                    default:\n                        return res;\n                }\n            }\n        }\n        finally{\n            if (p.canRelease(pageId, page, lvl))\n                page.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1887,
    "type": "Return",
    "comment": "@return the vector containing the custom elements.",
    "code": "public List getCustomElements() {\n    return customElements;\n}",
    "label": 1,
    "rec": "@return the list containing the custom elements."
  },
  {
    "id": 1888,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static double anyDouble() {\n        return reportMatcher(new InstanceOf(Double.class)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1889,
    "type": "Return",
    "comment": "@return The default PHPexeItem for the given debugger, or null if no such debugger exists.",
    "code": "public PHPexeItem getDefaultItem() {\n    return PHPDebugPlugin.getWorkspaceDefaultExe();\n}",
    "label": 1,
    "rec": "@return The default workspace PHPexeItem."
  },
  {
    "id": 1890,
    "type": "Return",
    "comment": "@return Entry (never  null).",
    "code": "    public GridCacheEntryEx entryEx(KeyCacheObject key, boolean touch) {\n        GridCacheEntryEx e = entry0(key, ctx.affinity().affinityTopologyVersion(), true, touch);\n\n        assert e != null;\n\n        return e;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1891,
    "type": "Return",
    "comment": "@return the 3 best  FinderPatterns from our list of candidates. The \"best\" are those that have been detected at least  #CENTER_QUORUM times, and whose module size differs from the average among those patterns the least",
    "code": "  private FinderPattern[] selectBestPatterns() throws NotFoundException {\n\n    int startSize = possibleCenters.size();\n    if (startSize < 3) {\n      // Couldn't find enough finder patterns\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    Collections.sort(possibleCenters, moduleComparator);\n\n    double distortion = Double.MAX_VALUE;\n    double[] squares = new double[3];\n    FinderPattern[] bestPatterns = new FinderPattern[3];\n\n    for (int i = 0; i < possibleCenters.size() - 2; i++) {\n      FinderPattern fpi = possibleCenters.get(i);\n      float minModuleSize = fpi.getEstimatedModuleSize();\n\n      for (int j = i + 1; j < possibleCenters.size() - 1; j++) {\n        FinderPattern fpj = possibleCenters.get(j);\n        double squares0 = squaredDistance(fpi, fpj);\n\n        for (int k = j + 1; k < possibleCenters.size(); k++) {\n          FinderPattern fpk = possibleCenters.get(k);\n          float maxModuleSize = fpk.getEstimatedModuleSize();\n          if (maxModuleSize > minModuleSize * 1.4f) {\n            // module size is not similar\n            continue;\n          }\n\n          squares[0] = squares0;\n          squares[1] = squaredDistance(fpj, fpk);\n          squares[2] = squaredDistance(fpi, fpk);\n          Arrays.sort(squares);\n\n          // a^2 + b^2 = c^2 (Pythagorean theorem), and a = b (isosceles triangle).\n          // Since any right triangle satisfies the formula c^2 - b^2 - a^2 = 0,\n          // we need to check both two equal sides separately.\n          // The value of |c^2 - 2 * b^2| + |c^2 - 2 * a^2| increases as dissimilarity\n          // from isosceles right triangle.\n          double d = Math.abs(squares[2] - 2 * squares[1]) + Math.abs(squares[2] - 2 * squares[0]);\n          if (d < distortion) {\n            distortion = d;\n            bestPatterns[0] = fpi;\n            bestPatterns[1] = fpj;\n            bestPatterns[2] = fpk;\n          }\n        }\n      }\n    }\n\n    if (distortion == Double.MAX_VALUE) {\n        throw NotFoundException.getNotFoundInstance();\n    }\n\n    return bestPatterns;\n  }\n",
    "label": 1,
    "rec": "@return the 3 best  FinderPatterns from our list of candidates. The \"best\" are those have similar module size and form a shape closer to a isosceles right triangle."
  },
  {
    "id": 1892,
    "type": "Return",
    "comment": "@return Portable type identifier for internal client messages classes.",
    "code": "    static int nextSystemTypeId() {\n        return typeIdGen.decrementAndGet();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1893,
    "type": "Return",
    "comment": "@return Returns greater than zero when double1 > double2, zero when double1 == double2, and less than zero when double1 < double2",
    "code": "public static int compare(double double1, double double2) {\n    long d1, d2;\n    long NaNbits = Double.doubleToLongBits(Double.NaN);\n    if ((d1 = Double.doubleToLongBits(double1)) == NaNbits) {\n        if (Double.doubleToLongBits(double2) == NaNbits) {\n            return NUM;\n        }\n        return NUM;\n    }\n    if ((d2 = Double.doubleToLongBits(double2)) == NaNbits) {\n        return -NUM;\n    }\n    if (double1 == double2) {\n        if (d1 == d2) {\n            return NUM;\n        }\n        return d1 > d2 ? NUM : -NUM;\n    }\n    return double1 > double2 ? NUM : -NUM;\n}",
    "label": 1,
    "rec": "@return Returns greater than zero when double1 is greater than double2, zero when double1 equals double2, and less than zero when double1 is less than double2"
  },
  {
    "id": 1894,
    "type": "Return",
    "comment": "@return Spi.",
    "code": "    private CommunicationSpi<MessageAdapter> newCommunicationSpi() {\n        TcpCommunicationSpi spi = new TcpCommunicationSpi();\n\n        if (!useShmem)\n            spi.setSharedMemoryPort(-1);\n\n        spi.setLocalPort(GridTestUtils.getNextCommPort(getClass()));\n        spi.setIdleConnectionTimeout(IDLE_CONN_TIMEOUT);\n\n        return spi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1895,
    "type": "Return",
    "comment": "@return the Path that results",
    "code": "protected Path incPath(Path source, Path toAdd) {\n    if (null == source) {\n        source = new Path(project);\n    }\n    if (null != toAdd) {\n        source.append(toAdd);\n    }\n    return source;\n}",
    "label": 1,
    "rec": "@return the (never-null) Path that results"
  },
  {
    "id": 1896,
    "type": "Return",
    "comment": "@return the current video quality",
    "code": "    public int getVideoQuality() {\n        return mCameraController.getVideoQuality();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1897,
    "type": "Return",
    "comment": "@return The {@link Symbol} annotation value for the class that object represents, or null if the annotation is not present.",
    "code": "public static String getSymbolValue(Object o) {\n    if (o instanceof Describable) {\n        return getSymbolValue(((Describable) o).getDescriptor().getClass());\n    } else {\n        return getSymbolValue(o.getClass());\n    }\n}",
    "label": 1,
    "rec": "@return The {@link Symbol} annotation value for the class (generally a {@link Descriptor} that object represents, or null if the annotation is not present."
  },
  {
    "id": 1898,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage getMessage(AlarmType alarmType) {\n\t\tif(isGetSupported == false) {\n\t\t\tlogger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlogger.debug(\"NODE {}: Creating new message for command SENSOR_ALARM_GET\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Get);\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \n    \t\t\t\t\t\t\t3, \n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \n\t\t\t\t\t\t\t\t(byte) SENSOR_ALARM_GET,\n\t\t\t\t\t\t\t\t(byte) alarmType.getKey() };\n    \tresult.setMessagePayload(newPayload);\n    \treturn result;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1899,
    "type": "Return",
    "comment": "@return start time formatted as a RFC 2445 DATE or DATE-TIME.</p>",
    "code": "public Date getStart() {\n    return start;\n}",
    "label": 1,
    "rec": "@return start time"
  },
  {
    "id": 1900,
    "type": "Return",
    "comment": "@return view name prefix",
    "code": "    public String getViewNamePrefix(SysSite site, SysDomain sysDomain) {\n        String path = CommonUtils.empty(sysDomain.getPath()) ? CommonConstants.BLANK\n                : sysDomain.getPath() + CommonConstants.SEPARATOR;\n        return getFullTemplatePath(site, path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1901,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Collection<Flash> getSupportedFlash() {\n        return Collections.unmodifiableSet(supportedFlash);\n    }\n",
    "label": 1,
    "rec": "@return a collection of supported values."
  },
  {
    "id": 1902,
    "type": "Return",
    "comment": "@return If transaction was not already present in committed set.",
    "code": "    public boolean addCommittedTx(IgniteInternalTx tx) {\n        boolean res = addCommittedTx(tx.xidVersion(), tx.nearXidVersion());\n\n        if (!tx.local() && !tx.near() && tx.onePhaseCommit())\n            addCommittedTx(tx.nearXidVersion(), null);\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1903,
    "type": "Return",
    "comment": "@return a dictionary of properties for this permission.",
    "code": "private Map<String, Object> getProperties() {\n    Map<String, Object> result = properties;\n    if (result != null) {\n        return result;\n    }\n    final Map<String, Object> props = new HashMap<String, Object>(NUM);\n    props.put(STR, getName());\n    if (bundle == null) {\n        return properties = props;\n    }\n    AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n        public Object run() {\n            props.put(STR, new Long(bundle.getBundleId()));\n            props.put(STR, bundle.getLocation());\n            String name = bundle.getSymbolicName();\n            if (name != null) {\n                props.put(STR, name);\n            }\n            SignerProperty signer = new SignerProperty(bundle);\n            if (signer.isBundleSigned()) {\n                props.put(STR, signer);\n            }\n            return null;\n        }\n    });\n    return properties = new Properties(props, attributes);\n}",
    "label": 1,
    "rec": "@return a map of properties for this permission."
  },
  {
    "id": 1904,
    "type": "Return",
    "comment": "@return a JSON asserter initialized with the provided document",
    "code": "    public static JsonAsserter with(Reader reader) throws ParseException, IOException {\n        try {\n            return new JsonAsserterImpl(JSON_PARSER.parse(convertReaderToString(reader)));\n        } catch (net.minidev.json.parser.ParseException e) {\n            throw new ParseException(e.toString(), e.getPosition());\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1905,
    "type": "Return",
    "comment": "@return true if the incoming request is an attempt to log in, false otherwise",
    "code": "    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {\n        HttpServletRequest httpRequest = toHttp(request);\n        String authzHeader = httpRequest.getHeader(AUTHORIZATION_HEADER);\n        return authzHeader != null && isLoginAttempt(authzHeader);\n    }\n",
    "label": 1,
    "rec": "@return true if the incoming request is an attempt to log in based, false otherwise"
  },
  {
    "id": 1906,
    "type": "Return",
    "comment": "@return  true If retry.",
    "code": "    private boolean findDown(final Get g, final long pageId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        Page page = page(pageId);\n\n        if (page == null)\n            return true; // Page was removed, retry.\n\n        try {\n            for (;;) {\n                // Init args.\n                g.pageId = pageId;\n                g.fwdId = fwdId;\n\n                int res = readPage(page, search, g, lvl, Get.RETRY);\n\n                switch (res) {\n                    case Get.RETRY:\n                        return true;\n\n                    case Get.GO_DOWN:\n                        assert g.pageId != pageId;\n                        assert g.fwdId != fwdId || fwdId == 0;\n\n                        // Go down recursively.\n                        if (findDown(g, g.pageId, g.fwdId, lvl - 1)) {\n                            checkInterrupted();\n\n                            continue; // The child page got splitted, need to reread our page.\n                        }\n\n                        return false;\n\n                    case Get.FOUND:\n                        return false; // We are done.\n\n                    case Get.NOT_FOUND:\n                        g.row = null; // Mark not found result.\n\n                        return false;\n\n                    default:\n                        assert false: res;\n                }\n            }\n        }\n        finally {\n            if (g.canRelease(page, lvl))\n                page.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1907,
    "type": "Return",
    "comment": "@return -1 if there have been no resourceRequest invocations",
    "code": "    public long getAvgResourceRequestWaitUs() {\n        long count = resourceRequestCount.get();\n        if(count > 0)\n            return totalResourceRequestTimeUs.get() / count;\n        return 0;\n    }\n",
    "label": 1,
    "rec": "@return 0 if there have been no resourceRequest invocations"
  },
  {
    "id": 1908,
    "type": "Return",
    "comment": "@return Integer reply, specifically: the cardinality (number of elements) of the set as an integer.",
    "code": "    public Long scard(final String key) {\n        runChecks();\n        client.scard(key);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1909,
    "type": "Return",
    "comment": "@return true if directory successfully added to jobConfigs",
    "code": "public boolean addJobDirectory(File dir) {\n    if (dir == null) {\n        return false;\n    }\n    File[] candidateConfigs = dir.listFiles(new FilenameFilter() {\n\n        public boolean accept(File dir, String name) {\n            return name.endsWith(STR);\n        }\n    });\n    if (candidateConfigs.length == NUM) {\n        return false;\n    }\n    if (jobConfigs.containsKey(dir.getName())) {\n        return false;\n    }\n    for (File cxml : candidateConfigs) {\n        try {\n            CrawlJob cj = new CrawlJob(cxml);\n            if (!cj.getJobDir().getParentFile().equals(getJobsDir())) {\n                writeJobPathFile(cj);\n            }\n            jobConfigs.put(cj.getShortName(), cj);\n            LOGGER.log(Level.INFO, STR + cj.getShortName());\n            return true;\n        } catch (IOException iae) {\n            LOGGER.log(Level.SEVERE, STR + dir, iae);\n        } catch (IllegalArgumentException iae) {\n            LOGGER.log(Level.SEVERE, STR + cxml, iae);\n        }\n    }\n    return false;\n}",
    "label": 1,
    "rec": "@return true if directory successfully added, false for any failure"
  },
  {
    "id": 1910,
    "type": "Return",
    "comment": "@return the tokenized command which can be processed by the ConsoleInterpreter",
    "code": "\tprotected String[] parseCommand(String command) {\n\t\tlogger.trace(\"going to parse command '{}'\", command);\n\t\tStreamTokenizer tokenizer = \n\t\t\tnew StreamTokenizer(new StringReader(command));\n\t\ttokenizer.wordChars('_', '_');\n\t\ttokenizer.wordChars('-', '-');\n\t\ttokenizer.wordChars('.', '.');\n\t\t\n\t\tList<String> tokens = new ArrayList<String>();\n\t\ttry {\n\t\t\tint tokenType = 0;\n\t\t\twhile (tokenType != StreamTokenizer.TT_EOF && tokenType != StreamTokenizer.TT_EOL) {\n\t\t\t\ttokenType = tokenizer.nextToken();\n\t\t\t\tString token = \"\"; \n\t\t\t\tswitch (tokenType) {\n\t\t\t\t\tcase StreamTokenizer.TT_WORD:\n\t\t\t\t\tcase 34 /* quoted String */:\n\t\t\t\t\t\ttoken = tokenizer.sval;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase StreamTokenizer.TT_NUMBER:\n\t\t\t\t\t\ttoken = String.valueOf(tokenizer.nval);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokens.add(token);\n\t\t\t\tlogger.trace(\"read value {} from the given command\", token);\n\t\t\t}\n\t\t} catch (IOException ioe) {}\n\n\t\treturn tokens.toArray(new String[0]);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1911,
    "type": "Return",
    "comment": "@return the {@link Optional}<{@link URI}> or {@link Optional#empty()} if it fails",
    "code": "protected URI asURI(String link) {\n    try {\n        return new URI(link);\n    } catch (URISyntaxException e) {\n        log.error(STR + link, e);\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return the {@link URI} or null if it fails"
  },
  {
    "id": 1912,
    "type": "Return",
    "comment": "@return Cache exception.",
    "code": "    private RuntimeException cacheException(IgniteCheckedException e) {\n        return CU.convertToCacheException(e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1913,
    "type": "Return",
    "comment": "@return first Element from 'next' contentModel. if type equals one of unary operations that'll be null.",
    "code": "public Element first() {\n    Element element = null;\n    if (type == DEFAULT_TYPE) {\n        element = (Element) content;\n    } else if (type == PLUS_TYPE || type == COMMA_TYPE) {\n        element = ((ContentModel) content).first();\n    }\n    return element;\n}",
    "label": 1,
    "rec": "@return The first element that must appear in the <code>ContentModel</code>. Null if zero or more than one <code>Element</code> occurrence is possible."
  },
  {
    "id": 1914,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static double gt(double value) {\n        return reportMatcher(new GreaterThan<Double>(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1915,
    "type": "Return",
    "comment": "@return Definitions factory or <code>null</code> if not found.",
    "code": "public DefinitionsFactory getDefinitionsFactory() {\n    return (DefinitionsFactory) applicationContext.getApplicationScope().get(DEFINITIONS_FACTORY);\n}",
    "label": 1,
    "rec": "@return Definitions impl or <code>null</code> if not found."
  },
  {
    "id": 1916,
    "type": "Return",
    "comment": "@return user object or a new user if none exists.",
    "code": "    public User getUser(String userName) {\n        //OVERLOADED CODE\n    \tString userNameLowered = userName.toLowerCase();\n    \tif (overloadedUsers.containsKey(userNameLowered)) {\n    \t\treturn overloadedUsers.get(userNameLowered);\n        }\n        //END CODE\n        if (getUsers().containsKey(userNameLowered)) {\n            return getUsers().get(userNameLowered);\n        }\n        User newUser = createUser(userName);\n        setUsersChanged(true);\n        return newUser;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1917,
    "type": "Return",
    "comment": "@return The filter string used by this listener.",
    "code": "public String toString() {\n    String filterString = getFilter();\n    if (filterString == null) {\n        filterString = STR;\n    }\n    return listener.getClass().getName() + STR + Integer.toHexString(System.identityHashCode(listener)) + filterString;\n}",
    "label": 1,
    "rec": "@return The string representation of this listener."
  },
  {
    "id": 1918,
    "type": "Return",
    "comment": "@return List of values (only 1 for Metadata) versioned byte[] eg. UTF bytes for cluster xml definitions",
    "code": "    public List<Versioned<byte[]>> get(ByteArray keyBytes, byte[] transforms)\n            throws VoldemortException {\n        // acquire read lock\n\n        readLock.lock();\n        try {\n            // get a read lock this prevents any sort of interleaving\\\n            // especially critical during reebalance when we set the new cluster\n            // and store xml\n\n            String key = ByteUtils.getString(keyBytes.get(), \"UTF-8\");\n\n            if(METADATA_KEYS.contains(key)) {\n                List<Versioned<byte[]>> values = Lists.newArrayList();\n\n                // Get the cached value and convert to string\n                Versioned<String> value = convertObjectToString(key, metadataCache.get(key));\n\n                // Metadata debugging information\n                if(logger.isTraceEnabled())\n                    logger.trace(\"Key \" + key + \" requested, returning: \" + value.getValue());\n\n                values.add(new Versioned<byte[]>(ByteUtils.getBytes(value.getValue(), \"UTF-8\"),\n                                                 value.getVersion()));\n\n                return values;\n            } else {\n                throw new VoldemortException(\"Unhandled Key:\" + key + \" for MetadataStore get()\");\n            }\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to read metadata key:\"\n                                                 + ByteUtils.getString(keyBytes.get(), \"UTF-8\")\n                                                 + \" delete config/.temp config/.version directories and restart.\",\n                                         e);\n        } finally {\n            readLock.unlock();\n        }\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1919,
    "type": "Return",
    "comment": "@return a new instance of a default {@link ValidationExceptionHandler}. Only called when no explicit {@link ValidationExceptionHandler} has been provided for validation.",
    "code": "protected ValidationExceptionHandler initializeHandler() {\n    return getHapiContext().getValidationExceptionHandler();\n}",
    "label": 1,
    "rec": "@return a new instance of a default {@link ValidationExceptionHandler} as specified in the {@link HapiContext}. Only called when no explicit {@link ValidationExceptionHandler} has been provided for validation using {@link #validate(Message, ValidationExceptionHandler)}."
  },
  {
    "id": 1920,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(SparseMatrix[] data, int fold) throws Exception {\n\n\t\tSparseMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\t\t\n\t\t\t/* baselines */\n\t\tcase \"globalavg\":\n\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"useravg\":\n\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"itemavg\":\n\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"random\":\n\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"constant\":\n\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"mostpop\":\n\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\n\t\t\t/* cores */\n\t\tcase \"userknn\":\n\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"itemknn\":\n\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"regsvd\":\n\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\tcase \"biasedmf\":\n\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\tcase \"svd++\":\n\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"pmf\":\n\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\tcase \"bpmf\":\n\t\t\treturn new BPMF(trainMatrix, testMatrix, fold);\n\t\tcase \"climf\":\n\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\tcase \"socialmf\":\n\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold);\n\t\tcase \"trustmf\":\n\t\t\treturn new TrustMF(trainMatrix, testMatrix, fold);\n\t\tcase \"wrmf\":\n\t\t\treturn new WRMF(trainMatrix, testMatrix, fold);\n\t\tcase \"bprmf\":\n\t\t\treturn new BPRMF(trainMatrix, testMatrix, fold);\n\t\tcase \"sorec\":\n\t\t\treturn new SoRec(trainMatrix, testMatrix, fold);\n\n\t\t\t/* extension */\n\t\tcase \"nmf\":\n\t\t\treturn new NMF(trainMatrix, testMatrix, fold);\n\t\tcase \"hybrid\":\n\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\tcase \"slopeone\":\n\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\n\t\tdefault:\n\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1921,
    "type": "Return",
    "comment": "@return true iff it fails.",
    "code": "private static boolean codeGenTest(String dirAndTest) {\n    dirAndTest = Util.unixizeFilepath(dirAndTest);\n    if (Jax.compile(dirAndTest + STR)) {\n        TestUtils.compileJava(dirAndTest + STR);\n        InputStream stdout = TestUtils.runJavaMain(dirAndTest + STR);\n        if (stdout != null) {\n            String output = Util.readAll(stdout);\n            if (output.trim().equals(STR)) {\n                if ((mode & VERBOSE) != NUM)\n                    System.out.println(STR + dirAndTest);\n                return true;\n            }\n        }\n    }\n    System.out.println(STR + dirAndTest);\n    return false;\n}",
    "label": 1,
    "rec": "@return true iff it passes."
  },
  {
    "id": 1922,
    "type": "Return",
    "comment": "@return an integer value specifying the maximum interval in seconds that a Session can remain inactive before it is considered expired.",
    "code": "\tpublic int getMaxInactiveIntervalInSeconds() {\n\t\treturn this.maxInactiveIntervalInSeconds;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1923,
    "type": "Return",
    "comment": "@return The count",
    "code": "public int getTotalResourceCount(K key) {\n    int rc = NUM;\n    if (!resourcePoolMap.containsKey(key)) {\n        return rc;\n    }\n    try {\n        Pool<V> resourcePool = getResourcePoolForExistingKey(key);\n        rc = resourcePool.size.get();\n    } catch (IllegalArgumentException iae) {\n        logger.debug(STR, iae);\n    }\n    return rc;\n}",
    "label": 1,
    "rec": "@return The count of existing resources. Returns 0 if no pool exists for given key."
  },
  {
    "id": 1924,
    "type": "Return",
    "comment": "@return date as a double.",
    "code": "    public static double getDoubleFromXMLDateString(String str) {\n        try {\n            DatatypeFactory dateFactory = DatatypeFactory.newInstance();\n            try {\n                return dateFactory.newXMLGregorianCalendar(str.length() > 23 ? str.substring(0, 23) : str).\n                        toGregorianCalendar().getTimeInMillis();\n            } catch (IllegalArgumentException ex) {\n                //Try simple format\n                SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                try {\n                    Date date = dateFormat.parse(str);\n                    return date.getTime();\n                } catch (ParseException ex1) {\n                    Exceptions.printStackTrace(ex1);\n                    return 0.0;\n                }\n            }\n        } catch (DatatypeConfigurationException ex) {\n            Exceptions.printStackTrace(ex);\n            return 0.0;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1925,
    "type": "Return",
    "comment": "@return a  LifecycleScopeProvider against this view.",
    "code": "  public static ScopeProvider from(View view) {\n    if (view == null) {\n      throw new NullPointerException(\"view == null\");\n    }\n    return new ViewScopeProvider(view);\n  }\n",
    "label": 1,
    "rec": "@return a  ScopeProvider against this view."
  },
  {
    "id": 1926,
    "type": "Return",
    "comment": "@return  True if all locks are owned.",
    "code": "    private boolean checkLocks() {\n        for (IgniteTxEntry<K, V> txEntry : tx.optimisticLockEntries()) {\n            while (true) {\n                GridCacheEntryEx<K, V> cached = txEntry.cached();\n\n                try {\n                    // Don't compare entry against itself.\n                    if (!cached.lockedLocally(tx.xidVersion())) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Transaction entry is not locked by transaction (will wait) [entry=\" + cached +\n                                \", tx=\" + tx + ']');\n\n                        return false;\n                    }\n\n                    break; // While.\n                }\n                // Possible if entry cached within transaction is obsolete.\n                catch (GridCacheEntryRemovedException ignored) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Got removed entry in future onAllReplies method (will retry): \" + txEntry);\n\n                    txEntry.cached(txEntry.context().cache().entryEx(txEntry.key()), txEntry.keyBytes());\n                }\n            }\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1927,
    "type": "Return",
    "comment": "@return The full URL to the root of the new instance, e.g. <code>styx://thehost.com:9092/mySGS/instances/1234567890abcde</code>. Note that the new instance may be created on a different server (for load balancing purposes, for example).",
    "code": "public SGSInstanceClient createNewInstance() throws StyxException {\n    String id = this.cloneFile.getContents();\n    CStyxFile instanceRoot = this.getInstanceFile(id);\n    return new SGSInstanceClient(this, instanceRoot);\n}",
    "label": 1,
    "rec": "@return SGSInstanceClient object representing the new instance"
  },
  {
    "id": 1928,
    "type": "Return",
    "comment": "@return GGFS mode.",
    "code": "    public IgfsMode mode() {\n        return mode;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1929,
    "type": "Return",
    "comment": "@return An array of {@link org.apache.lucene.document.Fieldable}",
    "code": "public IndexableField[] createFields(SchemaField field, Object value, float boost) {\n    IndexableField f = createField(field, value, boost);\n    return f == null ? new IndexableField[] {} : new IndexableField[] { f };\n}",
    "label": 1,
    "rec": "@return An array of {@link org.apache.lucene.index.IndexableField}"
  },
  {
    "id": 1930,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private ComputeJob job(final Callable<?> c) {\n        A.notNull(c, \"job\");\n\n        if (c instanceof GridComputeJobMasterLeaveAware) {\n            return new GridMasterLeaveAwareComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n\n                @Override public void onMasterNodeLeft(GridComputeTaskSession ses) throws GridException {\n                    ((GridComputeJobMasterLeaveAware)c).onMasterNodeLeft(ses);\n                }\n            };\n        }\n        else {\n            return new ComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1931,
    "type": "Return",
    "comment": "@return the results of the active directory search.",
    "code": "    protected LdapDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getLdapDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "@return the results of the LDAP directory search."
  },
  {
    "id": 1932,
    "type": "Return",
    "comment": "@return operate result",
    "code": "    public String recharge(@RequestAttribute SysSite site, BigDecimal change, @PathVariable(\"accountType\") String accountType,\n            String returnUrl, HttpServletRequest request, HttpSession session, ModelMap model) {\n        Map<String, String> config = configComponent.getConfigData(site.getId(), Config.CONFIG_CODE_SITE);\n        String safeReturnUrl = config.get(LoginConfigComponent.CONFIG_RETURN_URL);\n        if (ControllerUtils.isUnSafeUrl(returnUrl, site, safeReturnUrl, request)) {\n            returnUrl = site.isUseStatic() ? site.getSitePath() : site.getDynamicPath();\n        }\n        PaymentGateway paymentGateway = gatewayComponent.get(accountType);\n        if (null != paymentGateway && paymentGateway.enable(site.getId())) {\n            SysUser user = ControllerUtils.getUserFromSession(session);\n            if (null != user && null != change && 1 == change.compareTo(BigDecimal.ZERO)) {\n                String ip = RequestUtils.getIpAddress(request);\n                Date now = CommonUtils.getDate();\n                TradeOrder entity = new TradeOrder(site.getId(), user.getId(), change, ChargeProcessorComponent.GRADE_TYPE,\n                        UUID.randomUUID().toString(), accountType, ip, TradeOrderService.STATUS_PENDING_PAY, false, now);\n                orderService.create(entity);\n                TradeAccountHistory history = new TradeAccountHistory(site.getId(), UUID.randomUUID().toString(), user.getId(),\n                        user.getId(), change, BigDecimal.ZERO, BigDecimal.ZERO, TradeAccountHistoryService.STATUS_PEND, null,\n                        now);\n                historyService.save(history);\n                return UrlBasedViewResolver.REDIRECT_URL_PREFIX + site.getDynamicPath() + \"tradeOrder/pay/\" + accountType\n                        + \"?orderId=\" + entity.getId() + \"&returnUrl=\" + returnUrl;\n            }\n        }\n        return UrlBasedViewResolver.REDIRECT_URL_PREFIX + returnUrl;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1933,
    "type": "Return",
    "comment": "@return the Transaction that was created, or null if there are insufficient coins in the wallet.",
    "code": "    public Transaction sendCoinsOffline(SendRequest request) throws InsufficientMoneyException {\n        lock.lock();\n        try {\n            completeTx(request);\n            commitTx(request.tx);\n            return request.tx;\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@return the Transaction that was created"
  },
  {
    "id": 1934,
    "type": "Return",
    "comment": "@return Multi bulk reply",
    "code": "  public Set<String> smembers(final String key) {\n    checkIsInMulti();\n    client.smembers(key);\n    final List<String> members = client.getMultiBulkReply();\n    if (members == null) {\n      return null;\n    }\n    return SetFromList.of(members);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1935,
    "type": "Return",
    "comment": "@return The build platform.",
    "code": "public PlatformType getPlatform() {\n    return this.platform;\n}",
    "label": 1,
    "rec": "@return The operating system you are building for."
  },
  {
    "id": 1936,
    "type": "Return",
    "comment": "@return response object",
    "code": "    public JSONObject invoke(String method, Object... getParameters) throws IOException,\n            ActFmServiceException {\n        return invokeWithApi(null, method, getParameters);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1937,
    "type": "Return",
    "comment": "@return the name of the file, or the empty string if this is the root directory",
    "code": "public String getName() {\n    return this.name;\n}",
    "label": 1,
    "rec": "@return the name of this file"
  },
  {
    "id": 1938,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static int and(int first, int second) {\n        return LastArguments.instance().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1939,
    "type": "Return",
    "comment": "@return predicate with true on apply if job is buildable",
    "code": "public static <ITEM extends Item> Predicate<ITEM> isBuildable() {\n    return new Predicate<ITEM>() {\n\n        public boolean apply(ITEM item) {\n            return item instanceof Job ? ((Job<?, ?>) item).isBuildable() : item instanceof BuildableItem;\n        }\n    };\n}",
    "label": 1,
    "rec": "@return predicate with true on apply if item is buildable"
  },
  {
    "id": 1940,
    "type": "Return",
    "comment": "@return true, if successful",
    "code": "    private static boolean hasFieldProperModifier(Object object, Field field, boolean onlyInstanceFields) {\n        if (onlyInstanceFields) {\n            return !Modifier.isStatic(field.getModifiers());\n        } else if (object instanceof Class<?>) {\n            return Modifier.isStatic(field.getModifiers());\n        } else {\n            return !Modifier.isStatic(field.getModifiers());\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1941,
    "type": "Return",
    "comment": "@return Co",
    "code": "    public Collection<KeyCacheObject> cacheKeysView(Collection<?> keys) {\n        return cacheKeysView(keys, false);\n    }\n",
    "label": 1,
    "rec": "@return Read-only collection of KeyCacheObject instances."
  },
  {
    "id": 1942,
    "type": "Return",
    "comment": "@return EqualsBuilder - used to chain calls.",
    "code": "    public EqualsBuilder append(char lhs, char rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1943,
    "type": "Return",
    "comment": "@return A configuration configured via the stream",
    "code": "protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n    try {\n        List errors = new ArrayList();\n        Document document = xmlHelper.createSAXReader(resourceName, errors, entityResolver).read(new InputSource(stream));\n        if (errors.size() != NUM) {\n            throw new MappingException(STR, (Throwable) errors.get(NUM));\n        }\n        doConfigure(document);\n    } catch (DocumentException e) {\n        throw new HibernateException(STR + resourceName, e);\n    } finally {\n        try {\n            stream.close();\n        } catch (IOException ioe) {\n            log.warn(STR + resourceName, ioe);\n        }\n    }\n    return this;\n}",
    "label": 1,
    "rec": "@return this for method chaining"
  },
  {
    "id": 1944,
    "type": "Return",
    "comment": "@return New Hibernate  SessionFactory.",
    "code": "    private static SessionFactory createHibernateSessionFactory() {\n        ServiceRegistryBuilder builder = new ServiceRegistryBuilder();\n\n        builder.applySetting(\"hibernate.connection.url\", JDBC_URL);\n        builder.applySetting(\"hibernate.show_sql\", true);\n\n        return new Configuration().configure(U.resolveGridGainUrl(\"examples/config/hibernate/hibernate-L2-cache.xml\"))\n            .buildSessionFactory(builder.buildServiceRegistry());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1945,
    "type": "Return",
    "comment": "@return the new byte array backed by a buffer or an array",
    "code": "    public static UByteIndexer create(final BytePointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new UByteRawIndexer(pointer, sizes, strides)\n                                             : new UByteBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            byte[] array = new byte[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new UByteArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new byte indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 1946,
    "type": "Return",
    "comment": "@return File ID.",
    "code": "    public IgniteUuid getFileId() {\n        return fileId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1947,
    "type": "Return",
    "comment": "@return Returns a X509 certificate",
    "code": "public X509Certificate loadCertificate(InputStream in) throws WSSecurityException {\n    try {\n        CertificateFactory certFactory = getCertificateFactory();\n        return (X509Certificate) certFactory.generateCertificate(in);\n    } catch (CertificateException e) {\n        throw new WSSecurityException(WSSecurityException.SECURITY_TOKEN_UNAVAILABLE, STR, null, e);\n    }\n}",
    "label": 1,
    "rec": "@return An X509 certificate"
  },
  {
    "id": 1948,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private ComputeJob job(final Callable<?> c) {\n        A.notNull(c, \"job\");\n\n        if (c instanceof GridComputeJobMasterLeaveAware) {\n            return new GridMasterLeaveAwareComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n\n                @Override public void onMasterNodeLeft(GridComputeTaskSession ses) throws GridException {\n                    ((GridComputeJobMasterLeaveAware)c).onMasterNodeLeft(ses);\n                }\n            };\n        }\n        else {\n            return new GridComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1949,
    "type": "Return",
    "comment": "@return IRosterEntry that is current workbenchwindow selection. Returns <code>null</code> if nothing is selected.",
    "code": "protected IRosterEntry getSelectedRosterEntry() {\n    Object selection = getSelection();\n    if (selection instanceof IRosterEntry)\n        return (IRosterEntry) selection;\n    return null;\n}",
    "label": 1,
    "rec": "@return IRosterEntry that is current workbenchwindow selection. Returns <code>null</code> if nothing is selected or if something other than IRosterEntry is selected."
  },
  {
    "id": 1950,
    "type": "Return",
    "comment": "@return Affinity cached function.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, GridNode n)\n        throws GridException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        GridCacheAffinityFunction f = (GridCacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        GridCacheAffinityKeyMapper m = (GridCacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        Boolean portableEnabled = U.portableEnabled(n, cacheName);\n\n        return new AffinityInfo(f, m, t.get3(), portableEnabled != null && portableEnabled);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1951,
    "type": "Return",
    "comment": "@return String[]",
    "code": "@Override\n@NonNull\npublic String[] selectImports(@NonNull AnnotationMetadata importingClassMetadata) {\n    boolean enabledTxc = Boolean.valueOf(Objects.requireNonNull(importingClassMetadata.getAnnotationAttributes(EnableDistributedTransaction.class.getName())).get(STR).toString());\n    List<String> importClasses = new ArrayList<>();\n    importClasses.add(STR);\n    if (enabledTxc) {\n        importClasses.add(TxcConfiguration.class.getName());\n    }\n    return importClasses.toArray(new String[NUM]);\n}",
    "label": 1,
    "rec": "@return spi classes"
  },
  {
    "id": 1952,
    "type": "Return",
    "comment": "@return  True if entry is visitable.",
    "code": "    public boolean visitable(GridPredicate<GridCacheEntry<K, V>>[] filter) {\n        try {\n            if (obsoleteOrDeleted() || (filter != CU.<K, V>empty() && !cctx.isAll(wrap(false), filter)))\n                return false;\n        }\n        catch (GridException e) {\n            U.error(log, \"An exception was thrown while filter checking.\", e);\n\n            RuntimeException ex = e.getCause(RuntimeException.class);\n\n            if (ex != null)\n                throw ex;\n\n            Error err = e.getCause(Error.class);\n\n            if (err != null)\n                throw err;\n\n            return false;\n        }\n\n        GridCacheTxEx<K, V> tx = cctx.tm().localTxx();\n\n        return tx == null || !tx.removed(txKey());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1953,
    "type": "Return",
    "comment": "@return The source result at the given position.",
    "code": "public SuggestionCursor getSourceResult(ComponentName source) {\n    if (mClosed) {\n        throw new IllegalStateException(STR + source + STR);\n    }\n    return mSourceResultsBySource.get(source);\n}",
    "label": 1,
    "rec": "@return The source result for the given source. {@code null} if the source has not yet returned."
  },
  {
    "id": 1954,
    "type": "Return",
    "comment": "@return clone of Cluster cluster.",
    "code": "    public static Cluster cloneCluster(Cluster cluster) {\n        // Could add a better .clone() implementation that clones the derived\n        // data structures. The constructor invoked by this clone implementation\n        // can be slow for large numbers of partitions. Probably faster to copy\n        // all the maps and stuff.\n        return new Cluster(cluster.getName(),\n                           new ArrayList<Node>(cluster.getNodes()),\n                           new ArrayList<Zone>(cluster.getZones()));\n        /*-\n         * Historic \"clone\" code being kept in case this, for some reason, was the \"right\" way to be doing this.\n        ClusterMapper mapper = new ClusterMapper();\n        return mapper.readCluster(new StringReader(mapper.writeCluster(cluster)));\n         */\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1955,
    "type": "Return",
    "comment": "@return Array of AnalyzedTokenReadings that match equivalence relation defined for features tested.",
    "code": "@Nullable\npublic final AnalyzedTokenReadings[] getUnifiedTokens() {\n    if (tokSequence.isEmpty()) {\n        return null;\n    }\n    List<AnalyzedTokenReadings> uTokens = new ArrayList<>();\n    for (int j = NUM; j < tokSequence.size(); j++) {\n        boolean unifiedTokensFound = false;\n        for (int i = NUM; i < tokSequenceEquivalences.get(j).size(); i++) {\n            int featUnified = NUM;\n            if (tokSequenceEquivalences.get(j).get(i).containsKey(UNIFY_IGNORE)) {\n                addTokenToSequence(uTokens, tokSequence.get(j).getAnalyzedToken(i), j);\n                unifiedTokensFound = true;\n            } else {\n                for (final Map.Entry<String, List<String>> feat : unificationFeats.entrySet()) {\n                    if (tokSequenceEquivalences.get(j).get(i).containsKey(feat.getKey()) && tokSequenceEquivalences.get(j).get(i).get(feat.getKey()).isEmpty()) {\n                        featUnified = NUM;\n                    } else {\n                        featUnified++;\n                    }\n                    if (featUnified == unificationFeats.entrySet().size()) {\n                        addTokenToSequence(uTokens, tokSequence.get(j).getAnalyzedToken(i), j);\n                        unifiedTokensFound = true;\n                    }\n                }\n            }\n        }\n        if (!unifiedTokensFound) {\n            return null;\n        }\n    }\n    return uTokens.toArray(new AnalyzedTokenReadings[uTokens.size()]);\n}",
    "label": 1,
    "rec": "@return Array of AnalyzedTokenReadings that match equivalence relation defined for features tested, or {@code null}"
  },
  {
    "id": 1956,
    "type": "Return",
    "comment": "@return  true If we have fetched all the remote rows.",
    "code": "    public boolean fetchedAll() {\n        return fetchedCnt == rowsCnt.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1957,
    "type": "Return",
    "comment": "@return The brightness as a value from 0 -  HueBulb#MAX_BRIGHTNESS",
    "code": "\tpublic int getBrightness(int deviceNumber) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(Integer.toString(deviceNumber)).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 1,
    "rec": "@return The brightness as a value from 0 - 255"
  },
  {
    "id": 1958,
    "type": "Return",
    "comment": "@return Swap key.",
    "code": "    private SwapKey key(int i) {\n        return new SwapKey(new KeyCacheObjectImpl(i, U.intToBytes(i)), i % 11, U.intToBytes(i));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1959,
    "type": "Return",
    "comment": "@return A depth-ordered set of the nodes in the doc.",
    "code": "private static List<NodeDepth> initialiseAndOrderNodes(final Document doc) {\n    NodeIterator ni = ((DocumentTraversal) doc).createNodeIterator(doc.getDocumentElement(), NodeFilter.SHOW_ALL, null, false);\n    List<NodeDepth> depthSorted = new ArrayList<NodeDepth>();\n    Node n;\n    while ((n = ni.nextNode()) != null) {\n        depthSorted.add(new NodeDepth(n));\n    }\n    ni.detach();\n    Collections.sort(depthSorted, new NodeDepthComparator());\n    return depthSorted;\n}",
    "label": 1,
    "rec": "@return A depth-ordered list of the nodes in the doc."
  },
  {
    "id": 1960,
    "type": "Return",
    "comment": "@return the predicted class label. If the instance is of all zeros, return returns Integer.MIN_VALUE.",
    "code": "    public int predict(SparseArray x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob;\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    logprob = Math.log(priori[i]);\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += e.x * logcondprob[i][e.i];\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    logprob = Math.log(priori[i]);\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += logcondprob[i][e.i];\n                        } else {\n                            logprob += Math.log(1.0 - Math.exp(logcondprob[i][e.i]));\n                        }\n                    }\n                    break;\n\n                case CNB:\n                case WCNB:\n                case TWCNB:\n                    logprob = 0.0;\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob -= e.x * logcondprob[i][e.i];\n                        }\n                    }\n                    break;\n\n                default:\n                    // we should never reach here\n                    throw new IllegalStateException(\"Unknown model: \" + model);\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        MathEx.softmax(posteriori);\n        return labels.valueOf(MathEx.whichMax(posteriori));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1961,
    "type": "Return",
    "comment": "@return a plain-text representation of this text construct",
    "code": "@Override\npublic String getPlainText() {\n    return !isEmpty() ? HtmlToText.htmlToPlainText(html) : null;\n}",
    "label": 1,
    "rec": "@return a plain-text representation of this text construct or {@code null} if there is no html content."
  },
  {
    "id": 1962,
    "type": "Return",
    "comment": "@return IP finder.",
    "code": "    public TcpDiscoveryIpFinder getIpFinder() {\n        return new GridTcpDiscoveryVmIpFinder(true);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1963,
    "type": "Return",
    "comment": "@return Report File Name extracted from APX. If not specified there, a new report file section will be created in the internal APX tree.",
    "code": "public FilePath getReportFile() {\n    FilePath reportFile = extractRealPathFromElementText(STR);\n    if (reportFile == null) {\n        listener.getLogger().println(STR);\n    }\n    return reportFile;\n}",
    "label": 1,
    "rec": "@return Report File extracted from APX. If not specified there, a new report file section will be created in the internal APX tree."
  },
  {
    "id": 1964,
    "type": "Return",
    "comment": "@return Name of the scheduled job",
    "code": "    public String addScheduledJob(int interval, IScheduledJob job) {\n        if (schedulingService == null) {\n            schedulingService = (ISchedulingService) ScopeUtils.getScopeService(scope, ISchedulingService.class, JDKSchedulingService.class, false);\n        }\n        return schedulingService.addScheduledJob(interval, job);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1965,
    "type": "Return",
    "comment": "@return a new matrix with results of {@code C = A - B}",
    "code": "public DenseMatrix minus(Matrix otherMatrix) {\n    DenseMatrix denseMatrix = this.clone();\n    for (MatrixEntry matrixEntry : otherMatrix) {\n        denseMatrix.plus(matrixEntry.row(), matrixEntry.column(), -matrixEntry.get());\n    }\n    return denseMatrix;\n}",
    "label": 1,
    "rec": "@return a new Matrix"
  },
  {
    "id": 1966,
    "type": "Return",
    "comment": "@return HystrixCommandProperties",
    "code": "    /* package */static HystrixCommandProperties asMock(final Setter builder) {\n        return new HystrixCommandProperties(TestKey.TEST) {\n\n            @Override\n            public HystrixProperty<Boolean> circuitBreakerEnabled() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerEnabled());\n            }\n\n            @Override\n            public HystrixProperty<Integer> circuitBreakerErrorThresholdPercentage() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerErrorThresholdPercentage());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> circuitBreakerForceClosed() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerForceClosed());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> circuitBreakerForceOpen() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerForceOpen());\n            }\n\n            @Override\n            public HystrixProperty<Integer> circuitBreakerRequestVolumeThreshold() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerRequestVolumeThreshold());\n            }\n\n            @Override\n            public HystrixProperty<Integer> circuitBreakerSleepWindowInMilliseconds() {\n                return HystrixProperty.Factory.asProperty(builder.getCircuitBreakerSleepWindowInMilliseconds());\n            }\n\n            @Override\n            public HystrixProperty<Integer> executionIsolationSemaphoreMaxConcurrentRequests() {\n                return HystrixProperty.Factory.asProperty(builder.getExecutionIsolationSemaphoreMaxConcurrentRequests());\n            }\n\n            @Override\n            public HystrixProperty<ExecutionIsolationStrategy> executionIsolationStrategy() {\n                return HystrixProperty.Factory.asProperty(builder.getExecutionIsolationStrategy());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> executionIsolationThreadInterruptOnTimeout() {\n                return HystrixProperty.Factory.asProperty(builder.getExecutionIsolationThreadInterruptOnTimeout());\n            }\n\n            @Override\n            public HystrixProperty<String> executionIsolationThreadPoolKeyOverride() {\n                return HystrixProperty.Factory.nullProperty();\n            }\n\n            @Override\n            public HystrixProperty<Integer> executionTimeoutInMilliseconds() {\n                return HystrixProperty.Factory.asProperty(builder.getExecutionTimeoutInMilliseconds());\n            }\n\n            @Override\n            public HystrixProperty<Integer> fallbackIsolationSemaphoreMaxConcurrentRequests() {\n                return HystrixProperty.Factory.asProperty(builder.getFallbackIsolationSemaphoreMaxConcurrentRequests());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> fallbackEnabled() {\n                return HystrixProperty.Factory.asProperty(builder.getFallbackEnabled());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsHealthSnapshotIntervalInMilliseconds() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsHealthSnapshotIntervalInMilliseconds());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsRollingPercentileBucketSize() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingPercentileBucketSize());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> metricsRollingPercentileEnabled() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingPercentileEnabled());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsRollingPercentileWindow() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingPercentileWindowInMilliseconds());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsRollingPercentileWindowBuckets() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingPercentileWindowBuckets());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsRollingStatisticalWindowInMilliseconds() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingStatisticalWindowInMilliseconds());\n            }\n\n            @Override\n            public HystrixProperty<Integer> metricsRollingStatisticalWindowBuckets() {\n                return HystrixProperty.Factory.asProperty(builder.getMetricsRollingStatisticalWindowBuckets());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> requestCacheEnabled() {\n                return HystrixProperty.Factory.asProperty(builder.getRequestCacheEnabled());\n            }\n\n            @Override\n            public HystrixProperty<Boolean> requestLogEnabled() {\n                return HystrixProperty.Factory.asProperty(builder.getRequestLogEnabled());\n            }\n\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1967,
    "type": "Return",
    "comment": "@return true iff this flow info prevents local from being promoted to definite non null or definite null against an enclosing flow info",
    "code": "public boolean cannotBeDefinitelyNullOrNonNull(VariableBinding binding) {\n    return isPotentiallyUnknown(binding) || isPotentiallyNonNull(binding) && isPotentiallyNull(binding);\n}",
    "label": 1,
    "rec": "@return true iff this flow info prevents field or local from being promoted to definite non null or definite null against an enclosing flow info"
  },
  {
    "id": 1968,
    "type": "Return",
    "comment": "@return Parsed message.",
    "code": "    @Nullable private GridClientMessage parseCustomPacket(GridNioSession ses, ByteBuffer buf, ParserState state)\n        throws IOException, IgniteCheckedException {\n        assert state.packetType() == GridClientPacketType.GRIDGAIN;\n        assert state.packet() == null;\n\n        ByteArrayOutputStream tmp = state.buffer();\n\n        int len = state.index();\n\n        if (buf.remaining() > 0) {\n            if (len == 0) { // Don't know the size yet.\n                byte[] lenBytes = statefulRead(buf, tmp, 4);\n\n                if (lenBytes != null) {\n                    len = U.bytesToInt(lenBytes, 0);\n\n                    if (len == 0)\n                        return GridClientPingPacket.PING_MESSAGE;\n                    else if (len < 0)\n                        throw new IOException(\"Failed to parse incoming packet (invalid packet length) [ses=\" + ses +\n                            \", len=\" + len + ']');\n\n                    state.index(len);\n                }\n            }\n\n            if (len > 0 && state.header() == null) {\n                byte[] hdrBytes = statefulRead(buf, tmp, 40);\n\n                if (hdrBytes != null) {\n                    long reqId = GridClientByteUtils.bytesToLong(hdrBytes, 0);\n                    UUID clientId = GridClientByteUtils.bytesToUuid(hdrBytes, 8);\n                    UUID destId = GridClientByteUtils.bytesToUuid(hdrBytes, 24);\n\n                    state.header(new HeaderData(reqId, clientId, destId));\n                }\n            }\n\n            if (len > 0 && state.header() != null) {\n                final int packetSize = len - 40;\n\n                if (tmp.size() + buf.remaining() >= packetSize) {\n                    if (buf.remaining() > 0) {\n                        byte[] bodyBytes = new byte[packetSize - tmp.size()];\n\n                        buf.get(bodyBytes);\n\n                        tmp.write(bodyBytes);\n                    }\n\n                    return parseClientMessage(ses, state);\n                }\n                else\n                    copyRemaining(buf, tmp);\n            }\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1969,
    "type": "Return",
    "comment": "@return true if connection took place, false if the referenced transaction was not in the list.",
    "code": "    public ConnectionResult connect(Transaction transaction, ConnectMode mode) {\n        if (!transaction.getHash().equals(outpoint.getHash()))\n            return ConnectionResult.NO_SUCH_TX;\n        checkElementIndex((int) outpoint.getIndex(), transaction.getOutputs().size(), \"Corrupt transaction\");\n        TransactionOutput out = transaction.getOutput((int) outpoint.getIndex());\n        if (!out.isAvailableForSpending()) {\n            if (mode == ConnectMode.DISCONNECT_ON_CONFLICT) {\n                out.markAsUnspent();\n            } else if (mode == ConnectMode.ABORT_ON_CONFLICT) {\n                outpoint.fromTx = checkNotNull(out.parentTransaction);\n                return TransactionInput.ConnectionResult.ALREADY_SPENT;\n            }\n        }\n        connect(out);\n        return TransactionInput.ConnectionResult.SUCCESS;\n    }\n",
    "label": 1,
    "rec": "@return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not."
  },
  {
    "id": 1970,
    "type": "Return",
    "comment": "@return Cached value.",
    "code": "    @Nullable public V get(K key, boolean deserializePortable)\n        throws IgniteCheckedException {\n        Map<K, V> map = getAllAsync(F.asList(key), deserializePortable).get();\n\n        assert map.isEmpty() || map.size() == 1 : map.size();\n\n        return map.isEmpty() ? null : map.values().iterator().next();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1971,
    "type": "Return",
    "comment": "@return the array of string tokens or <code>null</code> if there are none",
    "code": "public static String[] getArrayFromList(String stringList, String separator) {\n    if (stringList == null || stringList.trim().length() == NUM)\n        return new String[NUM];\n    ArrayList list = new ArrayList();\n    StringTokenizer tokens = new StringTokenizer(stringList, separator);\n    while (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken().trim();\n        if (token.length() != NUM)\n            list.add(token);\n    }\n    return (String[]) list.toArray(new String[list.size()]);\n}",
    "label": 1,
    "rec": "@return the array of string tokens. If there are none then an empty array is returned."
  },
  {
    "id": 1972,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static float or(float first, float second) {\n        return LastArguments.instance().reportOr().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1973,
    "type": "Return",
    "comment": "@return {@link MRInputConfigurer}",
    "code": "public MRInputConfigBuilder groupSplits(boolean value) {\n    groupSplitsInAM = value;\n    return this;\n}",
    "label": 1,
    "rec": "@return {@link org.apache.tez.mapreduce.input.MRInput.MRInputConfigBuilder}"
  },
  {
    "id": 1974,
    "type": "Return",
    "comment": "@return New instance of CacheOperationContext with specific subject id.",
    "code": "    public CacheOperationContext forSubjectId(UUID subjId) {\n        return new CacheOperationContext(\n            skipStore,\n            subjId,\n            keepBinary,\n            expiryPlc,\n            noRetries,\n            dataCenterId,\n            recovery);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1975,
    "type": "Return",
    "comment": "@return true if this is the first time remove is called.",
    "code": "public boolean remove() {\n    return content.remove(this);\n}",
    "label": 1,
    "rec": "@return true if removed."
  },
  {
    "id": 1976,
    "type": "Return",
    "comment": "@return intent",
    "code": "    public static Intent createIntent(Repository repository) {\n        return createIntent(null, repository.getOwner().getLogin(),\n                repository.getName(), repository.getOwner());\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1977,
    "type": "Return",
    "comment": "@return decorator that caches the service instance until told otherwise.",
    "code": "public static <S> ImportDecorator<S> sticky(final Callable<Boolean> resetTask) {\n    return new StickyDecorator<S>(resetTask);\n}",
    "label": 1,
    "rec": "@return decorator that caches service instances."
  },
  {
    "id": 1978,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteInternalFuture<IgniteInternalTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteInternalFuture<IgniteInternalTx<K, V>> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteInternalFuture<IgniteInternalTx>)(IgniteInternalFuture)prep;\n\n            return new GridFinishedFuture<IgniteInternalTx>(cctx.kernalContext(), this);\n        }\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (IgniteTxOptimisticCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listenAsync(new CI1<IgniteInternalFuture<IgniteInternalTx<K, V>>>() {\n                @Override public void apply(IgniteInternalFuture<IgniteInternalTx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (IgniteTxOptimisticCheckedException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (IgniteCheckedException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1979,
    "type": "Return",
    "comment": "@return a matrix with results of {@code C = A + B}",
    "code": "public DenseMatrix add(double val) {\n    DenseMatrix res = new DenseMatrix(numRows, numColumns);\n    for (int i = NUM; i < numRows; i++) for (int j = NUM; j < numColumns; j++) res.data[i][j] = data[i][j] + val;\n    return res;\n}",
    "label": 1,
    "rec": "@return a new matrix with results of {@code C = A + c}"
  },
  {
    "id": 1980,
    "type": "Return",
    "comment": "@return Keep portable flag.",
    "code": "    public boolean keepPortable() {\n        GridCacheProjectionImpl<K, V> prj = projectionPerCall();\n\n        return prj != null && prj.isKeepPortable();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1981,
    "type": "Return",
    "comment": "@return  True if node for given ID is alive.",
    "code": "    public boolean alive(ClusterNode node) {\n        assert node != null;\n\n        return alive(node.id());\n    }\n",
    "label": 1,
    "rec": "@return  True if node is alive."
  },
  {
    "id": 1982,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static long or(long first, long second) {\n        return LastArguments.instance().reportOr().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1983,
    "type": "Return",
    "comment": "@return A measure of utility that ought to be minimized.",
    "code": "public double getUtility() {\n    return getMaxMinRatio();\n}",
    "label": 1,
    "rec": "@return utility metric that ought to be minimized."
  },
  {
    "id": 1984,
    "type": "Return",
    "comment": "@return Commit future.",
    "code": "    public IgniteFuture<GridCacheTx> rollbackAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Rolling back colocated tx locally: \" + this);\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/false);\n\n        cctx.mvcc().addFuture(fut);\n\n        IgniteFuture<GridCacheTxEx<K, V>> prep = prepFut.get();\n\n        if (prep == null || prep.isDone()) {\n            try {\n                if (prep != null)\n                    prep.get();\n            }\n            catch (GridException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to prepare transaction during rollback (will ignore) [tx=\" + this + \", msg=\" +\n                        e.getMessage() + ']');\n            }\n\n            fut.finish();\n        }\n        else\n            prep.listenAsync(new CI1<IgniteFuture<GridCacheTxEx<K, V>>>() {\n                @Override public void apply(IgniteFuture<GridCacheTxEx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n                    }\n                    catch (GridException e) {\n                        log.debug(\"Failed to prepare transaction during rollback (will ignore) [tx=\" + this + \", msg=\" +\n                            e.getMessage() + ']');\n                    }\n\n                    fut.finish();\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1985,
    "type": "Return",
    "comment": "@return the window at provided timestamp",
    "code": "public WindowWrap<T> currentWindow(long time) {\n    long timeId = time / windowLengthInMs;\n    int idx = (int) (timeId % array.length());\n    long windowStart = time - time % windowLengthInMs;\n    while (true) {\n        WindowWrap<T> old = array.get(idx);\n        if (old == null) {\n            WindowWrap<T> window = new WindowWrap<T>(windowLengthInMs, windowStart, newEmptyBucket());\n            if (array.compareAndSet(idx, null, window)) {\n                return window;\n            } else {\n                Thread.yield();\n            }\n        } else if (windowStart == old.windowStart()) {\n            return old;\n        } else if (windowStart > old.windowStart()) {\n            if (updateLock.tryLock()) {\n                try {\n                    return resetWindowTo(old, windowStart);\n                } finally {\n                    updateLock.unlock();\n                }\n            } else {\n                Thread.yield();\n            }\n        } else if (windowStart < old.windowStart()) {\n            return new WindowWrap<T>(windowLengthInMs, windowStart, newEmptyBucket());\n        }\n    }\n}",
    "label": 1,
    "rec": "@return current bucket item at provided timestamp"
  },
  {
    "id": 1986,
    "type": "Return",
    "comment": "@return Authentication subject context.",
    "code": "    private SecurityContext authenticate(GridRestRequest req) throws IgniteCheckedException {\n        UUID clientId = req.clientId();\n        SecurityContext secCtx = clientId == null ? null : sesMap.get(clientId);\n\n        if (secCtx != null)\n            return secCtx;\n\n        // Authenticate client if invalid session.\n        AuthenticationContext authCtx = new AuthenticationContext();\n\n        authCtx.subjectType(REMOTE_CLIENT);\n        authCtx.subjectId(req.clientId());\n\n        GridSecurityCredentials cred;\n\n        if (req.credentials() instanceof GridSecurityCredentials)\n            cred = (GridSecurityCredentials)req.credentials();\n        else if (req.credentials() instanceof String) {\n            String credStr = (String)req.credentials();\n\n            int idx = credStr.indexOf(':');\n\n            cred = idx >= 0 && idx < credStr.length() ?\n                new GridSecurityCredentials(credStr.substring(0, idx), credStr.substring(idx + 1)) :\n                new GridSecurityCredentials(credStr, null);\n        }\n        else {\n            cred = new GridSecurityCredentials();\n\n            cred.setUserObject(req.credentials());\n        }\n\n        authCtx.address(req.address());\n\n        authCtx.credentials(cred);\n\n        SecurityContext subjCtx = ctx.security().authenticate(authCtx);\n\n        if (subjCtx == null) {\n            if (req.credentials() == null)\n                throw new IgniteCheckedException(\"Failed to authenticate remote client (secure session SPI not set?): \" + req);\n            else\n                throw new IgniteCheckedException(\"Failed to authenticate remote client (invalid credentials?): \" + req);\n        }\n\n        return subjCtx;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1987,
    "type": "Return",
    "comment": "@return the default options vector with new values for the given options",
    "code": "public static Map<String, Double> jp_jpoption() {\n    return jp_jpoption(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);\n}",
    "label": 1,
    "rec": "@return the default options vector."
  },
  {
    "id": 1988,
    "type": "Return",
    "comment": "@return Metrics adapter.",
    "code": "    private ClusterMetricsSnapshot createMetrics(int waitingJobs, int activeJobs) {\n        ClusterMetricsSnapshot metrics = new ClusterMetricsSnapshot();\n\n        metrics.setCurrentWaitingJobs(waitingJobs);\n        metrics.setCurrentActiveJobs(activeJobs);\n\n        return metrics;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1989,
    "type": "Return",
    "comment": "@return A Collection of User object who are custodians of a user. Returns an empty Collection if no custodians are found.",
    "code": "public Collection getCustodiansFor(User user) throws NoCustodianFound, RemoteException {\n    String userName = null;\n    try {\n        userName = user.getName();\n        Collection coll = user.getReverseRelatedBy(this.RELATION_TYPE_GROUP_CUSTODIAN);\n        if (coll == null || coll.isEmpty()) {\n            try {\n                coll = this.getParentsFor(user);\n                return coll;\n            } catch (NoParentFound ex) {\n                throw new NoCustodianFound(userName);\n            }\n        }\n        return convertGroupCollectionToUserCollection(coll);\n    } catch (Exception e) {\n        throw new NoCustodianFound(userName);\n    }\n}",
    "label": 1,
    "rec": "@return A Collection of User object who are custodians of a user. If no custodian is found it will return the parents of that user. Returns an empty Collection if no custodians or parents are found."
  },
  {
    "id": 1990,
    "type": "Return",
    "comment": "@return a list of permission tickets associated with the given resourceId",
    "code": "    public List<PermissionTicketRepresentation> findByResource(final String resourceId) {\n        if (resourceId == null) {\n            throw new IllegalArgumentException(\"Resource id must not be null\");\n        }\n        Callable<List<PermissionTicketRepresentation>> callable = new Callable<List<PermissionTicketRepresentation>>() {\n            @Override\n            public List<PermissionTicketRepresentation> call() throws Exception {\n                return http.<List<PermissionTicketRepresentation>>get(serverConfiguration.getPermissionEndpoint()+\"/ticket\")\n                        .authorizationBearer(pat.call())\n                        .param(\"resourceId\", resourceId)\n                        .response().json(new TypeReference<List<PermissionTicketRepresentation>>(){}).execute();\n            }\n        };\n        try {\n            return callable.call();\n        } catch (Exception cause) {\n            return Throwables.retryAndWrapExceptionIfNecessary(callable, pat, \"Error querying permission ticket by resource\", cause);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1991,
    "type": "Return",
    "comment": "@return prefix:localName, or localName if prefix is null",
    "code": "public String getPrefixedName() {\n    final String attributeQualifier = name.getQualifier();\n    if (parent == null || attributeQualifier == null)\n        return getLocalName();\n    final String elementQualifier = parent.getQualifiedName().getQualifier();\n    if (elementQualifier == null || attributeQualifier.equals(elementQualifier))\n        return getLocalName();\n    final String prefix = parent.getNamespacePrefix(attributeQualifier);\n    return (prefix == null ? STR : prefix + STR) + getLocalName();\n}",
    "label": 1,
    "rec": "@return prefix:localName, or localName if prefix is null or this attribute is in the same namespace as the parent element."
  },
  {
    "id": 1992,
    "type": "Return",
    "comment": "@return Communication SPI.",
    "code": "    protected BlockTcpCommunicationSpi commSpi(Ignite ignite) {\n        return ((BlockTcpCommunicationSpi)ignite.configuration().getCommunicationSpi());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1993,
    "type": "Return",
    "comment": "@return a Float[] which is the new centroid",
    "code": "public Vector computeCentroid() {\n    Vector result = new SparseVector(pointTotal.cardinality());\n    for (int i = NUM; i < pointTotal.cardinality(); i++) result.set(i, new Double(pointTotal.get(i) / numPoints));\n    return result;\n}",
    "label": 1,
    "rec": "@return a point which is the new centroid"
  },
  {
    "id": 1994,
    "type": "Return",
    "comment": "@return Serializer.",
    "code": "    protected JavaObjectSerializer h2Serializer() {\n        return new JavaObjectSerializer() {\n                @Override public byte[] serialize(Object obj) throws Exception {\n                    return marshaller.marshal(obj);\n                }\n\n                @Override public Object deserialize(byte[] bytes) throws Exception {\n                    ClassLoader clsLdr = ctx != null ? U.resolveClassLoader(ctx.config()) : null;\n\n                    return marshaller.unmarshal(bytes, clsLdr);\n                }\n            };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1995,
    "type": "Return",
    "comment": "@return list of users",
    "code": "    public List<User> getOrgs() throws IOException {\n        SQLiteOpenHelper helper = new CacheHelper(context);\n        try {\n            List<User> userAndOrgs = loadUserAndOrgsFromDB(helper);\n\n            return userAndOrgs == null ? requestAndStoreUserAndOrgs(helper) : userAndOrgs;\n        } finally {\n            helper.close();\n        }\n    }\n",
    "label": 1,
    "rec": "@return list of user and Orgs"
  },
  {
    "id": 1996,
    "type": "Return",
    "comment": "@return the response body or NULL when the request went wrong",
    "code": "\tpublic static String executeUrl(String httpMethod, String url, Properties httpHeaders, InputStream content, String contentType, int timeout, String proxyHost, Integer proxyPort, String proxyUser, String proxyPassword, String nonProxyHosts) {\n\t\t\n\t\tHttpClient client = new HttpClient();\n\t\t\n\t\t// only configure a proxy if a host is provided\n\t\tif (StringUtils.isNotBlank(proxyHost) && proxyPort != null && shouldUseProxy(url, nonProxyHosts)) {\n\t\t\tclient.getHostConfiguration().setProxy(proxyHost, proxyPort);\n\t\t\tif (StringUtils.isNotBlank(proxyUser)) {\n\t\t\t\tclient.getState().setProxyCredentials(AuthScope.ANY,\n\t\t\t\t\tnew UsernamePasswordCredentials(proxyUser, proxyPassword));\n\t\t\t}\n\t\t}\n\t\t  \n\t\tHttpMethod method = HttpUtil.createHttpMethod(httpMethod, url);\n        method.getParams().setSoTimeout(timeout);\n\t\tmethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,\n\t\t\t\tnew DefaultHttpMethodRetryHandler(3, false));\n\t\tif(httpHeaders != null){\n\t\t\tfor(String httpHeaderKey: httpHeaders.stringPropertyNames()){\n\t\t\t\tmethod.addRequestHeader(new Header(httpHeaderKey,httpHeaders.getProperty(httpHeaderKey)));\n\t\t\t}\n\t\t}\n\t\t// add content if a valid method is given ...\n\t\tif (method instanceof EntityEnclosingMethod && content != null ) {\n\t\t\tEntityEnclosingMethod eeMethod = (EntityEnclosingMethod) method;\n\t\t\teeMethod.setRequestEntity(new InputStreamRequestEntity(content, contentType));\n\t\t}\n\n\t\tCredentials credentials = extractCredentials(url);\n\t\tif (credentials != null) {\n\t\t\tclient.getParams().setAuthenticationPreemptive(true); \n\t\t\tclient.getState().setCredentials(AuthScope.ANY, credentials);\t\t\t\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\ttry {\n\t\t\t\tlogger.debug(\"About to execute '\" + method.getURI().toString() + \"'\");\n\t\t\t} catch (URIException e) {\n\t\t\t\tlogger.debug(e.getMessage());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tint statusCode = client.executeMethod(method);\n\t\t\tif (statusCode != HttpStatus.SC_OK) {\n\t\t\t\tlogger.warn(\"Method failed: \" + method.getStatusLine());\n\t\t\t}\n\n\t\t\tString responseBody = IOUtils.toString(method.getResponseBodyAsStream());\n\t\t\tif (!responseBody.isEmpty()) {\n\t\t\t\tlogger.debug(responseBody);\n\t\t\t}\n\t\t\t\n\t\t\treturn responseBody;\n\t\t}\n\t\tcatch (HttpException he) {\n\t\t\tlogger.error(\"Fatal protocol violation: {}\", he.toString());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tlogger.error(\"Fatal transport error: {}\", ioe.toString());\n\t\t}\n\t\tfinally {\n\t\t\tmethod.releaseConnection();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1997,
    "type": "Return",
    "comment": "@return true if successful, false otherwise.",
    "code": "public VAdminProto.DisableStoreVersionResponse disableStoreVersion(Integer nodeId, String storeName, Long storeVersion, String info) {\n    VAdminProto.DisableStoreVersionRequest request = VAdminProto.DisableStoreVersionRequest.newBuilder().setStoreName(storeName).setPushVersion(storeVersion).setInfo(info).build();\n    VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder().setDisableStoreVersion(request).setType(VAdminProto.AdminRequestType.DISABLE_STORE_VERSION).build();\n    VAdminProto.DisableStoreVersionResponse response = null;\n    VAdminProto.DisableStoreVersionResponse.Builder responseBuilder = VAdminProto.DisableStoreVersionResponse.newBuilder();\n    try {\n        response = rpcOps.sendAndReceive(nodeId, adminRequest, responseBuilder).build();\n    } catch (UnreachableStoreException e) {\n        String errorMessage = STR + nodeId + STR + storeName + STR + storeVersion + STR + STR;\n        logger.warn(errorMessage, e);\n        response = responseBuilder.setDisableSuccess(false).setInfo(errorMessage).setNodeId(nodeId).build();\n    }\n    return response;\n}",
    "label": 1,
    "rec": "@return the {@link voldemort.client.protocol.pb.VAdminProto.DisableStoreVersionResponse}"
  },
  {
    "id": 1998,
    "type": "Return",
    "comment": "@return a Aead primitive from a  keysetHandle and a custom  keyManager.",
    "code": "  public static Aead getPrimitive(KeysetHandle keysetHandle, final KeyManager<Aead> keyManager)\n      throws GeneralSecurityException {\n    final PrimitiveSet<Aead> pset = Registry.getPrimitives(keysetHandle, keyManager);\n    validate(pset);\n    return new Aead() {\n      @Override\n      public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n          throws GeneralSecurityException {\n        return Bytes.concat(\n            pset.getPrimary().getIdentifier(),\n            pset.getPrimary().getPrimitive().encrypt(plaintext, associatedData));\n      }\n\n      @Override\n      public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n          throws GeneralSecurityException {\n        if (ciphertext.length > CryptoFormat.NON_RAW_PREFIX_SIZE) {\n          byte[] prefix = Arrays.copyOfRange(ciphertext, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);\n          byte[] ciphertextNoPrefix =\n              Arrays.copyOfRange(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE, ciphertext.length);\n          List<PrimitiveSet.Entry<Aead>> entries = pset.getPrimitive(prefix);\n          for (PrimitiveSet.Entry<Aead> entry : entries) {\n            try {\n              return entry.getPrimitive().decrypt(ciphertextNoPrefix, associatedData);\n            } catch (GeneralSecurityException e) {\n              logger.info(\"ciphertext prefix matches a key, but cannot decrypt: \" + e.toString());\n              continue;\n            }\n          }\n        }\n\n        // Let's try all RAW keys.\n        List<PrimitiveSet.Entry<Aead>> entries = pset.getRawPrimitives();\n        for (PrimitiveSet.Entry<Aead> entry : entries) {\n          try {\n            return entry.getPrimitive().decrypt(ciphertext, associatedData);\n          } catch (GeneralSecurityException e) {\n            continue;\n          }\n        }\n        // nothing works.\n        throw new GeneralSecurityException(\"decryption failed\");\n      }\n    };\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 1999,
    "type": "Return",
    "comment": "@return returns true if context has access to the given permission, false otherwise.",
    "code": "private static boolean hasSelfPermission(Context context, String permission) {\n    try {\n        return PermissionChecker.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED;\n    } catch (RuntimeException t) {\n        return false;\n    }\n}",
    "label": 1,
    "rec": "@return true if context has access to the given permission, false otherwise."
  },
  {
    "id": 2000,
    "type": "Return",
    "comment": "@return  true if node segment is 'client'.",
    "code": "    public static IgnitePredicate<ClusterNode> clientNode() {\n        return new IgnitePredicate<ClusterNode>() {\n            @Override public boolean apply(ClusterNode node) {\n                return \"client\".equals(node.attribute(\"segment\"));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2001,
    "type": "Return",
    "comment": "@return a string describing the status of the AllocationPointerOperations",
    "code": "public static final String print(final long[] address) {\n    if (address == null || address.length == NUM)\n        throw new IllegalArgumentException(STR);\n    final byte dim = getDimension(address[NUM]);\n    StringBuilder b = new StringBuilder(String.format(STR, getSize(address[NUM]), getCapacity(address[NUM]), getEndOffset(address[NUM])));\n    if (dim > NUM) {\n        b.append(String.format(STR, getSize(address[NUM]), getCapacity(address[NUM]), getEndOffset(address[NUM])));\n        if (dim > NUM)\n            b.append(String.format(STR, getSize(address[NUM]), getCapacity(address[NUM]), getEndOffset(address[NUM])));\n    }\n    return b.toString();\n}",
    "label": 1,
    "rec": "@return a string describing the status of the AllocationPointer"
  },
  {
    "id": 2002,
    "type": "Return",
    "comment": "@return null if s is null or empty, or result of s.trim() otherwise",
    "code": "  static String trim(String s) {\n    if (s == null) {\n      return null;\n    }\n    String result = s.trim();\n    return result.isEmpty() ? null : result;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2003,
    "type": "Return",
    "comment": "@return Definitions factory or <code>null</code> if not found.",
    "code": "public static DefinitionsFactory getDefinitionsFactory() {\n    return tilesUtilImpl.getDefinitionsFactory();\n}",
    "label": 1,
    "rec": "@return Definitions impl or <code>null</code> if not found."
  },
  {
    "id": 2004,
    "type": "Return",
    "comment": "@return New instance of CacheOperationContext with keep portable flag.",
    "code": "    public CacheOperationContext keepPortable() {\n        return new CacheOperationContext(\n            skipStore,\n            subjId,\n            true,\n            expiryPlc,\n            noRetries);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2005,
    "type": "Return",
    "comment": "@return formatted interpretation of raw content as a {@link Hashtable} mapping one {@link ResultMetadataType} to appropriate value, or <code>null</code> if not known",
    "code": "private static Map<ResultMetadataType, Object> parseExtensionString(String raw) {\n    ResultMetadataType type;\n    Object value;\n    switch(raw.length()) {\n        case NUM:\n            type = ResultMetadataType.ISSUE_NUMBER;\n            value = parseExtension2String(raw);\n            break;\n        case NUM:\n            type = ResultMetadataType.SUGGESTED_PRICE;\n            value = parseExtension5String(raw);\n            break;\n        default:\n            return null;\n    }\n    if (value == null) {\n        return null;\n    }\n    Map<ResultMetadataType, Object> result = new EnumMap<ResultMetadataType, Object>(ResultMetadataType.class);\n    result.put(type, value);\n    return result;\n}",
    "label": 1,
    "rec": "@return formatted interpretation of raw content as a {@link Map} mapping one {@link ResultMetadataType} to appropriate value, or {@code null} if not known"
  },
  {
    "id": 2006,
    "type": "Return",
    "comment": "@return the estimated error.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol) {\n        return solve(A, Ap, b, x, tol, itol, 2 * Math.max(A.nrows(), A.ncols()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2007,
    "type": "Return",
    "comment": "@return @link {@link EdgeManagerDescriptor} if a custom edge was setup, null otherwise.",
    "code": "@Private\npublic EdgeManagerPluginDescriptor getEdgeManagerDescriptor() {\n    return edgeManagerDescriptor;\n}",
    "label": 1,
    "rec": "@return @link {@link EdgeManagerPluginDescriptor} if a custom edge was setup, null otherwise."
  },
  {
    "id": 2008,
    "type": "Return",
    "comment": "@return Test resources.",
    "code": "        public IgniteTestResources getTestResources() {\n            return rsrcs;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2009,
    "type": "Return",
    "comment": "@return Index of the next needle in haystack after startPos, -1 if not found",
    "code": "private int indexOf(Iterator<String> iter, String search) {\n    for (int i = NUM; iter.hasNext(); i++) {\n        if (search.equals(iter.next())) {\n            return i;\n        }\n    }\n    return -NUM;\n}",
    "label": 1,
    "rec": "@return Index of the next search in after startPos, -1 if not found"
  },
  {
    "id": 2010,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static double geq(double value) {\n        reportMatcher(new GreaterOrEqual<Double>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2011,
    "type": "Return",
    "comment": "@return The forecast read",
    "code": "@Processor\n@InvalidateConnectionOn(exception = NotAuthenticatedException.class)\npublic ForeCast readForecast(String objectId) {\n    return (ForeCast) read(ServiceSourceCollection.Forecasts, objectId);\n}",
    "label": 1,
    "rec": "@return an instance of {@link org.mule.module.servicesource.model.forecast.ForeCast}"
  },
  {
    "id": 2012,
    "type": "Return",
    "comment": "@return Double value.",
    "code": "    static double getDouble(Object obj, long off) {\n        return GridUnsafe.getDoubleField(obj, off);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2013,
    "type": "Return",
    "comment": "@return Event spi.",
    "code": "public T2<String, Map<String, Object>> eventStorageSpi() {\n    return evtSpi;\n}",
    "label": 1,
    "rec": "@return Event storage SPI."
  },
  {
    "id": 2014,
    "type": "Return",
    "comment": "@return analyzer",
    "code": "    public Analyzer getAnalyzer() {\n        return getFullTextSession().getSearchFactory().getAnalyzer(\"cms\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2015,
    "type": "Return",
    "comment": "@return Safe URI for the current configuration.",
    "code": "public String buildSafe() {\n    if (key == null) {\n        throw new IllegalStateException(STR);\n    }\n    StringBuilder config = assembleConfig().append(md5(target));\n    final byte[] encrypted = aes128Encrypt(config, normalizeString(key, NUM));\n    final String encoded = Utilities.base64Encode(encrypted);\n    return new StringBuilder(host).append(STR).append(encoded).append(STR).append(target).toString();\n}",
    "label": 1,
    "rec": "@return Safe URL for the current configuration."
  },
  {
    "id": 2016,
    "type": "Return",
    "comment": "@return Dummy metrics provider.",
    "code": "    protected DiscoveryMetricsProvider createMetricsProvider() {\n        return new DiscoveryMetricsProvider() {\n            /** {@inheritDoc} */\n            @Override public ClusterMetrics metrics() { return new ClusterMetricsSnapshot(); }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2017,
    "type": "Return",
    "comment": "@return {@link PagedCollection} or null if the current page is the last page",
    "code": "private ResourceCollection<T> getNextPage() {\n    if (isLastPage()) {\n        return null;\n    }\n    return pager.getPage(currentPageNumber + NUM);\n}",
    "label": 1,
    "rec": "@return {@link ResourceCollection} or null if the current page is the last page"
  },
  {
    "id": 2018,
    "type": "Return",
    "comment": "@return If the field was present in the hash it is deleted and 1 is returned, otherwise 0 is returned and no operation is performed.",
    "code": "    public Long hdel(final String key, final String field) {\n        runChecks();\n        client.hdel(key, field);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2019,
    "type": "Return",
    "comment": "@return the tag's value as an array of Strings",
    "code": "@Nullable\npublic String[] getStringArray(int tagType) {\n    Object o = getObject(tagType);\n    if (o == null)\n        return null;\n    if (o instanceof String[])\n        return (String[]) o;\n    if (o instanceof String)\n        return new String[] { (String) o };\n    if (o instanceof int[]) {\n        int[] ints = (int[]) o;\n        String[] strings = new String[ints.length];\n        for (int i = NUM; i < strings.length; i++) strings[i] = Integer.toString(ints[i]);\n        return strings;\n    } else if (o instanceof byte[]) {\n        byte[] bytes = (byte[]) o;\n        String[] strings = new String[bytes.length];\n        for (int i = NUM; i < strings.length; i++) strings[i] = Byte.toString(bytes[i]);\n        return strings;\n    } else if (o instanceof Rational[]) {\n        Rational[] rationals = (Rational[]) o;\n        String[] strings = new String[rationals.length];\n        for (int i = NUM; i < strings.length; i++) strings[i] = rationals[i].toSimpleString(false);\n        return strings;\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the tag's value as an array of Strings. If the value is unset or cannot be converted, <code>null</code> is returned."
  },
  {
    "id": 2020,
    "type": "Return",
    "comment": "@return a javafx Image",
    "code": "    private static Image qrCodeImage(String uri) {\n        return toImage(qrCodeMatrix(uri));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2021,
    "type": "Return",
    "comment": "@return A three element {@link String} array with the username, password, and save state, in that order. Returns <code>null</code> if the dialog was canceled.",
    "code": "public AuthenticationInfo getResult() {\n    return result;\n}",
    "label": 1,
    "rec": "@return the authentication information given by the user, or null if the user cancelled"
  },
  {
    "id": 2022,
    "type": "Return",
    "comment": "@return author name or null if missing",
    "code": "    public static Date getCommitterDate(final Commit commit) {\n        GitCommit rawCommit = commit.commit();\n        if (rawCommit == null)\n            return null;\n\n        GitUser commitCommitter = rawCommit.committer();\n        return commitCommitter != null && commitCommitter.date() != null ? commitCommitter.date(): null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2023,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private Frame reBalance(final Frame fr, long seed) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that can be load-balanced (and shuffled), depending on whether force_load_balance and shuffle_training_data are set"
  },
  {
    "id": 2024,
    "type": "Return",
    "comment": "@return session timeout",
    "code": "    public int  session()\n    {\n        return multiple(SESSION_MULTIPLE).milliseconds();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2025,
    "type": "Return",
    "comment": "@return The column or <code>null</code> if there is none in this table",
    "code": "public Column[] getAutoIncrementColumn() {\n    Collection autoIncrColumns = CollectionUtils.select(_columns, new Predicate() {\n\n        public boolean evaluate(Object input) {\n            return ((Column) input).isAutoIncrement();\n        }\n    });\n    return (Column[]) autoIncrColumns.toArray(new Column[autoIncrColumns.size()]);\n}",
    "label": 1,
    "rec": "@return The columns"
  },
  {
    "id": 2026,
    "type": "Return",
    "comment": "@return whether the Java version is compatible with Java 9",
    "code": "  public boolean isJava9Compatible() {\n    return javaSpecVersionNumber.getMajor() >= 9;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2027,
    "type": "Return",
    "comment": "@return a Mac primitive from a  keysetHandle.",
    "code": "  public static Mac getPrimitive(KeysetHandle keysetHandle, final KeyManager<Mac> keyManager)\n      throws GeneralSecurityException {\n    final PrimitiveSet<Mac> primitives = Registry.getPrimitives(keysetHandle, keyManager);\n    final byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};\n    return new Mac() {\n      @Override\n      public byte[] computeMac(final byte[] data) throws GeneralSecurityException {\n        if (primitives.getPrimary().getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {\n          return Bytes.concat(\n              primitives.getPrimary().getIdentifier(),\n              primitives.getPrimary().getPrimitive().computeMac(Bytes.concat(data, formatVersion)));\n        }\n        return Bytes.concat(\n            primitives.getPrimary().getIdentifier(),\n            primitives.getPrimary().getPrimitive().computeMac(data));\n      }\n\n      @Override\n      public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException {\n        if (mac.length <= CryptoFormat.NON_RAW_PREFIX_SIZE) {\n          // This also rejects raw MAC with size of 4 bytes or fewer. Those MACs are\n          // clearly insecure, thus should be discouraged.\n          throw new GeneralSecurityException(\"tag too short\");\n        }\n        byte[] prefix = Arrays.copyOfRange(mac, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);\n        byte[] macNoPrefix = Arrays.copyOfRange(mac, CryptoFormat.NON_RAW_PREFIX_SIZE, mac.length);\n        List<PrimitiveSet.Entry<Mac>> entries = primitives.getPrimitive(prefix);\n        for (PrimitiveSet.Entry<Mac> entry : entries) {\n          try {\n            if (entry.getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {\n              entry.getPrimitive().verifyMac(macNoPrefix, Bytes.concat(data, formatVersion));\n            } else {\n              entry.getPrimitive().verifyMac(macNoPrefix, data);\n            }\n            // If there is no exception, the MAC is valid and we can return.\n            return;\n          } catch (GeneralSecurityException e) {\n            logger.info(\"tag prefix matches a key, but cannot verify: \" + e.toString());\n            // Ignored as we want to continue verification with the remaining keys.\n          }\n        }\n\n        // None \"non-raw\" key matched, so let's try the raw keys (if any exist).\n        entries = primitives.getRawPrimitives();\n        for (PrimitiveSet.Entry<Mac> entry : entries) {\n          try {\n            entry.getPrimitive().verifyMac(mac, data);\n            // If there is no exception, the MAC is valid and we can return.\n            return;\n          } catch (GeneralSecurityException ignored) {\n            // Ignored as we want to continue verification with other raw keys.\n          }\n        }\n        // nothing works.\n        throw new GeneralSecurityException(\"invalid MAC\");\n      }\n    };\n  }\n",
    "label": 1,
    "rec": "@return a Mac primitive from a  keysetHandle and a custom  keyManager."
  },
  {
    "id": 2028,
    "type": "Return",
    "comment": "@return  True if values should be always unmarshalled.",
    "code": "    public boolean isUnmarshalValues() {\n        return cacheCfg.isQueryIndexEnabled();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2029,
    "type": "Return",
    "comment": "@return the VM (static) singleton SecurityManager, used only on rare occasions.",
    "code": "public static SecurityManager getSecurityManager() throws IllegalStateException {\n    SecurityManager securityManager = ThreadContext.getSecurityManager();\n    if (securityManager == null) {\n        securityManager = SecurityUtils.securityManager;\n    }\n    if (securityManager == null) {\n        String msg = STR + ThreadContext.class.getName() + STR + STR;\n        throw new IllegalStateException(msg);\n    }\n    return securityManager;\n}",
    "label": 1,
    "rec": "@return the SecurityManager accessible to the calling code."
  },
  {
    "id": 2030,
    "type": "Return",
    "comment": "@return Schemas.",
    "code": "    BinarySchema schema() {\n        return schemaBuilder.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2031,
    "type": "Return",
    "comment": "@return The Jenkins version.",
    "code": "public JenkinsVersion getVersion() {\n    if (client.getJenkinsVersion().isEmpty()) {\n        isRunning();\n    }\n    JenkinsVersion jv = new JenkinsVersion(client.getJenkinsVersion());\n    return jv;\n}",
    "label": 1,
    "rec": "@return {@link JenkinsVersion}"
  },
  {
    "id": 2032,
    "type": "Return",
    "comment": "@return Backup nodes.",
    "code": "    public static Collection<ClusterNode> backups(Collection<ClusterNode> nodes) {\n        if (nodes == null || nodes.size() <= 1)\n            return Collections.emptyList();\n\n        return F.view(nodes, F.notEqualTo(F.first(nodes)));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2033,
    "type": "Return",
    "comment": "@return the ZuulFilter",
    "code": "public IZuulFilter getFilter(String sCode, String sName) throws Exception {\n    if (filterCheck.get(sName) == null) {\n        filterCheck.putIfAbsent(sName, sName);\n        if (!sCode.equals(filterClassCode.get(sName))) {\n            LOG.info(STR + sName);\n            filterRegistry.remove(sName);\n        }\n    }\n    IZuulFilter filter = filterRegistry.get(sName);\n    if (filter == null) {\n        Class clazz = COMPILER.compile(sCode, sName);\n        if (!Modifier.isAbstract(clazz.getModifiers())) {\n            filter = FILTER_FACTORY.newInstance(clazz);\n        }\n    }\n    return filter;\n}",
    "label": 1,
    "rec": "@return the IZuulFilter"
  },
  {
    "id": 2034,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    private Object[] readEnumArray0(@Nullable Class<?> cls) throws BinaryObjectException {\n        switch (checkFlag(ENUM_ARR)) {\n            case NORMAL:\n                // Read class even if we know it in advance to set correct stream position.\n                Class<?> cls0 = PortableUtils.doReadClass(in, ctx, ldr);\n\n                if (cls == null)\n                    cls = cls0;\n\n                return PortableUtils.doReadEnumArray(in, ctx, ldr, cls);\n\n            case HANDLE:\n                return readHandleField();\n\n            default:\n                return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2035,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forClassLoader() {\n    return forClassLoader(classLoaders());\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 2036,
    "type": "Return",
    "comment": "@return  Mode encoded by these bits",
    "code": "  static Mode forBits(int bits) throws ReaderException {\n    switch (bits) {\n      case 0x0:\n        return TERMINATOR;\n      case 0x1:\n        return NUMERIC;\n      case 0x2:\n        return ALPHANUMERIC;\n      case 0x4:\n        return BYTE;\n      case 0x7:\n        return ECI;\n      case 0x8:\n        return KANJI;\n      default:\n        throw new ReaderException(\"Illegal mode bits: \" + bits);\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2037,
    "type": "Return",
    "comment": "@return the string converted to UTF-8",
    "code": "public static String readStringNZ(Memory mem, int address, int n) {\n    StringBuilder sb = new StringBuilder();\n    address &= Memory.addressMask;\n    if (address + n > MemoryMap.END_RAM) {\n        n = MemoryMap.END_RAM - address + NUM;\n    }\n    int b;\n    for (; n > NUM; n--) {\n        b = mem.read8(address++);\n        if (b == NUM)\n            break;\n        sb.append((char) b);\n    }\n    return sb.toString();\n}",
    "label": 1,
    "rec": "@return the string"
  },
  {
    "id": 2038,
    "type": "Return",
    "comment": "@return New MaterialData with the given data",
    "code": "    public MaterialData getNewData(final byte raw) {\n        if (data == null) {\n            return new MaterialData(id, raw);\n        }\n\n        try {\n            Constructor<? extends MaterialData> ctor = data.getConstructor(int.class, byte.class);\n\n            return ctor.newInstance(id, raw);\n        } catch (InstantiationException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IllegalArgumentException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (InvocationTargetException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchMethodException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (SecurityException ex) {\n            Logger.getLogger(Material.class.getName()).log(Level.SEVERE, null, ex);\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2039,
    "type": "Return",
    "comment": "@return the solution, which is actually the matrix B in case of exact solution.",
    "code": "public static DenseMatrix solve(double[][] A, double[][] B) {\n    DenseMatrix b = new ColumnMajorMatrix(B);\n    DenseMatrix X = new ColumnMajorMatrix(A[NUM].length, B[NUM].length);\n    if (A.length == A[NUM].length) {\n        LUDecomposition lu = new LUDecomposition(A);\n        lu.solve(b, X);\n    } else {\n        QRDecomposition qr = new QRDecomposition(A);\n        qr.solve(b, X);\n    }\n    return X;\n}",
    "label": 1,
    "rec": "@return the solution."
  },
  {
    "id": 2040,
    "type": "Return",
    "comment": "@return the request URI",
    "code": "    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2041,
    "type": "Return",
    "comment": "@return Cached session.",
    "code": "    private WebSession createSession(HttpServletRequest httpReq) {\n        HttpSession ses = httpReq.getSession(true);\n\n        String sesId = sesIdTransformer != null ? sesIdTransformer.apply(ses.getId()) : ses.getId();\n\n        return createSession(ses, sesId);\n    }\n",
    "label": 1,
    "rec": "@return New session."
  },
  {
    "id": 2042,
    "type": "Return",
    "comment": "@return This instance creation time.",
    "code": "    public long getCreateTime() {\n        return createTime0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2043,
    "type": "Return",
    "comment": "@return the full path of the file, or the library name, loaded (but  if (!loadLibraries || cls == null)  return null; )",
    "code": "    public static String load(Class cls) {\n        if (!loadLibraries || cls == null) {\n            return null;\n        }\n\n        // Find the top enclosing class, to match the library filename\n        cls = getEnclosingClass(cls);\n\n        // Force initialization of the class in case it needs it\n        try {\n            cls = Class.forName(cls.getName(), true, cls.getClassLoader());\n        } catch (ClassNotFoundException ex) {\n            Error e = new NoClassDefFoundError(ex.toString());\n            e.initCause(ex);\n            throw e;\n        }\n\n        // Preload native libraries desired by our class\n        ClassProperties p = loadProperties(cls, loadProperties(), true);\n        LinkedList<String> preloads = new LinkedList<String>();\n        preloads.addAll(p.get(\"loader.preload\"));\n        preloads.addAll(p.get(\"compiler.link\"));\n        UnsatisfiedLinkError preloadError = null;\n        for (String preload : preloads) {\n            try {\n                URL[] urls = findLibrary(cls, p, preload);\n                loadLibrary(urls, preload);\n            } catch (UnsatisfiedLinkError e) {\n                preloadError = e;\n            }\n        }\n\n        try {\n            String library = p.getProperty(\"loader.library\");\n            URL[] urls = findLibrary(cls, p, library);\n            return loadLibrary(urls, library);\n        } catch (UnsatisfiedLinkError e) {\n            if (preloadError != null) {\n                e.initCause(preloadError);\n            }\n            throw e;\n        }\n    }\n",
    "label": 1,
    "rec": "@return the full path to the main file loaded, or the library name if unknown (but  if (!loadLibraries || cls == null)  return null; )"
  },
  {
    "id": 2044,
    "type": "Return",
    "comment": "@return text and bytes encoded within the QR Code",
    "code": "  public DecoderResult decode(BitMatrix bits) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion();\n    ErrorCorrectionLevel ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser.decode(resultBytes, version);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2045,
    "type": "Return",
    "comment": "@return a ChannelFuture that can be used to wait for the socket to connect. A socket connection does not mean that protocol handshake has occured.",
    "code": "public Peer connectTo(InetSocketAddress address) {\n    return connectTo(address, true);\n}",
    "label": 1,
    "rec": "@return The newly created Peer object. Use {@link com.google.bitcoin.core.Peer#getConnectionOpenFuture()} if you want a future which completes when the connection is open."
  },
  {
    "id": 2046,
    "type": "Return",
    "comment": "@return A measure of utility that ought to be minimized.",
    "code": "    public double getUtility() {\n\n        return (UTILITY_MULTIPLIER_IOPS * getZonePrimaryMaxMin())\n               + (UTILITY_MULTIPLIER_CAPACITY * getNaryMaxMin());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2047,
    "type": "Return",
    "comment": "@return A 32-character image identifier.",
    "code": "public Image getPortrait() {\n    return this.portrait;\n}",
    "label": 1,
    "rec": "@return An {@link Image} object."
  },
  {
    "id": 2048,
    "type": "Return",
    "comment": "@return Status.",
    "code": "    public static GridHadoopJobStatus status(GridHadoopJobMetadata meta) {\n        GridHadoopJobInfo jobInfo = meta.jobInfo();\n\n        return new GridHadoopJobStatus(\n            meta.jobId(),\n            jobInfo.jobName(),\n            jobInfo.user(),\n            meta.pendingSplits() != null ? meta.pendingSplits().size() : 0,\n            meta.pendingReducers() != null ? meta.pendingReducers().size() : 0,\n            meta.mapReducePlan().mappers(),\n            meta.mapReducePlan().reducers(),\n            meta.phase(),\n            meta.failCause() != null,\n            meta.version()\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2049,
    "type": "Return",
    "comment": "@return The result fetched from the result vector, null if the result could not be found",
    "code": "public static List fetchAllActionResults(List resultList, int action, List actionResultList) {\n    for (int i = NUM; i < resultList.size(); i++) {\n        WSSecurityEngineResult result = (WSSecurityEngineResult) resultList.get(i);\n        int resultAction = ((java.lang.Integer) result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n        if (resultAction == action) {\n            actionResultList.add(result);\n        }\n    }\n    return actionResultList;\n}",
    "label": 1,
    "rec": "@return The result fetched from the result list, null if the result could not be found"
  },
  {
    "id": 2050,
    "type": "Return",
    "comment": "@return a  HmacKey.",
    "code": "  public static HmacKey createHmacKey(byte[] keyValue, int tagSize) throws Exception {\n    HmacParams params = HmacParams.newBuilder()\n        .setHash(HashType.SHA256)\n        .setTagSize(tagSize)\n        .build();\n\n    return HmacKey.newBuilder()\n        .setParams(params)\n        .setKeyValue(ByteString.copyFrom(keyValue))\n        .build();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2051,
    "type": "Return",
    "comment": "@return Returns the tag contained in this AudioFile, or a new one if file hasn't any tag.",
    "code": "public Tag getTag() {\n    return tag;\n}",
    "label": 1,
    "rec": "@return Returns the tag contained in this AudioFile, or null if no tag exists."
  },
  {
    "id": 2052,
    "type": "Return",
    "comment": "@return the video codec",
    "code": "    public VideoCodec getVideoCodec() {\n        return videoCodec;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2053,
    "type": "Return",
    "comment": "@return a value or wrapped exception, see WrappedValues",
    "code": "@Nullable\nprotected T recursionDetected(boolean firstTime) {\n    throw new IllegalStateException(STR);\n}",
    "label": 1,
    "rec": "@return a value to be returned on a recursive call or subsequent calls"
  },
  {
    "id": 2054,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static long geq(long value) {\n        return reportMatcher(new GreaterOrEqual<Long>(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2055,
    "type": "Return",
    "comment": "@return Skip store flag.",
    "code": "    public static CacheFlag[] parseCacheFlags(int cacheFlagsBits) {\n        if (cacheFlagsBits == 0)\n            return EMPTY_FLAGS;\n\n        EnumSet<CacheFlag> flagSet = EnumSet.noneOf(CacheFlag.class);\n\n        if ((cacheFlagsBits & 1) != 0)\n            flagSet.add(CacheFlag.SKIP_STORE);\n\n        if ((cacheFlagsBits & (1 << 1)) != 0)\n            flagSet.add(CacheFlag.SKIP_SWAP);\n\n        if ((cacheFlagsBits & (1 << 2)) != 0)\n            flagSet.add(CacheFlag.SYNC_COMMIT);\n\n        if ((cacheFlagsBits & (1 << 4)) != 0)\n            flagSet.add(CacheFlag.INVALIDATE);\n\n        return flagSet.toArray(new CacheFlag[flagSet.size()]);\n    }\n",
    "label": 1,
    "rec": "@return Array of cache flags."
  },
  {
    "id": 2056,
    "type": "Return",
    "comment": "@return Key value type descriptors.",
    "code": "        protected Collection<CacheQueryTypeDescriptor> valueDescriptors() {\n            return typeMetadata.getValueDescriptors();\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2057,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastStableBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastStableBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 2058,
    "type": "Return",
    "comment": "@return -1 if b1  b2, and 0 if they are equal",
    "code": "    public static int compare(byte[] b1, byte[] b2) {\n        for(int i = 0, j = 0; i < b1.length && j < b2.length; i++, j++) {\n            int a = (b1[i] & 0xff);\n            int b = (b2[j] & 0xff);\n            if(a != b) {\n                return a - b;\n            }\n        }\n        return b1.length - b2.length;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2059,
    "type": "Return",
    "comment": "@return prepared statement for the query",
    "code": "  private void generateMaxScnSkippedForTxnChunkedQuery(Connection db)\n  \tthrows SQLException\n  {\n\tif ( null == _txnChunkJumpScnStmt)\n\t{\n\t\tStringBuilder sql = new StringBuilder();\n\n\t\tsql.append(\"SELECT max(t.scn) from (\");\n\t\tsql.append(\"select /*+ index(tx) */ tx.scn, row_number() OVER (ORDER BY tx.scn) r FROM \");\n\t\tsql.append(_selectSchema +  \"sy$txlog tx \");\n\t\tsql.append(\"WHERE tx.scn >  ? AND tx.scn < 9999999999999999999999999999) t \");\n\t\tsql.append(\"WHERE r <= ?\");\n\n\t\t_txnChunkJumpScnStmt = db.prepareStatement(sql.toString());\n\t}\n\n\treturn;\n  }\n",
    "label": 1,
    "rec": "@return None"
  },
  {
    "id": 2060,
    "type": "Return",
    "comment": "@return whether the camera has started",
    "code": "    public boolean isOpened() {\n        return mCameraEngine.getState() >= CameraEngine.STATE_STARTED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2061,
    "type": "Return",
    "comment": "@return a list of all configuration objects",
    "code": "public Collection<AbstractCacheServiceConfiguration<K, V>> getAllConfigurations() {\n    return (Collection) new ArrayList<AbstractCacheServiceConfiguration>(list);\n}",
    "label": 1,
    "rec": "@return a collection of all service configuration objects"
  },
  {
    "id": 2062,
    "type": "Return",
    "comment": "@return  True if should use system transactions which are isolated from user transactions.",
    "code": "    public boolean systemTx() {\n        return cacheType == CacheType.UTILITY || (cacheType == CacheType.INTERNAL && transactional());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2063,
    "type": "Return",
    "comment": "@return Copy spis.",
    "code": "public T2<String, Map<String, Object>>[] checkpointSpis() {\n    return cpSpis;\n}",
    "label": 1,
    "rec": "@return Checkpoint SPIs."
  },
  {
    "id": 2064,
    "type": "Return",
    "comment": "@return if import of turn restrictions is enabled",
    "code": "    public boolean isEnableTurnRestrictions()\n    {\n        return turnCosts;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2065,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private static Frame reBalance(final Frame fr, long seed, boolean local, boolean force_load_balance, boolean shuffle_training_data) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 2066,
    "type": "Return",
    "comment": "@return Remote candidates.",
    "code": "    public Collection<GridCacheMvccCandidate<K>> remoteCandidates() {\n        Collection<GridCacheMvccCandidate<K>> rmtCands = new LinkedList<>();\n\n        for (GridDistributedCacheEntry<K, V> entry : locked()) {\n            rmtCands.addAll(entry.remoteMvccSnapshot());\n        }\n\n        return rmtCands;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2067,
    "type": "Return",
    "comment": "@return true if done.",
    "code": "@Override\npublic final boolean dealWithCharacters(Reader reader) throws IOException, ManifoldCFException {\n    while (true) {\n        int amt = reader.read(charBuffer);\n        if (amt == -NUM)\n            return false;\n        for (int i = NUM; i < amt; i++) {\n            if (dealWithCharacter(charBuffer[i]))\n                return true;\n        }\n    }\n}",
    "label": 1,
    "rec": "@return true if abort signalled, false if end of stream."
  },
  {
    "id": 2068,
    "type": "Return",
    "comment": "@return \"updated\"  ExecutionResult",
    "code": "        public ExecutionResult addEmission(HystrixEventType eventType) {\n            switch (eventType) {\n                case EMIT: if (events.contains(HystrixEventType.EMIT)) {\n                    return new ExecutionResult(events, executionTime, failedExecutionException, executionException, numEmissions + 1, numFallbackEmissions);\n                } else {\n                    return new ExecutionResult(getUpdatedList(this.events, HystrixEventType.EMIT), executionTime, failedExecutionException, executionException, numEmissions +1, numFallbackEmissions);\n                }\n                case FALLBACK_EMIT: if (events.contains(HystrixEventType.FALLBACK_EMIT)) {\n                    return new ExecutionResult(events, executionTime, failedExecutionException, executionException, numEmissions, numFallbackEmissions + 1);\n                } else {\n                    return new ExecutionResult(getUpdatedList(this.events, HystrixEventType.FALLBACK_EMIT), executionTime, failedExecutionException, executionException, numEmissions, numFallbackEmissions + 1);\n                }\n                default: return this;\n            }\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2069,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private static Frame reBalance(final Frame fr, long seed, boolean local, boolean force_load_balance, boolean shuffle_training_data) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 2070,
    "type": "Return",
    "comment": "@return Object.",
    "code": "    Object read(GridPortableReaderImpl reader) throws GridPortableException {\n        assert reader != null;\n\n        switch (mode) {\n            case BYTE:\n                return reader.readByte();\n\n            case SHORT:\n                return reader.readShort();\n\n            case INT:\n                return reader.readInt();\n\n            case LONG:\n                return reader.readLong();\n\n            case FLOAT:\n                return reader.readFloat();\n\n            case DOUBLE:\n                return reader.readDouble();\n\n            case CHAR:\n                return reader.readChar();\n\n            case BOOLEAN:\n                return reader.readBoolean();\n\n            case STRING:\n                return reader.readString();\n\n            case UUID:\n                return reader.readUuid();\n\n            case BYTE_ARR:\n                return reader.readByteArray();\n\n            case SHORT_ARR:\n                return reader.readShortArray();\n\n            case INT_ARR:\n                return reader.readShortArray();\n\n            case LONG_ARR:\n                return reader.readLongArray();\n\n            case FLOAT_ARR:\n                return reader.readFloatArray();\n\n            case DOUBLE_ARR:\n                return reader.readDoubleArray();\n\n            case CHAR_ARR:\n                return reader.readCharArray();\n\n            case BOOLEAN_ARR:\n                return reader.readBooleanArray();\n\n            case STRING_ARR:\n                return reader.readStringArray();\n\n            case UUID_ARR:\n                return reader.readUuidArray();\n\n            case OBJ_ARR:\n                return reader.readObjectArray();\n\n            case COL:\n                return reader.readCollection();\n\n            case MAP:\n                return reader.readMap();\n\n            case PORTABLE:\n                GridPortable portableEx = newInstance(cls);\n\n                portableEx.readPortable(reader);\n\n                return portableEx;\n\n            case OBJECT:\n                GridPortable portable = newInstance(cls);\n\n                for (FieldInfo info : fields) {\n                    Field f = info.field;\n\n                    Object val = reader.readObject(f.getName());\n\n                    try {\n                        f.set(portable, val);\n                    }\n                    catch (IllegalAccessException e) {\n                        throw new GridPortableException(\"Failed to set value for field: \" + f, e);\n                    }\n                }\n\n                return portable;\n\n            default:\n                assert false : \"Invalid mode: \" + mode;\n\n                return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2071,
    "type": "Return",
    "comment": "@return will always return an edge",
    "code": "public static HGVEdge getHGVEdge(HGPersistentHandle sourceH, HGPersistentHandle targetH) {\n    HGVNode source = getHGVNode(sourceH, true);\n    HGVNode target = getHGVNode(targetH, true);\n    if (source == null || target == null)\n        return null;\n    return getHGVEdge(source, target, true);\n}",
    "label": 1,
    "rec": "@return will always return an edge or null"
  },
  {
    "id": 2072,
    "type": "Return",
    "comment": "@return a  ThreadFactory.",
    "code": "  public static ThreadFactory getThreadFactory(String nameFormat, boolean daemon) {\n    return new ThreadFactoryBuilder()\n        .setDaemon(daemon)\n        .setNameFormat(nameFormat)\n        .build();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2073,
    "type": "Return",
    "comment": "@return the target of the symbolic link, or null if it is not a symbolic link",
    "code": "public static String readSymLink(File path) throws IOException {\n    Path nioPath = path.toPath();\n    Path target = Files.readSymbolicLink(nioPath);\n    String targetString = target.toString();\n    if (SystemReader.getInstance().isWindows()) {\n        targetString = targetString.replace(STR, STR);\n    } else if (SystemReader.getInstance().isMacOS()) {\n        targetString = Normalizer.normalize(targetString, Form.NFC);\n    }\n    return targetString;\n}",
    "label": 1,
    "rec": "@return target path of the symlink, or null if it is not a symbolic link"
  },
  {
    "id": 2074,
    "type": "Return",
    "comment": "@return standard message",
    "code": "\tpublic Msg makeStandardMessage(byte flags, byte cmd1, byte cmd2)\n\t\t\tthrows FieldException, IOException {\n\t\tMsg m = Msg.s_makeMessage(\"SendStandardMessage\");\n\t\tm.setAddress(\"toAddress\", getAddress());\n\t\tm.setByte(\"messageFlags\", flags);\n\t\tm.setByte(\"command1\", cmd1);\n\t\tm.setByte(\"command2\", cmd2);\n\t\treturn m;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2075,
    "type": "Return",
    "comment": "@return an {@link Iterator} visiting the given {@code kedge} and all connected edges in a(n almost) breadth first search fashion",
    "code": "public static Iterator<ElkEdge> getConnectedEdges(final ElkEdge edge) {\n    return Iterators.filter(getConnectedElements(edge, false), ElkEdge.class);\n}",
    "label": 1,
    "rec": "@return an {@link Iterator} visiting the given edge and all connected edges in a(n almost) breadth first search fashion"
  },
  {
    "id": 2076,
    "type": "Return",
    "comment": "@return Partition.",
    "code": "    public int partition(Object key) {\n        if (ctx.portableEnabled()) {\n            try {\n                key = ctx.marshalToPortable(key);\n            }\n            catch (IgniteException e) {\n                U.error(log, \"Failed to marshal key to portable: \" + key, e);\n            }\n        }\n\n        return aff.partition(affinityKey(key));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2077,
    "type": "Return",
    "comment": "@return List of String objects or an empty List",
    "code": "public List<String> getSuggestedReplacements() {\n    return Collections.unmodifiableList(suggestedReplacements);\n}",
    "label": 1,
    "rec": "@return unmodifiable list of String objects or an empty List"
  },
  {
    "id": 2078,
    "type": "Return",
    "comment": "@return the direct NIO  ByteBuffer created",
    "code": "    public ByteBuffer asByteBuffer() {\n        if (isNull()) {\n            return null;\n        }\n        if (limit > 0 && limit < position) {\n            throw new IllegalArgumentException(\"limit < position: (\" + limit + \" < \" + position + \")\");\n        }\n        int size = sizeof();\n        Pointer p = new Pointer();\n        p.address = address;\n        return p.position(size * position)\n                .limit(size * (limit <= 0 ? position + 1 : limit))\n                .asDirectBuffer().order(ByteOrder.nativeOrder());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2079,
    "type": "Return",
    "comment": "@return The thread-bound {@link ContainerRequest} instance.",
    "code": "public static ExecutionContext getContainerRequest() {\n    return (ExecutionContext) requestThreadLocal.get();\n}",
    "label": 1,
    "rec": "@return The thread-bound {@link ExecutionContext} instance."
  },
  {
    "id": 2080,
    "type": "Return",
    "comment": "@return boolean: true if it is converged; false otherwise",
    "code": "\tprotected boolean isConverged(int iter) {\n\n\t\t// print out debug info\n\t\tif (verbose) {\n\t\t\tLogs.debug(\"{}{} iter {}: errs = {}, delta_errs = {}, loss = {}, delta_loss = {}, learn_rate = {}\",\n\t\t\t\t\tnew Object[] { algoName, foldInfo, iter, (float) errs, (float) (last_errs - errs), (float) loss,\n\t\t\t\t\t\t\t(float) (Math.abs(last_loss) - Math.abs(loss)), (float) lRate });\n\t\t}\n\n\t\tif (Double.isNaN(loss)) {\n\t\t\tLogs.error(\"Loss = NaN: current settings cannot train the recommender! Try other settings instead!\");\n\t\t\tSystem.exit(-1);\n\t\t}\n\n\t\t// check if converged\n\t\tboolean cond1 = (errs < 1e-5);\n\t\tboolean cond2 = (last_errs >= errs && last_errs - errs < 1e-5);\n\t\tboolean converged = cond1 || cond2;\n\t\t\n\t\t// if not converged, update learning rate\n\t\tif(!converged)\n\t\t\tupdateLRate(iter);\n\t\t\n\t\treturn converged;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2081,
    "type": "Return",
    "comment": "@return  DetectorResult encapsulating results of detecting a PDF417 Code",
    "code": "  public PDF417DetectorResult detect(boolean multiple) throws NotFoundException {\n    return detect(null, multiple);\n  }\n",
    "label": 1,
    "rec": "@return  PDF417DetectorResult encapsulating results of detecting a PDF417 Code"
  },
  {
    "id": 2082,
    "type": "Return",
    "comment": "@return Class loader for given class (never  null).",
    "code": "    private static ClassLoader detectClassLoader(Class<?> cls) {\n        ClassLoader ctxClsLdr = Thread.currentThread().getContextClassLoader();\n\n        ClassLoader clsLdr = cls.getClassLoader();\n\n        if (clsLdr == null)\n            clsLdr = U.gridClassLoader();\n\n        if (U.p2pLoader(ctxClsLdr))\n            return clsLdr;\n\n        if (ctxClsLdr != null) {\n            if (ctxClsLdr == clsLdr)\n                return ctxClsLdr;\n\n            try {\n                // Check if context loader is wider than direct object class loader.\n                Class<?> c = Class.forName(cls.getName(), true, ctxClsLdr);\n\n                if (c == cls)\n                    return ctxClsLdr;\n            }\n            catch (ClassNotFoundException ignored) {\n                // No-op.\n            }\n        }\n\n        return clsLdr;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2083,
    "type": "Return",
    "comment": "@return The call service.",
    "code": "CallServiceWrapper getCallService(CallServiceDescriptor descriptor) {\n    registerCallService(descriptor);\n    return mCallServices.get(descriptor.getServiceComponent());\n}",
    "label": 1,
    "rec": "@return The corresponding call-service wrapper or null upon failure to retrieve it."
  },
  {
    "id": 2084,
    "type": "Return",
    "comment": "@return true if this task completed",
    "code": "    public boolean isFinished() {\n        AsyncHttpRequest _request = request.get();\n        return _request == null || _request.isDone();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2085,
    "type": "Return",
    "comment": "@return true if command was registered with the passed in label, false otherwise. If isAlias was true a return of false indicates no command was registered. If isAlias was false a return of false indicates the fallbackPrefix was used one or more times to create a unique name for the command",
    "code": "private synchronized boolean register(String label, Command command, boolean isAlias) {\n    if (isAlias && knownCommands.containsKey(label)) {\n        return false;\n    }\n    boolean registered = true;\n    Command conflict = knownCommands.get(label);\n    if (conflict != null && conflict.getLabel().equals(label)) {\n        return false;\n    }\n    if (!isAlias) {\n        command.setLabel(label);\n    }\n    knownCommands.put(label, command);\n    return registered;\n}",
    "label": 1,
    "rec": "@return true if command was registered, false otherwise."
  },
  {
    "id": 2086,
    "type": "Return",
    "comment": "@return a List",
    "code": "    public List<ZuulFilter> getFiltersByType(FilterType filterType) {\n\n        List<ZuulFilter> list = hashFiltersByType.get(filterType);\n        if (list != null) return list;\n\n        list = new ArrayList<ZuulFilter>();\n\n        Collection<ZuulFilter> filters = filterRegistry.getAllFilters();\n        for (Iterator<ZuulFilter> iterator = filters.iterator(); iterator.hasNext(); ) {\n            ZuulFilter filter = iterator.next();\n            if (filter.filterType().equals(filterType)) {\n                list.add(filter);\n            }\n        }\n\n        // Sort by filterOrder.\n        Collections.sort(list, Comparator.comparingInt(ZuulFilter::filterOrder));\n\n        hashFiltersByType.putIfAbsent(filterType, list);\n        return list;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2087,
    "type": "Return",
    "comment": "@return the directory \"$(ControllerConfig.defaultDir)/uninstall\": This needs to be improved",
    "code": "protected static File getLibraryUninstallDir() {\n    return new File(System.getProperty(STR, System.getProperty(STR)) + File.separator + STR + File.separator + STR + File.separator + STR);\n}",
    "label": 1,
    "rec": "@return the directory \"System.getProperty(\"app.home\", System.getProperty(\"user.home\")/lib/udfs/uninstall\""
  },
  {
    "id": 2088,
    "type": "Return",
    "comment": "@return Security credentials.",
    "code": "    public SecurityCredentials credentials() {\n        return creds;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2089,
    "type": "Return",
    "comment": "@return a list of resolved SRV addresses sorted by priority and weight.",
    "code": "public SrvResolverResult resolveSrv(DNSName name) throws IOException {\n    ResolverResult<SRV> result = resolve(name, SRV.class);\n    return new SrvResolverResult(result, this);\n}",
    "label": 1,
    "rec": "@return a <code>SrvResolverResult</code> instance which can be used to retrieve the addresses."
  },
  {
    "id": 2090,
    "type": "Return",
    "comment": "@return the resulting matrix",
    "code": "    public SparseMatrix run(SparseMatrix a, double maxResidual, double pGamma, double loopGain, double maxZero) {\n\n        //System.out.println(\"original matrix\\n\" + a.transpose().toStringDense());\n\n        // add cycles\n        addLoops(a, loopGain);\n\n        // make stochastic\n        a.normaliseRows();\n        //System.out.println(\"normalised\\n\" + a.transpose().toStringDense());\n\n        double residual = 1.;\n        int i = 0;\n\n        if (cancelled) {\n            return a;\n        }\n\n        // main iteration\n        while (residual > maxResidual) {\n            i++;\n            a = expand(a);\n            residual = inflate(a, pGamma, maxZero);\n            System.out.println(\"residual energy = \" + residual);\n            if (cancelled) {\n                return a;\n            }\n        }\n        return a;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2091,
    "type": "Return",
    "comment": "@return PriorityQueue<RegisteredListener> the looked up or create queue matching the requested type",
    "code": "private SortedSet<RegisteredListener> getEventListeners(Event.Type type) {\n    SortedSet<RegisteredListener> eventListeners = listeners.get(type);\n    if (eventListeners != null) {\n        return eventListeners;\n    }\n    eventListeners = new TreeSet<RegisteredListener>(comparer);\n    listeners.put(type, eventListeners);\n    return eventListeners;\n}",
    "label": 1,
    "rec": "@return SortedSet<RegisteredListener> the looked up or create queue matching the requested type"
  },
  {
    "id": 2092,
    "type": "Return",
    "comment": "@return The message processor",
    "code": "\tpublic static ZWaveCommandProcessor getMessageDispatcher(SerialMessage.SerialMessageClass serialMessage) {\n\t\tif(messageMap == null) {\n\t\t\tmessageMap = new HashMap<SerialMessage.SerialMessageClass, Class<? extends ZWaveCommandProcessor>>();\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AddNodeToNetwork, AddNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationCommandHandler, ApplicationCommandMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationUpdate, ApplicationUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignReturnRoute, AssignReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignSucReturnRoute, AssignSucReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.DeleteReturnRoute, DeleteReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.EnableSuc, EnableSucMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetRoutingInfo, GetRoutingInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetVersion, GetVersionMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetSucNodeId, GetSucNodeIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetControllerCapabilities, GetControllerCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IdentifyNode, IdentifyNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.MemoryGetId, MemoryGetIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveFailedNodeID, RemoveFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IsFailedNodeID, IsFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveNodeFromNetwork, RemoveNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeInfo, RequestNodeInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeNeighborUpdate, RequestNodeNeighborUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SendData, SendDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialApiGetCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetInitData, SerialApiGetInitDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiSetTimeouts, SerialApiSetTimeoutsMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiSoftReset, SerialApiSoftResetMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SetSucNodeID, SetSucNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SetDefault, ControllerSetDefaultMessageClass.class);\n\t\t}\n\n\t\tConstructor<? extends ZWaveCommandProcessor> constructor;\n\t\ttry {\n\t\t\tif(messageMap.get(serialMessage) == null) {\n\t\t\t\tlogger.warn(\"SerialMessage class {} is not implemented!\", serialMessage.getLabel());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconstructor = messageMap.get(serialMessage).getConstructor();\n\t\t\treturn constructor.newInstance();\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Command processor error\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2093,
    "type": "Return",
    "comment": "@return a set of supported values.",
    "code": "    public Collection<AspectRatio> getSupportedPictureAspectRatios() {\n        return Collections.unmodifiableSet(supportedPictureAspectRatio);\n    }\n",
    "label": 1,
    "rec": "@return a collection of supported values."
  },
  {
    "id": 2094,
    "type": "Return",
    "comment": "@return image",
    "code": "    protected BitmapDrawable getImage(final CommitUser user) {\n        return getImageBy(user.getEmail());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2095,
    "type": "Return",
    "comment": "@return <code>null</code>.",
    "code": "public static <T> T argThat(Matcher<T> matcher) {\n    return (T) MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(new HamcrestArgumentMatcher(matcher)).returnFor(MatcherGenericTypeExtractor.genericTypeOfMatcher(matcher.getClass()));\n}",
    "label": 1,
    "rec": "@return <code>null</code> or default value for primitive (0, false, etc.)"
  },
  {
    "id": 2096,
    "type": "Return",
    "comment": "@return Marshaller.",
    "code": "    public IgniteMarshaller marshaller() {\n        return ctx.config().getMarshaller();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2097,
    "type": "Return",
    "comment": "@return an {@link Iterator} visiting the given {@code kedges} and all (transitively) connected ones.",
    "code": "public static Iterator<ElkEdge> getConnectedEdges(final Iterable<ElkEdge> edges) {\n    return Iterators.concat(Iterators.transform(edges.iterator(), new Function<ElkEdge, Iterator<ElkEdge>>() {\n\n        public Iterator<ElkEdge> apply(final ElkEdge kedge) {\n            return getConnectedEdges(kedge);\n        }\n    }));\n}",
    "label": 1,
    "rec": "@return an {@link Iterator} visiting the given edges and all (transitively) connected ones."
  },
  {
    "id": 2098,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    private CacheConfiguration cacheConfig(GridCacheMode cacheMode, int preloadOrder, String name) {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setName(name);\n        cfg.setCacheMode(cacheMode);\n        cfg.setPreloadOrder(preloadOrder);\n        cfg.setPreloadMode(ASYNC);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2099,
    "type": "Return",
    "comment": "@return a list of articles, returns an empty list if not found",
    "code": "public JSONObject getArticlesByAuthorId(final String authorId, final int currentPageNum, final int pageSize) throws ServiceException {\n    try {\n        final JSONObject ret = articleRepository.getByAuthorId(authorId, currentPageNum, pageSize);\n        final JSONArray articles = ret.getJSONArray(Keys.RESULTS);\n        for (int i = NUM; i < articles.length(); i++) {\n            final JSONObject article = articles.getJSONObject(i);\n            article.put(ARTICLE_CREATE_TIME, article.getLong(ARTICLE_CREATED));\n            article.put(ARTICLE_T_CREATE_DATE, new Date(article.optLong(ARTICLE_CREATED)));\n            article.put(Article.ARTICLE_T_UPDATE_DATE, new Date(article.optLong(ARTICLE_UPDATED)));\n        }\n        return ret;\n    } catch (final Exception e) {\n        LOGGER.log(Level.ERROR, STR + authorId + STR + currentPageNum + STR + pageSize + STR, e);\n        throw new ServiceException(e);\n    }\n}",
    "label": 1,
    "rec": "@return result"
  },
  {
    "id": 2100,
    "type": "Return",
    "comment": "@return duration value in minutes",
    "code": "    protected static int parseDuration( String str )\n    {\n        if (str == null)\n            return 0;\n\n        int index = str.indexOf(\":\");\n\n        try\n        {\n            if (index > 0)\n            {\n                String hourStr = str.substring(0, index);\n                String minStr = str.substring(index + 1);\n                index = minStr.indexOf(\":\");\n                int minutes = 0;\n                if (index > 0)\n                {\n                    // string contains hours too\n                    String dayStr = hourStr;\n                    hourStr = minStr.substring(0, index);\n                    minStr = minStr.substring(index + 1);\n                    minutes = Integer.parseInt(dayStr) * 60 * 24;\n                }\n\n                minutes += Integer.parseInt(hourStr) * 60;\n                minutes += Integer.parseInt(minStr);\n                return minutes;\n            } else\n            {\n                return Integer.parseInt(str);\n            }\n        } catch (Exception ex)\n        {\n            logger.error(\"Cannot parse \" + str + \" using 0 minutes\");\n        }\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2101,
    "type": "Return",
    "comment": "@return last segment of commit file path",
    "code": "    public static String getName(final String path) {\n        if (TextUtils.isEmpty(path))\n            return path;\n\n        int lastSlash = path.lastIndexOf('/');\n        if (lastSlash != -1 && lastSlash + 1 < path.length())\n            return path.substring(lastSlash + 1);\n        else\n            return path;\n    }\n",
    "label": 1,
    "rec": "@return last segment of path"
  },
  {
    "id": 2102,
    "type": "Return",
    "comment": "@return the command class.",
    "code": "\tpublic ZWaveCommandClass resolveCommandClass(CommandClass commandClass, int endpointId)\n\t{\n\t\tif (commandClass == null)\n\t\t\treturn null;\n\t\t\n\t\tZWaveMultiInstanceCommandClass multiInstanceCommandClass = (ZWaveMultiInstanceCommandClass)supportedCommandClasses.get(CommandClass.MULTI_INSTANCE);\n\t\t\n\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 2) {\n\t\t\tZWaveEndpoint endpoint = multiInstanceCommandClass.getEndpoint(endpointId);\n\t\t\t\n\t\t\tif (endpoint != null) { \n\t\t\t\tZWaveCommandClass result = endpoint.getCommandClass(commandClass);\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t} \n\t\t}\n\t\t\n\t\tZWaveCommandClass result = getCommandClass(commandClass);\n\t\t\n\t\tif (result == null)\n\t\t\treturn result;\n\t\t\n\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 1 &&\n\t\t\t\tresult.getInstances() >= endpointId)\n\t\t\treturn result;\n\t\t\n\t\treturn endpointId == 1 ? result : null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2103,
    "type": "Return",
    "comment": "@return The context Map to use to pass to a  SubjectFactory for subject creation.",
    "code": "    protected SubjectContext resolvePrincipals(SubjectContext context) {\n        PrincipalCollection principals = context.resolvePrincipals();\n        if (CollectionUtils.isEmpty(principals)) {\n            log.trace(\"No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.\");\n            principals = getRememberedIdentity(context);\n            if (!CollectionUtils.isEmpty(principals)) {\n                log.debug(\"Found remembered PrincipalCollection.  Adding to the context to be used \" +\n                        \"for subject construction by the SubjectFactory.\");\n                context.setPrincipals(principals);\n            } else {\n                log.trace(\"No remembered identity found.  Returning original context.\");\n            }\n        }\n\n        return context;\n    }\n",
    "label": 1,
    "rec": "@return The Subject context to use to pass to a  SubjectFactory for subject creation."
  },
  {
    "id": 2104,
    "type": "Return",
    "comment": "@return true iff all bits are set or not set in range, according to value argument",
    "code": "  public boolean isRange(int start, int end, boolean value) {\n    if (end < start) {\n      throw new IllegalArgumentException();\n    }\n    if (end == start) {\n      return true; // empty range matches\n    }\n    end--; // will be easier to treat this as the last actually set bit -- inclusive    \n    int firstInt = start >> 5;\n    int lastInt = end >> 5;\n    for (int i = firstInt; i <= lastInt; i++) {\n      int firstBit = i > firstInt ? 0 : start & 0x1F;\n      int lastBit = i < lastInt ? 31 : end & 0x1F;\n      int mask;\n      if (firstBit == 0 && lastBit == 31) {\n        mask = -1;\n      } else {\n        mask = 0;\n        for (int j = firstBit; j <= lastBit; j++) {\n          mask |= 1 << j;\n        }\n      }\n\n      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,\n      // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n      if ((bits[i] & mask) != (value ? mask : 0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2105,
    "type": "Return",
    "comment": "@return binary plaintext",
    "code": "public byte[] decrypt(byte[] cipherData) {\n    if (cipherData.length < OVERHEAD_SIZE) {\n        throw new DoubleClickCryptoException(STR + cipherData.length + STR);\n    }\n    byte[] workBytes = cipherData.clone();\n    ByteBuffer workBuffer = ByteBuffer.wrap(workBytes);\n    try {\n        xorPayloadToHmacPad(workBytes);\n        int confirmationSignature = hmacSignature(workBytes);\n        int integritySignature = workBuffer.getInt(workBytes.length - SIGNATURE_SIZE);\n        workBuffer.putInt(workBytes.length - SIGNATURE_SIZE, confirmationSignature);\n        if (confirmationSignature != integritySignature) {\n            throw new DoubleClickCryptoException(STR + Integer.toHexString(confirmationSignature) + STR + Integer.toHexString(integritySignature));\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(dump(STR, cipherData, workBytes));\n        }\n        return workBytes;\n    } catch (InvalidKeyException | NoSuchAlgorithmException | ShortBufferException e) {\n        if (logger.isWarnEnabled()) {\n            logger.warn(dump(STR, cipherData, workBytes));\n        }\n        throw new DoubleClickCryptoException(e);\n    }\n}",
    "label": 1,
    "rec": "@return initVector || payload || I'(signature) Where I'(signature) == I(signature) for success, different for failure"
  },
  {
    "id": 2106,
    "type": "Return",
    "comment": "@return JDK marshaller.",
    "code": "    Marshaller jdkMarshaller() {\n        return jdkMarshaller;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2107,
    "type": "Return",
    "comment": "@return This proxy for chaining, never {@code null}.",
    "code": "public Proxy setPort(int port) {\n    return new Proxy(type, host, port, auth);\n}",
    "label": 1,
    "rec": "@return The new proxy, never {@code null}."
  },
  {
    "id": 2108,
    "type": "Return",
    "comment": "@return Path.",
    "code": "    public IgniteFsPath path() {\n        return path;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2109,
    "type": "Return",
    "comment": "@return this event.",
    "code": "public DefaultTransferEvent setDataBuffer(byte[] buffer, int offset, int length) {\n    return setDataBuffer(ByteBuffer.wrap(buffer, offset, length));\n}",
    "label": 1,
    "rec": "@return This event for chaining, never {@code null}."
  },
  {
    "id": 2110,
    "type": "Return",
    "comment": "@return new  ExecutionResult with event added",
    "code": "    public ExecutionResult addEvent(HystrixEventType eventType) {\n        return new ExecutionResult(eventCounts.plus(eventType), startTimestamp, executionLatency,\n                userThreadLatency, failedExecutionException, executionException,\n                executionOccurred ? executionOccurred : didExecutionOccur(eventType), isExecutedInThread, collapserKey);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2111,
    "type": "Return",
    "comment": "@return depth, or  TransactionConfidence#NOT_IN_BEST_CHAIN or  TransactionConfidence#NOT_SEEN_IN_CHAIN",
    "code": "    public int getDepthInBlocks(BlockChain chain) {\n        if (getConfidenceType() != ConfidenceType.BUILDING) {\n            throw new IllegalStateException(\"Confidence type is not BUILDING\");\n        }\n        int height = getAppearedAtChainHeight();\n        return chain.getBestChainHeight() - height + 1;\n    }\n",
    "label": 1,
    "rec": "@return depth"
  },
  {
    "id": 2112,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private GridComputeJob job(final Runnable r) {\n        A.notNull(r, \"job\");\n\n        if (r instanceof GridComputeJobMasterLeaveAware) {\n            return new GridMasterLeaveAwareComputeJobAdapter() {\n                @Nullable @Override public Object execute() {\n                    r.run();\n\n                    return null;\n                }\n\n                @Override public void onMasterNodeLeft(GridComputeTaskSession ses) throws GridException {\n                    ((GridComputeJobMasterLeaveAware)r).onMasterNodeLeft(ses);\n                }\n            };\n        }\n        else {\n            return new GridComputeJobAdapter() {\n                @Nullable @Override public Object execute() {\n                    r.run();\n\n                    return null;\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2113,
    "type": "Return",
    "comment": "@return true if CA certificate",
    "code": "public Optional<Boolean> getBasicConstraints() {\n    return getExtensions().map(BasicConstraints::fromExtensions).findAny().map(BasicConstraints::isCA);\n}",
    "label": 1,
    "rec": "@return If basic constraints extension is present: returns true if CA cert, false otherwise. Returns empty if the extension is not present."
  },
  {
    "id": 2114,
    "type": "Return",
    "comment": "@return Context which should be used for inflating the header layout",
    "code": "        public Context getContextForInflater(Activity activity) {\n            Context context = null;\n            ActionBar ab = ((ActionBarActivity) activity).getSupportActionBar();\n            if (ab != null) {\n                context = ab.getThemedContext();\n            }\n            if (context == null) {\n                context = activity;\n            }\n            return context;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2115,
    "type": "Return",
    "comment": "@return top <i>n</i> entries sorted by descending value",
    "code": "public Int2IntMap.Entry[] getEntriesSortedByValue(int k) {\n    Int2IntMap.Entry[] entries = getEntriesSortedByValue();\n    if (entries == null)\n        return null;\n    if (entries.length < k)\n        return entries;\n    return Arrays.copyOfRange(entries, NUM, k);\n}",
    "label": 1,
    "rec": "@return top <i>k</i> entries sorted by descending value"
  },
  {
    "id": 2116,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            GridBiTuple<String, String> t = stash.get();\n\n            return GridGainEx.gridx(t.get1()).cachex(t.get2());\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2117,
    "type": "Return",
    "comment": "@return the DocumentFragment resulting from the parse of the source",
    "code": "Node deserialize(String source, Node ctx) throws XMLEncryptionException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    Map<String, String> storedNamespaces = new HashMap<String, String>();\n    Node wk = ctx;\n    while (wk != null) {\n        NamedNodeMap atts = wk.getAttributes();\n        if (atts != null) {\n            for (int i = NUM; i < atts.getLength(); ++i) {\n                Node att = atts.item(i);\n                String nodeName = att.getNodeName();\n                if ((nodeName.equals(STR) || nodeName.startsWith(STR)) && !storedNamespaces.containsKey(att.getNodeName())) {\n                    sb.append(STR + nodeName + STR + att.getNodeValue() + STR);\n                    storedNamespaces.put(nodeName, att.getNodeValue());\n                }\n            }\n        }\n        wk = wk.getParentNode();\n    }\n    sb.append(STR + source + STR);\n    String fragment = sb.toString();\n    try {\n        if (dbf == null) {\n            dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            dbf.setAttribute(STR, Boolean.TRUE);\n            dbf.setValidating(false);\n        }\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Document d = db.parse(new InputSource(new StringReader(fragment)));\n        Element fragElt = (Element) contextDocument.importNode(d.getDocumentElement(), true);\n        DocumentFragment result = contextDocument.createDocumentFragment();\n        Node child = fragElt.getFirstChild();\n        while (child != null) {\n            fragElt.removeChild(child);\n            result.appendChild(child);\n            child = fragElt.getFirstChild();\n        }\n        return result;\n    } catch (SAXException se) {\n        throw new XMLEncryptionException(STR, se);\n    } catch (ParserConfigurationException pce) {\n        throw new XMLEncryptionException(STR, pce);\n    } catch (IOException ioe) {\n        throw new XMLEncryptionException(STR, ioe);\n    }\n}",
    "label": 1,
    "rec": "@return the Node resulting from the parse of the source"
  },
  {
    "id": 2118,
    "type": "Return",
    "comment": "@return nearest  int",
    "code": "  public static int round(float d) {\n    return (int) (d + (d < 0.0f ? -0.5f : 0.5f));\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2119,
    "type": "Return",
    "comment": "@return A {@see WorkbenchModuleResource}associated with the current ModuleCore with its sourcePath equivalent to aResource",
    "code": "public ComponentResource createWorkbenchModuleResource(IResource aResource) {\n    if (isReadOnly)\n        throwAttemptedReadOnlyModification();\n    ComponentResource moduleResource = MODULE_FACTORY.createWorkbenchModuleResource();\n    String sourcePath = IPath.SEPARATOR + aResource.getProject().getName() + IPath.SEPARATOR + aResource.getProjectRelativePath().toString();\n    moduleResource.setSourcePath(URI.createURI(sourcePath));\n    return moduleResource;\n}",
    "label": 1,
    "rec": "@return A {@see ComponentResource}associated with the current ModuleCore with its sourcePath equivalent to aResource"
  },
  {
    "id": 2120,
    "type": "Return",
    "comment": "@return Collection of cache nodes.",
    "code": "    public Collection<ClusterNode> nodes(long topVer) {\n        return nodes(new AffinityTopologyVersion(topVer));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2121,
    "type": "Return",
    "comment": "@return {@link PropertiesItem}",
    "code": "private IItem getSelectedItem() {\n    final ISelection selection = viewer.getSelection();\n    return (IItem) ((IStructuredSelection) selection).getFirstElement();\n}",
    "label": 1,
    "rec": "@return {@link IItem}"
  },
  {
    "id": 2122,
    "type": "Return",
    "comment": "@return  True if need to undeploy.",
    "code": "    private boolean undeploy(ClassLoader ldr, GridCacheEntryEx e, GridCacheAdapter cache) {\n        KeyCacheObject key = e.key();\n\n        GridCacheEntryEx entry = cache.peekEx(key);\n\n        if (entry == null)\n            return false;\n\n        Object key0;\n        Object val0;\n\n        try {\n            CacheObject v = entry.peek(GridCachePeekMode.GLOBAL, CU.empty0());\n\n            key0 = key.value(cache.context().cacheObjectContext(), false);\n\n            assert key0 != null : \"Key cannot be null for cache entry: \" + e;\n\n            val0 = CU.value(v, cache.context(), false);\n        }\n        catch (GridCacheEntryRemovedException ignore) {\n            return false;\n        }\n        catch (IgniteException ignore) {\n            // Peek can throw runtime exception if unmarshalling failed.\n            return true;\n        }\n\n        ClassLoader keyLdr = U.detectObjectClassLoader(key0);\n        ClassLoader valLdr = U.detectObjectClassLoader(val0);\n\n        boolean res = F.eq(ldr, keyLdr) || F.eq(ldr, valLdr);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Finished examining entry [entryCls=\" + e.getClass() +\n                \", key=\" + key0 + \", keyCls=\" + key0.getClass() +\n                \", valCls=\" + (val0 != null ? val0.getClass() : \"null\") +\n                \", keyLdr=\" + keyLdr + \", valLdr=\" + valLdr + \", res=\" + res + ']');\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2123,
    "type": "Return",
    "comment": "@return the revision",
    "code": "public InternalCDORevision getRevision(final CDOID id) {\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        AbstractQueryStatement<InternalCDORevision> query = createGetRevisionByIDStatement(id);\n        return query.query(connection);\n    } catch (Exception e) {\n        throw new DBException(STR, e);\n    } finally {\n        DBUtil.close(connection);\n    }\n}",
    "label": 1,
    "rec": "@return the revision that was found"
  },
  {
    "id": 2124,
    "type": "Return",
    "comment": "@return a Size",
    "code": "    public Size getPreviewSize() {\n        return mCameraController != null ? mCameraController.getPreviewSize() : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2125,
    "type": "Return",
    "comment": "@return Returns author's name, or <code>null</code> if not known",
    "code": "public String getAuthorName() {\n    return getAttributeValue(RepositoryTaskAttribute.COMMENT_AUTHOR_NAME);\n}",
    "label": 1,
    "rec": "@return Returns author's name, or an empty string"
  },
  {
    "id": 2126,
    "type": "Return",
    "comment": "@return the result of  Process#waitFor()",
    "code": "    int compile(String sourceFilename, String outputFilename, ClassProperties properties)\n            throws IOException, InterruptedException {\n        ArrayList<String> command = new ArrayList<String>();\n\n        includeJavaPaths(properties, header);\n\n        String platform  = Loader.getPlatform();\n        String compilerPath = properties.getProperty(\"platform.compiler\");\n        command.add(compilerPath);\n\n        {\n            String p = properties.getProperty(\"platform.sysroot.prefix\", \"\");\n            for (String s : properties.get(\"platform.sysroot\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.includepath.prefix\", \"\");\n            for (String s : properties.get(\"platform.includepath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        command.add(sourceFilename);\n\n        Collection<String> allOptions = properties.get(\"platform.compiler.*\");\n        if (allOptions.isEmpty()) {\n            allOptions.add(\"default\");\n        }\n        for (String s : allOptions) {\n            if (s == null || s.length() == 0) {\n                continue;\n            }\n            String p = \"platform.compiler.\" + s;\n            String options = properties.getProperty(p);\n            if (options != null && options.length() > 0) {\n                command.addAll(Arrays.asList(options.split(\" \")));\n            } else if (!\"default\".equals(s)) {\n                logger.warn(\"Could not get the property named \\\"\" + p + \"\\\"\");\n            }\n        }\n\n        command.addAll(compilerOptions);\n\n        String output = properties.getProperty(\"platform.compiler.output\");\n        if (output != null && output.length() > 0) {\n            command.addAll(Arrays.asList(output.split(\" \")));\n        }\n\n        if (output == null || output.length() == 0 || output.endsWith(\" \")) {\n            command.add(outputFilename);\n        } else {\n            command.add(command.remove(command.size() - 1) + outputFilename);\n        }\n\n        {\n            String p  = properties.getProperty(\"platform.linkpath.prefix\", \"\");\n            String p2 = properties.getProperty(\"platform.linkpath.prefix2\");\n            for (String s : properties.get(\"platform.linkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                    if (p2 != null) {\n                        if (p2.endsWith(\" \")) {\n                            command.add(p2.trim()); command.add(s);\n                        } else {\n                            command.add(p2 + s);\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.link.prefix\", \"\");\n            String x = properties.getProperty(\"platform.link.suffix\", \"\");\n            int i = command.size(); // to inverse order and satisfy typical compilers\n            for (String s : properties.get(\"platform.link\")) {\n                String[] libnameversion = s.split(\"@\");\n                if (libnameversion.length == 3 && libnameversion[1].length() == 0) {\n                    // Only use the version number when the user gave us a double @\n                    s = libnameversion[0] + libnameversion[2];\n                } else {\n                    s = libnameversion[0];\n                }\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s); command.add(i + 2, x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(i, p + s); command.add(i + 1, x.trim());\n                } else {\n                    command.add(i, p + s + x);\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.frameworkpath.prefix\", \"\");\n            for (String s : properties.get(\"platform.frameworkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.framework.prefix\", \"\");\n            String x = properties.getProperty(\"platform.framework.suffix\", \"\");\n            for (String s : properties.get(\"platform.framework\")) {\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(p.trim()); command.add(s); command.add(x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(p.trim()); command.add(s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(p + s); command.add(x.trim());\n                } else {\n                    command.add(p + s + x);\n                }\n            }\n        }\n\n        String text = \"\";\n        boolean windows = platform.startsWith(\"windows\");\n        for (String s : command) {\n            boolean hasSpaces = s.indexOf(\" \") > 0;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += s;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += \" \";\n        }\n        logger.info(text);\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (environmentVariables != null) {\n            pb.environment().putAll(environmentVariables);\n        }\n        return pb.inheritIO().start().waitFor();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2127,
    "type": "Return",
    "comment": "@return this path its geometry (cached)",
    "code": "    public PointList calcPoints()\n    {\n        final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());\n        if (edgeIds.isEmpty())\n        {\n            if (isFound())\n            {\n                points.add(graph.getNodeAccess(), endNode);\n            }\n            return points;\n        }\n\n        int tmpNode = getFromNode();\n        points.add(nodeAccess, tmpNode);\n        forEveryEdge(new EdgeVisitor()\n        {\n            @Override\n            public void next( EdgeIteratorState eb, int index )\n            {\n                PointList pl = eb.fetchWayGeometry(2);\n                for (int j = 0; j < pl.getSize(); j++)\n                {\n                    points.add(pl, j);\n                }\n            }\n        });\n        return points;\n    }\n",
    "label": 1,
    "rec": "@return this path its geometry"
  },
  {
    "id": 2128,
    "type": "Return",
    "comment": "@return dialog",
    "code": "    public static AlertDialog create(final Context context) {\n        return new LightAlertDialog(context, THEME_HOLO_LIGHT);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2129,
    "type": "Return",
    "comment": "@return <code>true</code> if the <code>AccDefaultFlag</code> flag is included",
    "code": "public static boolean isDefaultMethod(int flags) {\n    return (flags & AccDefaultMethod) != NUM;\n}",
    "label": 1,
    "rec": "@return <code>true</code> if the <code>AccDefaultMethod</code> flag is included"
  },
  {
    "id": 2130,
    "type": "Return",
    "comment": "@return next newly created key using the child derivation funtcion",
    "code": "    public DeterministicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation) {\n        DeterministicKey parent = get(parentPath, relative, createParent);\n        int nAttempts = 0;\n        while (nAttempts++ < MAX_CHILD_DERIVATION_ATTEMPTS) {\n            try {\n                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getChildNumberPath(), privateDerivation);\n                return deriveChild(parent, createChildNumber);\n            } catch (HDDerivationException ignore) { }\n        }\n        throw new HDDerivationException(\"Maximum number of child derivation attempts reached, this is probably an indication of a bug.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2131,
    "type": "Return",
    "comment": "@return an int array, containing due, time, eta, currentDeckdue",
    "code": "public static int[] getWidgetSmallStatus(Context context) {\n    openDBIfClosed(context);\n    Cursor cursor = null;\n    int due = NUM;\n    int progress = NUM;\n    int eta = NUM;\n    boolean noDeck = true;\n    try {\n        cursor = mMetaDb.query(STR, new String[] { STR, STR, STR, STR, STR, STR }, null, null, null, null, null);\n        while (cursor.moveToNext()) {\n            noDeck = false;\n            if (cursor.getInt(NUM) == NUM) {\n                due += cursor.getInt(NUM) + cursor.getInt(NUM) + cursor.getInt(NUM);\n                progress = cursor.getInt(NUM);\n                eta = cursor.getInt(NUM);\n            }\n        }\n    } catch (SQLiteException e) {\n        Log.e(AnkiDroidApp.TAG, STR, e);\n    } finally {\n        if (cursor != null && !cursor.isClosed()) {\n            cursor.close();\n        }\n    }\n    return new int[] { noDeck ? -NUM : due, progress, eta };\n}",
    "label": 1,
    "rec": "@return an int array, containing due, progress, eta"
  },
  {
    "id": 2132,
    "type": "Return",
    "comment": "@return Exchange type.",
    "code": "    private ExchangeType onClientNodeEvent(boolean crd) throws IgniteCheckedException {\n        assert CU.clientNode(discoEvt.eventNode()) : this;\n\n        if (discoEvt.type() == EVT_NODE_LEFT || discoEvt.type() == EVT_NODE_FAILED) {\n            onLeft();\n\n            assert !discoEvt.eventNode().isLocal() : discoEvt;\n        }\n        else\n            assert discoEvt.type() == EVT_NODE_JOINED || discoEvt.type() == EVT_DISCOVERY_CUSTOM_EVT : discoEvt;\n\n        cctx.affinity().onClientEvent(this, crd);\n\n        return discoEvt.eventNode().isLocal() ? ExchangeType.CLIENT : ExchangeType.NONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2133,
    "type": "Return",
    "comment": "@return the integer reference",
    "code": "public long put(String name) {\n    if (name == null || name.isEmpty()) {\n        return NUM;\n    }\n    if (name.equals(lastName)) {\n        return lastIndex;\n    }\n    byte[] bytes = getBytes(name);\n    long oldPointer = bytePointer;\n    names.ensureCapacity(bytePointer + NUM + bytes.length);\n    byte[] sizeBytes = new byte[] { (byte) bytes.length };\n    names.setBytes(bytePointer, sizeBytes, sizeBytes.length);\n    bytePointer++;\n    names.setBytes(bytePointer, bytes, bytes.length);\n    bytePointer += bytes.length;\n    if (bytePointer < NUM) {\n        throw new IllegalStateException(STR);\n    }\n    lastName = name;\n    lastIndex = oldPointer;\n    return oldPointer;\n}",
    "label": 1,
    "rec": "@return the byte pointer to the name"
  },
  {
    "id": 2134,
    "type": "Return",
    "comment": "@return All the fields names contained into a hash.",
    "code": "    public List<String> hkeys(String key) {\n        runChecks();\n        client.hkeys(key);\n        return client.getMultiBulkReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2135,
    "type": "Return",
    "comment": "@return The brightness as a value from 0 -  HueBulb#MAX_BRIGHTNESS",
    "code": "\tpublic int getBrightness(int deviceNumber) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(Integer.toString(deviceNumber)).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 1,
    "rec": "@return The brightness as a value from 0 - 255"
  },
  {
    "id": 2136,
    "type": "Return",
    "comment": "@return Deployment mode.",
    "code": "    public IgniteDeploymentMode deploymentMode() {\n        return depMode;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2137,
    "type": "Return",
    "comment": "@return a key with some specific properties.",
    "code": "public static Key createKey(Message proto, int keyId, KeyStatusType status, OutputPrefixType prefixType) throws Exception {\n    return createKey(proto, keyId, status, prefixType, KeyData.KeyMaterialType.UNKNOWN_KEYMATERIAL);\n}",
    "label": 1,
    "rec": "@return a key with some specified properties."
  },
  {
    "id": 2138,
    "type": "Return",
    "comment": "@return Grid instance.",
    "code": "    public IgniteEx grid() {\n        return ctx.grid();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2139,
    "type": "Return",
    "comment": "@return true if the name is valid",
    "code": "@Deprecated\nprotected boolean validate(String name) {\n    return true;\n}",
    "label": 1,
    "rec": "@return Always <code>true</code>"
  },
  {
    "id": 2140,
    "type": "Return",
    "comment": "@return the Annotation that this interceptor will process for the specified method invocation.",
    "code": "    protected Annotation getAnnotation(MethodInvocation mi) throws IllegalArgumentException {\n        if (mi == null) {\n            throw new IllegalArgumentException(\"method argument cannot be null\");\n        }\n        Method m = mi.getMethod();\n        if (m == null) {\n            String msg = MethodInvocation.class.getName() + \" parameter incorrectly \" +\n                    \"constructed.  getMethod() returned null\";\n            throw new IllegalArgumentException(msg);\n\n        }\n        return m.getAnnotation(getHandler().getAnnotationClass());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2141,
    "type": "Return",
    "comment": "@return a string describing the status and contents of the AllocationPointerOperations",
    "code": "public static final String dump(final long[] address) {\n    if (address == null || address.length == NUM)\n        throw new IllegalArgumentException(STR);\n    final byte dim = getDimension(address[NUM]);\n    StringBuilder b = new StringBuilder(print(address));\n    return b.toString();\n}",
    "label": 1,
    "rec": "@return a string describing the details of the AllocationPointer FIXME: implement this"
  },
  {
    "id": 2142,
    "type": "Return",
    "comment": "@return Collection of cache nodes.",
    "code": "    public Collection<ClusterNode> cacheNodes(AffinityTopologyVersion topVer) {\n        return resolveDiscoCache(null, topVer).allNodesWithCaches(topVer.topologyVersion());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2143,
    "type": "Return",
    "comment": "@return the new long array backed by a buffer or an array",
    "code": "    public static LongIndexer create(final LongPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new LongRawIndexer(pointer, sizes, strides)\n                                             : new LongBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            long[] array = new long[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new LongArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new long indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 2144,
    "type": "Return",
    "comment": "@return amount of counters in the given group.",
    "code": "    public int groupSize(String grpName) {\n        int res = 0;\n\n        for (GridHadoopCounter counter : cntrs.values()) {\n            if (grpName.equals(counter.group()))\n                res++;\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2145,
    "type": "Return",
    "comment": "@return the byte length of bundle object",
    "code": "public long getLength() throws IOException {\n    return bundleLength;\n}",
    "label": 1,
    "rec": "@return the byte length of messages"
  },
  {
    "id": 2146,
    "type": "Return",
    "comment": "@return Page link.",
    "code": "    public static long link(long pageId, int itemId) {\n        assert itemId >= 0 && itemId < 255: itemId;\n        assert (pageId >> (PAGE_IDX_SIZE + RESERVED_SIZE + FILE_ID_SIZE)) == 0 : U.hexLong(pageId);\n\n        return pageId | (((long)itemId) << (PAGE_IDX_SIZE + FILE_ID_SIZE + RESERVED_SIZE));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2147,
    "type": "Return",
    "comment": "@return an {@link OpcBinaryDataTypeCodec}, or {@code null} if none was found.",
    "code": "@Nullable\ndefault OpcUaBinaryDataTypeCodec<?> getBinaryCodec(String namespaceUri, String description) {\n    DataTypeCodec codec = getCodec(namespaceUri, description);\n    if (codec instanceof OpcUaBinaryDataTypeCodec) {\n        return (OpcUaBinaryDataTypeCodec) codec;\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return an {@link OpcUaBinaryDataTypeCodec}, or {@code null} if none was found."
  },
  {
    "id": 2148,
    "type": "Return",
    "comment": "@return Description.",
    "code": "    public String description() {\n        return \"-nn=\" + nodes + \"-b=\" + backups + \"-sm=\" + syncMode + \"-cl=\" + clientOnly +\n            (orderMode == null ? \"\" : \"-wom=\" + orderMode) + \"-txc=\" + txConcurrency;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2149,
    "type": "Return",
    "comment": "@return the ByteArray representing the key",
    "code": "private List<ByteArray> readKey(String requestURI) {\n    List<ByteArray> keyList = null;\n    String[] parts = requestURI.split(STR);\n    if (parts.length > NUM) {\n        String base64KeyList = parts[NUM];\n        keyList = new ArrayList<ByteArray>();\n        if (!base64KeyList.contains(STR)) {\n            String rawKey = base64KeyList.trim();\n            keyList.add(new ByteArray(Base64.decodeBase64(rawKey.getBytes())));\n        } else {\n            String[] base64KeyArray = base64KeyList.split(STR);\n            for (String base64Key : base64KeyArray) {\n                String rawKey = base64Key.trim();\n                keyList.add(new ByteArray(Base64.decodeBase64(rawKey.getBytes())));\n            }\n        }\n    }\n    return keyList;\n}",
    "label": 1,
    "rec": "@return the List<ByteArray> representing the key (or keys)"
  },
  {
    "id": 2150,
    "type": "Return",
    "comment": "@return Local node.",
    "code": "    public ClusterNode localNode() {\n        return kernalCtx.discovery().localNode();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2151,
    "type": "Return",
    "comment": "@return a Vector of Strings representing the species for which the data source contains information",
    "code": "public Vector getSupportedSpecies() {\n    String sql = STR;\n    ResultSet rs = query(sql);\n    if (rs == null) {\n        return EMPTY_VECTOR;\n    }\n    Vector taxid = new Vector();\n    try {\n        while (rs.next()) {\n            String sp = rs.getString(NUM);\n            taxid.add(sp);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n        return taxid;\n    }\n    return taxid;\n}",
    "label": 1,
    "rec": "@return a Vector of Strings representing the taxid for which the data source contains information"
  },
  {
    "id": 2152,
    "type": "Return",
    "comment": "@return  True if value is in the set.",
    "code": "        boolean containsValue(V v) {\n            A.notNull(v, \"value\");\n\n            for (Iterator<V> it = valueIterator(); it.hasNext(); ) {\n                V v0 = it.next();\n\n                if (F.eq(v0, v))\n                    return true;\n            }\n\n            return false;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2153,
    "type": "Return",
    "comment": "@return an iterable of all {@link MessageObserver} of this message",
    "code": "public List<MessageObserver> getMessageObservers() {\n    if (messageObservers == null) {\n        return Collections.emptyList();\n    } else {\n        return Collections.unmodifiableList(messageObservers);\n    }\n}",
    "label": 1,
    "rec": "@return an immutable list of the registered observers."
  },
  {
    "id": 2154,
    "type": "Return",
    "comment": "@return procedure result",
    "code": "    static boolean sessionForThreadHasFailed()\n    {\n        return failedSessionThreads.contains(Thread.currentThread());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2155,
    "type": "Return",
    "comment": "@return the value of the '<em>Server</em>' reference.",
    "code": "public IBuildServer getServer() {\n    if (eContainerFeatureID() != BuildPackage.BUILD_PLAN__SERVER)\n        return null;\n    return (IBuildServer) eContainer();\n}",
    "label": 1,
    "rec": "@return the value of the '<em>Server</em>' container reference."
  },
  {
    "id": 2156,
    "type": "Return",
    "comment": "@return SVMLightPArser instance or null",
    "code": "  public static PSetupGuess guessSetup(byte [] bits){\n    InputStream is = new ByteArrayInputStream(bits);\n    SVMLightParser p = new SVMLightParser(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, false));\n    InspectDataOut dout = new InspectDataOut();\n    try{p.streamParse(is, dout);}catch(Exception e){throw new RuntimeException(e);}\n    return new PSetupGuess(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, dout._ncols,false,null,false),dout._nlines,dout._invalidLines,dout.data(),dout.errors());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2157,
    "type": "Return",
    "comment": "@return the default response for method calls on the mock object",
    "code": "public IDefaultResponse getDefaultResponse() {\n    return defaultResponse;\n}",
    "label": 1,
    "rec": "@return the default response strategy for the mock object"
  },
  {
    "id": 2158,
    "type": "Return",
    "comment": "@return Oldest node.",
    "code": "    ClusterNode oldestNode() {\n        return oldestNode.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2159,
    "type": "Return",
    "comment": "@return ratio of total variance between counters and pattern compared to total pattern size, where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means the total variance between counters and patterns equals the pattern length, higher values mean even more variance",
    "code": "  private static float patternMatchVariance(int[] counters, int[] pattern, float maxIndividualVariance) {\n    int numCounters = counters.length;\n    int total = 0;\n    int patternLength = 0;\n    for (int i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this\n      // is too small to reliably match, so fail:\n      return Float.POSITIVE_INFINITY;\n    }\n    // We're going to fake floating-point math in integers. We just need to use more bits.\n    // Scale up patternLength so that intermediate values below like scaledCounter will have\n    // more \"significant digits\".\n    float unitBarWidth = (float) total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n\n    float totalVariance = 0.0f;\n    for (int x = 0; x < numCounters; x++) {\n      int counter = counters[x];\n      float scaledPattern = pattern[x] * unitBarWidth;\n      float variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n      if (variance > maxIndividualVariance) {\n        return Float.POSITIVE_INFINITY;\n      }\n      totalVariance += variance;\n    }\n    return totalVariance / total;\n  }\n",
    "label": 1,
    "rec": "@return ratio of total variance between counters and pattern compared to total pattern size"
  },
  {
    "id": 2160,
    "type": "Return",
    "comment": "@return the current contents of this output stream, as a byte array.",
    "code": "    public byte toByteArray()[] {\n        return count == buf.length ? buf : copyOf(buf, count);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2161,
    "type": "Return",
    "comment": "@return the {@link org.apache.tez.runtime.api.TezOutputContext} for the output",
    "code": "public final OutputContext getContext() {\n    return outputContext;\n}",
    "label": 1,
    "rec": "@return the {@link org.apache.tez.runtime.api.OutputContext} for the output"
  },
  {
    "id": 2162,
    "type": "Return",
    "comment": "@return Handle.",
    "code": "    int handle(Object obj) {\n        assert obj != null;\n\n        Integer h = handles.get(obj);\n\n        if (h != null)\n            return out.position() - h;\n        else {\n            handles.put(obj, out.position());\n\n            return -1;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2163,
    "type": "Return",
    "comment": "@return a new session instance.",
    "code": "public Session createSession(SessionContext initData) {\n    if (initData != null) {\n        String host = initData.getHost();\n        if (host != null) {\n            return new SimpleSession(host);\n        }\n    }\n    return new SimpleSession();\n}",
    "label": 1,
    "rec": "@return a new {@link SimpleSession SimpleSession} instance"
  },
  {
    "id": 2164,
    "type": "Return",
    "comment": "@return Entry file ID.",
    "code": "    public IgniteUuid fileId() {\n        return fileId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2165,
    "type": "Return",
    "comment": "@return either the local object corresponding to that identifier, or null if there is no match",
    "code": "public ATObject resolveObject(ATObjectID objectId) {\n    ATObject localObject = (ATObject) exportedObjectsTable_.get(objectId);\n    if (localObject == null) {\n        if (objectId.isRemote()) {\n            return createRemoteFarRef(objectId);\n        } else {\n            ELActor localActor = owner_.getHost().getActor(objectId.getActorId());\n            return createLocalFarRef(localActor, objectId);\n        }\n    } else {\n        return localObject;\n    }\n}",
    "label": 1,
    "rec": "@return either the local object corresponding to that identifier, or a far reference designating the id"
  },
  {
    "id": 2166,
    "type": "Return",
    "comment": "@return  True if system cache.",
    "code": "    public static boolean isSystemCache(String cacheName) {\n        return isUtilityCache(cacheName) || isHadoopSystemCache(cacheName);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2167,
    "type": "Return",
    "comment": "@return Validation state that should be effective for the parent element state",
    "code": "public boolean pop() throws XMLStreamException {\n    if (mSize == NUM) {\n        throw new IllegalStateException(STR);\n    }\n    mElements[--mSize] = null;\n    return (mSize > NUM);\n}",
    "label": 1,
    "rec": "@return True if stack still has elements; false if not (root closed)"
  },
  {
    "id": 2168,
    "type": "Return",
    "comment": "@return Set ID.",
    "code": "    public IgniteUuid setId() {\n        return setId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2169,
    "type": "Return",
    "comment": "@return server response S0+S1+S2",
    "code": "    public IoBuffer decodeClientRequest1(IoBuffer in) {\n        if (log.isTraceEnabled()) {\n            log.debug(\"decodeClientRequest1: {}\", Hex.encodeHexString(in.array()));\n        }\n        if (in.hasArray()) {\n            c1 = in.array();\n        } else {\n            c1 = new byte[Constants.HANDSHAKE_SIZE];\n            in.get(c1);\n        }\n        //if (log.isTraceEnabled()) {\n        //    log.trace(\"C1: {}\", Hex.encodeHexString(c1));\n        //}\n        if (log.isDebugEnabled()) {\n            log.debug(\"Flash player version {}\", Hex.encodeHexString(Arrays.copyOfRange(c1, 4, 8)));\n        }\n        // check for un-versioned handshake\n        int clientVersionByte = (c1[4] & 0xff);\n        if (clientVersionByte == 0) {\n            return generateUnversionedHandshake(c1);\n        }\n        // make sure this is a client we can communicate with\n        //if (validate(c1)) {\n        //    log.debug(\"Valid RTMP client detected, algorithm: {}\", algorithm);\n        //} else {\n        //    log.info(\"Invalid RTMP connection data detected, you may experience errors\");\n        //}\n        // handle encryption setup\n        if (useEncryption()) {\n            // configure based on type and fp version\n            if (handshakeType == 6 || handshakeType == 8) {\n                // start off with algorithm 1 if we're type 6 or 8\n                algorithm = 1;\n                // set to xtea type 8 if client is fp10 capable\n                if (clientVersionByte == 128) {\n                    handshakeType = 8;\n                }\n            }\n            // get the DH offset in the handshake bytes, generates DH keypair, and adds the public key to handshake bytes\n            int clientDHOffset = getDHOffset(algorithm, c1, 0);\n            log.trace(\"Incoming DH offset: {}\", clientDHOffset);\n            // get the clients public key\n            outgoingPublicKey = new byte[KEY_LENGTH];\n            System.arraycopy(c1, clientDHOffset, outgoingPublicKey, 0, KEY_LENGTH);\n            log.debug(\"Client public key: {}\", Hex.encodeHexString(outgoingPublicKey));\n            // get the servers dh offset\n            int serverDHOffset = getDHOffset(algorithm, handshakeBytes, 0);\n            log.trace(\"Outgoing DH offset: {}\", serverDHOffset);\n            // create keypair\n            KeyPair keys = generateKeyPair();\n            // get public key\n            incomingPublicKey = getPublicKey(keys);\n            log.debug(\"Server public key: {}\", Hex.encodeHexString(incomingPublicKey));\n            // add to handshake bytes\n            System.arraycopy(incomingPublicKey, 0, handshakeBytes, serverDHOffset, KEY_LENGTH);\n            // create the RC4 ciphers\n            initRC4Encryption(getSharedSecret(outgoingPublicKey, keyAgreement));\n            switch (handshakeType) {\n                case RTMPConnection.RTMP_ENCRYPTED:\n                    \n                    break;\n                case RTMPConnection.RTMP_ENCRYPTED_XTEA:\n                    \n                    break;\n                case RTMPConnection.RTMP_ENCRYPTED_BLOWFISH:\n                    \n                    break;\n            }\n        }\n        // create the server digest\n        int digestPosServer = getDigestOffset(algorithm, handshakeBytes, 0);\n        log.debug(\"Server digest position offset: {} algorithm: {}\", digestPosServer, algorithm);\n        // calculate the server hash and add to the handshake bytes (S1)\n        calculateDigest(digestPosServer, handshakeBytes, 0, GENUINE_FMS_KEY, 36, handshakeBytes, digestPosServer);\n        log.debug(\"Server digest: {}\", Hex.encodeHexString(Arrays.copyOfRange(handshakeBytes, digestPosServer, digestPosServer + DIGEST_LENGTH)));\n        // S1 is ready to be sent to the client, copy it before we proceed, since swfhash generation may overwrite the server digest\n        byte[] s1 = new byte[Constants.HANDSHAKE_SIZE];\n        System.arraycopy(handshakeBytes, 0, s1, 0, Constants.HANDSHAKE_SIZE);\n        // get the client digest\n        log.trace(\"Trying algorithm: {}\", algorithm);\n        int digestPosClient = getDigestOffset(algorithm, c1, 0);\n        log.debug(\"Client digest position offset: {}\", digestPosClient);\n        if (!verifyDigest(digestPosClient, c1, GENUINE_FP_KEY, 30)) {\n            // try a different position\n            algorithm ^= 1;\n            log.trace(\"Trying algorithm: {}\", algorithm);\n            digestPosClient = getDigestOffset(algorithm, c1, 0);\n            log.debug(\"Client digest position offset: {}\", digestPosClient);\n            if (!verifyDigest(digestPosClient, c1, GENUINE_FP_KEY, 30)) {\n                log.warn(\"Client digest verification failed\");\n                return null;\n            }\n        }\n        // how in the heck do we generate a hash for a swf when we dont know which one is requested\n        byte[] swfHash = new byte[DIGEST_LENGTH];\n        // calculate the client hash\n        byte[] clientDigestHash = new byte[DIGEST_LENGTH];\n        calculateDigest(digestPosClient, c1, 0, GENUINE_FP_KEY, 30, clientDigestHash, 0);\n        log.debug(\"Client digest: {}\", Hex.encodeHexString(clientDigestHash));\n        // compute key\n        calculateHMAC_SHA256(clientDigestHash, 0, DIGEST_LENGTH, GENUINE_FMS_KEY, 68, swfHash, 0);\n        log.debug(\"Key: {}\", Hex.encodeHexString(swfHash));\n        // calculate swf hash. what should swf size be?\n        calculateSwfVerification(handshakeBytes, swfHash, DIGEST_LENGTH);\n        log.debug(\"swfVerification: {}\", Hex.encodeHexString(swfVerificationBytes));\n        // create output buffer\n        IoBuffer s0s1 = IoBuffer.allocate(Constants.HANDSHAKE_SIZE + 1); // 1537\n        // set handshake with encryption type \n        s0s1.put(handshakeType); // 1\n        s0s1.put(s1); // 1536\n        s0s1.flip();\n        if (log.isTraceEnabled()) {\n            log.trace(\"S0+S1 size: {}\", s0s1.limit());\n        }\n        return s0s1;\n    }\n",
    "label": 1,
    "rec": "@return server response S0+S1"
  },
  {
    "id": 2170,
    "type": "Return",
    "comment": "@return  True if values should be always unmarshalled.",
    "code": "    public boolean isUnmarshalValues() {\n        return GridQueryProcessor.isEnabled(cacheCfg) || !cacheCfg.isStoreValueBytes();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2171,
    "type": "Return",
    "comment": "@return whether or not this pre-requisite requires an exact match",
    "code": "public byte getMatch() {\n    return match;\n}",
    "label": 1,
    "rec": "@return a byte code indicating the type of match this pre-requisite requires"
  },
  {
    "id": 2172,
    "type": "Return",
    "comment": "@return Transactions interface implementation.",
    "code": "    public IgniteTransactionsEx transactions() {\n        return transactions;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2173,
    "type": "Return",
    "comment": "@return list of fully qualified class names for scanned source files.",
    "code": "public static Map<String, String> scan(String sourceDir) {\n    final String sourceDirWithSeparator = sourceDir.endsWith(File.separator) ? sourceDir : sourceDir + File.separator;\n    final File dir = new File(sourceDirWithSeparator);\n    if (!dir.exists() || !dir.isDirectory()) {\n        return Collections.emptyMap();\n    }\n    @SuppressWarnings(STR)\n    final Collection<File> files = (Collection<File>) FileUtils.listFiles(dir, null, true);\n    final Map<String, String> classFileNames = new HashMap<String, String>();\n    final int prefixLength = sourceDirWithSeparator.length();\n    for (File f : files) {\n        assert (f.exists() && f.isFile());\n        final int extensionIndex = f.getName().lastIndexOf(STR);\n        final String filePath = f.getPath();\n        if (extensionIndex < NUM || !filePath.startsWith(sourceDirWithSeparator)) {\n            continue;\n        }\n        final int reverseExtensionIndex = f.getName().length() - extensionIndex;\n        classFileNames.put(filePath.substring(prefixLength, filePath.length() - reverseExtensionIndex).replace(File.separator, STR), filePath);\n    }\n    return classFileNames;\n}",
    "label": 1,
    "rec": "@return map from fully qualified class name to filename for scanned source files."
  },
  {
    "id": 2174,
    "type": "Return",
    "comment": "@return  True if skip future during remap.",
    "code": "    private boolean skipFuture(boolean remap, IgniteInternalFuture<?> fut) {\n        return !(isMini(fut)) || (remap && (((MiniFuture)fut).rcvRes == 1));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2175,
    "type": "Return",
    "comment": "@return an Object representing the parsed program. If the parse fails, null will be returned. (The parse failure will result in a call to the ErrorReporter from CompilerEnvirons.)",
    "code": "public AstRoot parse(String sourceString, String sourceURI, int lineno) {\n    if (parseFinished)\n        throw new IllegalStateException(STR);\n    this.sourceURI = sourceURI;\n    if (compilerEnv.isIdeMode()) {\n        this.sourceChars = sourceString.toCharArray();\n    }\n    this.ts = new TokenStream(this, null, sourceString, lineno);\n    try {\n        return parse();\n    } catch (IOException iox) {\n        throw new IllegalStateException();\n    } finally {\n        parseFinished = true;\n    }\n}",
    "label": 1,
    "rec": "@return an {@link AstRoot} object representing the parsed program. If the parse fails, {@code null} will be returned. (The parse failure will result in a call to the {@link ErrorReporter} from {@link CompilerEnvirons}.)"
  },
  {
    "id": 2176,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2177,
    "type": "Return",
    "comment": "@return the identity of the pusher who signed the cert, as a string.",
    "code": "public String getPusher() {\n    return pusher.getRaw();\n}",
    "label": 1,
    "rec": "@return the raw line that signed the cert, as a string."
  },
  {
    "id": 2178,
    "type": "Return",
    "comment": "@return see description",
    "code": "    public static Date toDate(int time) {\n        return new Date(time * 1000L);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2179,
    "type": "Return",
    "comment": "@return The redacted message, if anything changed.",
    "code": "public String redact(String msg) {\n    for (Map.Entry<String, List<MatcherReplacement>> entry : mrTL.get().entrySet()) {\n        String key = entry.getKey();\n        for (MatcherReplacement mr : entry.getValue()) {\n            if (hasTrigger(key, msg)) {\n                mr.matcher.reset(msg);\n                if (mr.matcher.find()) {\n                    msg = mr.matcher.replaceAll(mr.replacement);\n                }\n            }\n        }\n    }\n    return msg;\n}",
    "label": 1,
    "rec": "@return The (potentially) redacted message."
  },
  {
    "id": 2180,
    "type": "Return",
    "comment": "@return Cache memory mode.",
    "code": "    public CacheMemoryMode getMemoryMode() {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2181,
    "type": "Return",
    "comment": "@return the {@link com.raizlabs.android.dbflow.config.BaseDatabaseDefinition} for the specified database",
    "code": "public static BaseDatabaseDefinition getDatabase(String databaseName) {\n    BaseDatabaseDefinition database = globalDatabaseHolder.getDatabase(databaseName);\n    if (database != null)\n        return database;\n    throw new InvalidDBConfiguration(STR + databaseName + STR + STR);\n}",
    "label": 1,
    "rec": "@return the {@link BaseDatabaseDefinition} for the specified database"
  },
  {
    "id": 2182,
    "type": "Return",
    "comment": "@return date as a double.",
    "code": "    public static double getDoubleFromXMLDateString(String str) {\n        try {\n            return dateFactory.newXMLGregorianCalendar(str.length() > 10 ? str.substring(0, 10) : str).\n                    toGregorianCalendar().getTimeInMillis();\n        } catch (IllegalArgumentException ex) {\n            //Try simple format\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n            try {\n                Date date = dateFormat.parse(str.length() > 10 ? str.substring(0, 10) : str);\n                return date.getTime();\n            } catch (ParseException ex1) {\n                Exceptions.printStackTrace(ex1);\n                return 0.0;\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2183,
    "type": "Return",
    "comment": "@return The managed exclusions or {@code null} if the exclusions are not managed.",
    "code": "public Collection<Exclusion> getExclusions() {\n    return exclusions;\n}",
    "label": 1,
    "rec": "@return The new exclusions or {@code null} if the exclusions are not managed and the existing dependency exclusions should remain unchanged."
  },
  {
    "id": 2184,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private GridComputeJob job(final Callable<?> c) {\n        A.notNull(c, \"job\");\n\n        if (c instanceof GridComputeJobMasterLeaveAware) {\n            return new GridMasterLeaveAwareComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n\n                @Override public void onMasterNodeLeft(GridComputeTaskSession ses) throws GridException {\n                    ((GridComputeJobMasterLeaveAware)c).onMasterNodeLeft(ses);\n                }\n            };\n        }\n        else {\n            return new GridComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new GridRuntimeException(e);\n                    }\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2185,
    "type": "Return",
    "comment": "@return the current date/time as a date object",
    "code": "public LocalDateTime now() {\n    return LocalDateTime.now();\n}",
    "label": 1,
    "rec": "@return the current date/time as a LocalDateTime object"
  },
  {
    "id": 2186,
    "type": "Return",
    "comment": "@return OverloadedWorldHolder",
    "code": "\tpublic OverloadedWorldHolder getWorldData(String worldName) {\n\n\t\tString worldNameLowered = worldName.toLowerCase();\n\n\t\t// Find this worlds data\n\t\tif (worldsData.containsKey(worldNameLowered))\n\t\t\treturn getUpdatedWorldData(worldNameLowered);\n\t\t\n\t\t// Oddly no data source was found for this world so attempt to return the global mirror.\n\t\tif (worldsData.containsKey(\"all_unnamed_worlds\")) {\n\t\t\tGroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning all_unnamed_worlds world...\");\n\t\t\treturn getUpdatedWorldData(\"all_unnamed_worlds\");\n\t\t}\n\t\t\n\t\t// Oddly no data source or global mirror was found for this world so return the default.\n\t\tGroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning default world...\");\n\t\treturn getDefaultWorld();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2187,
    "type": "Return",
    "comment": "@return A set of deleted partitions in Target cluster or empty set",
    "code": "public static <T> Set<T> getDeletedInTarget(final Set<T> current, final Set<T> target) {\n    if (current == null || target == null) {\n        return new HashSet<T>();\n    }\n    return getDiff(current, target);\n}",
    "label": 1,
    "rec": "@return A set of deleted objects in target or empty set"
  },
  {
    "id": 2188,
    "type": "Return",
    "comment": "@return Error code.",
    "code": "    private int errorCode(GridException e, boolean checkIo) {\n        if (X.hasCause(e, GridGgfsFileNotFoundException.class))\n            return ERR_FILE_NOT_FOUND;\n        else if (GridGgfsPathAlreadyExistsException.class.isInstance(e))\n            return ERR_PATH_ALREADY_EXISTS;\n        else if (GridGgfsDirectoryNotEmptyException.class.isInstance(e))\n            return ERR_DIRECTORY_NOT_EMPTY;\n        else if (GridGgfsParentNotDirectoryException.class.isInstance(e))\n            return ERR_PARENT_NOT_DIRECTORY;\n        else if (GridGgfsInvalidHdfsVersionException.class.isInstance(e))\n            return ERR_INVALID_HDFS_VERSION;\n        else if (X.hasCause(e, GridGgfsCorruptedFileException.class))\n            return ERR_CORRUPTED_FILE;\n            // This check should be the last.\n        else if (GridGgfsException.class.isInstance(e)) {\n            if (checkIo && e.hasCause(IOException.class)) {\n                IOException e0 = e.getCause(IOException.class);\n\n                return errorCode(GridGgfsHadoopUtils.cast(e0), false);\n            }\n\n            return ERR_GGFS_GENERIC;\n        }\n\n        return ERR_GENERIC;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2189,
    "type": "Return",
    "comment": "@return LivingEntity that damaged the player",
    "code": "public Entity getDamager() {\n    return damager;\n}",
    "label": 1,
    "rec": "@return Entity that damaged the player"
  },
  {
    "id": 2190,
    "type": "Return",
    "comment": "@return Boolean",
    "code": "    public boolean has(String key) {\n        return urlParams.get(key) != null ||\n                streamParams.get(key) != null ||\n                fileParams.get(key) != null ||\n                urlParamsWithObjects.get(key) != null ||\n                fileArrayParams.get(key) != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2191,
    "type": "Return",
    "comment": "@return true if end reached.",
    "code": "@Override\npublic final boolean dealWithBytes(InputStream inputStream) throws IOException, ManifoldCFException {\n    while (true) {\n        int amt = inputStream.read(byteBuffer);\n        if (amt == -NUM)\n            return false;\n        for (int i = NUM; i < amt; i++) {\n            if (dealWithByte(byteBuffer[i]))\n                return true;\n        }\n    }\n}",
    "label": 1,
    "rec": "@return true if abort signalled, false if end of stream reached."
  },
  {
    "id": 2192,
    "type": "Return",
    "comment": "@return true if renderable, false otherwise",
    "code": "    public static boolean isValid(final Event event) {\n        if (event == null)\n            return false;\n\n        final EventPayload payload = event.getPayload();\n        if (payload == null || EventPayload.class.equals(payload.getClass()))\n            return false;\n\n        final String type = event.getType();\n        if (TextUtils.isEmpty(type))\n            return false;\n\n        return TYPE_COMMIT_COMMENT.equals(type) //\n                || TYPE_CREATE.equals(type) //\n                || TYPE_DELETE.equals(type) //\n                || TYPE_DOWNLOAD.equals(type) //\n                || TYPE_FOLLOW.equals(type) //\n                || TYPE_FORK.equals(type) //\n                || TYPE_FORK_APPLY.equals(type) //\n                || TYPE_GIST.equals(type) //\n                || TYPE_GOLLUM.equals(type) //\n                || TYPE_ISSUE_COMMENT.equals(type) //\n                || TYPE_ISSUES.equals(type) //\n                || TYPE_MEMBER.equals(type) //\n                || TYPE_PUBLIC.equals(type) //\n                || TYPE_PULL_REQUEST.equals(type) //\n                || TYPE_PUSH.equals(type) //\n                || TYPE_TEAM_ADD.equals(type) //\n                || TYPE_WATCH.equals(type);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2193,
    "type": "Return",
    "comment": "@return true iff local cannot be null for this flow info",
    "code": "public boolean cannotBeNull(VariableBinding binding) {\n    return isDefinitelyNonNull(binding) || isProtectedNonNull(binding);\n}",
    "label": 1,
    "rec": "@return true iff field or local cannot be null for this flow info"
  },
  {
    "id": 2194,
    "type": "Return",
    "comment": "@return verification mode",
    "code": "    public static VerificationMode atLeastOnce() {\n        return VerificationModeFactory.atLeastOnce();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2195,
    "type": "Return",
    "comment": "@return The count",
    "code": "public int getCheckedInResourcesCount(K key) {\n    int rc = NUM;\n    if (!resourcePoolMap.containsKey(key)) {\n        return rc;\n    }\n    try {\n        Pool<V> resourcePool = getResourcePoolForExistingKey(key);\n        rc = resourcePool.queue.size();\n    } catch (IllegalArgumentException iae) {\n        logger.debug(STR, iae);\n    }\n    return rc;\n}",
    "label": 1,
    "rec": "@return The count of checked in resources. Returns 0 if no pool exists for given key."
  },
  {
    "id": 2196,
    "type": "Return",
    "comment": "@return  MockitoGenericMetadata representing this generic return type.",
    "code": "    public MockitoGenericMetadata resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnType(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2197,
    "type": "Return",
    "comment": "@return Current version directory, else null",
    "code": "    private File getCurrentVersion() {\n        File latestSymLink = new File(storeDir, \"latest\");\n        if(latestSymLink.exists() && Utils.isSymLink(latestSymLink)) {\n            File canonicalLatestVersion = null;\n            try {\n                canonicalLatestVersion = latestSymLink.getCanonicalFile();\n            } catch(IOException e) {}\n\n            if(canonicalLatestVersion != null\n               && ReadOnlyUtils.checkVersionDirName(canonicalLatestVersion))\n                return canonicalLatestVersion;\n        }\n        File[] versionDirs = ReadOnlyUtils.getVersionDirs(storeDir);\n\n        if(versionDirs == null || versionDirs.length == 0) {\n            return null;\n        } else {\n            return ReadOnlyUtils.findKthVersionedDir(versionDirs,\n                                                     versionDirs.length - 1,\n                                                     versionDirs.length - 1)[0];\n        }\n    }\n",
    "label": 1,
    "rec": "@return Max version directory"
  },
  {
    "id": 2198,
    "type": "Return",
    "comment": "@return new schema",
    "code": "    public Schema build()\n    {\n        return new Schema(name, pathRegex, path, documentation, dataValidator, ephemeral, sequential, watched, canBeDeleted);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2199,
    "type": "Return",
    "comment": "@return edgePointer which is edgeId edgeEntrySize",
    "code": "    protected int internalEdgeAdd(int fromNodeId, int toNodeId, double dist, int flags) {\n        int newOrExistingEdge = nextEdge();\n        connectNewEdge(fromNodeId, newOrExistingEdge);\n        connectNewEdge(toNodeId, newOrExistingEdge);\n        writeEdge(newOrExistingEdge, fromNodeId, toNodeId, EMPTY_LINK, EMPTY_LINK, dist, flags);\n        return newOrExistingEdge;\n    }\n",
    "label": 1,
    "rec": "@return edgeIdPointer which is edgeId edgeEntrySize"
  },
  {
    "id": 2200,
    "type": "Return",
    "comment": "@return  True if entry is locally mapped as a primary or back up node.",
    "code": "    protected boolean isNearLocallyMapped(GridCacheEntryEx e, AffinityTopologyVersion topVer) {\n        return ctx.affinity().belongs(ctx.localNode(), e.partition(), topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2201,
    "type": "Return",
    "comment": "@return the data contained in this message (i.e. the message payload). The position and limit of the ByteBuffer will be set correctly, but please note that the position will probably not be zero! This ByteBuffer might actually contain all the raw data for the RreadMessage. When you have finished with the data, call buf.release() to return the buffer to the pool.",
    "code": "public ByteBuffer getData() {\n    return ByteBuffer.wrap(this.bytes, this.pos, this.count);\n}",
    "label": 1,
    "rec": "@return the data contained in this message as a MINA ByteBuffer"
  },
  {
    "id": 2202,
    "type": "Return",
    "comment": "@return Atomic long value.",
    "code": "    private Object peekDht(ClusterNode node) throws IgniteCheckedException {\n        return grid(node).jcache(null).localPeek(new GridCacheInternalKeyImpl(ATOMIC_LONG_NAME), CachePeekMode.BACKUP,\n            CachePeekMode.PRIMARY);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2203,
    "type": "Return",
    "comment": "@return True if the file contains searchedEntryName. False otherwise",
    "code": "public static boolean hasEntry(File file, String entryName) throws IOException {\n    List<String> elements = getEntryNames(file);\n    return elements.contains(entryName);\n}",
    "label": 1,
    "rec": "@return True if the file contains entryName. False otherwise"
  },
  {
    "id": 2204,
    "type": "Return",
    "comment": "@return State of  device",
    "code": "\tprivate State getStateFromConfig(Config pilightConfig, PilightBindingConfig bindingConfig) {\n\t\tLocation loc = pilightConfig.getConfig().get(bindingConfig.getLocation());\n\t\tif (loc != null) {\n\t\t\tDevice dev = loc.getDevices().get(bindingConfig.getDevice());\n\t\t\t\n\t\t\tif (dev != null) {\n\t\t\t\tString devType = dev.getType().toString();\n\t\t\t\tif (devType.equals(DeviceType.SWITCH) || devType.equals(DeviceType.DIMMER)) {\n\t\t\t\t\tOnOffType state = OnOffType.valueOf(dev.getState().toUpperCase());\n\t\t\t\t\t\n\t\t\t\t\tif (dev.getDimlevel() != null && dev.getDimlevel() > 0) {\n\t\t\t\t\t\tif (state.equals(OnOffType.ON))\n\t\t\t\t\t\t\treturn new PercentType(getPercentageFromDimLevel(dev.getDimlevel().toString()));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn new PercentType(0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn state;\n\t\t\t\t} else if (devType.equals(DeviceType.VALUE)) {\n\t\t\t\t\tbindingConfig.setDecimals(dev.getDeviceDecimals());\n\t\t\t\t\t\n\t\t\t\t\tString property = bindingConfig.getProperty();\n\t\t\t\t\tif (dev.getProperties().containsKey(property)) {\n\t\t\t\t\t\tString value = dev.getProperties().get(property);\n\t\t\t\t\t\treturn getStateFromProperty(value, bindingConfig);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "label": 1,
    "rec": "@return Current state of the item"
  },
  {
    "id": 2205,
    "type": "Return",
    "comment": "@return Collection of cache nodes.",
    "code": "    public Collection<ClusterNode> cacheNodes(long topVer) {\n        return resolveDiscoCache(null, topVer).allNodesWithCaches(topVer);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2206,
    "type": "Return",
    "comment": "@return the integer reference",
    "code": "    public long put( String name )\n    {\n        if (name == null || name.isEmpty())\n        {\n            return 0;\n        }\n        if (name.equals(lastName))\n        {\n            return lastIndex;\n        }\n        byte[] bytes = getBytes(name);\n        long oldPointer = bytePointer;\n        names.ensureCapacity(bytePointer + 1 + bytes.length);\n        byte[] sizeBytes = new byte[]\n        {\n            (byte) bytes.length\n        };\n        names.setBytes(bytePointer, sizeBytes, sizeBytes.length);\n        bytePointer++;\n        names.setBytes(bytePointer, bytes, bytes.length);\n        bytePointer += bytes.length;\n        if (bytePointer < 0)\n        {\n            throw new IllegalStateException(\"Way index is too large. Cannot contain more than 2GB\");\n        }\n        lastName = name;\n        lastIndex = oldPointer;\n        return oldPointer;\n    }\n",
    "label": 1,
    "rec": "@return the byte pointer to the name"
  },
  {
    "id": 2207,
    "type": "Return",
    "comment": "@return Exit value of program.",
    "code": "    public int run(String[] args) {\n        int rv = -1;\n\n        try {\n            rv = run2(args);\n        }\n        catch (org.apache.hadoop.mapred.FileAlreadyExistsException e) {\n            if (ctrlc != null) { ctrlc.setComplete(); }\n            System.out.println(\"ERROR: \" + (e.getMessage() != null ? e.getMessage() : \"(null)\"));\n            System.exit(1);\n        }\n        catch (Exception e) {\n            System.out.println(\"ERROR: \" + (e.getMessage() != null ? e.getMessage() : \"(null)\"));\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        return rv;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2208,
    "type": "Return",
    "comment": "@return {@code load(getCallerClass(2)) }",
    "code": "public static String load(boolean pathsFirst) {\n    Class cls = getCallerClass(NUM);\n    return load(cls, loadProperties(), pathsFirst);\n}",
    "label": 1,
    "rec": "@return {@code load(getCallerClass(2), loadProperties(), pathsFirst) }"
  },
  {
    "id": 2209,
    "type": "Return",
    "comment": "@return a message which will be used as content",
    "code": "    protected String handleError(final String message, final Throwable cause) {\n        notifier().error(formatMessage(message), cause);\n        return formatMessage(message);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2210,
    "type": "Return",
    "comment": "@return an allocation expression for the boxed value.",
    "code": "public MessageSend createBoxing(Expression resultExpr, BaseTypeBinding type) {\n    char[][] boxedType = boxTypeName(type);\n    return messageSend(qualifiedTypeReference(boxedType), TypeConstants.VALUEOF, new Expression[] { resultExpr });\n}",
    "label": 1,
    "rec": "@return a message send for the boxed value."
  },
  {
    "id": 2211,
    "type": "Return",
    "comment": "@return intent",
    "code": "    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(layout.gist_view);\n        final Gist gist = (Gist) getIntent().getSerializableExtra(GIST);\n        if (gist == null) {\n            gistId.setVisibility(INVISIBLE);\n            created.setVisibility(INVISIBLE);\n            description.setVisibility(INVISIBLE);\n            author.setVisibility(INVISIBLE);\n            gravatar.setVisibility(INVISIBLE);\n\n            final String id = getIntent().getStringExtra(GIST_ID);\n            final ProgressDialog progress = new ProgressDialog(this);\n            progress.setMessage(getString(string.loading_gist));\n            progress.setIndeterminate(true);\n            progress.show();\n            new RoboAsyncTask<Gist>(this) {\n\n                public Gist call() throws Exception {\n                    return gistServiceProvider.get(ViewGistActivity.this).getGist(id);\n                }\n\n                protected void onSuccess(Gist gist) throws Exception {\n                    progress.cancel();\n                    displayGist(gist);\n                }\n\n                protected void onException(Exception e) throws RuntimeException {\n                    progress.cancel();\n                    Log.d(\"GHVGA\", e.getMessage(), e);\n                    Toast.makeText(ViewGistActivity.this, e.getMessage(), 5000).show();\n                }\n            }.execute();\n        } else\n            displayGist(gist);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2212,
    "type": "Return",
    "comment": "@return {@link RepositoryIssue} or null if none found in given {@link Uri}",
    "code": "public static Issue getIssue(Uri uri) {\n    List<String> segments = uri.getPathSegments();\n    if (segments == null)\n        return null;\n    if (segments.size() < NUM)\n        return null;\n    if (!STR.equals(segments.get(NUM)) && !STR.equals(segments.get(NUM)))\n        return null;\n    String repoOwner = segments.get(NUM);\n    if (!RepositoryUtils.isValidOwner(repoOwner))\n        return null;\n    String repoName = segments.get(NUM);\n    if (!RepositoryUtils.isValidRepo(repoName))\n        return null;\n    String number = segments.get(NUM);\n    if (TextUtils.isEmpty(number))\n        return null;\n    int issueNumber;\n    try {\n        issueNumber = Integer.parseInt(number);\n    } catch (NumberFormatException nfe) {\n        return null;\n    }\n    if (issueNumber < NUM)\n        return null;\n    Repository repo = InfoUtils.createRepoFromData(repoOwner, repoName);\n    return Issue.builder().repository(repo).number(issueNumber).build();\n}",
    "label": 1,
    "rec": "@return {@link Issue} or null if none found in given {@link Uri}"
  },
  {
    "id": 2213,
    "type": "Return",
    "comment": "@return Statement.",
    "code": "    protected Statement initializeH2Schema() throws SQLException {\n        // All logic is moved to child classes.\n        return conn.createStatement();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2214,
    "type": "Return",
    "comment": "@return current bucket item at provided timestamp",
    "code": "public WindowWrap<T> currentWindow(long time) {\n    if (time < NUM) {\n        return null;\n    }\n    long timeId = time / windowLengthInMs;\n    int idx = (int) (timeId % array.length());\n    long windowStart = time - time % windowLengthInMs;\n    while (true) {\n        WindowWrap<T> old = array.get(idx);\n        if (old == null) {\n            WindowWrap<T> window = new WindowWrap<T>(windowLengthInMs, windowStart, newEmptyBucket());\n            if (array.compareAndSet(idx, null, window)) {\n                return window;\n            } else {\n                Thread.yield();\n            }\n        } else if (windowStart == old.windowStart()) {\n            return old;\n        } else if (windowStart > old.windowStart()) {\n            if (updateLock.tryLock()) {\n                try {\n                    return resetWindowTo(old, windowStart);\n                } finally {\n                    updateLock.unlock();\n                }\n            } else {\n                Thread.yield();\n            }\n        } else if (windowStart < old.windowStart()) {\n            return new WindowWrap<T>(windowLengthInMs, windowStart, newEmptyBucket());\n        }\n    }\n}",
    "label": 1,
    "rec": "@return current bucket item at provided timestamp if the time is valid; null if time is invalid"
  },
  {
    "id": 2215,
    "type": "Return",
    "comment": "@return the  TopicPartitions currently assigned to this container, either explicitly or by Kafka; may be null if not assigned yet.",
    "code": "\tpublic Collection<TopicPartition> getAssignedPartitions() {\n\t\tif (this.listenerConsumer.definedPartitions != null) {\n\t\t\treturn Collections.unmodifiableCollection(this.listenerConsumer.definedPartitions);\n\t\t}\n\t\telse if (this.listenerConsumer.assignedPartitions != null) {\n\t\t\treturn Collections.unmodifiableCollection(this.listenerConsumer.assignedPartitions);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2216,
    "type": "Return",
    "comment": "@return <code>true</code> if the response is acceptable, <code>false</code> if not.",
    "code": "protected String isResponseAcceptable(DNSMessage response) {\n    return null;\n}",
    "label": 1,
    "rec": "@return <code>null</code> if the response is acceptable, or a String if not."
  },
  {
    "id": 2217,
    "type": "Return",
    "comment": "@return the encoded output String",
    "code": "    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        return URLEncoder.encode(input, encodingScheme);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2218,
    "type": "Return",
    "comment": "@return a list of articles, returns an empty list if not found",
    "code": "public JSONObject getArticlesByTag(final String tagId, final int currentPageNum, final int pageSize) throws ServiceException {\n    try {\n        JSONObject result = tagArticleRepository.getByTagId(tagId, currentPageNum, pageSize);\n        if (null == result) {\n            return null;\n        }\n        final JSONArray tagArticleRelations = result.getJSONArray(Keys.RESULTS);\n        if (NUM == tagArticleRelations.length()) {\n            return null;\n        }\n        final Set<String> articleIds = new HashSet<>();\n        for (int i = NUM; i < tagArticleRelations.length(); i++) {\n            final JSONObject tagArticleRelation = tagArticleRelations.getJSONObject(i);\n            final String articleId = tagArticleRelation.getString(Article.ARTICLE + STR + Keys.OBJECT_ID);\n            articleIds.add(articleId);\n        }\n        final List<JSONObject> retArticles = new ArrayList<>();\n        final Query query = new Query().setFilter(new PropertyFilter(Keys.OBJECT_ID, FilterOperator.IN, articleIds)).setPageCount(NUM);\n        result = articleRepository.get(query);\n        final JSONArray articles = result.getJSONArray(Keys.RESULTS);\n        for (int i = NUM; i < articles.length(); i++) {\n            final JSONObject article = articles.getJSONObject(i);\n            if (!article.getBoolean(Article.ARTICLE_IS_PUBLISHED)) {\n                continue;\n            }\n            article.put(ARTICLE_CREATE_TIME, article.getLong(ARTICLE_CREATED));\n            article.put(ARTICLE_T_CREATE_DATE, new Date(article.getLong(ARTICLE_CREATED)));\n            article.put(Article.ARTICLE_T_UPDATE_DATE, new Date(article.optLong(ARTICLE_UPDATED)));\n            retArticles.add(article);\n        }\n        final JSONObject ret = new JSONObject();\n        ret.put(Pagination.PAGINATION, result.optJSONObject(Pagination.PAGINATION));\n        ret.put(Keys.RESULTS, (Object) retArticles);\n        return ret;\n    } catch (final Exception e) {\n        LOGGER.log(Level.ERROR, STR + tagId + STR, e);\n        throw new ServiceException(e);\n    }\n}",
    "label": 1,
    "rec": "@return result, returns {@code null} if not found"
  },
  {
    "id": 2219,
    "type": "Return",
    "comment": "@return Integer reply, this commands will reply with the new value of key after the increment.",
    "code": "    public Long decr(final byte[] key) {\n        checkIsInMulti();\n        client.decr(key);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2220,
    "type": "Return",
    "comment": "@return The singleton instance of BandwidthTimerManager.",
    "code": "@Nonnull\npublic static DeviceBandwidthSampler getInstance() {\n    return DeviceBandwidthSamplerHolder.instance;\n}",
    "label": 1,
    "rec": "@return The singleton instance of DeviceBandwidthSampler."
  },
  {
    "id": 2221,
    "type": "Return",
    "comment": "@return image",
    "code": "    public static Bitmap getBitmap(final String imagePath, int width, int height) {\n        Point size = getSize(imagePath);\n        return getBitmap(imagePath, getScale(size, width, height));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2222,
    "type": "Return",
    "comment": "@return the corner radius.",
    "code": "public float getCornerRadius() {\n    return getMaxCornerRadius();\n}",
    "label": 1,
    "rec": "@return the largest corner radius."
  },
  {
    "id": 2223,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static short and(short first, short second) {\n        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2224,
    "type": "Return",
    "comment": "@return an enumeration of all bound values on objectKey in attributeName, with duplicate values included; the returned enumeration is never null; elements in the returned enumeration are ordered arbitrarily.",
    "code": "public static List getAllAttributeValues(final String objectKey, final String attributeName, final CyData cyData, final CyDataDefinition cyDataDef) {\n    final ArrayList bucket = new ArrayList();\n    final int keyspaceDims = cyDataDef.getAttributeKeyspaceDimensionality(attributeName);\n    if (keyspaceDims < NUM) {\n        final Object attrVal = cyData.getAttributeValue(objectKey, attributeName, null);\n        if (attrVal != null)\n            bucket.add(attrVal);\n    } else {\n        final CountedEnumeration dim1Keys = cyData.getAttributeKeyspan(objectKey, attributeName, null);\n        r_getAllAttributeValues(objectKey, attributeName, cyData, bucket, dim1Keys, new Object[NUM], keyspaceDims);\n    }\n    return bucket;\n}",
    "label": 1,
    "rec": "@return a list of all bound values on objectKey in attributeName, with duplicate values included; the returned list is never null; elements in the returned list are ordered arbitrarily; subsequent operations on cyData or cyDataDef will have no effect on the returned list."
  },
  {
    "id": 2225,
    "type": "Return",
    "comment": "@return Evicted readers.",
    "code": "    public Collection<GridCacheTxKey<K>> nearEvicted() {\n        return nearEvicted;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2226,
    "type": "Return",
    "comment": "@return the installable units installed",
    "code": "public IQueryResult<IInstallableUnit> listInstalledElements(boolean rootsOnly, IProgressMonitor monitor) {\n    IProfileRegistry registry = (IProfileRegistry) getAgent().getService(IProfileRegistry.SERVICE_NAME);\n    IProfile profile = registry.getProfile(IProfileRegistry.SELF);\n    if (profile == null)\n        return new CollectionResult<IInstallableUnit>(null);\n    if (rootsOnly)\n        return profile.query(new UserVisibleRootQuery(), monitor);\n    return profile.query(QueryUtil.ALL_UNITS, monitor);\n}",
    "label": 1,
    "rec": "@return the installable units installed, or an empty result if the installation profile of the running system cannot be accessed"
  },
  {
    "id": 2227,
    "type": "Return",
    "comment": "@return Evicted keys.",
    "code": "    public Collection<IgniteTxKey<K>> evicted() {\n        return evicted;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2228,
    "type": "Return",
    "comment": "@return The note read",
    "code": "@Processor\n@InvalidateConnectionOn(exception = NotAuthenticatedException.class)\npublic Note readNote(String objectId) {\n    return (Note) read(ServiceSourceCollection.Notes, objectId);\n}",
    "label": 1,
    "rec": "@return an instance of {@link org.mule.module.servicesource.model.note.Note}"
  },
  {
    "id": 2229,
    "type": "Return",
    "comment": "@return the direction",
    "code": "    public BlockFace getFacing() {\n        byte data = (byte) (getData() & 0x3);\n        switch (data) {\n        case 0:\n            return BlockFace.WEST;\n\n        case 1:\n            return BlockFace.NORTH;\n\n        case 2:\n            return BlockFace.EAST;\n\n        case 3:\n            return BlockFace.SOUTH;\n        }\n        return null; // shouldn't happen\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2230,
    "type": "Return",
    "comment": "@return refreshed issue",
    "code": "public Single<Issue> refreshIssue(Repository repository, int issueNumber) {\n    return service.getIssue(repository.owner().login(), repository.name(), issueNumber).map(response -> addIssueOrThrow(repository, response, R.string.error_issue_load));\n}",
    "label": 1,
    "rec": "@return A {@link Single} representing the issues"
  },
  {
    "id": 2231,
    "type": "Return",
    "comment": "@return the template",
    "code": "\tpublic RegisteredClient getTemplate() {\n\t\treturn template;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2232,
    "type": "Return",
    "comment": "@return true if the process-true is alive, false otherwise.",
    "code": "public boolean isAlive() {\n    if (pid == -NUM) {\n        return false;\n    } else {\n        return isAlive(pid.toString());\n    }\n}",
    "label": 1,
    "rec": "@return true if the root-process is alive, false otherwise."
  },
  {
    "id": 2233,
    "type": "Return",
    "comment": "@return  True if cache is accessible on the given node.",
    "code": "        public boolean cacheNode(ClusterNode node) {\n            return !node.isDaemon() && activated(node.id()) &&\n                (CU.affinityNode(node, cacheFilter) || clientNodes.containsKey(node.id()));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2234,
    "type": "Return",
    "comment": "@return true if the authzHeader value matches that configured as defined by the  # getAuthzScheme () authzHeaderScheme.",
    "code": "    protected boolean isLoginAttempt(String authzHeader) {\n        String authzScheme = getAuthzScheme().toLowerCase();\n        return authzHeader.toLowerCase().startsWith(authzScheme);\n    }\n",
    "label": 1,
    "rec": "@return true if the authzHeader value matches that configured as defined by the  #getAuthzScheme() authzScheme."
  },
  {
    "id": 2235,
    "type": "Return",
    "comment": "@return the parsed  PolicySelection, or  null if no selection could be made.",
    "code": "  ConfigOrError parseLoadBalancerPolicy(Map<String, ?> serviceConfig, ChannelLogger channelLogger) {\n    try {\n      List<LbConfig> loadBalancerConfigs = null;\n      if (serviceConfig != null) {\n        List<Map<String, ?>> rawLbConfigs =\n            ServiceConfigUtil.getLoadBalancingConfigsFromServiceConfig(serviceConfig);\n        loadBalancerConfigs = ServiceConfigUtil.unwrapLoadBalancingConfigList(rawLbConfigs);\n      }\n      if (loadBalancerConfigs != null && !loadBalancerConfigs.isEmpty()) {\n        List<String> policiesTried = new ArrayList<>();\n        for (LbConfig lbConfig : loadBalancerConfigs) {\n          String policy = lbConfig.getPolicyName();\n          LoadBalancerProvider provider = registry.getProvider(policy);\n          if (provider == null) {\n            policiesTried.add(policy);\n          } else {\n            if (!policiesTried.isEmpty()) {\n              channelLogger.log(\n                  ChannelLogLevel.DEBUG,\n                  \"{0} specified by Service Config are not available\", policiesTried);\n            }\n            ConfigOrError parsedLbPolicyConfig =\n                provider.parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n            if (parsedLbPolicyConfig.getError() != null) {\n              return parsedLbPolicyConfig;\n            }\n            return ConfigOrError.fromConfig(\n                new PolicySelection(provider, serviceConfig, parsedLbPolicyConfig.getConfig()));\n          }\n        }\n        return ConfigOrError.fromError(\n            Status.UNKNOWN.withDescription(\n                \"None of \" + policiesTried + \" specified by Service Config are available.\"));\n      }\n      return null;\n    } catch (RuntimeException e) {\n      return ConfigOrError.fromError(\n          Status.UNKNOWN.withDescription(\"can't parse load balancer configuration\").withCause(e));\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2236,
    "type": "Return",
    "comment": "@return the predicted class label. For MULTINOMIAL and BERNOULLI models, returns -1 if the instance does not contain any feature words.",
    "code": "    public int predict(int[] x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        if (posteriori == null) {\n            posteriori = new double[k];\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob = Math.log(priori[i]);\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += x[j] * Math.log(condprob[i][j]);\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += Math.log(condprob[i][j]);\n                        } else {\n                            logprob += Math.log(1.0 - condprob[i][j]);\n                        }\n                    }\n                    break;\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        return label(posteriori);\n    }\n",
    "label": 1,
    "rec": "@return the predicted class label. If the instance is of all zeros, return returns Integer.MIN_VALUE."
  },
  {
    "id": 2237,
    "type": "Return",
    "comment": "@return the number of frames",
    "code": "    int audioRecordBufferFrames() {\n        return 50;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2238,
    "type": "Return",
    "comment": "@return The {@link InetAddress} used for passive data connections",
    "code": "public String getPassiveAddress() {\n    return passiveAddress;\n}",
    "label": 1,
    "rec": "@return The address used for passive data connections"
  },
  {
    "id": 2239,
    "type": "Return",
    "comment": "@return Protocol version.",
    "code": "    public long version() {\n        return ver;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2240,
    "type": "Return",
    "comment": "@return {@link Delta} - type of change",
    "code": "public DeltaType getDelta() {\n    return delta;\n}",
    "label": 1,
    "rec": "@return {@link DeltaType} - type of change"
  },
  {
    "id": 2241,
    "type": "Return",
    "comment": "@return First qualified file info.",
    "code": "    private IgfsEntryInfo fileForFragmentizer0(IgniteUuid parentId, Collection<IgniteUuid> exclude)\n        throws IgniteCheckedException {\n        IgfsEntryInfo info = info(parentId);\n\n        // Check if file was concurrently deleted.\n        if (info == null)\n            return null;\n\n        assert info.isDirectory();\n\n        Map<String, IgfsListingEntry> listing = info.listing();\n\n        for (IgfsListingEntry entry : listing.values()) {\n            if (entry.isFile()) {\n                IgfsEntryInfo fileInfo = info(entry.fileId());\n\n                if (fileInfo != null) {\n                    if (!exclude.contains(fileInfo.id()) &&\n                        fileInfo.fileMap() != null &&\n                        !fileInfo.fileMap().ranges().isEmpty())\n                        return fileInfo;\n                }\n            }\n            else {\n                IgfsEntryInfo fileInfo = fileForFragmentizer0(entry.fileId(), exclude);\n\n                if (fileInfo != null)\n                    return fileInfo;\n            }\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2242,
    "type": "Return",
    "comment": "@return false if the value capacity was reached and instead of the real value the SHORT_MAX was stored.",
    "code": "    boolean isInfinity(long pointer) {\n        return (landmarkWeightDA.getInt(pointer) & FROM_WEIGHT_INF) == FROM_WEIGHT_INF;\n    }\n",
    "label": 1,
    "rec": "@return false if the value capacity was reached and instead of the real value the MAX was stored."
  },
  {
    "id": 2243,
    "type": "Return",
    "comment": "@return a URL for the resource, or null if the resource could not be found.",
    "code": "    protected URL findResource(String name) {\n        try {\n            return Whitebox.invokeMethod(deferTo, \"findResource\", name);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2244,
    "type": "Return",
    "comment": "@return object containing attributes of n",
    "code": "public void set(Node n) {\n    if (n == null)\n        return;\n    Node root = n.getOwnerDocument().getDocumentElement();\n    ChildNumber currChildNo = new ChildNumber(n);\n    String xpath = getXPath(n, currChildNo.getXPath(), true);\n    NodeList siblings = n.getParentNode().getChildNodes();\n    setCharPos(currChildNo.getDOM(), siblings, this);\n    while (!NodeOps.checkIfSameNode(root, n)) {\n        n = n.getParentNode();\n        currChildNo.setChildNumber(n);\n        xpath = getXPath(n, currChildNo.getXPath(), false) + xpath;\n    }\n    _path = xpath;\n}",
    "label": 1,
    "rec": "@return object containing position of n"
  },
  {
    "id": 2245,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    private Object readResolve() throws ObjectStreamException {\n        try {\n            GridCacheProjectionImpl<K, V> prj = stash.get().get1();\n\n            GridCacheQueriesEx<K, V> delegate = stash.get().get2();\n\n            assert prj != null;\n\n            return new GridCacheQueriesProxy<>(prj.context(), prj, delegate);\n        }\n        catch (Exception e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2246,
    "type": "Return",
    "comment": "@return a valid number for the specified country and type. Returns null when the metadata does not contain such information.",
    "code": "public PhoneNumber getExampleNumberForType(String regionCode, PhoneNumberType type) {\n    if (!isValidRegionCode(regionCode)) {\n        LOGGER.log(Level.WARNING, STR);\n        return null;\n    }\n    PhoneNumberDesc desc = getNumberDescByType(getMetadataForRegion(regionCode), type);\n    try {\n        if (desc.hasExampleNumber()) {\n            return parse(desc.getExampleNumber(), regionCode);\n        }\n    } catch (NumberParseException e) {\n        LOGGER.log(Level.SEVERE, e.toString());\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return a valid number for the specified region and type. Returns null when the metadata does not contain such information."
  },
  {
    "id": 2247,
    "type": "Return",
    "comment": "@return whether the camera has started",
    "code": "    public boolean isOpened() {\n        return mCameraEngine.getEngineState() >= CameraEngine.STATE_STARTED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2248,
    "type": "Return",
    "comment": "@return null if no entry in cache or if entry is expired",
    "code": "public List<DownloadablePackage> getFromCache(String type) {\n    PackageListCacheEntry entry = cache.get(type);\n    if (entry == null || isExpired(entry)) {\n        return new ArrayList<>();\n    }\n    return entry.getPackages();\n}",
    "label": 1,
    "rec": "@return an empty list if no entry in cache or if entry is expired"
  },
  {
    "id": 2249,
    "type": "Return",
    "comment": "@return an instance of the type of this AttributeType.",
    "code": "    public Object parse(String str) {\n        switch (this) {\n            case BYTE:\n                return new Byte(removeDecimalDigitsFromString(str));\n            case SHORT:\n                return new Short(removeDecimalDigitsFromString(str));\n            case INT:\n                return new Integer(removeDecimalDigitsFromString(str));\n            case LONG:\n                return new Long(removeDecimalDigitsFromString(str));\n            case FLOAT:\n                return new Float(str);\n            case DOUBLE:\n                return new Double(str);\n            case BOOLEAN:\n                return new Boolean(str);\n            case CHAR:\n                return new Character(str.charAt(0));\n            case BIGINTEGER:\n                return new BigInteger(removeDecimalDigitsFromString(str));\n            case BIGDECIMAL:\n                return new BigDecimal(str);\n            case DYNAMIC_BYTE:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_SHORT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_INT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_LONG:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_FLOAT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_DOUBLE:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BOOLEAN:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_CHAR:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_STRING:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BIGINTEGER:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BIGDECIMAL:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case TIME_INTERVAL:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case LIST_BYTE:\n                return new ByteList(removeDecimalDigitsFromString(str));\n            case LIST_SHORT:\n                return new ShortList(removeDecimalDigitsFromString(str));\n            case LIST_INTEGER:\n                return new IntegerList(removeDecimalDigitsFromString(str));\n            case LIST_LONG:\n                return new LongList(removeDecimalDigitsFromString(str));\n            case LIST_FLOAT:\n                return new FloatList(str);\n            case LIST_DOUBLE:\n                return new DoubleList(str);\n            case LIST_BOOLEAN:\n                return new BooleanList(str);\n            case LIST_CHARACTER:\n                return new CharacterList(str);\n            case LIST_STRING:\n                return new StringList(str);\n            case LIST_BIGINTEGER:\n                return new BigIntegerList(removeDecimalDigitsFromString(str));\n            case LIST_BIGDECIMAL:\n                return new BigDecimalList(str);\n        }\n        return str;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2250,
    "type": "Return",
    "comment": "@return The next column",
    "code": "public String getNextColumn() {\n    return _nextColumnName;\n}",
    "label": 1,
    "rec": "@return The name of the next column"
  },
  {
    "id": 2251,
    "type": "Return",
    "comment": "@return List of methods with given annotation, possibly  null.",
    "code": "    private List<GridResourceMethod> getMethodsFromCache(Class<?> cls, Class<? extends Annotation> annCls) {\n        return mtdCache.get(new GridResourceClass(cls, annCls));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2252,
    "type": "Return",
    "comment": "@return taxonomy accessor for this index",
    "code": "public final TaxonomyAccessor getTaxonomyAccessor() {\n    if (useFacets()) {\n        TaxonomyAccessor accessor = getTaxonomyAccessorInstance();\n        return accessor;\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return taxonomy accessor for this index, null when facets are not activated"
  },
  {
    "id": 2253,
    "type": "Return",
    "comment": "@return current future.",
    "code": "    protected IgniteInternalFuture currentFuture() throws IgniteCheckedException {\n        throw new IgniteCheckedException(\"Future listening is not supported in \" + getClass());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2254,
    "type": "Return",
    "comment": "@return the InfinispanKeyValueEntityManagerFactory instance",
    "code": "public InfinispanBucketManagerFactory get(org.infinispan.configuration.cache.Configuration config) throws NullPointerException {\n    requireNonNull(config, STR);\n    return new InfinispanBucketManagerFactory(new DefaultCacheManager(config));\n}",
    "label": 1,
    "rec": "@return the InfinispanBucketManagerFactory instance"
  },
  {
    "id": 2255,
    "type": "Return",
    "comment": "@return Queue unique ID.",
    "code": "    IgniteUuid id() {\n        return id;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2256,
    "type": "Return",
    "comment": "@return the baseSplit",
    "code": "public org.apache.hadoop.mapred.InputSplit getBaseSplit() {\n    return baseMapRedSplit;\n}",
    "label": 1,
    "rec": "@return the baseMapRedSplit"
  },
  {
    "id": 2257,
    "type": "Return",
    "comment": "@return  HystrixPropertiesStrategy implementation to use",
    "code": "    public HystrixPropertiesStrategy getPropertiesStrategy() {\n        if (propertiesFactory != null) {\n            // we have a global override so use it\n            return propertiesFactory;\n        } else {\n            // we don't have an injected default nor an override so construct a default\n            return HystrixPropertiesStrategyDefault.getInstance();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2258,
    "type": "Return",
    "comment": "@return This proxy for chaining, never {@code null}.",
    "code": "public Proxy setType(String type) {\n    return new Proxy(type, host, port, auth);\n}",
    "label": 1,
    "rec": "@return The new proxy, never {@code null}."
  },
  {
    "id": 2259,
    "type": "Return",
    "comment": "@return Object.",
    "code": "    Object read(OptimizedObjectInputStream in) throws ClassNotFoundException, IOException {\n        switch (type) {\n            case TYPE_BYTE:\n                return in.readByte();\n\n            case TYPE_SHORT:\n                return in.readShort();\n\n            case TYPE_INT:\n                return in.readInt();\n\n            case TYPE_LONG:\n                return in.readLong();\n\n            case TYPE_FLOAT:\n                return in.readFloat();\n\n            case TYPE_DOUBLE:\n                return in.readDouble();\n\n            case TYPE_CHAR:\n                return in.readChar();\n\n            case TYPE_BOOLEAN:\n                return in.readBoolean();\n\n            case TYPE_BYTE_ARR:\n                return in.readByteArray();\n\n            case TYPE_SHORT_ARR:\n                return in.readShortArray();\n\n            case TYPE_INT_ARR:\n                return in.readIntArray();\n\n            case TYPE_LONG_ARR:\n                return in.readLongArray();\n\n            case TYPE_FLOAT_ARR:\n                return in.readFloatArray();\n\n            case TYPE_DOUBLE_ARR:\n                return in.readDoubleArray();\n\n            case TYPE_CHAR_ARR:\n                return in.readCharArray();\n\n            case TYPE_BOOLEAN_ARR:\n                return in.readBooleanArray();\n\n            case TYPE_OBJ_ARR:\n                return in.readArray(arrCompType);\n\n            case TYPE_STR:\n                return in.readString();\n\n            case TYPE_ENUM:\n                return enumVals[in.readInt()];\n\n            case TYPE_UUID:\n                return in.readUuid();\n\n            case TYPE_PROPS:\n                return in.readProperties();\n\n            case TYPE_ARRAY_LIST:\n                return in.readArrayList();\n\n            case TYPE_HASH_MAP:\n                return in.readHashMap(false);\n\n            case TYPE_HASH_SET:\n                return in.readHashSet(mapFieldOff);\n\n            case TYPE_LINKED_LIST:\n                return in.readLinkedList();\n\n            case TYPE_LINKED_HASH_MAP:\n                return in.readLinkedHashMap(false);\n\n            case TYPE_LINKED_HASH_SET:\n                return in.readLinkedHashSet(mapFieldOff);\n\n            case TYPE_DATE:\n                return in.readDate();\n\n            case TYPE_CLS:\n                return classDescriptor(in.readInt(), in.classLoader(), ctx, mapper).describedClass();\n\n            case TYPE_EXTERNALIZABLE:\n                verifyChecksum(in.readShort());\n\n                return in.readExternalizable(constructor, readResolveMtd);\n\n            case TYPE_SERIALIZABLE:\n                verifyChecksum(in.readShort());\n\n                return in.readSerializable(cls, readObjMtds, readResolveMtd, fields);\n\n            default:\n                throw new IllegalStateException(\"Invalid class type: \" + type);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2260,
    "type": "Return",
    "comment": "@return new vector(length, theta), theta in -pi/2 through pi/2",
    "code": "public double[] getGradient(int x, int y) {\n    return new double[] { getLength(x, y), getTheta(x, y) };\n}",
    "label": 1,
    "rec": "@return double[length, theta]"
  },
  {
    "id": 2261,
    "type": "Return",
    "comment": "@return  true if the skip store flag is set.",
    "code": "    public boolean skipStore() {\n        if (nearContext())\n            return dht().near().context().skipStore();\n\n        GridCacheProjectionImpl<K, V> prj = prjPerCall.get();\n\n        return (prj != null && prj.skipStore());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2262,
    "type": "Return",
    "comment": "@return the original plaintext",
    "code": "public Optional<byte[]> open(byte[] nonce, byte[] ciphertext) {\n    final XSalsa20Engine xsalsa20 = new XSalsa20Engine();\n    final Poly1305 poly1305 = new Poly1305();\n    xsalsa20.init(false, new ParametersWithIV(new KeyParameter(key), nonce));\n    final byte[] sk = new byte[NUM];\n    xsalsa20.processBytes(sk, NUM, sk.length, sk, NUM);\n    poly1305.init(new KeyParameter(sk));\n    final int len = Math.max(ciphertext.length - NUM, NUM);\n    poly1305.update(ciphertext, NUM, len);\n    final byte[] calculatedMAC = new byte[NUM];\n    poly1305.doFinal(calculatedMAC, NUM);\n    final byte[] presentedMAC = new byte[NUM];\n    System.arraycopy(ciphertext, NUM, presentedMAC, NUM, Math.min(ciphertext.length, NUM));\n    if (!MessageDigest.isEqual(calculatedMAC, presentedMAC)) {\n        return Optional.empty();\n    }\n    final byte[] plaintext = new byte[len];\n    xsalsa20.processBytes(ciphertext, NUM, plaintext.length, plaintext, NUM);\n    return Optional.of(plaintext);\n}",
    "label": 1,
    "rec": "@return an {@link Optional} of the original plaintext, or if either the key, nonce, or ciphertext was modified, an empty {@link Optional}"
  },
  {
    "id": 2263,
    "type": "Return",
    "comment": "@return the permission with the given id",
    "code": "    public UmaPermissionRepresentation findById(final String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Permission id must not be null\");\n        }\n\n        Callable<UmaPermissionRepresentation> callable = new Callable<UmaPermissionRepresentation>() {\n            @Override\n            public UmaPermissionRepresentation call() {\n                return http.<UmaPermissionRepresentation>get(serverConfiguration.getPolicyEndpoint() + \"/\" + id)\n                        .authorizationBearer(pat.call())\n                        .response().json(UmaPermissionRepresentation.class).execute();\n            }\n        };\n        try {\n            return callable.call();\n        } catch (Exception cause) {\n            return Throwables.retryAndWrapExceptionIfNecessary(callable, pat, \"Error creating policy for resource [\" + resourceId + \"]\", cause);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2264,
    "type": "Return",
    "comment": "@return The {@link FileSystemManager}",
    "code": "public FileSystemFactory getFileSystem() {\n    return getServerContext().getFileSystemManager();\n}",
    "label": 1,
    "rec": "@return The {@link FileSystemFactory}"
  },
  {
    "id": 2265,
    "type": "Return",
    "comment": "@return Output stream to the secondary file system.",
    "code": "    GridGgfsWriter out() {\n        return out;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2266,
    "type": "Return",
    "comment": "@return Either the total fee paid (assuming all existing inputs had a connected output) or null if we cannot afford the transaction.",
    "code": "    public boolean completeTx(SendRequest req) {\n        lock.lock();\n        try {\n            Preconditions.checkArgument(!req.completed, \"Given SendRequest has already been completed.\");\n            // Calculate the amount of value we need to import.\n            BigInteger value = BigInteger.ZERO;\n            for (TransactionOutput output : req.tx.getOutputs()) {\n                value = value.add(output.getValue());\n            }\n            BigInteger totalOutput = value;\n\n            log.info(\"Completing send tx with {} outputs totalling {} (not including fees)\",\n                    req.tx.getOutputs().size(), bitcoinValueToFriendlyString(value));\n\n            // If any inputs have already been added, we don't need to get their value from wallet\n            BigInteger totalInput = BigInteger.ZERO;\n            for (TransactionInput input : req.tx.getInputs())\n                if (input.getConnectedOutput() != null)\n                    totalInput = totalInput.add(input.getConnectedOutput().getValue());\n                else\n                    log.warn(\"SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.\");\n            value = value.subtract(totalInput);\n\n            List<TransactionInput> originalInputs = new ArrayList<TransactionInput>(req.tx.getInputs());\n\n            // We need to know if we need to add an additional fee because one of our values are smaller than 0.01 BTC\n            boolean needAtLeastReferenceFee = false;\n            if (req.ensureMinRequiredFee) {\n                for (TransactionOutput output : req.tx.getOutputs())\n                    if (output.getValue().compareTo(Utils.CENT) < 0) {\n                        needAtLeastReferenceFee = true;\n                        break;\n                    }\n            }\n\n            // Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us\n            // with the actual outputs that'll be used to gather the required amount of value. In this way, users\n            // can customize coin selection policies.\n            //\n            // Note that this code is poorly optimized: the spend candidates only alter when transactions in the wallet\n            // change - it could be pre-calculated and held in RAM, and this is probably an optimization worth doing.\n            // Note that output.isMine(this) needs to test the keychain which is currently an array, so it's\n            // O(candidate outputs ^ keychain.size())! There's lots of low hanging fruit here.\n            LinkedList<TransactionOutput> candidates = calculateSpendCandidates(true);\n            Address changeAddress = req.changeAddress;\n            int minSize = 0;\n            // There are 3 possibilities for what adding change might do:\n            // 1) No effect\n            // 2) Causes increase in fee (change < 0.01 COINS)\n            // 3) Causes the transaction to have a dust output or change < fee increase (ie change will be thrown away)\n            // If we get either of the last 2, we keep note of what the inputs looked like at the time and move try to\n            // add inputs as we go up the list (keeping track of minimum inputs for each category).  At the end, we pick\n            // the best input set as the one which generates the lowest total fee.\n            BigInteger additionalValueForNextCategory = null;\n            CoinSelection selection3 = null;\n            CoinSelection selection2 = null; TransactionOutput selection2Change = null;\n            CoinSelection selection1 = null; TransactionOutput selection1Change = null;\n            while (true) {\n                req.tx.clearInputs();\n                for (TransactionInput input : originalInputs)\n                    req.tx.addInput(input);\n\n                BigInteger fees = req.fee.add(BigInteger.valueOf(minSize/1000).multiply(req.feePerKb));\n                if (needAtLeastReferenceFee && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)\n                    fees = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;\n\n                BigInteger valueNeeded = value.add(fees);\n                if (additionalValueForNextCategory != null)\n                    valueNeeded = valueNeeded.add(additionalValueForNextCategory);\n                BigInteger additionalValueSelected = additionalValueForNextCategory;\n\n                // Of the coins we could spend, pick some that we actually will spend.\n                CoinSelection selection = coinSelector.select(valueNeeded, candidates);\n                // Can we afford this?\n                if (selection.valueGathered.compareTo(valueNeeded) < 0)\n                    break;\n                checkState(selection.gathered.size() > 0 || originalInputs.size() > 0);\n\n                // We keep track of an upper bound on transaction size to calculate fees that need added\n                // Note that the difference between the upper bound and lower bound is usually small enough that it\n                // will be very rare that we pay a fee we do not need to\n                int size = 0;\n\n                // We can't be sure a selection is valid until we check fee per kb at the end, so we just store them here temporarily\n                boolean eitherCategory2Or3 = false;\n                boolean isCategory3 = false;\n\n                BigInteger change = selection.valueGathered.subtract(valueNeeded);\n                if (additionalValueSelected != null)\n                    change = change.add(additionalValueSelected);\n\n                TransactionOutput changeOutput = null;\n                // If change is < 0.01 BTC, we will need to have at least minfee to be accepted by the network\n                if (req.ensureMinRequiredFee && !change.equals(BigInteger.ZERO) &&\n                        change.compareTo(Utils.CENT) < 0 && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0) {\n                    // This solution may fit into category 2, but it may also be category 3, we'll check that later\n                    eitherCategory2Or3 = true;\n                    additionalValueForNextCategory = Utils.CENT;\n                    // If the change is smaller than the fee we want to add, this will be negative\n                    change = change.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(fees));\n                }\n\n                if (change.compareTo(BigInteger.ZERO) > 0) {\n                    // The value of the inputs is greater than what we want to send. Just like in real life then,\n                    // we need to take back some coins ... this is called \"change\". Add another output that sends the change\n                    // back to us. The address comes either from the request or getChangeAddress() as a default..\n                    if (changeAddress == null)\n                        changeAddress = getChangeAddress();\n                    changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);\n                    // If the change output would result in this transaction being rejected as dust, just drop the change and make it a fee\n                    if (req.ensureMinRequiredFee && Transaction.MIN_NONDUST_OUTPUT.compareTo(change) >= 0) {\n                        // This solution definitely fits in category 3\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(\n                                                         Transaction.MIN_NONDUST_OUTPUT.add(BigInteger.ONE));\n                    } else {\n                        size += changeOutput.bitcoinSerialize().length + VarInt.sizeOf(req.tx.getOutputs().size()) - VarInt.sizeOf(req.tx.getOutputs().size() - 1);\n                        // This solution is either category 1 or 2\n                        if (!eitherCategory2Or3) // must be category 1\n                            additionalValueForNextCategory = null;\n                    }\n                } else {\n                    if (eitherCategory2Or3) {\n                        // This solution definitely fits in category 3 (we threw away change because it was smaller than MIN_TX_FEE)\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);\n                    }\n                }\n\n                for (TransactionOutput output : selection.gathered) {\n                    req.tx.addInput(output);\n                    // If the scriptBytes don't default to none, our size calculations will be thrown off\n                    checkState(req.tx.getInput(req.tx.getInputs().size()-1).getScriptBytes().length == 0);\n                    try {\n                        if (output.getScriptPubKey().isSentToAddress()) {\n                            // Send-to-address spends usually take maximum pubkey.length (as it may be compressed or not) + 75 bytes\n                            size += this.findKeyFromPubHash(output.getScriptPubKey().getPubKeyHash()).getPubKey().length + 75;\n                        } else if (output.getScriptPubKey().isSentToRawPubKey())\n                            size += 74; // Send-to-pubkey spends usually take maximum 74 bytes to spend\n                        else\n                            throw new RuntimeException(\"Unknown output type returned in coin selection\");\n                    } catch (ScriptException e) {\n                        // If this happens it means an output script in a wallet tx could not be understood. That should never\n                        // happen, if it does it means the wallet has got into an inconsistent state.\n                        throw new RuntimeException(e);\n                    }\n                }\n\n                // Estimate transaction size and loop again if we need more fee per kb\n                size += req.tx.bitcoinSerialize().length;\n                if (size/1000 > minSize/1000 && req.feePerKb.compareTo(BigInteger.ZERO) > 0) {\n                    minSize = size;\n                    // We need more fees anyway, just try again with the same additional value\n                    additionalValueForNextCategory = additionalValueSelected;\n                    continue;\n                }\n\n                if (isCategory3) {\n                    if (selection3 == null)\n                        selection3 = selection;\n                } else if (eitherCategory2Or3) {\n                    // If we are in selection2, we will require at least CENT additional. If we do that, there is no way\n                    // we can end up back here because CENT additional will always get us to 1\n                    checkState(selection2 == null);\n                    checkState(additionalValueForNextCategory.equals(Utils.CENT));\n                    selection2 = selection;\n                    selection2Change = checkNotNull(changeOutput); // If we get no change in category 2, we are actually in category 3\n                } else {\n                    // Once we get a category 1 (change kept), we should break out of the loop because we can't do better\n                    checkState(selection1 == null);\n                    checkState(additionalValueForNextCategory == null);\n                    selection1 = selection;\n                    selection1Change = changeOutput;\n                }\n\n                if (additionalValueForNextCategory != null) {\n                    if (additionalValueSelected != null)\n                        checkState(additionalValueForNextCategory.compareTo(additionalValueSelected) > 0);\n                    continue;\n                }\n                break;\n            }\n\n            req.tx.clearInputs();\n            for (TransactionInput input : originalInputs)\n                req.tx.addInput(input);\n\n            if (selection3 == null && selection2 == null && selection1 == null) {\n                log.warn(\"Insufficient value in wallet for send\");\n                // TODO: Should throw an exception here.\n                return false;\n            }\n\n            BigInteger lowestFee = null;\n            CoinSelection bestCoinSelection = null;\n            TransactionOutput bestChangeOutput = null;\n            if (selection1 != null) {\n                if (selection1Change != null)\n                    lowestFee = selection1.valueGathered.subtract(selection1Change.getValue());\n                else\n                    lowestFee = selection1.valueGathered;\n                bestCoinSelection = selection1;\n                bestChangeOutput = selection1Change;\n            }\n\n            if (selection2 != null) {\n                BigInteger fee = selection2.valueGathered.subtract(checkNotNull(selection2Change).getValue());\n                if (lowestFee == null || fee.compareTo(lowestFee) < 0) {\n                    lowestFee = fee;\n                    bestCoinSelection = selection2;\n                    bestChangeOutput = selection2Change;\n                }\n            }\n\n            if (selection3 != null) {\n                if (lowestFee == null || selection3.valueGathered.compareTo(lowestFee) < 0) {\n                    bestCoinSelection = selection3;\n                    bestChangeOutput = null;\n                }\n            }\n\n            for (TransactionOutput output : bestCoinSelection.gathered)\n                req.tx.addInput(output);\n\n            totalInput = totalInput.add(bestCoinSelection.valueGathered);\n\n            req.tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);\n\n            if (bestChangeOutput != null) {\n                req.tx.addOutput(bestChangeOutput);\n                totalOutput = totalOutput.add(bestChangeOutput.getValue());\n                log.info(\"  with {} coins change\", bitcoinValueToFriendlyString(bestChangeOutput.getValue()));\n            }\n\n            // Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.\n            try {\n                req.tx.signInputs(Transaction.SigHash.ALL, this, req.aesKey);\n            } catch (ScriptException e) {\n                // If this happens it means an output script in a wallet tx could not be understood. That should never\n                // happen, if it does it means the wallet has got into an inconsistent state.\n                throw new RuntimeException(e);\n            }\n\n            // Check size.\n            int size = req.tx.bitcoinSerialize().length;\n            if (size > Transaction.MAX_STANDARD_TX_SIZE) {\n                // TODO: Throw an exception here.\n                log.error(\"Transaction could not be created without exceeding max size: {} vs {}\", size,\n                          Transaction.MAX_STANDARD_TX_SIZE);\n                return false;\n            }\n\n            // Label the transaction as being self created. We can use this later to spend its change output even before\n            // the transaction is confirmed.\n            req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);\n\n            req.completed = true;\n            req.fee = totalInput.subtract(totalOutput);\n            log.info(\"  completed {} with {} inputs\", req.tx.getHashAsString(), req.tx.getInputs().size());\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@return whether or not the requested send is affordable."
  },
  {
    "id": 2267,
    "type": "Return",
    "comment": "@return Session IDs.",
    "code": "    public Collection<IgniteUuid> sessionIds() {\n        return enabled() ? new ArrayList<>(keyMap.keySet()) : Collections.<IgniteUuid>emptyList();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2268,
    "type": "Return",
    "comment": "@return a new NodeBuilder associated with this node",
    "code": "public Node createNode(final String name, final NodeProcessor nodeProcessor) {\n    checkIsBuilt();\n    if (this.nameToNodeMap.get(name) != null) {\n        throw new DagException(String.format(STR + STR, this, name));\n    }\n    final Node node = new Node(name, nodeProcessor, this.dag);\n    this.nameToNodeMap.put(name, node);\n    return node;\n}",
    "label": 1,
    "rec": "@return a new node"
  },
  {
    "id": 2269,
    "type": "Return",
    "comment": "@return Indexing SPI implementation.",
    "code": "    public IndexingSpi getIndexingSpi() {\n        return indexingSpi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2270,
    "type": "Return",
    "comment": "@return schema of all subresources that are the descendants of the specified resource",
    "code": "public List<ResourceSchema> getSubResources(ResourceSchema parentSchema) {\n    return _subResources.get(parentSchema);\n}",
    "label": 1,
    "rec": "@return schema of direct subresources of the specified resource"
  },
  {
    "id": 2271,
    "type": "Return",
    "comment": "@return Grid configuration",
    "code": "    private IgniteConfiguration config(int idx) {\n        GridGgfsConfiguration ggfsCfg = new GridGgfsConfiguration();\n\n        ggfsCfg.setDataCacheName(\"dataCache\");\n        ggfsCfg.setMetaCacheName(\"metaCache\");\n        ggfsCfg.setName(\"ggfs\");\n        ggfsCfg.setBlockSize(BLOCK_SIZE);\n        ggfsCfg.setDefaultMode(PRIMARY);\n        ggfsCfg.setFragmentizerEnabled(false);\n\n        GridCacheConfiguration dataCacheCfg = new GridCacheConfiguration();\n\n        dataCacheCfg.setName(\"dataCache\");\n        dataCacheCfg.setCacheMode(PARTITIONED);\n        dataCacheCfg.setAtomicityMode(TRANSACTIONAL);\n        dataCacheCfg.setDistributionMode(PARTITIONED_ONLY);\n        dataCacheCfg.setWriteSynchronizationMode(FULL_SYNC);\n        dataCacheCfg.setAffinityMapper(new GridGgfsGroupDataBlocksKeyMapper(1));\n        dataCacheCfg.setBackups(0);\n        dataCacheCfg.setQueryIndexEnabled(false);\n\n        GridCacheConfiguration metaCacheCfg = new GridCacheConfiguration();\n\n        metaCacheCfg.setName(\"metaCache\");\n        metaCacheCfg.setCacheMode(REPLICATED);\n        metaCacheCfg.setAtomicityMode(TRANSACTIONAL);\n        dataCacheCfg.setWriteSynchronizationMode(GridCacheWriteSynchronizationMode.FULL_SYNC);\n        metaCacheCfg.setQueryIndexEnabled(false);\n\n        IgniteConfiguration cfg = new IgniteConfiguration();\n\n        GridTcpDiscoverySpi discoSpi = new GridTcpDiscoverySpi();\n\n        discoSpi.setIpFinder(IP_FINDER);\n\n        cfg.setDiscoverySpi(discoSpi);\n        cfg.setCacheConfiguration(dataCacheCfg, metaCacheCfg);\n        cfg.setGgfsConfiguration(ggfsCfg);\n\n        cfg.setGridName(\"node-\" + idx);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2272,
    "type": "Return",
    "comment": "@return the number of bytes returned in the message",
    "code": "public int getCount() {\n    return this.count;\n}",
    "label": 1,
    "rec": "@return the number of bytes returned in the message (i.e. the payload size)"
  },
  {
    "id": 2273,
    "type": "Return",
    "comment": "@return the probability of this sequence.",
    "code": "    public double p(int[] o) {\n        return MathEx.exp(logp(o));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2274,
    "type": "Return",
    "comment": "@return Returns the vector of stored signature values.",
    "code": "public List getSignatureValues() {\n    return signatureValues;\n}",
    "label": 1,
    "rec": "@return Returns the list of stored signature values."
  },
  {
    "id": 2275,
    "type": "Return",
    "comment": "@return the  ZWaveCommandClass that can be used to get a converter suitable to do the conversion.",
    "code": "\tprivate ZWaveCommandClass resolveConverter(Item item, ZWaveNode node, int endpointId) {\n\t\tif(item == null)\n\t\t\treturn null;\n\n\t\tZWaveMultiInstanceCommandClass multiInstanceCommandClass = null;\n\t\tZWaveCommandClass result = null;\n\t\t\n\t\tif (endpointId != 1)\n\t\t\tmultiInstanceCommandClass = (ZWaveMultiInstanceCommandClass)node.getCommandClass(CommandClass.MULTI_INSTANCE);\n\n\t\tif (!preferredCommandClasses.containsKey(item.getClass())) {\n\t\t\tlogger.warn(\"No preferred command classes found for item class = {}\", item.getClass().toString());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tfor (CommandClass commandClass : preferredCommandClasses.get(item.getClass())) {\n\t\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 2) {\n\t\t\t\tZWaveEndpoint endpoint = multiInstanceCommandClass.getEndpoint(endpointId);\n\t\t\t\t\n\t\t\t\tif (endpoint != null) { \n\t\t\t\t\tresult = endpoint.getCommandClass(commandClass);\n\t\t\t\t} \n\t\t\t}\n\t\t\t\n\t\t\tif (result == null)\n\t\t\t\tresult = node.getCommandClass(commandClass);\n\t\t\t\n\t\t\tif (result == null)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 1 &&\n\t\t\t\t\tresult.getInstances() < endpointId)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (converters.containsKey(commandClass))\n\t\t\t\treturn result;\n\t\t}\n\t\t\n\t\tlogger.warn(\"No matching command classes found for item class = {}, node id = {}, endpoint id = {}\", \n\t\t\t\titem.getClass().toString(), node.getNodeId(), endpointId);\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2276,
    "type": "Return",
    "comment": "@return return string is not blank",
    "code": "public static boolean isNotBlank(String... str) {\n    if (str == null)\n        return false;\n    for (String s : str) {\n        if (isBlank(s)) {\n            return false;\n        }\n    }\n    return true;\n}",
    "label": 1,
    "rec": "@return return any one in this list of string is not blank"
  },
  {
    "id": 2277,
    "type": "Return",
    "comment": "@return Mini-future ID.",
    "code": "        IgniteUuid miniId() {\n            return miniId;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2278,
    "type": "Return",
    "comment": "@return int The associated icon",
    "code": "public static final int getIcon(Context context, FileSystemObject fso) {\n    if (sMimeTypes == null) {\n        loadMimeTypes(context);\n    }\n    if (fso instanceof Directory || FileHelper.isSymlinkRefDirectory(fso)) {\n        return R.drawable.ic_fso_folder;\n    }\n    String ext = FileHelper.getExtension(fso);\n    if (ext != null) {\n        MimeTypeInfo mimeTypeInfo = sMimeTypes.get(ext);\n        if (mimeTypeInfo != null) {\n            int drawableId = NUM;\n            if (sCachedIndentifiers.containsKey(ext)) {\n                drawableId = sCachedIndentifiers.get(ext).intValue();\n            } else {\n                drawableId = ResourcesHelper.getIdentifier(context.getResources(), STR, mimeTypeInfo.mDrawable);\n                sCachedIndentifiers.put(ext, Integer.valueOf(drawableId));\n            }\n            return drawableId;\n        }\n    }\n    if (fso.getPermissions().getUser().isExecute()) {\n        return R.drawable.ic_fso_type_executable;\n    }\n    return R.drawable.ic_fso_default;\n}",
    "label": 1,
    "rec": "@return int The associated mime/type icon resource identifier"
  },
  {
    "id": 2279,
    "type": "Return",
    "comment": "@return the value for the named  init-param, or  null if there was no  init-param specified by that name.",
    "code": "    protected String getInitParam(String paramName) {\n        FilterConfig config = getFilterConfig();\n        if (config != null) {\n            return StringUtils.clean(config.getInitParameter(paramName));\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2280,
    "type": "Return",
    "comment": "@return <code>true</code> if it is the <tt>OclInvalid</tt>; <code>false</code>, otherwise",
    "code": "public boolean isInvalid(Object value) {\n    return getEnvironment().getOCLStandardLibrary().getInvalid() == value;\n}",
    "label": 1,
    "rec": "@return <code>true</code> if it is the <tt>invalid</tt>; <code>false</code>, otherwise"
  },
  {
    "id": 2281,
    "type": "Return",
    "comment": "@return octicons typeface",
    "code": "    public static Typeface getOcticons(final Context context) {\n        if (OCTICONS == null)\n            OCTICONS = getTypeface(context, \"octicons-regular-webfont.ttf\");\n        return OCTICONS;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2282,
    "type": "Return",
    "comment": "@return map File -> basedir-relative path",
    "code": "public FileToPathMap scan() {\n    FileToPathMap result = new FileToPathMap();\n    recursiveScan(baseDir, result, Path.fromOSString(baseDir.getAbsolutePath()));\n    return result;\n}",
    "label": 1,
    "rec": "@return map canonical File -> basedir-relative path"
  },
  {
    "id": 2283,
    "type": "Return",
    "comment": "@return File id already stored in meta cache or  null if passed file info was stored.",
    "code": "    private IgniteUuid putIfAbsentNonTx(IgniteUuid parentId, String fileName, IgfsFileInfo newFileInfo)\n        throws IgniteCheckedException {\n        if (log.isDebugEnabled())\n            log.debug(\"Locking parent id [parentId=\" + parentId + \", fileName=\" + fileName + \", newFileInfo=\" +\n                newFileInfo + ']');\n\n        assert validTxState(true);\n\n        // Lock only parent file ID.\n        IgfsFileInfo parentInfo = info(parentId);\n\n        if (parentInfo == null)\n            throw fsException(new IgfsPathNotFoundException(\"Failed to lock parent directory (not found): \" +\n                parentId));\n\n        if (!parentInfo.isDirectory())\n            throw fsException(new IgfsPathIsNotDirectoryException(\"Parent file is not a directory: \" + parentInfo));\n\n        IgfsListingEntry childEntry = parentInfo.listing().get(fileName);\n\n        if (childEntry != null)\n            return childEntry.fileId();\n\n        if (!id2InfoPrj.putIfAbsent(newFileInfo.id(), newFileInfo))\n            throw fsException(\"Failed to add file details into cache: \" + newFileInfo);\n\n        id2InfoPrj.invoke(parentId, new ListingAdd(fileName, new IgfsListingEntry(newFileInfo)));\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2284,
    "type": "Return",
    "comment": "@return the next valid execution time",
    "code": "public Long nextExecutionTime() {\n    Date nextExec = cex.getNextValidTimeAfter(new Date());\n    if (nextExec == null)\n        return null;\n    return nextExec.getTime();\n}",
    "label": 1,
    "rec": "@return the next valid execution time or null if there isn't one"
  },
  {
    "id": 2285,
    "type": "Return",
    "comment": "@return  True if configurations match.",
    "code": "    private boolean matches(CacheConfiguration ccfg0, CacheConfiguration ccfg1) {\n        return\n            F.eq(ccfg0.getCacheMode(), ccfg1.getCacheMode()) &&\n            F.eq(ccfg0.getBackups(), ccfg1.getBackups()) &&\n            F.eq(ccfg0.getAtomicityMode(), ccfg1.getAtomicityMode()) &&\n            F.eq(ccfg0.getAtomicWriteOrderMode(), ccfg1.getAtomicWriteOrderMode()) &&\n            F.eq(ccfg0.getMemoryMode(), ccfg1.getMemoryMode());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2286,
    "type": "Return",
    "comment": "@return an array with all interfaces. The array may be empty.",
    "code": "public static Set getAllInterfaces(final Class clazz) {\n    final Set interfaces = new HashSet();\n    getInterfaces(clazz, interfaces);\n    interfaces.remove(InvokerReference.class);\n    return interfaces;\n}",
    "label": 1,
    "rec": "@return a {@link Set} with all interfaces. The set may be empty."
  },
  {
    "id": 2287,
    "type": "Return",
    "comment": "@return date format as getDateFormat with weekday",
    "code": "    public static SimpleDateFormat getDateFormatWithWeekday(Context context) {\n        try {\n            return new SimpleDateFormat(\"EEEE, \" + getDateFormatString(context));\n        } catch (Exception e) {\n            return new SimpleDateFormat(\"EEEE, d MMM yyyy\");\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2288,
    "type": "Return",
    "comment": "@return Auth spi.",
    "code": "public T2<String, Map<String, Object>> authenticationSpi() {\n    return authSpi;\n}",
    "label": 1,
    "rec": "@return Authentication SPI."
  },
  {
    "id": 2289,
    "type": "Return",
    "comment": "@return GGFS mode.",
    "code": "    public IgniteFsMode resolveMode(IgniteFsPath path) {\n        assert path != null;\n\n        if (modes == null)\n            return dfltMode;\n        else {\n            IgniteFsMode mode = modesCache.get(path);\n\n            if (mode == null) {\n                for (T2<IgniteFsPath, IgniteFsMode> entry : modes) {\n                    if (startsWith(path, entry.getKey())) {\n                        // As modes ordered from most specific to least specific first mode found is ours.\n                        mode = entry.getValue();\n\n                        break;\n                    }\n                }\n\n                if (mode == null)\n                    mode = dfltMode;\n\n                modesCache.put(path, mode);\n            }\n\n            return mode;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2290,
    "type": "Return",
    "comment": "@return the new byte array backed by a buffer or an array",
    "code": "    public static ByteIndexer create(final BytePointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new ByteRawIndexer(pointer, sizes, strides)\n                                             : new ByteBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            byte[] array = new byte[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new ByteArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new byte indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 2291,
    "type": "Return",
    "comment": "@return whether the producer will block  Producer#send and  Producer#sendAsync operations when the pending queue is full",
    "code": "    public boolean getBlockIfQueueFull() {\n        return conf.isBlockIfQueueFull();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2292,
    "type": "Return",
    "comment": "@return The script type.",
    "code": "@Nullable\npublic ScriptType getScriptType() {\n    if (ScriptPattern.isPayToPubKeyHash(this))\n        return ScriptType.P2PKH;\n    if (ScriptPattern.isPayToPubKey(this))\n        return ScriptType.P2PK;\n    if (ScriptPattern.isPayToScriptHash(this))\n        return ScriptType.P2SH;\n    return null;\n}",
    "label": 1,
    "rec": "@return The script type, or null if the script is of unknown type"
  },
  {
    "id": 2293,
    "type": "Return",
    "comment": "@return  True if lock had been removed.",
    "code": "    public boolean isRemoved(GridCacheContext<K, V> cacheCtx, GridCacheVersion ver) {\n        return !cacheCtx.isNear() && !cacheCtx.isLocal() && ver != null && rmvLocks.contains(ver);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2294,
    "type": "Return",
    "comment": "@return the database Column this property maps to",
    "code": "public Column getColumn() {\n    return _column;\n}",
    "label": 1,
    "rec": "@return The column"
  },
  {
    "id": 2295,
    "type": "Return",
    "comment": "@return Binary field.",
    "code": "        private BinaryField binaryField(BinaryObject obj) {\n            if (skipFieldLookup)\n                return null;\n\n            BinaryField field0 = field;\n\n            if (field0 == null && !fieldTaken) {\n                BinaryType type = obj.type();\n\n                if (type != null) {\n                    field0 = type.field(propName);\n\n                    assert field0 != null;\n\n                    field = field0;\n                }\n\n                fieldTaken = true;\n            }\n\n            return field0;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2296,
    "type": "Return",
    "comment": "@return null if the project does not have any specific preferences.",
    "code": "public boolean loadProjectPreferences(ProjectPreferences pp) {\n    IEclipsePreferences pref = getPreferences();\n    if (pref == null)\n        return false;\n    int version = pref.getInt(PrefConstants.frameworkVersion, NUM);\n    if (version == NUM)\n        return false;\n    pp.setOverride(pref.getBoolean(PrefConstants.override, ProjectPreferences.DefaultOverride));\n    pp.setSuspend(pref.getBoolean(PrefConstants.suspend, ProjectPreferences.DefaultSuspend));\n    Validator[] vals = ValManager.getDefault().getValidators2(_project);\n    loadPreferences(vals, pref);\n    pp.setValidators(vals);\n    return true;\n}",
    "label": 1,
    "rec": "@return false if the project does not have any specific preferences."
  },
  {
    "id": 2297,
    "type": "Return",
    "comment": "@return Queue.",
    "code": "    private static CacheQueue<String> initializeQueue(Ignite ignite, String queueName) throws IgniteCheckedException {\n        // Initialize new FIFO queue.\n        CacheQueue<String> queue = ignite.cache(CACHE_NAME).dataStructures().queue(queueName, 0, false, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < ignite.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2298,
    "type": "Return",
    "comment": "@return RowPanelExpander child of the table, or null",
    "code": "public PanelExpansion getPanelExpansion() {\n    for (UIComponent kid : getChildren()) if (kid instanceof PanelExpansion)\n        return (PanelExpansion) kid;\n    return null;\n}",
    "label": 1,
    "rec": "@return PanelExpansion child of the table, or null"
  },
  {
    "id": 2299,
    "type": "Return",
    "comment": "@return Multi bulk reply",
    "code": "    public Set<byte[]> keys(final byte[] pattern) {\n        checkIsInMulti();\n        client.keys(pattern);\n        final HashSet<byte[]> keySet = new HashSet<byte[]>(client.getBinaryMultiBulkReply());\n        return keySet;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2300,
    "type": "Return",
    "comment": "@return the list of remote user agents",
    "code": "public static Set<String> getRemoteUserAgents() {\n    if (unitTestShell == null) {\n        return null;\n    }\n    return unitTestShell.runStyle.getUserAgents();\n}",
    "label": 1,
    "rec": "@return the set of remote user agents"
  },
  {
    "id": 2301,
    "type": "Return",
    "comment": "@return the configuration parameter.",
    "code": "\t\tpublic ConfigurationParameter getParameter() {\n\t\t\treturn (ConfigurationParameter) this.getValue();\n\t\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2302,
    "type": "Return",
    "comment": "@return Collection of {@link UserEntity}.",
    "code": "public List<UserEntity> transformUserEntityCollection(String userListJsonResponse) throws JsonSyntaxException {\n    List<UserEntity> userEntityCollection;\n    try {\n        Type listOfUserEntityType = new TypeToken<List<UserEntity>>() {\n        }.getType();\n        userEntityCollection = this.gson.fromJson(userListJsonResponse, listOfUserEntityType);\n        return userEntityCollection;\n    } catch (JsonSyntaxException jsonException) {\n        throw jsonException;\n    }\n}",
    "label": 1,
    "rec": "@return List of {@link UserEntity}."
  },
  {
    "id": 2303,
    "type": "Return",
    "comment": "@return Type ID.",
    "code": "    public int typeId(String typeName) {\n        String typeName0 = typeName(typeName);\n\n        Integer id = predefinedTypeNames.get(typeName0);\n\n        if (id != null)\n            return id;\n\n        if (marshCtx.isSystemType(typeName))\n            return typeName.hashCode();\n\n        return userTypeIdMapper(typeName0).typeId(typeName0);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2304,
    "type": "Return",
    "comment": "@return the adjusted insets.",
    "code": "public static ElkPadding calculateRequiredNodeLabelSpace(final NodeAdapter<?> node, final double labelSpacing) {\n    ElkPadding nodeLabelPadding = node.getProperty(CoreOptions.NODE_LABELS_PADDING);\n    return calculateRequiredNodeLabelSpace(node, labelSpacing, nodeLabelPadding, new HashMap<LabelLocation, LabelGroup>(), new ElkPadding(node.getPadding()));\n}",
    "label": 1,
    "rec": "@return the adjusted padding."
  },
  {
    "id": 2305,
    "type": "Return",
    "comment": "@return the ClientRegionShortcut used to configure the GemFire ClientCache Region.",
    "code": "\tprotected ClientRegionShortcut getClientRegionShortcut() {\n\t\treturn (this.clientRegionShortcut != null ? this.clientRegionShortcut : DEFAULT_CLIENT_REGION_SHORTCUT);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2306,
    "type": "Return",
    "comment": "@return A set of added partitions in target cluster or empty set",
    "code": "public static <T> Set<T> getAddedInTarget(Set<T> current, Set<T> target) {\n    if (current == null || target == null) {\n        return new HashSet<T>();\n    }\n    return getDiff(target, current);\n}",
    "label": 1,
    "rec": "@return A set of added partitions in target or empty set"
  },
  {
    "id": 2307,
    "type": "Return",
    "comment": "@return a Size",
    "code": "    public Size getPreviewSize() {\n        if (getWidth() == 0 || getHeight() == 0) return null;\n\n        // Get the preview size and crop according to the current view size.\n        // It's better to do calculations in the REF_VIEW reference, and then flip if needed.\n        Size preview = mCameraController.getPreviewSize(CameraController.REF_VIEW);\n        AspectRatio viewRatio = AspectRatio.of(getWidth(), getHeight());\n        Rect crop = CropHelper.computeCrop(preview, viewRatio);\n        Size cropSize = new Size(crop.width(), crop.height());\n        if (mCameraController.flip(CameraController.REF_VIEW, CameraController.REF_OUTPUT)) {\n            return cropSize.flip();\n        } else {\n            return cropSize;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2308,
    "type": "Return",
    "comment": "@return {@link Repository} or null if unparseable",
    "code": "public static Repo getRepository(Uri uri) {\n    List<String> segments = uri.getPathSegments();\n    if (segments == null)\n        return null;\n    if (segments.size() < NUM)\n        return null;\n    String repoOwner = segments.get(NUM);\n    if (!RepositoryUtils.isValidOwner(repoOwner))\n        return null;\n    String repoName = segments.get(NUM);\n    if (!RepositoryUtils.isValidRepo(repoName))\n        return null;\n    Repo repository = new Repo();\n    User owner = new User();\n    owner.login = repoOwner;\n    repository.name = repoName;\n    repository.owner = owner;\n    return repository;\n}",
    "label": 1,
    "rec": "@return {@link Repo} or null if unparseable"
  },
  {
    "id": 2309,
    "type": "Return",
    "comment": "@return Script result",
    "code": "    public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {\n\treturn eval(script, toByteArray(keys.size()), getParams(keys, args));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2310,
    "type": "Return",
    "comment": "@return Returns greater than zero when this.doubleValue() > object.doubleValue(), zero when this.doubleValue() == object.doubleValue(), and less than zero when this.doubleValue() < object.doubleValue()",
    "code": "public int compareTo(Double object) {\n    long d1, d2;\n    long NaNbits = Double.doubleToLongBits(Double.NaN);\n    if ((d1 = Double.doubleToLongBits(value)) == NaNbits) {\n        if (Double.doubleToLongBits(object.value) == NaNbits) {\n            return NUM;\n        }\n        return NUM;\n    }\n    if ((d2 = Double.doubleToLongBits(object.value)) == NaNbits) {\n        return -NUM;\n    }\n    if (value == object.value) {\n        if (d1 == d2) {\n            return NUM;\n        }\n        return d1 > d2 ? NUM : -NUM;\n    }\n    return value > object.value ? NUM : -NUM;\n}",
    "label": 1,
    "rec": "@return Returns greater than zero when this.doubleValue() is greater than object.doubleValue(), zero when this.doubleValue() equals object.doubleValue(), and less than zero when this.doubleValue() is less than object.doubleValue()"
  },
  {
    "id": 2311,
    "type": "Return",
    "comment": "@return Mini future ID.",
    "code": "    public IgniteUuid miniId() {\n        return miniId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2312,
    "type": "Return",
    "comment": "@return Number of bytes output (0 or 1)",
    "code": "public boolean decodePadded1(byte[] resultBuffer, int resultOffset, int resultEnd, int data) throws IllegalArgumentException {\n    if (mCurrSegmentPtr >= mCurrSegmentEnd) {\n        if (!nextSegment()) {\n            markPartialInput(NUM, data, true);\n            return false;\n        }\n    }\n    char ch = mCurrSegment[mCurrSegmentPtr++];\n    if (ch != CHAR_PADDING) {\n        throw reportInvalidChar(ch, STR);\n    }\n    data >>= NUM;\n    if (resultOffset >= resultEnd) {\n        markPartialOutput(NUM, data);\n        return false;\n    }\n    resultBuffer[resultOffset] = (byte) data;\n    return true;\n}",
    "label": 1,
    "rec": "@return True if decoding and outputting succeeded; false if at least one failed due to lacking input or room for output."
  },
  {
    "id": 2313,
    "type": "Return",
    "comment": "@return Error.",
    "code": "    protected IgniteSpiException duplicateIdError(GridTcpDiscoveryDuplicateIdMessage msg) {\n        assert msg != null;\n\n        return new IgniteSpiException(\"Local node has the same ID as existing node in topology \" +\n            \"(fix configuration and restart local node) [localNode=\" + locNode +\n            \", existingNode=\" + msg.node() + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2314,
    "type": "Return",
    "comment": "@return the copy of original object created by the original object's serialization/deserialization methods",
    "code": "public static <T> T createCopy(final T original) {\n    final Kryo kryo = new Kryo();\n    return (T) kryo.copy(original);\n}",
    "label": 1,
    "rec": "@return the copy of original object"
  },
  {
    "id": 2315,
    "type": "Return",
    "comment": "@return the parser or null if no such command has been registered.",
    "code": "  public BinaryCommandParser createParser(byte opcode, Channel channel, ByteOrder byteOrder)\n  {\n    BinaryCommandParserFactory factory = _binaryParsers.get(opcode);\n    return (null != factory) ? factory.createParser(channel, byteOrder) : null;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2316,
    "type": "Return",
    "comment": "@return zTask ",
    "code": "public static String version() {\n    return String.format(STR, majorVersion(), releaseLevel(), minorVersion());\n}",
    "label": 1,
    "rec": "@return nutz "
  },
  {
    "id": 2317,
    "type": "Return",
    "comment": "@return GGFS exception.",
    "code": "    public static IgniteFsException cast(String msg, IOException e) {\n        if (e instanceof FileNotFoundException)\n            return new GridGgfsFileNotFoundException(e);\n        else if (e instanceof ParentNotDirectoryException)\n            return new GridGgfsParentNotDirectoryException(msg, e);\n        else if (e instanceof PathIsNotEmptyDirectoryException)\n            return new GridGgfsDirectoryNotEmptyException(e);\n        else if (e instanceof PathExistsException)\n            return new IgniteFsPathAlreadyExistsException(msg, e);\n        else\n            return new IgniteFsException(msg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2318,
    "type": "Return",
    "comment": "@return a reified closure wrapping the Java method Example: eval \"(reflect: tbl).getMethod('at')\" where tbl is a NATTable => downMethod(aNATTable, \"at\") => NATTable must have a method named base_at",
    "code": "public static final ATMethod downMethod(ATObject natObject, String jSelector, ATSymbol origName) throws InterpreterException {\n    return new NativeMethod(JavaInterfaceAdaptor.getMethod(natObject.getClass(), natObject, jSelector), origName);\n}",
    "label": 1,
    "rec": "@return a reified method wrapping the Java method Example: eval \"(reflect: tbl).getMethod('at')\" where tbl is a NATTable => downMethod(aNATTable, \"base_at\") => NATTable must have a method named base_at Callers should use the more specialised 'downBaseLevelMethod' and 'downMetaLevelMethod' methods to specify the prefix of the method to be found"
  },
  {
    "id": 2319,
    "type": "Return",
    "comment": "@return OverloadedWorldHolder",
    "code": "    public OverloadedWorldHolder getWorldData(String worldName) {\n    \tString worldNameLowered = worldName.toLowerCase();\n    \t\n    \tif (worldsData.containsKey(worldNameLowered))\n    \t\t\treturn worldsData.get(worldNameLowered);\n\n        GroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning default world...\");\n        return getDefaultWorld();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2320,
    "type": "Return",
    "comment": "@return a {@link AndroidLifecycle} against this owner.",
    "code": "public static AndroidLifecycleScopeProvider from(LifecycleOwner owner) {\n    return from(owner.getLifecycle());\n}",
    "label": 1,
    "rec": "@return a {@link AndroidLifecycleScopeProvider} against this owner."
  },
  {
    "id": 2321,
    "type": "Return",
    "comment": "@return true if the subject was successfully logged in, false otherwise",
    "code": "    protected boolean executeLogin(ServletRequest request, ServletResponse response) {\n        boolean isLoggedIn = false;\n\n        HttpServletRequest httpRequest = toHttp(request);\n        String authorizationHeader = httpRequest.getHeader(AUTHORIZATION_HEADER);\n\n        if (authorizationHeader != null && authorizationHeader.length() > 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Executing login with headers [\" + authorizationHeader + \"]\");\n            }\n\n            String[] authTokens = authorizationHeader.split(\" \");\n\n            if (authTokens[0].trim().equalsIgnoreCase(HttpServletRequest.BASIC_AUTH)) {\n                String encodedCredentials = authTokens[1];\n\n                byte[] decodedCredentialByteArray = Base64.decodeBase64(encodedCredentials);\n                String decodedCredentials = new String(decodedCredentialByteArray);\n\n                String[] credentials = decodedCredentials.split(\":\");\n\n                if (credentials != null && credentials.length > 1) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Processing login request [\" + credentials[0] + \"]\");\n                    }\n                    Subject subject = getSubject(request, response);\n                    UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(credentials[0], credentials[1]);\n                    try {\n                        subject.login(usernamePasswordToken);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Successfully logged in user [\" + credentials[0] + \"]\");\n                        }\n                        isLoggedIn = true;\n                    } catch (AuthenticationException ae) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Unable to log in subject [\" + credentials[0] + \"]\", ae);\n                        }\n\n                        return sendChallenge(request, response);\n                    }\n                }\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Returning [\" + isLoggedIn + \"] from executeLogin()\");\n        }\n\n        return isLoggedIn;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2322,
    "type": "Return",
    "comment": "@return Directory path with file separator in the end",
    "code": "public static String makeDirectory(String... dirs) {\n    String dirPath = makeDirPath(dirs);\n    return makeDirectory(dirPath);\n}",
    "label": 1,
    "rec": "@return constructed directory path"
  },
  {
    "id": 2323,
    "type": "Return",
    "comment": "@return Default grid state.",
    "code": "    public static IgniteState state() {\n        return GridGainEx.state();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2324,
    "type": "Return",
    "comment": "@return Status containing shares, progress, shards and seal status",
    "code": "public VaultStatus getStatus() {\n    WebTarget target = baseTarget.path(STR);\n    Response response = null;\n    try {\n        response = target.request().accept(STR).header(STR, this.vaultToken).get();\n        if (response.getStatus() != NUM) {\n            ErrorResponse error = response.readEntity(ErrorResponse.class);\n            throw new VaultException(response.getStatus(), error.getErrors());\n        }\n        return response.readEntity(VaultStatus.class);\n    } finally {\n        if (response != null) {\n            response.close();\n        }\n    }\n}",
    "label": 1,
    "rec": "@return VaultStatus containing shares, progress, shards and seal status"
  },
  {
    "id": 2325,
    "type": "Return",
    "comment": "@return Data transfer object for given GGFS.",
    "code": "    public static VisorGgfs from(GridGgfs ggfs) throws GridException {\n        assert ggfs != null;\n\n        return new VisorGgfs(\n            ggfs.name(),\n            ggfs.configuration().getDefaultMode(),\n            VisorGgfsMetrics.from(ggfs.metrics()),\n            ggfs.configuration().getSecondaryFileSystem() != null\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2326,
    "type": "Return",
    "comment": "@return the variance of the log normal distribution.",
    "code": "public double variance() {\n    if (usesStDev) {\n        return getStDev() * getStDev();\n    }\n    return NUM / scaleParameter.getParameterValue(NUM);\n}",
    "label": 1,
    "rec": "@return the variance of the log normal distribution. Not really the variance of the lognormal but the S^2 parameter"
  },
  {
    "id": 2327,
    "type": "Return",
    "comment": "@return GGFS configurations.",
    "code": "    public IgfsConfiguration[] getGgfsConfiguration() {\n        return ggfsCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2328,
    "type": "Return",
    "comment": "@return the  HttpHost proxy associated with the first matching hostname  Pattern or @literal null if none matches.",
    "code": "  public ProxyMapping getProxyFor(String hostname) {\n\n    Objects.requireNonNull(hostname, \"hostname\");\n    if (hostnameToProxyCache.containsKey(hostname)) {\n      return hostnameToProxyCache.get(hostname);\n    }\n    ProxyMapping proxyMapping = entries.stream() //\n            .filter(e -> e.matches(hostname)) //\n            .findFirst() //\n            .orElse(null);\n    if (proxyMapping == null) {\n      proxyMapping = new ProxyMapping(null, null, null);\n    }\n    hostnameToProxyCache.put(hostname, proxyMapping);\n    return proxyMapping;\n  }\n",
    "label": 1,
    "rec": "@return the  ProxyMapping associated with the first matching hostname  Pattern or the  ProxyMapping including @literal null as  HttpHost if none matches."
  },
  {
    "id": 2329,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    private Object readResolve() throws ObjectStreamException {\n        return prj.services();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2330,
    "type": "Return",
    "comment": "@return true, if successful",
    "code": "public static boolean areEqual(Object o1, Object o2) {\n    return o1 == null ? o2 == null : o1.equals(o2);\n}",
    "label": 1,
    "rec": "@return true, if the objects are equals (meaning that the equals() method returns true)"
  },
  {
    "id": 2331,
    "type": "Return",
    "comment": "@return Version for a QR Code of that dimension",
    "code": "  public static Version getProvisionalVersionForDimension(int dimension) throws FormatException {\n    if (dimension % 4 != 1) {\n      throw FormatException.getFormatInstance();\n    }\n    try {\n      return getVersionForNumber((dimension - 17) / 4);\n    } catch (IllegalArgumentException ignored) {\n      throw FormatException.getFormatInstance();\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2332,
    "type": "Return",
    "comment": "@return the choosen data node",
    "code": "public Node chooseRandom(String scope) {\n    netlock.readLock().lock();\n    try {\n        if (scope.startsWith(STR)) {\n            return chooseRandom(NodeBase.ROOT, scope.substring(NUM));\n        } else {\n            return chooseRandom(scope, null);\n        }\n    } finally {\n        netlock.readLock().unlock();\n    }\n}",
    "label": 1,
    "rec": "@return the choosen node"
  },
  {
    "id": 2333,
    "type": "Return",
    "comment": "@return Hadoop-enabled nodes.",
    "code": "    public Collection<GridNode> nodes() {\n        return ctx.discovery().cacheNodes(CU.SYS_CACHE_HADOOP, ctx.discovery().topologyVersion());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2334,
    "type": "Return",
    "comment": "@return {@link OperationStatus.OK} or {@link OperationStatus.FAILED}.",
    "code": "@Deprecated\npublic Actions.ActionResult saveDocument(File saveFile) {\n    if (saveToXml) {\n        PaccmanFileOld pf = new PaccmanFileOld();\n        try {\n            pf.write(saveFile, getDocumentController());\n        } catch (PaccmanIOException pie) {\n            pie.printStackTrace();\n            return FAILED;\n        }\n    }\n    if (saveToDatabase) {\n        PaccmanDao db = new PaccmanDao(new File(saveFile.getAbsolutePath()).getPath() + STR);\n        try {\n            db.save(getDocumentController());\n        } catch (SQLException ex) {\n            org.paccman.tools.Logger.getDefaultLogger(this).log(Level.SEVERE, null, ex);\n        } catch (UnsupportedEncodingException ex) {\n            org.paccman.tools.Logger.getDefaultLogger(this).log(Level.SEVERE, null, ex);\n        }\n    }\n    return OK;\n}",
    "label": 1,
    "rec": "@return {@link OK} or {@link FAILED}."
  },
  {
    "id": 2335,
    "type": "Return",
    "comment": "@return true if the given sensorIdString is configured correctly and false otherwise",
    "code": "\tprotected boolean checkSensorId(String sensorIdString) {\n\t\treturn sensorIdString.matches(\"\\\\[A-F0-9]{2}\\\\.[A-F0-9]{12}\");\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2336,
    "type": "Return",
    "comment": "@return version of the service, or {@code -1} if no version found.",
    "code": "public Version getVersion(Class<? extends Service> serviceClass) {\n    List<Version> versions = getVersions();\n    Version v = getVersion(versions, serviceClass);\n    if (v == null) {\n        throw new IllegalStateException(STR + serviceClass);\n    }\n    return v;\n}",
    "label": 1,
    "rec": "@return version of the service."
  },
  {
    "id": 2337,
    "type": "Return",
    "comment": "@return A Checksum (generator) of type checkSumType which contains the computed checksum of the copied file",
    "code": "    private byte[] copyFileWithCheckSum(HdfsFile source, File dest, CheckSumType checkSumType)\n            throws IOException {\n        byte[] checkSum = null;\n        logger.debug(\"Starting copy of \" + source + \" to \" + dest);\n\n        // Check if its Gzip compressed\n        boolean isCompressed = source.isCompressed();\n        FilterInputStream input = null;\n\n        OutputStream output = null;\n        long startTimeMS = System.currentTimeMillis();\n        int previousAttempt = 0;\n\n        for (int attempt = 1; attempt <= fetcher.getMaxAttempts(); attempt++) {\n            boolean success = false;\n            long totalBytesRead = 0;\n            boolean fsOpened = false;\n            try {\n                CheckSum fileCheckSumGenerator = null;\n                // Create a per file checksum generator\n                if (checkSumType != null) {\n                    fileCheckSumGenerator = CheckSum.getInstance(checkSumType);\n                }\n\n                logger.info(\"Starting attempt #\" + attempt + \"/\" + fetcher.getMaxAttempts() +\n                        \" to fetch remote file: \" + source + \" to local destination: \" + dest);\n\n                input = new ThrottledInputStream(fs.open(source.getPath()), fetcher.getThrottler(), stats);\n\n                if (isCompressed) {\n                    // We are already bounded by the \"hdfs.fetcher.buffer.size\"\n                    // specified in the Voldemort config, the default value of\n                    // which is 64K. Using the same as the buffer size for\n                    // GZIPInputStream as well.\n                    input = new GZIPInputStream(input, this.bufferSize);\n                }\n                fsOpened = true;\n\n                output = new BufferedOutputStream(new FileOutputStream(dest));\n\n                int read;\n\n                while (true) {\n                    read = input.read(buffer);\n                    if (read < 0) {\n                        break;\n                    } else {\n                        output.write(buffer, 0, read);\n                    }\n\n                    // Update the per file checksum\n                    if(fileCheckSumGenerator != null) {\n                        fileCheckSumGenerator.update(buffer, 0, read);\n                    }\n\n                    stats.recordBytesWritten(read);\n                    totalBytesRead += read;\n                    boolean reportIntervalPassed = stats.getBytesTransferredSinceLastReport() > fetcher.getReportingIntervalBytes();\n                    if (attempt != previousAttempt || reportIntervalPassed) {\n                        previousAttempt = attempt;\n                        NumberFormat format = NumberFormat.getNumberInstance();\n                        format.setMaximumFractionDigits(2);\n                        String message = stats.getTotalBytesTransferred() / (1024 * 1024) + \" MB copied at \"\n                                + format.format(stats.getBytesTransferredPerSecond() / (1024 * 1024)) + \" MB/sec\"\n                                + \", \" + format.format(stats.getPercentCopied()) + \" % complete\"\n                                + \", attempt: #\" + attempt + \"/\" + fetcher.getMaxAttempts()\n                                + \", current file: \" + dest.getName();\n                        if (this.status == null) {\n                            // This is to accommodate tests and the old ReadOnlyStoreManagementServlet code path\n                            // FIXME: Delete this when we get rid of the old code which does not use status\n                            logger.info(message);\n                        } else {\n                            this.status.setStatus(message);\n                            // status.toString() is more detailed than just the message. We print the whole\n                            // thing so that server-side logs are very similar to client (BnP) -side logs.\n                            logger.info(this.status.toString());\n                        }\n\n                        if (reportIntervalPassed) {\n                            stats.reset();\n                        }\n                    }\n                }\n                if(fileCheckSumGenerator != null) {\n                    checkSum = fileCheckSumGenerator.getCheckSum();\n                }\n                stats.reportFileDownloaded(dest,\n                                           startTimeMS,\n                                           source.getSize(),\n                                           System.currentTimeMillis() - startTimeMS,\n                                           attempt,\n                                           totalBytesRead,\n                                           checkSum);\n                logger.info(\"Completed copy of \" + source + \" to \" + dest);\n                success = true;\n            } catch (IOException e) {\n                if(!fsOpened) {\n                    logger.error(\"Error while opening the file stream to \" + source, e);\n                } else {\n                    logger.error(\"Error while copying file \" + source + \" after \" + totalBytesRead + \" bytes.\", e);\n                }\n                if(e.getCause() != null) {\n                    logger.error(\"Cause of error \", e.getCause());\n                }\n\n                if(attempt < fetcher.getMaxAttempts()) {\n                    logger.info(\"Will retry copying after \" + fetcher.getRetryDelayMs() + \" ms\");\n                    sleepForRetryDelayMs();\n                } else {\n                    stats.reportFileError(dest, fetcher.getMaxAttempts(), startTimeMS, e);\n                    logger.info(\"Fetcher giving up copy after \" + fetcher.getMaxAttempts() + \" attempts\");\n                    throw e;\n                }\n            } finally {\n                IOUtils.closeQuietly(output);\n                IOUtils.closeQuietly(input);\n                if(success) {\n                    break;\n                }\n            }\n        }\n        return checkSum;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2338,
    "type": "Return",
    "comment": "@return the Assignment",
    "code": "public int getAssgn() {\n    return assignment;\n}",
    "label": 1,
    "rec": "@return the Assignment ID"
  },
  {
    "id": 2339,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    protected CacheConfiguration cacheConfiguration(String gridName) throws Exception {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setSwapEnabled(swapEnabled());\n        cfg.setCacheMode(cacheMode());\n        cfg.setAtomicityMode(atomicityMode());\n\n        if (atomicityMode() == ATOMIC && cacheMode() != LOCAL) {\n            assert atomicWriteOrderMode() != null;\n\n            cfg.setAtomicWriteOrderMode(atomicWriteOrderMode());\n        }\n\n        cfg.setWriteSynchronizationMode(writeSynchronization());\n        cfg.setDistributionMode(distributionMode());\n        cfg.setPortableEnabled(portableEnabled());\n\n        cfg.setCacheLoaderFactory(loaderFactory());\n\n        cfg.setCacheWriterFactory(writerFactory());\n\n        CacheStore<?, ?> store = cacheStore();\n\n        if (store != null) {\n            cfg.setCacheStoreFactory(new FactoryBuilder.SingletonFactory(store));\n\n            cfg.setReadThrough(true);\n            cfg.setWriteThrough(true);\n        }\n\n        if (cacheMode() == PARTITIONED)\n            cfg.setBackups(1);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2340,
    "type": "Return",
    "comment": "@return the parsed metadata entry or null if not defined",
    "code": "public <T> T get(Key<T> key) {\n    if (containsKey(key)) {\n        MetadataEntry metadataEntry = Iterables.getLast(store.get(key.name()));\n        return metadataEntry.getParsed(key);\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the parsed metadata entry or null if there are none."
  },
  {
    "id": 2341,
    "type": "Return",
    "comment": "@return Service.",
    "code": "    public ManagedService service() {\n        return cfg.getService();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2342,
    "type": "Return",
    "comment": "@return {@link Hashtable} mapping {@link ResultMetadataType} keys to values. May be <code>null</code>. This contains optional metadata about what was detected about the barcode, like orientation.",
    "code": "public Map<ResultMetadataType, Object> getResultMetadata() {\n    return resultMetadata;\n}",
    "label": 1,
    "rec": "@return {@link Map} mapping {@link ResultMetadataType} keys to values. May be {@code null}. This contains optional metadata about what was detected about the barcode, like orientation."
  },
  {
    "id": 2343,
    "type": "Return",
    "comment": "@return the bytes which make up this packet, either the original byte array or the newly written one.",
    "code": "    public byte[] getPacket()\n    {\n        return packet == null ? packet = out.toByteArray() : packet;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2344,
    "type": "Return",
    "comment": "@return  CenterAnimationBuilder instance. Call  com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.CenterAnimationBuilder#start() to start the anim.",
    "code": "    public AnimationBuilder animateCenter(PointF sCenter) {\n        if (!isImageReady()) {\n            return null;\n        }\n        return new AnimationBuilder(sCenter);\n    }\n",
    "label": 1,
    "rec": "@return  AnimationBuilder instance. Call  com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.AnimationBuilder#start() to start the anim."
  },
  {
    "id": 2345,
    "type": "Return",
    "comment": "@return  memberOffsets.get(type).get(member)",
    "code": "    public static int offsetof(Class<? extends Pointer> type, String member) {\n        // Should we synchronize that?\n        HashMap<String,Integer> offsets = memberOffsets.get(type);\n        while (offsets == null && type.getSuperclass() != null) {\n            type = type.getSuperclass().asSubclass(Pointer.class);\n            offsets = memberOffsets.get(type);\n        }\n        return offsets.get(member);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2346,
    "type": "Return",
    "comment": "@returns boolean true if password supplied can decrypt the first private key in the wallet, false otherwise.",
    "code": "    public boolean checkPassword(CharSequence password) {\n        lock.lock();\n        try {\n            if (keyCrypter == null) {\n                // The password cannot decrypt anything as the keyCrypter is null.\n                return false;\n            }\n            return checkAESKey(keyCrypter.deriveKey(checkNotNull(password)));\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 1,
    "rec": "@return boolean true if password supplied can decrypt the first private key in the wallet, false otherwise."
  },
  {
    "id": 2347,
    "type": "Return",
    "comment": "@return text and bytes encoded within the Data Matrix Code",
    "code": "  public DecoderResult decode(BitMatrix bits) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion(bits);\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser.decode(resultBytes);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2348,
    "type": "Return",
    "comment": "@return empty if no EAR components",
    "code": "public static IVirtualComponent[] getEARComponentsFromProject(IProject project) {\n    Vector v = new Vector();\n    try {\n        IFlexibleProject flex = ComponentCore.createFlexibleProject(project);\n        IVirtualComponent[] components = flex.getComponents();\n        for (int i = NUM; i < components.length; i++) {\n            if (isEARComponent(project, components[i].getName())) {\n                v.add(components[i]);\n            }\n        }\n    } catch (Exception e) {\n    }\n    return (IVirtualComponent[]) v.toArray(new IVirtualComponent[NUM]);\n}",
    "label": 1,
    "rec": "@return empty if no EAR components; must not return null"
  },
  {
    "id": 2349,
    "type": "Return",
    "comment": "@return Integer reply, this commands will reply with the new value of key after the increment.",
    "code": "    public Long incr(final String key) {\n        runChecks();\n        client.incr(key);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2350,
    "type": "Return",
    "comment": "@return {@link ICompletionContextResolver}",
    "code": "public static ICompletionStrategyFactory[] getActive() {\n    if (instances == null) {\n        List<ICompletionStrategyFactory> factories = new LinkedList<ICompletionStrategyFactory>();\n        IConfigurationElement[] elements = Platform.getExtensionRegistry().getConfigurationElementsFor(STR);\n        for (IConfigurationElement element : elements) {\n            if (element.getName().equals(STR)) {\n                try {\n                    factories.add((ICompletionStrategyFactory) element.createExecutableExtension(STR));\n                } catch (CoreException e) {\n                    PHPCorePlugin.log(e);\n                }\n            }\n        }\n        factories.add(new CompletionStrategyFactory());\n        instances = (ICompletionStrategyFactory[]) factories.toArray(new ICompletionStrategyFactory[factories.size()]);\n    }\n    return instances;\n}",
    "label": 1,
    "rec": "@return array of active {@link ICompletionContextResolver}'s"
  },
  {
    "id": 2351,
    "type": "Return",
    "comment": "@return Schema.",
    "code": "    private BinarySchema createSchema() {\n        assert fieldIdLen == BinaryUtils.FIELD_ID_LEN;\n\n        BinarySchema.Builder builder = BinarySchema.Builder.newBuilder();\n\n        int searchPos = footerStart;\n        int searchEnd = searchPos + footerLen;\n\n        while (searchPos < searchEnd) {\n            int fieldId = in.readIntPositioned(searchPos);\n\n            builder.addField(fieldId);\n\n            searchPos += BinaryUtils.FIELD_ID_LEN + fieldOffsetLen;\n        }\n\n        return builder.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2352,
    "type": "Return",
    "comment": "@return The context Map to use to pass to a  SubjectFactory for subject creation.",
    "code": "    protected SubjectContext resolveSession(SubjectContext context) {\n        if (context.resolveSession() != null) {\n            log.debug(\"Context already contains a session.  Returning.\");\n            return context;\n        }\n        log.trace(\"No session found in context.  Looking for a session id to resolve in to a session.\");\n        //otherwise try to resolve a session if a session id exists:\n        Serializable sessionId = getSessionId(context);\n        if (sessionId != null) {\n            try {\n                Session session = getSession(sessionId);\n                context.setSession(session);\n            } catch (InvalidSessionException e) {\n                onInvalidSessionId(sessionId, e);\n                log.debug(\"Referenced sessionId {} is invalid.  Ignoring and creating an anonymous \" +\n                        \"(session-less) Subject instance.\", sessionId);\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Exception resulting from invalid referenced sessionId \" + sessionId, e);\n                }\n            }\n        }\n        return context;\n    }\n",
    "label": 1,
    "rec": "@return The context to use to pass to a  SubjectFactory for subject creation."
  },
  {
    "id": 2353,
    "type": "Return",
    "comment": "@return the users",
    "code": "    public ArrayList<ProducteevUser> getUsers() {\n        if (users == null) {\n            return new ArrayList<ProducteevUser>(); // Don't return null\n        }\n        return users;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2354,
    "type": "Return",
    "comment": "@return true iff we have found at least 3 finder patterns that have been detected at least  #CENTER_QUORUM times each",
    "code": "  private boolean haveMulitplyConfirmedCenters() {\n    int confirmedCount = 0;\n    float totalModuleSize = 0.0f;\n    int max = possibleCenters.size();\n    for (int i = 0; i < max; i++) {\n      FinderPattern pattern = (FinderPattern) possibleCenters.elementAt(i);\n      if (pattern.getCount() >= CENTER_QUORUM) {\n        confirmedCount++;\n        totalModuleSize += pattern.getEstimatedModuleSize();\n      }\n    }\n    if (confirmedCount < 3) {\n      return false;\n    }\n    // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n    // and that we need to keep looking. We detect this by asking if the estimated module sizes\n    // vary too much. We arbitrarily say that when the total deviation from average exceeds\n    // 15% of the total module size estimates, it's too much.\n    float average = totalModuleSize / max;\n    float totalDeviation = 0.0f;\n    for (int i = 0; i < max; i++) {\n      FinderPattern pattern = (FinderPattern) possibleCenters.elementAt(i);\n      totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n    }\n    return totalDeviation <= 0.15f * totalModuleSize;\n  }\n",
    "label": 1,
    "rec": "@return true iff we have found at least 3 finder patterns that have been detected at least  #CENTER_QUORUM times each, and, the estimated module size of the candidates is \"pretty similar\""
  },
  {
    "id": 2355,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            IgniteBiTuple<String, String> t = stash.get();\n\n            return IgnitionEx.localIgnite().cachex(t.get2());\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2356,
    "type": "Return",
    "comment": "@return a BytesInput that will read the given bytes from the ByteBuffers",
    "code": "@Deprecated\npublic static BytesInput from(ByteBuffer buffer, int offset, int length) {\n    ByteBuffer tmp = buffer.duplicate();\n    tmp.position(offset);\n    ByteBuffer slice = tmp.slice();\n    slice.limit(length);\n    return new ByteBufferBytesInput(slice);\n}",
    "label": 1,
    "rec": "@return a BytesInput that will read the given bytes from the ByteBuffer"
  },
  {
    "id": 2357,
    "type": "Return",
    "comment": "@return the Subject instance that represents the user and session data for the newly authenticated user.",
    "code": "    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\n        return getSubjectFactory().createSubject(token, info, getSubject(false));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2358,
    "type": "Return",
    "comment": "@return The new {@link MockitoGenericMetadata}.",
    "code": "public static GenericMetadataSupport from(Type type) {\n    Checks.checkNotNull(type, STR);\n    if (type instanceof Class) {\n        return new FromClassGenericMetadataSupport((Class<?>) type);\n    }\n    if (type instanceof ParameterizedType) {\n        return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n    }\n    throw new MockitoException(STR + type.getClass().getCanonicalName() + STR + type);\n}",
    "label": 1,
    "rec": "@return The new {@link GenericMetadataSupport}."
  },
  {
    "id": 2359,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static short and(short first, short second) {\n        return LastArguments.instance().reportAnd(2).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2360,
    "type": "Return",
    "comment": "@return newly created factory of type ConfigurableDefinitionsFactory.",
    "code": "public static DefinitionsFactory createDefinitionsFactory(DefinitionsFactoryConfig factoryConfig) throws DefinitionsFactoryException {\n    return tilesUtilImpl.createDefinitionsFactory(factoryConfig);\n}",
    "label": 1,
    "rec": "@return newly created impl of type ConfigurableDefinitionsFactory."
  },
  {
    "id": 2361,
    "type": "Return",
    "comment": "@return A PlanarYUVLuminanceSource instance.",
    "code": "  public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {\n    Rect rect = getFramingRectInPreview();\n    if (rect == null) {\n      return null;\n    }\n    // Go ahead and assume it's YUV rather than die.\n    return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n                                        rect.width(), rect.height(), false);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2362,
    "type": "Return",
    "comment": "@return new {@code GcpKmsAeadKey} proto",
    "code": "@Override\npublic MessageLite newKey(ByteString serializedKeyFormat) throws GeneralSecurityException {\n    try {\n        KmsAeadKeyFormat format = KmsAeadKeyFormat.parseFrom(serializedKeyFormat);\n        return newKey(format);\n    } catch (InvalidProtocolBufferException e) {\n        throw new GeneralSecurityException(STR, e);\n    }\n}",
    "label": 1,
    "rec": "@return new {@code KmsAeadKey} proto"
  },
  {
    "id": 2363,
    "type": "Return",
    "comment": "@return a Aead primitive from a  keysetHandle and a custom  keyManager.",
    "code": "      public byte[] encrypt(final byte[] plaintext, final byte[] aad)\n          throws GeneralSecurityException {\n        return SubtleUtil.concat(\n            primitives.getPrimary().getIdentifier(),\n            primitives.getPrimary().getPrimitive().encrypt(plaintext, aad));\n      }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2364,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private Frame reBalance(final Frame fr, long seed, boolean local) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 2365,
    "type": "Return",
    "comment": "@return Non-system caches.",
    "code": "    private Collection<GridCacheConfiguration> caches(Ignite g) {\n        return F.view(Arrays.asList(g.configuration().getCacheConfiguration()), new IgnitePredicate<GridCacheConfiguration>() {\n            @Override public boolean apply(GridCacheConfiguration c) {\n                return c.getName() == null || !c.getName().equals(CU.UTILITY_CACHE_NAME);\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2366,
    "type": "Return",
    "comment": "@return converted HTML, returns {@code null} if the specified markdown text is \"\" or {@code null}, returns \"Markdown error\" if exception",
    "code": "public static String toHTML(final String markdownText) {\n    if (Strings.isEmptyOrNull(markdownText)) {\n        return STR;\n    }\n    final ExecutorService pool = Executors.newSingleThreadExecutor();\n    final long[] threadId = new long[NUM];\n    final Callable<String> call = () -> {\n        threadId[NUM] = Thread.currentThread().getId();\n        String html = LANG_PROPS_SERVICE.get(STR);\n        if (MARKED_AVAILABLE) {\n            html = toHtmlByMarked(markdownText);\n            if (!StringUtils.startsWith(html, STR)) {\n                html = STR + html + STR;\n            }\n        } else {\n            com.vladsch.flexmark.ast.Node document = PARSER.parse(markdownText);\n            html = RENDERER.render(document);\n            if (!StringUtils.startsWith(html, STR)) {\n                html = STR + html + STR;\n            }\n            html = formatMarkdown(html);\n        }\n        return html;\n    };\n    Stopwatchs.start(STR);\n    try {\n        final Future<String> future = pool.submit(call);\n        return future.get(MD_TIMEOUT, TimeUnit.MILLISECONDS);\n    } catch (final TimeoutException e) {\n        LOGGER.log(Level.ERROR, STR + markdownText + STR);\n        Callstacks.printCallstack(Level.ERROR, new String[] { STR }, null);\n        final Set<Thread> threads = Thread.getAllStackTraces().keySet();\n        for (final Thread thread : threads) {\n            if (thread.getId() == threadId[NUM]) {\n                thread.stop();\n                break;\n            }\n        }\n    } catch (final Exception e) {\n        LOGGER.log(Level.ERROR, STR + markdownText + STR, e);\n    } finally {\n        pool.shutdownNow();\n        Stopwatchs.end();\n    }\n    return LANG_PROPS_SERVICE.get(STR);\n}",
    "label": 1,
    "rec": "@return converted HTML, returns an empty string \"\" if the specified markdown text is \"\" or {@code null}, returns 'markdownErrorLabel' if exception"
  },
  {
    "id": 2367,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    @Nullable @Override public CacheObject unswap(boolean needVal)\n        throws IgniteCheckedException, GridCacheEntryRemovedException {\n        boolean swapEnabled = cctx.swap().swapEnabled();\n\n        if (!swapEnabled && !cctx.isOffHeapEnabled())\n            return null;\n\n        synchronized (this) {\n            checkObsolete();\n\n            if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {\n                GridCacheSwapEntry e;\n\n                if (cctx.offheapTiered()) {\n                    e = cctx.swap().readOffheapPointer(this);\n\n                    if (e != null) {\n                        if (e.offheapPointer() > 0) {\n                            offHeapPointer(e.offheapPointer());\n\n                            flags |= IS_OFFHEAP_PTR_MASK;\n\n                            if (needVal) {\n                                CacheObject val = cctx.fromOffheap(offHeapPointer(), false);\n\n                                e.value(val);\n                            }\n                        }\n                        else // Read from swap.\n                            offHeapPointer(0);\n                    }\n                }\n                else\n                    e = detached() ? cctx.swap().read(this, true, true, true, false) : cctx.swap().readAndRemove(this);\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Read swap entry [swapEntry=\" + e + \", cacheEntry=\" + this + ']');\n\n                flags |= IS_UNSWAPPED_MASK;\n\n                // If there is a value.\n                if (e != null) {\n                    long delta = e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis();\n\n                    if (delta >= 0) {\n                        CacheObject val = e.value();\n\n                        val = cctx.kernalContext().cacheObjects().prepareForCache(val, cctx);\n\n                        // Set unswapped value.\n                        update(val, e.expireTime(), e.ttl(), e.version(), false);\n\n                        // Must update valPtr again since update() will reset it.\n                        if (cctx.offheapTiered() && e.offheapPointer() > 0)\n                            offHeapPointer(e.offheapPointer());\n\n                        return val;\n                    }\n                    else\n                        clearIndex(e.value());\n                }\n            }\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2368,
    "type": "Return",
    "comment": "@return {@link Controller},",
    "code": "public NavigationController build() {\n    if (items.size() == NUM) {\n        return null;\n    }\n    if (defaultColor != NUM) {\n        for (MaterialItemView v : items) {\n            v.setColor(defaultColor);\n        }\n    }\n    MaterialItemLayout materialItemLayout = new MaterialItemLayout(getContext());\n    materialItemLayout.initialize(items, mode);\n    materialItemLayout.setPadding(NUM, mTabPaddingTop, NUM, mTabPaddingBottom);\n    PageBottomTabLayout.this.removeAllViews();\n    PageBottomTabLayout.this.addView(materialItemLayout);\n    return materialItemLayout;\n}",
    "label": 1,
    "rec": "@return {@link NavigationController},"
  },
  {
    "id": 2369,
    "type": "Return",
    "comment": "@return Event predicate.",
    "code": "    public static GridPredicate<GridEvent> eventNode(@Nullable final Collection<? extends GridNode> nodes) {\n        return isEmpty(nodes) ? F.<GridEvent>alwaysFalse() : new GridPredicate<GridEvent>() {\n            @Override public boolean apply(GridEvent e) {\n                assert e != null;\n\n                return !forAll(nodes, not(nodeForNodeId(e.nodeId())));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2370,
    "type": "Return",
    "comment": "@return The current IconExtDrawable for chaining.",
    "code": "public IconicsDrawable iconText(String icon) {\n    return iconText(icon, null);\n}",
    "label": 1,
    "rec": "@return The current IconicsDrawable for chaining."
  },
  {
    "id": 2371,
    "type": "Return",
    "comment": "@return Affinity-ready topology version.",
    "code": "    public AffinityTopologyVersion affinityTopologyVersion() {\n        return aff.lastVersion();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2372,
    "type": "Return",
    "comment": "@return The parameter name after it is modified in case it was in \" <code>arg0</code>\" format.",
    "code": "private String getParameterName(final String parameterName) {\n    final String name = parameterName.length() <= NUM && parameterName.startsWith(STR) ? STR : parameterName;\n    if (argumentCounter.containsKey(name)) {\n        final Integer counter = argumentCounter.get(name);\n        argumentCounter.put(name, counter + NUM);\n        return String.format(STR, name, counter + NUM);\n    } else {\n        argumentCounter.put(name, NUM);\n    }\n    return name;\n}",
    "label": 1,
    "rec": "@return The unique parameter name, i.e. if there already has been a name \"button\" in the current template, the new parameter name will be \"button2\"."
  },
  {
    "id": 2373,
    "type": "Return",
    "comment": "@return K",
    "code": "    private Observable<R> getFallbackOrThrowException(final AbstractCommand<R> _cmd, final HystrixEventType eventType, final FailureType failureType, final String message, final Exception originalException) {\n        final HystrixRequestContext requestContext = HystrixRequestContext.getContextForCurrentThread();\n        long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n        // record the executionResult\n        // do this before executing fallback so it can be queried from within getFallback (see See https://github.com/Netflix/Hystrix/pull/144)\n        executionResult = executionResult.addEvent((int) latency, eventType);\n\n        if (isUnrecoverable(originalException)) {\n            logger.error(\"Unrecoverable Error for HystrixCommand so will throw HystrixRuntimeException and not apply fallback. \", originalException);\n\n            /* executionHook for all errors */\n            Exception e = wrapWithOnErrorHook(failureType, originalException);\n            return Observable.error(new HystrixRuntimeException(failureType, this.getClass(), getLogMessagePrefix() + \" \" + message + \" and encountered unrecoverable error.\", e, null));\n        } else {\n            if (isRecoverableError(originalException)) {\n                logger.warn(\"Recovered from java.lang.Error by serving Hystrix fallback\", originalException);\n            }\n\n            if (properties.fallbackEnabled().get()) {\n                /* fallback behavior is permitted so attempt */\n\n                final Action1<Notification<? super R>> setRequestContext = new Action1<Notification<? super R>>() {\n                    @Override\n                    public void call(Notification<? super R> rNotification) {\n                        setRequestContextIfNeeded(requestContext);\n                    }\n                };\n\n                final Action1<R> markFallbackEmit = new Action1<R>() {\n                    @Override\n                    public void call(R r) {\n                        if (shouldOutputOnNextEvents()) {\n                            executionResult = executionResult.addEvent(HystrixEventType.FALLBACK_EMIT);\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_EMIT, commandKey);\n                        }\n                    }\n                };\n\n                final Action0 markFallbackCompleted = new Action0() {\n                    @Override\n                    public void call() {\n                        long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n                        eventNotifier.markEvent(HystrixEventType.FALLBACK_SUCCESS, commandKey);\n                        executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_SUCCESS);\n                    }\n                };\n\n                final Func1<Throwable, Observable<R>> handleFallbackError = new Func1<Throwable, Observable<R>>() {\n                    @Override\n                    public Observable<R> call(Throwable t) {\n                        /* executionHook for all errors */\n                        Exception e = wrapWithOnErrorHook(failureType, originalException);\n                        Exception fe = getExceptionFromThrowable(t);\n\n                        long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n                        Exception toEmit;\n\n                        if (fe instanceof UnsupportedOperationException) {\n                            logger.debug(\"No fallback for HystrixCommand. \", fe); // debug only since we're throwing the exception and someone higher will do something with it\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_MISSING, commandKey);\n                            executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_MISSING);\n\n                            toEmit = new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and no fallback available.\", e, fe);\n                        } else {\n                            logger.debug(\"HystrixCommand execution \" + failureType.name() + \" and fallback failed.\", fe);\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_FAILURE, commandKey);\n                            executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_FAILURE);\n\n                            toEmit = new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback failed.\", e, fe);\n                        }\n\n                        // NOTE: we're suppressing fallback exception here\n                        if (shouldNotBeWrapped(originalException)) {\n                            return Observable.error(e);\n                        }\n\n                        return Observable.error(toEmit);\n                    }\n                };\n\n                final TryableSemaphore fallbackSemaphore = getFallbackSemaphore();\n                final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false);\n                final Action0 singleSemaphoreRelease = new Action0() {\n                    @Override\n                    public void call() {\n                        if (semaphoreHasBeenReleased.compareAndSet(false, true)) {\n                            fallbackSemaphore.release();\n                        }\n                    }\n                };\n\n                Observable<R> fallbackExecutionChain;\n\n                // acquire a permit\n                if (fallbackSemaphore.tryAcquire()) {\n                    try {\n                        if (isFallbackUserDefined()) {\n                            executionHook.onFallbackStart(this);\n                            fallbackExecutionChain = getFallbackObservable();\n                        } else {\n                            //same logic as above without the hook invocation\n                            fallbackExecutionChain = getFallbackObservable();\n                        }\n                    } catch (Throwable ex) {\n                        //If hook or user-fallback throws, then use that as the result of the fallback lookup\n                        fallbackExecutionChain = Observable.error(ex);\n                    }\n\n                    return fallbackExecutionChain\n                            .doOnEach(setRequestContext)\n                            .lift(new FallbackHookApplication(_cmd))\n                            .lift(new DeprecatedOnFallbackHookApplication(_cmd))\n                            .doOnNext(markFallbackEmit)\n                            .doOnCompleted(markFallbackCompleted)\n                            .onErrorResumeNext(handleFallbackError)\n                            .doOnTerminate(singleSemaphoreRelease)\n                            .doOnUnsubscribe(singleSemaphoreRelease);\n                } else {\n                   return handleFallbackRejectionByEmittingError();\n                }\n            } else {\n                return handleFallbackDisabledByEmittingError(originalException, failureType, message);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2374,
    "type": "Return",
    "comment": "@return Returns the speed.",
    "code": "public int getSpeed() {\n    return speedXY;\n}",
    "label": 1,
    "rec": "@return Returns the speed for the X & Y axes."
  },
  {
    "id": 2375,
    "type": "Return",
    "comment": "@return Offset within the page in bytes.",
    "code": "    public static int bytesOffset(long link) {\n        return (int)((link >> (PAGE_IDX_SIZE + FILE_ID_SIZE)) & OFFSET_MASK) << 3;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2376,
    "type": "Return",
    "comment": "@return empty array if no web components",
    "code": "public static IVirtualComponent[] getWebComponents(IProject project) {\n    Vector v = new Vector();\n    try {\n        IFlexibleProject flex = ComponentCore.createFlexibleProject(project);\n        IVirtualComponent[] components = flex.getComponents();\n        for (int i = NUM; i < components.length; i++) {\n            if (isWebComponent(project, components[i].getName())) {\n                v.add(components[i]);\n            }\n        }\n    } catch (Exception e) {\n    }\n    return (IVirtualComponent[]) v.toArray(new IVirtualComponent[NUM]);\n}",
    "label": 1,
    "rec": "@return empty array if no web components; must not return null"
  },
  {
    "id": 2377,
    "type": "Return",
    "comment": "@return true if the given object is a  Attributes equal attributes.",
    "code": "  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Attributes that = (Attributes) o;\n    if (data.size() != that.data.size()) {\n      return false;\n    }\n    for (Entry<Key<?>, Object> e : data.entrySet()) {\n      if (!that.data.containsKey(e.getKey())) {\n        return false;\n      }\n      if (!Objects.equal(e.getValue(), that.data.get(e.getKey()))) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2378,
    "type": "Return",
    "comment": "@return Frame that has potentially more chunks",
    "code": "  private Frame reBalance(final Frame fr, long seed, boolean local) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 1,
    "rec": "@return Frame that has potentially more chunks and might be shuffled (if shuffle_training_data is set)"
  },
  {
    "id": 2379,
    "type": "Return",
    "comment": "@return listenable",
    "code": "    public Listenable<SharedValueListener> getListenable()\n    {\n        return listeners;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2380,
    "type": "Return",
    "comment": "@return Query.",
    "code": "    private static Set<String> collectAllSpaces(GridSqlQuery qry, Set<String> spaces) {\n        if (qry instanceof GridSqlUnion) {\n            GridSqlUnion union = (GridSqlUnion)qry;\n\n            collectAllSpaces(union.left(), spaces);\n            collectAllSpaces(union.right(), spaces);\n        }\n        else\n            collectAllSpacesInFrom(((GridSqlSelect)qry).from(), spaces);\n\n        return spaces;\n    }\n",
    "label": 1,
    "rec": "@return Space names."
  },
  {
    "id": 2381,
    "type": "Return",
    "comment": "@return  True if this node is a data node for given cache.",
    "code": "        public boolean dataNode(ClusterNode node) {\n            return !node.isDaemon() && activated(node.id()) && CU.affinityNode(node, cacheFilter);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2382,
    "type": "Return",
    "comment": "@return This dependency for chaining, never {@code null}.",
    "code": "public Dependency setArtifact(Artifact artifact) {\n    if (this.artifact.equals(artifact)) {\n        return this;\n    }\n    return new Dependency(artifact, scope, optional, exclusions);\n}",
    "label": 1,
    "rec": "@return The new dependency, never {@code null}."
  },
  {
    "id": 2383,
    "type": "Return",
    "comment": "@return ID of the remote node if node alive.",
    "code": "    private UUID pingNode(InetSocketAddress addr) throws GridException {\n        assert addr != null;\n\n        if (F.contains(locNodeAddrs, addr))\n            return locNodeId;\n\n        GridFutureAdapterEx<UUID> fut = new GridFutureAdapterEx<>();\n\n        GridFuture<UUID> oldFut = pingMap.putIfAbsent(addr, fut);\n\n        if (oldFut != null)\n            return oldFut.get();\n        else {\n            Collection<Throwable> errs = null;\n\n            try {\n                Socket sock = null;\n\n                for (int i = 0; i < reconCnt; i++) {\n                    try {\n                        if (addr.isUnresolved())\n                            addr = new InetSocketAddress(InetAddress.getByName(addr.getHostName()), addr.getPort());\n\n                        long tstamp = U.currentTimeMillis();\n\n                        sock = openSocket(addr);\n\n                        // Handshake response will act as ping response.\n                        writeToSocket(sock, new GridTcpDiscoveryHandshakeRequest(locNodeId));\n\n                        GridTcpDiscoveryHandshakeResponse res = readMessage(sock, null, netTimeout);\n\n                        if (locNodeId.equals(res.creatorNodeId())) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"Handshake response from local node: \" + res);\n\n                            break;\n                        }\n\n                        stats.onClientSocketInitialized(U.currentTimeMillis() - tstamp);\n\n                        fut.onDone(res.creatorNodeId());\n\n                        return res.creatorNodeId();\n                    }\n                    catch (IOException | GridException e) {\n                        if (errs == null)\n                            errs = new ArrayList<>();\n\n                        errs.add(e);\n                    }\n                    finally {\n                        U.closeQuiet(sock);\n                    }\n                }\n            }\n            catch (Throwable t) {\n                fut.onDone(t);\n\n                throw U.cast(t);\n            }\n            finally {\n                if (!fut.isDone())\n                    fut.onDone(U.exceptionWithSuppressed(\"Failed to ping node by address: \" + addr, errs));\n\n                boolean b = pingMap.remove(addr, fut);\n\n                assert b;\n            }\n\n            return fut.get();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2384,
    "type": "Return",
    "comment": "@return whether we sent to at least one peer",
    "code": "public Future<Transaction> broadcastTransaction(final Transaction tx) {\n    FutureTask<Transaction> future = new FutureTask<Transaction>(new Runnable() {\n\n        public void run() {\n            for (Peer peer : peers) {\n                try {\n                    peer.sendMessage(tx);\n                } catch (IOException e) {\n                    log.warn(STR, e.getMessage());\n                }\n            }\n        }\n    }, tx);\n    peerGroupThread.addTask(future);\n    return future;\n}",
    "label": 1,
    "rec": "@return a Future that can be used to wait for the async broadcast to complete."
  },
  {
    "id": 2385,
    "type": "Return",
    "comment": "@return Parsed expression.",
    "code": "    private GridSqlElement parseExpression0(Expression expression, boolean calcTypes) {\n        if (expression instanceof ExpressionColumn) {\n            ExpressionColumn expCol = (ExpressionColumn)expression;\n\n            return new GridSqlColumn(expCol.getColumn(),\n                parseTable(expCol.getTableFilter()),\n                expression.getColumnName(),\n                expression.getSQL());\n        }\n\n        if (expression instanceof Alias)\n            return new GridSqlAlias(expression.getAlias(),\n                parseExpression(expression.getNonAliasExpression(), calcTypes), true);\n\n        if (expression instanceof ValueExpression)\n            return new GridSqlConst(expression.getValue(null));\n\n        if (expression instanceof Operation) {\n            Operation operation = (Operation)expression;\n\n            Integer type = OPERATION_TYPE.get(operation);\n\n            if (type == Operation.NEGATE) {\n                assert OPERATION_RIGHT.get(operation) == null;\n\n                return new GridSqlOperation(GridSqlOperationType.NEGATE,\n                    parseExpression(OPERATION_LEFT.get(operation), calcTypes));\n            }\n\n            return new GridSqlOperation(OPERATION_OP_TYPES[type],\n                parseExpression(OPERATION_LEFT.get(operation), calcTypes),\n                parseExpression(OPERATION_RIGHT.get(operation), calcTypes));\n        }\n\n        if (expression instanceof Comparison) {\n            Comparison cmp = (Comparison)expression;\n\n            GridSqlOperationType opType = COMPARISON_TYPES[COMPARISON_TYPE.get(cmp)];\n\n            assert opType != null : COMPARISON_TYPE.get(cmp);\n\n            Expression leftExp = COMPARISON_LEFT.get(cmp);\n            GridSqlElement left = parseExpression(leftExp, calcTypes);\n\n            if (opType.childrenCount() == 1)\n                return new GridSqlOperation(opType, left);\n\n            Expression rightExp = COMPARISON_RIGHT.get(cmp);\n            GridSqlElement right = parseExpression(rightExp, calcTypes);\n\n            return new GridSqlOperation(opType, left, right);\n        }\n\n        if (expression instanceof ConditionNot)\n            return new GridSqlOperation(NOT, parseExpression(expression.getNotIfPossible(null), calcTypes));\n\n        if (expression instanceof ConditionAndOr) {\n            ConditionAndOr andOr = (ConditionAndOr)expression;\n\n            int type = ANDOR_TYPE.get(andOr);\n\n            assert type == ConditionAndOr.AND || type == ConditionAndOr.OR;\n\n            return new GridSqlOperation(type == ConditionAndOr.AND ? AND : OR,\n                parseExpression(ANDOR_LEFT.get(andOr), calcTypes), parseExpression(ANDOR_RIGHT.get(andOr), calcTypes));\n        }\n\n        if (expression instanceof Subquery) {\n            Query qry = ((Subquery)expression).getQuery();\n\n            assert0(qry instanceof Select, expression);\n\n            return new GridSqlSubquery(parse((Select)qry));\n        }\n\n        if (expression instanceof ConditionIn) {\n            GridSqlOperation res = new GridSqlOperation(IN);\n\n            res.addChild(parseExpression(LEFT_CI.get((ConditionIn)expression), calcTypes));\n\n            List<Expression> vals = VALUE_LIST_CI.get((ConditionIn)expression);\n\n            for (Expression val : vals)\n                res.addChild(parseExpression(val, calcTypes));\n\n            return res;\n        }\n\n        if (expression instanceof ConditionInConstantSet) {\n            GridSqlOperation res = new GridSqlOperation(IN);\n\n            res.addChild(parseExpression(LEFT_CICS.get((ConditionInConstantSet)expression), calcTypes));\n\n            List<Expression> vals = VALUE_LIST_CICS.get((ConditionInConstantSet)expression);\n\n            for (Expression val : vals)\n                res.addChild(parseExpression(val, calcTypes));\n\n            return res;\n        }\n\n        if (expression instanceof ConditionInSelect) {\n            GridSqlOperation res = new GridSqlOperation(IN);\n\n            boolean all = ALL.get((ConditionInSelect)expression);\n            int compareType = COMPARE_TYPE.get((ConditionInSelect)expression);\n\n            assert0(!all, expression);\n            assert0(compareType == Comparison.EQUAL, expression);\n\n            res.addChild(parseExpression(LEFT_CIS.get((ConditionInSelect)expression), calcTypes));\n\n            Query qry = QUERY.get((ConditionInSelect)expression);\n\n            assert0(qry instanceof Select, qry);\n\n            res.addChild(new GridSqlSubquery(parse((Select)qry)));\n\n            return res;\n        }\n\n        if (expression instanceof CompareLike) {\n            assert0(ESCAPE.get((CompareLike)expression) == null, expression);\n\n            boolean regexp = REGEXP_CL.get((CompareLike)expression);\n\n            return new GridSqlOperation(regexp ? REGEXP : LIKE,\n                parseExpression(LEFT.get((CompareLike)expression), calcTypes),\n                parseExpression(RIGHT.get((CompareLike)expression), calcTypes));\n        }\n\n        if (expression instanceof Function) {\n            Function f = (Function)expression;\n\n            GridSqlFunction res = new GridSqlFunction(null, f.getName());\n\n            if (f.getArgs() != null) {\n                if (f.getFunctionType() == Function.TABLE || f.getFunctionType() == Function.TABLE_DISTINCT) {\n                    Column[] cols = FUNC_TBL_COLS.get((TableFunction)f);\n                    Expression[] args = f.getArgs();\n\n                    assert cols.length == args.length;\n\n                    for (int i = 0; i < cols.length; i++) {\n                        GridSqlElement arg = parseExpression(args[i], calcTypes);\n\n                        GridSqlAlias alias = new GridSqlAlias(cols[i].getName(), arg, false);\n\n                        alias.resultType(fromColumn(cols[i]));\n\n                        res.addChild(alias);\n                    }\n                }\n                else {\n                    for (Expression arg : f.getArgs()) {\n                        if (arg == null) {\n                            if (f.getFunctionType() != Function.CASE)\n                                throw new IllegalStateException(\"Function type with null arg: \" + f.getFunctionType());\n\n                            res.addChild(GridSqlPlaceholder.EMPTY);\n                        }\n                        else\n                            res.addChild(parseExpression(arg, calcTypes));\n                    }\n                }\n            }\n\n            if (f.getFunctionType() == Function.CAST || f.getFunctionType() == Function.CONVERT)\n                res.resultType(fromExpression(f));\n\n            return res;\n        }\n\n        if (expression instanceof JavaFunction) {\n            JavaFunction f = (JavaFunction)expression;\n\n            FunctionAlias alias = FUNC_ALIAS.get(f);\n\n            GridSqlFunction res = new GridSqlFunction(alias.getSchema().getName(), f.getName());\n\n            if (f.getArgs() != null) {\n                for (Expression arg : f.getArgs())\n                    res.addChild(parseExpression(arg, calcTypes));\n            }\n\n            return res;\n        }\n\n        if (expression instanceof Parameter)\n            return new GridSqlParameter(((Parameter)expression).getIndex());\n\n        if (expression instanceof Aggregate) {\n            int typeId = TYPE.get((Aggregate)expression);\n\n            if (GridSqlAggregateFunction.isValidType(typeId)) {\n                GridSqlAggregateFunction res = new GridSqlAggregateFunction(DISTINCT.get((Aggregate)expression), typeId);\n\n                Expression on = ON.get((Aggregate)expression);\n\n                if (on != null)\n                    res.addChild(parseExpression(on, calcTypes));\n\n                return res;\n            }\n        }\n\n        if (expression instanceof ExpressionList) {\n            Expression[] exprs = EXPR_LIST.get((ExpressionList)expression);\n\n            GridSqlArray res = new GridSqlArray(exprs.length);\n\n            for (Expression expr : exprs)\n                res.addChild(parseExpression(expr, calcTypes));\n\n            return res;\n        }\n\n        throw new IgniteException(\"Unsupported expression: \" + expression + \" [type=\" +\n            expression.getClass().getSimpleName() + ']');\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2386,
    "type": "Return",
    "comment": "@return the {@link org.apache.tez.runtime.api.TezInputContext} for the input",
    "code": "public final InputContext getContext() {\n    return inputContext;\n}",
    "label": 1,
    "rec": "@return the {@link org.apache.tez.runtime.api.InputContext} for the input"
  },
  {
    "id": 2387,
    "type": "Return",
    "comment": "@return null if never sync'd",
    "code": "    public TodorooCursor<Task> getLocallyUpdated(Property<?>[] properties) {\n        long lastSyncDate = Utilities.getLastSyncDate();\n        if(lastSyncDate == 0)\n            return taskDao.query(Query.select(Task.ID).where(Criterion.none));\n        return\n            taskDao.query(Query.select(properties).join(METADATA_JOIN).\n                    where(Criterion.and(MetadataCriteria.withKey(METADATA_KEY),\n                            Task.MODIFICATION_DATE.gt(lastSyncDate))));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2388,
    "type": "Return",
    "comment": "@return PullToRefreshAttacher linked with this view.",
    "code": "    public static PullToRefreshAttacher getAttacher(Activity activity, int viewId) {\n        PullToRefreshLayout layout = (PullToRefreshLayout) activity.findViewById(viewId);\n        if (layout != null) {\n            return layout.getAttacher();\n        }\n        return null;\n    }\n",
    "label": 1,
    "rec": "@return The PullToRefreshAttacher linked with the  PullToRefreshLayout found with the id given at viewId"
  },
  {
    "id": 2389,
    "type": "Return",
    "comment": "@return true the current xml entry is a way entry and has nodes",
    "code": "    boolean filterWay( OSMWay item )\n    {\n        // ignore broken geometry\n        if (item.getNodes().size() < 2)\n            return false;\n\n        // ignore multipolygon geometry\n        if (!item.hasTags())\n            return false;\n\n        return encodingManager.acceptWay(item) > 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2390,
    "type": "Return",
    "comment": "@return the SentryScheduler instance",
    "code": "public static Sentry getInstance() {\n    if (instance == null) {\n        synchronized (lock) {\n            if (instance == null) {\n                instance = new Sentry();\n            }\n        }\n    }\n    return instance;\n}",
    "label": 1,
    "rec": "@return the Sentry instance"
  },
  {
    "id": 2391,
    "type": "Return",
    "comment": "@return a  KeyFormat for  keyType and  keyFormat. For example, createKeyFormat(\"AesGcm\", \"key_size: 32\") would return a  KeyFormat of 256-bit AesGcm.",
    "code": "  public static KeyFormat createKeyFormat(String keyType, String keyFormat)\n      throws Exception {\n    // To parse {@code keyFormat}, we need to find the corresponding proto class.\n    String keyFormatName = keyType + KEY_FORMAT_SUFFIX;\n    Class<?> keyFormatClass = loadClass(keyFormatName);\n    if (keyFormatClass == null) {\n      throw new IllegalArgumentException(\"Cannot find key type \" + keyType);\n    }\n    Builder builder = getBuilder(keyFormatClass);\n    TextFormat.merge(keyFormat, builder);\n\n    return createKeyFormat(getTypeUrl(keyType), builder.build().toByteString());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2392,
    "type": "Return",
    "comment": "@return A new {@link ModelClass}",
    "code": "public TModel loadFromCursor(Cursor cursor) {\n    TModel model = newInstance();\n    loadFromCursor(cursor, model);\n    return model;\n}",
    "label": 1,
    "rec": "@return A new {@link TModel}"
  },
  {
    "id": 2393,
    "type": "Return",
    "comment": "@return Event predicate.",
    "code": "    public static IgnitePredicate<GridEvent> eventType(@Nullable final int... types) {\n        return isEmpty(types) ? F.<GridEvent>alwaysFalse() : new IgnitePredicate<GridEvent>() {\n            @Override public boolean apply(GridEvent e) {\n                assert e != null;\n\n                assert types != null;\n\n                for (int t : types) {\n                    if (e.type() == t)\n                        return true;\n                }\n\n                return false;\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2394,
    "type": "Return",
    "comment": "@return The {@link InetAddress} used for active data connections",
    "code": "public String getActiveLocalAddress() {\n    return activeLocalAddress;\n}",
    "label": 1,
    "rec": "@return The address used for active data connections"
  },
  {
    "id": 2395,
    "type": "Return",
    "comment": "@return the estimated error.",
    "code": "    public static double solve(Matrix A, double[] b, double[] x, double tol) {\n        return solve(A, diagonalPreconditioner(A), b, x, tol);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2396,
    "type": "Return",
    "comment": "@return channel selector of this output gate",
    "code": "public ChannelSelector<T> getChannelSelector() {\n    return this.channelSelector;\n}",
    "label": 1,
    "rec": "@return the output gate's channel selector or <code>null</code> if the gate operates in broadcast mode"
  },
  {
    "id": 2397,
    "type": "Return",
    "comment": "@return Reader.",
    "code": "    private BinaryReaderExImpl reader(@Nullable BinaryReaderHandles rCtx) {\n        return new BinaryReaderExImpl(ctx,\n            BinaryHeapInputStream.create(arr, start),\n            ctx.configuration().getClassLoader(),\n            rCtx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2398,
    "type": "Return",
    "comment": "@return the user's current presence, or <tt>null</tt> if the user is unavailable or if no presence information is available..",
    "code": "public Presence getPresence(String user) {\n    String key = getPresenceMapKey(StringUtils.parseBareAddress(user));\n    Map<String, Presence> userPresences = presenceMap.get(key);\n    if (userPresences == null) {\n        Presence presence = new Presence(Presence.Type.unavailable);\n        presence.setFrom(user);\n        return presence;\n    } else {\n        Presence presence = null;\n        for (String resource : userPresences.keySet()) {\n            Presence p = userPresences.get(resource);\n            if (!p.isAvailable()) {\n                continue;\n            }\n            if (presence == null || p.getPriority() > presence.getPriority()) {\n                presence = p;\n            } else if (p.getPriority() == presence.getPriority()) {\n                Presence.Mode pMode = p.getMode();\n                if (pMode == null) {\n                    pMode = Presence.Mode.available;\n                }\n                Presence.Mode presenceMode = presence.getMode();\n                if (presenceMode == null) {\n                    presenceMode = Presence.Mode.available;\n                }\n                if (pMode.compareTo(presenceMode) < NUM) {\n                    presence = p;\n                }\n            }\n        }\n        if (presence == null) {\n            presence = new Presence(Presence.Type.unavailable);\n            presence.setFrom(user);\n            return presence;\n        } else {\n            return presence;\n        }\n    }\n}",
    "label": 1,
    "rec": "@return the user's current presence, or unavailable presence if the user is offline or if no presence information is available.."
  },
  {
    "id": 2399,
    "type": "Return",
    "comment": "@return the current session type",
    "code": "    public SessionType getSessionType() {\n        return mCameraController.getSessionType();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2400,
    "type": "Return",
    "comment": "@return an unmodifiable view of the specified set",
    "code": "public static <E> Multiset<E> unmodifiableMultiset(Multiset<E> multiset) {\n    return new UnmodifiableMultiset<E>(multiset);\n}",
    "label": 1,
    "rec": "@return an unmodifiable view of the multiset"
  },
  {
    "id": 2401,
    "type": "Return",
    "comment": "@return commit",
    "code": "    public Commit getCommit() {\n        return commit;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2402,
    "type": "Return",
    "comment": "@return the current value",
    "code": "@Override\npublic AtomicValue<T> decrement() throws Exception {\n    return worker(numberHelper().negativeOne());\n}",
    "label": 1,
    "rec": "@return value info"
  },
  {
    "id": 2403,
    "type": "Return",
    "comment": "@return Swap context.",
    "code": "    protected SwapContext context() {\n        return context(null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2404,
    "type": "Return",
    "comment": "@return Writer checked out of a pool of files.",
    "code": "public WriterPoolMember borrowFile() throws IOException {\n    WriterPoolMember writer = null;\n    while (writer == null) {\n        try {\n            writer = availableWriters.poll(maxWait, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n        }\n        if (writer == null) {\n            writer = makeNewWriterIfAppropriate();\n        }\n    }\n    return writer;\n}",
    "label": 1,
    "rec": "@return Writer checked out of a pool of files or created"
  },
  {
    "id": 2405,
    "type": "Return",
    "comment": "@return Permission object",
    "code": "    public static Permission loadPermission(String name, Map<String, Object> data) {\n        return loadPermission(name, data, DEFAULT_PERMISSION, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2406,
    "type": "Return",
    "comment": "@return false if going back is not possible.",
    "code": "public boolean goBack() {\n    boolean canGoBack = history.size() > NUM || (pendingTraversal != null && pendingTraversal.state != TraversalState.FINISHED);\n    if (!canGoBack)\n        return false;\n    History.Builder builder = history.buildUpon();\n    builder.pop();\n    final History newHistory = builder.build();\n    setHistory(newHistory, Direction.BACKWARD);\n    return true;\n}",
    "label": 1,
    "rec": "@return false if going back is not possible or a traversal is in progress."
  },
  {
    "id": 2407,
    "type": "Return",
    "comment": "@return Collection of keys for which given cache is primary.",
    "code": "    private Iterable<Integer> primaryKeysForCache(CacheProjection<Integer,String> cache, int cnt) {\n        Collection<Integer> found = new ArrayList<>(cnt);\n\n        assert false;\n//        for (int i = 0; i < 10000; i++) {\n//            if (cache.entry(i).primary()) {\n//                found.add(i);\n//\n//                if (found.size() == cnt)\n//                    return found;\n//            }\n//        }\n\n        throw new IllegalStateException(\"Unable to find \" + cnt + \" keys as primary for cache.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2408,
    "type": "Return",
    "comment": "@return the list of projects to be locked during a publish operation.",
    "code": "@SuppressWarnings(STR)\nList<IProject> getProjectPublishLockList(IProgressMonitor monitor) {\n    final List<IProject> projectPublishLockList = new ArrayList<IProject>();\n    IModule[] curModules = getModules();\n    if (curModules != null && curModules.length > NUM) {\n        for (IModule curModule : curModules) {\n            visitModule(new IModule[] { curModule }, new IModuleVisitor() {\n\n                public boolean visit(IModule[] modules2) {\n                    for (IModule curModule2 : modules2) {\n                        IProject curProject = curModule2.getProject();\n                        if (curProject != null) {\n                            if (!projectPublishLockList.contains(curProject)) {\n                                projectPublishLockList.add(curProject);\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }, monitor);\n        }\n    }\n    return projectPublishLockList;\n}",
    "label": 1,
    "rec": "@return the list of projects"
  },
  {
    "id": 2409,
    "type": "Return",
    "comment": "@return Multi bulk reply",
    "code": "    public List<String> keys(String pattern) {\n        checkIsInMulti();\n        client.keys(pattern);\n        return client.getMultiBulkReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2410,
    "type": "Return",
    "comment": "@return an unique id if (edgeFrom, edgeTo, nodeVia) to avoid doubled entries during parsing",
    "code": "public long getItemId() {\n    return ((long) edgeFrom) << NUM | ((long) edgeTo);\n}",
    "label": 1,
    "rec": "@return an unique id (edgeFrom, edgeTo) to avoid doubled entries during parsing"
  },
  {
    "id": 2411,
    "type": "Return",
    "comment": "@return todoroo cursor. PLEASE CLOSE THIS CURSOR!",
    "code": "    private TodorooCursor<Task> getTasksWithReminders(Property<?>... properties) {\n        return taskDao.query(Query.select(properties).where(Criterion.and(TaskCriteria.isActive(),\n                Criterion.or(Task.REMINDER_FLAGS.gt(0), Task.REMINDER_PERIOD.gt(0)))));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2412,
    "type": "Return",
    "comment": "@return the Account associated with the user account corresponding to the specified token",
    "code": "    protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) {\n        if (!realm.supports(token)) {\n            String msg = \"Realm [\" + realm + \"] does not support authentication token [\" +\n                    token + \"].  Please ensure that the appropriate Realm implementation is \" +\n                    \"configured correctly or that the realm accepts AuthenticationTokens of this type.\";\n            throw new UnsupportedTokenException(msg);\n        }\n        AuthenticationInfo info = realm.getAuthenticationInfo(token);\n        if (info == null) {\n            String msg = \"Realm [\" + realm + \"] was unable to find account data for the \" +\n                    \"submitted AuthenticationToken [\" + token + \"].\";\n            throw new UnknownAccountException(msg);\n        }\n        return info;\n    }\n",
    "label": 1,
    "rec": "@return the AuthenticationInfo associated with the user account corresponding to the specified token"
  },
  {
    "id": 2413,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String delete(String code, String _csrf, HttpServletRequest request, HttpSession session, ModelMap model) {\n        if (ControllerUtils.verifyNotEquals(\"_csrf\", ControllerUtils.getAdminToken(request), _csrf, model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysSite site = getSite(request);\n        SysUser user = ControllerUtils.getAdminFromSession(session);\n        SysDept dept = sysDeptService.getEntity(user.getDeptId());\n        if (ControllerUtils.verifyNotEmpty(\"deptId\", user.getDeptId(), model)\n                || ControllerUtils.verifyNotEmpty(\"deptId\", dept, model)\n                || ControllerUtils\n                        .verifyCustom(\"noright\",\n                                !(dept.isOwnsAllConfig()\n                                        || null != sysDeptConfigService.getEntity(new SysDeptConfigId(user.getDeptId(), code))),\n                                model)) {\n            return CommonConstants.TEMPLATE_ERROR;\n        }\n        SysConfigData entity = service.getEntity(new SysConfigDataId(site.getId(), code));\n        if (null != entity) {\n            service.delete(entity.getId());\n            logOperateService.save(new LogOperate(site.getId(), user.getId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                    \"delete.configData\", RequestUtils.getIpAddress(request), CommonUtils.getDate(), JsonUtils.getString(entity)));\n            configComponent.removeCache(site.getId(), entity.getId().getCode());\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2414,
    "type": "Return",
    "comment": "@return UpdaterParam update udf parameter",
    "code": "public UpdateParam getParam() {\n    return param;\n}",
    "label": 1,
    "rec": "@return UpdateParam update udf parameter"
  },
  {
    "id": 2415,
    "type": "Return",
    "comment": "@return Write order mode for atomic cache.",
    "code": "    protected CacheAtomicWriteOrderMode atomicWriteOrderMode() {\n        return CLOCK;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2416,
    "type": "Return",
    "comment": "@return a Filter that tests all elements",
    "code": "public static <E> Predicates.AllPredicate<E> all(Predicate<E>... predicates) {\n    return new Predicates.AllPredicate<E>(predicates);\n}",
    "label": 1,
    "rec": "@return a Predicate that tests all elements"
  },
  {
    "id": 2417,
    "type": "Return",
    "comment": "@return Local node.",
    "code": "    public static ClusterNode localNode(IgniteCache<?, ?> cache) {\n        return cache.unwrap(Ignite.class).cluster().localNode();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2418,
    "type": "Return",
    "comment": "@return the project that contains the resource at the given URI.",
    "code": "public IProject project(Resource resource) {\n    return file(resource.getURI()).getProject();\n}",
    "label": 1,
    "rec": "@return the project that contains the given resource."
  },
  {
    "id": 2419,
    "type": "Return",
    "comment": "@return User value.",
    "code": "    private V convert(Object val) {\n        if (val == null)\n            return null;\n\n        return locStore ? ((IgniteBiTuple<V, GridCacheVersion>)val).get1() : (V)val;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2420,
    "type": "Return",
    "comment": "@return false if going back is not possible.",
    "code": "  public boolean goBack() {\n    boolean canGoBack = history.size() > 1 || (pendingTraversal != null\n        && pendingTraversal.state != TraversalState.FINISHED);\n    if (!canGoBack) return false;\n    History.Builder builder = history.buildUpon();\n    builder.pop();\n    final History newHistory = builder.build();\n    setHistory(newHistory, Direction.BACKWARD);\n    return true;\n  }\n",
    "label": 1,
    "rec": "@return false if going back is not possible or a traversal is in progress."
  },
  {
    "id": 2421,
    "type": "Return",
    "comment": "@return Number of nodes for this test.",
    "code": "    public int nodeCount() {\n        return 4;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2422,
    "type": "Return",
    "comment": "@return a handle to file identified by the given URI.",
    "code": "public IFile file(URI uri) {\n    IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n    IPath path = pathOf(uri);\n    return (path != null) ? root.getFile(path) : null;\n}",
    "label": 1,
    "rec": "@return a handle to a workspace file identified by the given URI or {@code null} if the URI does not belong to a workspace file."
  },
  {
    "id": 2423,
    "type": "Return",
    "comment": "@return duration nanoseconds, or  null if it isn't present.",
    "code": "  static Long getTimeoutFromMethodConfig(Map<String, ?> methodConfig) {\n    return JsonUtil.getStringAsDuration(methodConfig, \"timeout\");\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2424,
    "type": "Return",
    "comment": "@return - returns the size of the largest HStore",
    "code": "HStore.HStoreSize largestHStore(final Text midkey) {\n    HStore.HStoreSize biggest = null;\n    boolean splitable = true;\n    lock.obtainReadLock();\n    try {\n        for (HStore h : stores.values()) {\n            HStore.HStoreSize size = h.size(midkey);\n            if (splitable) {\n                splitable = size.splitable;\n            }\n            if (biggest == null) {\n                biggest = size;\n                continue;\n            }\n            if (size.getAggregate() > biggest.getAggregate()) {\n                biggest = size;\n            }\n        }\n        biggest.setSplitable(splitable);\n        return biggest;\n    } finally {\n        lock.releaseReadLock();\n    }\n}",
    "label": 1,
    "rec": "@return returns size of largest HStore. Also returns whether store is splitable or not (Its not splitable if region has a store that has a reference store file)."
  },
  {
    "id": 2425,
    "type": "Return",
    "comment": "@return response to be returned to the browser",
    "code": "    protected Response handleBrowserAuthenticationRequest(ClientSessionModel clientSession, LoginProtocol protocol, boolean isPassive) {\n\n        List<IdentityProviderModel> identityProviders = realm.getIdentityProviders();\n        for (IdentityProviderModel identityProvider : identityProviders) {\n            if (identityProvider.isAuthenticateByDefault()) {\n                // TODO if we are isPassive we should propagate this flag to default identity provider also if possible\n                return buildRedirectToIdentityProvider(identityProvider.getAlias(), new ClientSessionCode(realm, clientSession).getCode());\n            }\n        }\n\n        AuthenticationFlowModel flow = getAuthenticationFlow();\n        String flowId = flow.getId();\n        AuthenticationProcessor processor = createProcessor(clientSession, flowId, LoginActionsService.AUTHENTICATE_PATH);\n\n        if (isPassive) {\n            // OIDC prompt == NONE or SAML 2 IsPassive flag\n            // This means that client is just checking if the user is already completely logged in.\n            // We cancel login if any authentication action or required action is required\n            Response challenge = null;\n            Response challenge2 = null;\n            try {\n                challenge = processor.authenticateOnly();\n                if (challenge == null) {\n                    challenge2 = processor.attachSessionExecutionRequiredActions();\n                }\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n\n            if (challenge != null || challenge2 != null) {\n                if (processor.isUserSessionCreated()) {\n                    session.sessions().removeUserSession(realm, processor.getUserSession());\n                }\n                if (challenge != null)\n                    return protocol.sendError(clientSession, Error.PASSIVE_LOGIN_REQUIRED);\n                else\n                    return protocol.sendError(clientSession, Error.PASSIVE_INTERACTION_REQUIRED);\n            } else {\n                return processor.finishAuthentication(protocol);\n            }\n        } else {\n            try {\n                RestartLoginCookie.setRestartCookie(realm, clientConnection, uriInfo, clientSession);\n                return processor.authenticate();\n            } catch (Exception e) {\n                return processor.handleBrowserException(e);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2426,
    "type": "Return",
    "comment": "@return  true if and only if this instance.low >= low and this instance.right <= high, otherwise  false.",
    "code": "\tpublic boolean isInRange(double low, double high) {\n\t\tif (low > high)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The left endpoint of the interval must be less than \" +\n\t\t\t\t\t\t\"the right endpoint.\");\n\n\t\treturn intervalTree.overlapsWith(new Interval<T>(low, high));\n\t}\n",
    "label": 1,
    "rec": "@return  true a given time interval overlaps with any interval of this instance, otherwise  false."
  },
  {
    "id": 2427,
    "type": "Return",
    "comment": "@return  True on success.",
    "code": "    private boolean compareAndSet(long offs, int expect, int update) {\n        return GridUnsafe.compareAndSwapInt(this, offs, expect, update);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2428,
    "type": "Return",
    "comment": "@return Playback position in seconds or -1 if not available.",
    "code": "public int position() {\n    if (this.oggPlayer != null) {\n        return this.oggPlayer.position();\n    }\n    return -NUM;\n}",
    "label": 1,
    "rec": "@return Playback position in milliseconds or -1 if not available."
  },
  {
    "id": 2429,
    "type": "Return",
    "comment": "@return true if valid, false otherwise",
    "code": "    public static boolean isValid(final Reference ref) {\n        if (ref == null)\n            return false;\n\n        String name = ref.getRef();\n        return !TextUtils.isEmpty(name) && !name.startsWith(\"refs/pull\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2430,
    "type": "Return",
    "comment": "@return the wrapped OMElement",
    "code": "public Element getValue() {\n    return element;\n}",
    "label": 1,
    "rec": "@return the wrapped Element"
  },
  {
    "id": 2431,
    "type": "Return",
    "comment": "@return SqlLiteral",
    "code": "\tprivate int readTokenName(char[] cs, int i, StringBuilder sb) {\n\t\tfor (++i; i < cs.length; i++) {\n\t\t\tint b = (int) cs[i];\n\t\t\t// Special case for underline ('_')\n\t\t\tif (b == 95) {\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t\t// \u00e9\u0081\u0087\u00e5\u0088\u00b0\u00e4\u00ba\u0086 '$'\n\t\t\telse if (b == 36) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\t// \u00e6\u00ad\u00a3\u00e5\u00b8\u00b8\u00e7\u009a\u0084\u00e4\u00b8\u008d\u00e5\u008f\u00af\u00e5\u00bf\u00bd\u00e7\u0095\u00a5\u00e7\u009a\u0084\u00e5\u00ad\u0097\u00e7\u00ac\u00a6\n\t\t\telse if ((b >= 0 && b <= 47)\n\t\t\t\t\t\t|| (b >= 58 && b <= 64)\n\t\t\t\t\t\t|| (b >= 91 && b <= 96)\n\t\t\t\t\t\t|| (b >= 123 && b <= 160)) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t}\n\t\treturn i - 1;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2432,
    "type": "Return",
    "comment": "@return The global max push version",
    "code": "public Map<String, Long> getROGlobalMaxVersion(List<String> storeNames) {\n    Map<String, Long> storeToMaxVersion = Maps.newHashMapWithExpectedSize(storeNames.size());\n    for (String storeName : storeNames) {\n        storeToMaxVersion.put(storeName, NUM);\n    }\n    for (Node node : currentCluster.getNodes()) {\n        Map<String, Long> currentNodeVersions = getROMaxVersion(node.getId(), storeNames);\n        for (String storeName : currentNodeVersions.keySet()) {\n            Long maxVersion = storeToMaxVersion.get(storeName);\n            if (maxVersion != null && maxVersion < currentNodeVersions.get(storeName)) {\n                storeToMaxVersion.put(storeName, currentNodeVersions.get(storeName));\n            }\n        }\n    }\n    return storeToMaxVersion;\n}",
    "label": 1,
    "rec": "@return A map of store-name to their corresponding max version id"
  },
  {
    "id": 2433,
    "type": "Return",
    "comment": "@return Reconstructed object.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            GridBiTuple<String, Object> t = stash.get();\n\n            String gridNameR = t.get1();\n            Object ctgrR = t.get2();\n\n            return GridGainEx.gridx(gridNameR).log().getLogger(ctgrR);\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2434,
    "type": "Return",
    "comment": "@return The changes",
    "code": "protected ColumnDefinitionChange compareColumns(Table sourceTable, Column sourceColumn, Table targetTable, Column targetColumn) {\n    if (ColumnDefinitionChange.isChanged(getPlatformInfo(), sourceColumn, targetColumn)) {\n        Column newColumnDef = _cloneHelper.clone(sourceColumn, true);\n        int targetTypeCode = _platformInfo.getTargetJdbcType(targetColumn.getTypeCode());\n        boolean sizeMatters = _platformInfo.hasSize(targetTypeCode);\n        boolean scaleMatters = _platformInfo.hasPrecisionAndScale(targetTypeCode);\n        newColumnDef.setTypeCode(targetColumn.getTypeCode());\n        newColumnDef.setSize(sizeMatters || scaleMatters ? targetColumn.getSize() : null);\n        newColumnDef.setAutoIncrement(targetColumn.isAutoIncrement());\n        newColumnDef.setRequired(targetColumn.isRequired());\n        newColumnDef.setDescription(targetColumn.getDescription());\n        newColumnDef.setDefaultValue(targetColumn.getDefaultValue());\n        return new ColumnDefinitionChange(sourceTable.getName(), sourceColumn.getName(), newColumnDef);\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return The change or <code>null</code> if the columns are the same"
  },
  {
    "id": 2435,
    "type": "Return",
    "comment": "@return stubber - to select a method for stubbing",
    "code": "    public static PowerMockitoStubber doNothing() {\n        return POWERMOCKITO_CORE.doNothing();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2436,
    "type": "Return",
    "comment": "@return true if the service was created by this class",
    "code": "public static boolean isDefaultService(ExecutorService service) {\n    return service != null && service == defaultExecutorService;\n}",
    "label": 1,
    "rec": "@return true if the service is not null and was created by this class"
  },
  {
    "id": 2437,
    "type": "Return",
    "comment": "@return empty String (\"\")",
    "code": "    public static String anyString() {\n        reportMatcher(new InstanceOf(String.class));\n        return \"\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2438,
    "type": "Return",
    "comment": "@return The currently connected clients in a WebSocket[].",
    "code": "public Set<WebSocket> connections() {\n    return this.connections;\n}",
    "label": 1,
    "rec": "@return The currently connected clients."
  },
  {
    "id": 2439,
    "type": "Return",
    "comment": "@return Version represented as  GridUuid",
    "code": "    public IgniteUuid asGridUuid() {\n        return new IgniteUuid(new UUID(((long)topVer << 32) | nodeOrderDrId, globalTime), order);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2440,
    "type": "Return",
    "comment": "@return String encoded using detected charset or UTF-8",
    "code": "@JsonProperty(STR)\npublic String getBodyAsString() {\n    if (body == null) {\n        return STR;\n    }\n    Charset charset = headers == null ? Strings.DEFAULT_CHARSET : headers.getContentTypeHeader().charset();\n    return Strings.stringFromBytes(body, charset);\n}",
    "label": 1,
    "rec": "@return Encoded string"
  },
  {
    "id": 2441,
    "type": "Return",
    "comment": "@return GridSpiException Converted exception.",
    "code": "                    private IgniteSpiException unwrapException(GridException e) {\n                        // Avoid double-wrapping.\n                        if (e.getCause() instanceof IgniteSpiException)\n                            return (IgniteSpiException)e.getCause();\n\n                        return new IgniteSpiException(\"Failed to execute SPI context method.\", e);\n                    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2442,
    "type": "Return",
    "comment": "@return a set view of the entities contained in this EventCache",
    "code": "public Set keySet() {\n    return Collections.unmodifiableSet(entityToCopyMap.keySet());\n}",
    "label": 1,
    "rec": "@return an unmodifiable set view of the entities contained in this EventCache"
  },
  {
    "id": 2443,
    "type": "Return",
    "comment": "@return Hadoop task type.",
    "code": "    private TaskType taskType(GridHadoopTaskType type) {\n        switch (type) {\n            case SETUP:\n                return TaskType.JOB_SETUP;\n            case MAP:\n            case COMBINE:\n                return TaskType.MAP;\n\n            case REDUCE:\n                return TaskType.REDUCE;\n\n            case COMMIT:\n            case ABORT:\n                return TaskType.JOB_CLEANUP;\n\n            default:\n                return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2444,
    "type": "Return",
    "comment": "@return a Float[] which is the new centroid",
    "code": "private Vector computeCentroid() {\n    if (numPoints == NUM)\n        return pointTotal;\n    else if (centroid == null) {\n        centroid = pointTotal.divide(numPoints);\n    }\n    return centroid;\n}",
    "label": 1,
    "rec": "@return the new centroid"
  },
  {
    "id": 2445,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(SparseMatrix[] data, int fold) throws Exception {\n\n\t\tSparseMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\t\tcase \"globalavg\":\n\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"useravg\":\n\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"itemavg\":\n\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"random\":\n\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"constant\":\n\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"mostpop\":\n\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\t\tcase \"userknn\":\n\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"itemknn\":\n\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"slopeone\":\n\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\t\tcase \"regsvd\":\n\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\tcase \"biasedmf\":\n\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\tcase \"svd++\":\n\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"pmf\":\n\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\tcase \"climf\":\n\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\tcase \"socialmf\":\n\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold);\n\t\tcase \"trustmf\":\n\t\t\treturn new TrustMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-basemf\":\n\t\t\treturn new BaseMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dmf\":\n\t\t\treturn new DMF(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-basenm\":\n\t\t\treturn new BaseNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-dnm\":\n\t\t\treturn new DNM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-drm\":\n\t\t\treturn new DRM(trainMatrix, testMatrix, fold);\n\t\tcase \"aaai-drmplus\":\n\t\t\treturn new DRMPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"hybrid\":\n\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\tdefault:\n\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2446,
    "type": "Return",
    "comment": "@return an array of booleans indicating the current configuration",
    "code": "public static int[] getCurrentConfiguration() {\n    final int[] current = new int[PROP_SIZE];\n    current[NUM] = !UnsafeAdapter.getMemoryMBean().isSafeMemory() ? NUM : NUM;\n    current[NUM] = UnsafeAdapter.getMemoryMBean().isTrackingEnabled() ? NUM : NUM;\n    current[NUM] = UnsafeAdapter.getMemoryMBean().isAlignmentEnabled() ? NUM : NUM;\n    current[NUM] = UnsafeAdapter.getMemoryMBean().isSafeMemoryOffHeap() ? NUM : NUM;\n    current[NUM] = AllocationPointerOperations.ALLOC_SIZE;\n    return current;\n}",
    "label": 1,
    "rec": "@return an array of ints indicating the current configuration"
  },
  {
    "id": 2447,
    "type": "Return",
    "comment": "@return true if the element and method should be generated",
    "code": "    public boolean generateInsertSelective() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        return tableConfiguration.isInsertStatementEnabled();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2448,
    "type": "Return",
    "comment": "@return The list of nodes sorted by NodePriority::compare",
    "code": "List<PrioritizableNode> prioritize() {\n    List<PrioritizableNode> priorityList = new ArrayList<>(nodes.values());\n    Collections.sort(priorityList);\n    return priorityList;\n}",
    "label": 1,
    "rec": "@return The list of nodes sorted by PrioritizableNode::compare"
  },
  {
    "id": 2449,
    "type": "Return",
    "comment": "@return a  State which type is inherited by the  TypeParser or a  StringType if item is null",
    "code": "\tprivate State createState(Class<? extends Item> itemType, String transformedResponse) {\n\t\ttry {\n\t\t\tif (itemType.isAssignableFrom(NumberItem.class)) {\n\t\t\t\treturn DecimalType.valueOf(transformedResponse);\n\t\t\t} else if (itemType.isAssignableFrom(ContactItem.class)) {\n\t\t\t\treturn OpenClosedType.valueOf(transformedResponse);\n\t\t\t} else if (itemType.isAssignableFrom(SwitchItem.class)) {\n\t\t\t\treturn OnOffType.valueOf(transformedResponse);\n\t\t\t} else if (itemType.isAssignableFrom(RollershutterItem.class)) {\n\t\t\t\treturn PercentType.valueOf(transformedResponse);\n\t\t\t} else {\n\t\t\t\treturn StringType.valueOf(transformedResponse);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.debug(\"Couldn't create state of type '{}' for value '{}'\", itemType, transformedResponse);\n\t\t\treturn StringType.valueOf(transformedResponse);\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2450,
    "type": "Return",
    "comment": "@return string representation of the MAC address: x:xx:xx:xx:xx:xx (in lowercase).",
    "code": "public static String convertMacAddressToString(byte[] macAddress) {\n    return String.format(STR, macAddress[NUM], macAddress[NUM], macAddress[NUM], macAddress[NUM], macAddress[NUM], macAddress[NUM]);\n}",
    "label": 1,
    "rec": "@return string representation of the MAC address: xx:xx:xx:xx:xx:xx (in lower-case)."
  },
  {
    "id": 2451,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static int anyInt() {\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2452,
    "type": "Return",
    "comment": "@return Boolean reply, true if the key exists, otherwise false",
    "code": "public Long exists(final byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    client.exists(keys);\n    return client.getIntegerReply();\n}",
    "label": 1,
    "rec": "@return Integer reply, specifically: an integer greater than 0 if one or more keys existed 0 if none of the specified keys existed"
  },
  {
    "id": 2453,
    "type": "Return",
    "comment": "@return message router.",
    "code": "    public MessageRouter getMessageRouter(int numPartitions) {\n        return conf.getCustomMessageRouter();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2454,
    "type": "Return",
    "comment": "@return the session which matches the session identifier or <code>null</code> if no such session exists.",
    "code": "private DTLSSession getSessionByIdentifier(byte[] sessionId) {\n    if (sessionId == null || sessionId.length == NUM) {\n        return null;\n    }\n    for (DTLSSession session : dtlsSessions.values()) {\n        SessionId sessionIdentifier = session.getSessionIdentifier();\n        if (sessionIdentifier != null) {\n            if (Arrays.equals(sessionId, sessionIdentifier.getSessionId())) {\n                return session;\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the corresponding session or <code>null</code> if none of the cached sessions has the given identifier"
  },
  {
    "id": 2455,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static float not(float first) {\n        MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot();\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2456,
    "type": "Return",
    "comment": "@return the adjusted insets.",
    "code": "public static ElkPadding calculateRequiredNodeLabelSpace(final NodeAdapter<?> node, final double labelSpacing, final ElkPadding nodeLabelPadding, final Map<LabelLocation, LabelGroup> labelGroupsBoundingBoxes, final ElkPadding padding) {\n    if (!node.getLabels().iterator().hasNext()) {\n        return padding;\n    }\n    final Set<NodeLabelPlacement> nodeLabelPlacement = node.getProperty(CoreOptions.NODE_LABELS_PLACEMENT);\n    final LabelLocation nodeLabelLocation = LabelLocation.fromNodeLabelPlacement(nodeLabelPlacement);\n    for (final LabelAdapter<?> label : node.getLabels()) {\n        LabelLocation labelPlacement = LabelLocation.fromNodeLabelPlacement(label.getProperty(CoreOptions.NODE_LABELS_PLACEMENT));\n        if (labelPlacement == LabelLocation.UNDEFINED) {\n            labelPlacement = nodeLabelLocation;\n        }\n        label.setVolatileId(labelPlacement.ordinal());\n        final Rectangle boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);\n        boundingBox.width = Math.max(boundingBox.width, label.getSize().x);\n        boundingBox.height += label.getSize().y + labelSpacing;\n    }\n    boolean hPrio = nodeLabelPlacement.contains(NodeLabelPlacement.H_PRIORITY);\n    for (final Entry<LabelLocation, LabelGroup> entry : labelGroupsBoundingBoxes.entrySet()) {\n        final Rectangle boundingBox = entry.getValue();\n        boundingBox.height -= labelSpacing;\n        switch(entry.getKey()) {\n            case IN_T_L:\n                if (hPrio) {\n                    padding.left = Math.max(padding.left, boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.top = Math.max(padding.top, boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n            case IN_T_C:\n                padding.top = Math.max(padding.top, boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                break;\n            case IN_T_R:\n                if (hPrio) {\n                    padding.right = Math.max(padding.right, boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.top = Math.max(padding.top, boundingBox.height + labelSpacing + nodeLabelPadding.top);\n                }\n                break;\n            case IN_C_L:\n                padding.left = Math.max(padding.left, boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                break;\n            case IN_C_R:\n                padding.right = Math.max(padding.right, boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                break;\n            case IN_B_L:\n                if (hPrio) {\n                    padding.left = Math.max(padding.left, boundingBox.width + labelSpacing + nodeLabelPadding.left);\n                } else {\n                    padding.bottom = Math.max(padding.bottom, boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n            case IN_B_C:\n                padding.bottom = Math.max(padding.bottom, boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                break;\n            case IN_B_R:\n                if (hPrio) {\n                    padding.right = Math.max(padding.right, boundingBox.width + labelSpacing + nodeLabelPadding.right);\n                } else {\n                    padding.bottom = Math.max(padding.bottom, boundingBox.height + labelSpacing + nodeLabelPadding.bottom);\n                }\n                break;\n            default:\n        }\n    }\n    padding.top = Math.max(padding.top, nodeLabelPadding.top);\n    padding.left = Math.max(padding.left, nodeLabelPadding.left);\n    padding.right = Math.max(padding.right, nodeLabelPadding.right);\n    padding.bottom = Math.max(padding.bottom, nodeLabelPadding.bottom);\n    return padding;\n}",
    "label": 1,
    "rec": "@return the adjusted padding."
  },
  {
    "id": 2457,
    "type": "Return",
    "comment": "@return string array value",
    "code": "    public static String[] converStringArray(TemplateModel model) throws TemplateModelException {\n        if (model instanceof TemplateSequenceModel) {\n            TemplateSequenceModel smodel = (TemplateSequenceModel) model;\n            String[] values = new String[smodel.size()];\n            for (int i = 0; i < smodel.size(); i++) {\n                values[i] = converString(smodel.get(i));\n            }\n            return values;\n        }\n        String str = converString(model);\n        if (CommonUtils.notEmpty(str)) {\n            if (0 <= str.indexOf(Constants.COMMA_DELIMITED)) {\n                return StringUtils.split(str, Constants.COMMA_DELIMITED);\n            } else {\n                return StringUtils.split(str, Constants.BLANK_SPACE);\n            }\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2458,
    "type": "Return",
    "comment": "@return Socket address.",
    "code": "    private static Collection<InetSocketAddress> address(String ipStr) throws GridSpiException {\n        if (ipStr.endsWith(\":\"))\n            ipStr = ipStr.substring(0, ipStr.length() - 1);\n        else if (ipStr.indexOf(':') >= 0) {\n            StringTokenizer st = new StringTokenizer(ipStr, \":\");\n\n            if (st.countTokens() == 2) {\n                String addrStr = st.nextToken();\n                String portStr = st.nextToken();\n\n                if (portStr.contains(\"..\")) {\n                    int port1;\n                    int port2;\n\n                    try {\n                        port1 = Integer.parseInt(portStr.substring(0, portStr.indexOf(\"..\")));\n                        port2 = Integer.parseInt(portStr.substring(portStr.indexOf(\"..\") + 2, portStr.length()));\n\n                        if (port2 < port1 || port1 == port2 || port1 <= 0 || port2 <= 0)\n                            throw new GridSpiException(\"Failed to parse provided address: \" + ipStr);\n\n                        Collection<InetSocketAddress> res = new ArrayList<>(port2 - port1);\n\n                        // Upper bound included.\n                        for (int i = port1; i <= port2; i++)\n                            res.add(new InetSocketAddress(addrStr, i));\n\n                        return res;\n                    }\n                    catch (IllegalArgumentException e) {\n                        throw new GridSpiException(\"Failed to parse provided address: \" + ipStr, e);\n                    }\n                }\n                else {\n                    try {\n                        int port = Integer.parseInt(portStr);\n\n                        return Collections.singleton(new InetSocketAddress(addrStr, port));\n                    }\n                    catch (IllegalArgumentException e) {\n                        throw new GridSpiException(\"Failed to parse provided address: \" + ipStr, e);\n                    }\n                }\n            }\n            else\n                throw new GridSpiException(\"Failed to parse provided address: \" + ipStr);\n        }\n\n        // Provided address does not contain port (will use default one).\n        return Collections.singleton(new InetSocketAddress(ipStr, 0));\n    }\n",
    "label": 1,
    "rec": "@return Socket addresses (may contain 1 or more addresses if provided string includes port range)."
  },
  {
    "id": 2459,
    "type": "Return",
    "comment": "@return null.",
    "code": "    public static float[] aryEq(float[] value) {\n        reportMatcher(new ArrayEquals(value));\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2460,
    "type": "Return",
    "comment": "@return the name of the language.",
    "code": "public TargetLanguage language() {\n    return language;\n}",
    "label": 1,
    "rec": "@return the language."
  },
  {
    "id": 2461,
    "type": "Return",
    "comment": "@return true if re-queue is successful",
    "code": "                    public Void call() throws Exception\n                    {\n                        doWorkLoop();\n                        return null;\n                    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2462,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getLastUnsuccessfulBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        retVal = takeLast(retVal, job.getLastUnsuccessfulBuild());\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 2463,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage setValueMessage(int level) {\n\t\tif(isGetSupported == false) {\n\t\t\tlogger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlogger.debug(\"Creating new message for application command SWITCH_BINARY_SET for node {}\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.SendData, SerialMessagePriority.Set);\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \n    \t\t\t\t\t\t\t3, \n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \n\t\t\t\t\t\t\t\t(byte) SWITCH_BINARY_SET,\n\t\t\t\t\t\t\t\t(byte) (level > 0 ? 0xFF : 0x00)\n\t\t\t\t\t\t\t\t};\n    \tresult.setMessagePayload(newPayload);\n    \treturn result;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2464,
    "type": "Return",
    "comment": "@return possible object is {@link Customerid }",
    "code": "public String getCustomerid() {\n    return customerid;\n}",
    "label": 1,
    "rec": "@return possible object is {@link String }"
  },
  {
    "id": 2465,
    "type": "Return",
    "comment": "@return  false If failed to finish and we need to lock more pages up.",
    "code": "        private boolean finishTail(boolean ignoreMergeMore) throws IgniteCheckedException {\n            assert !isFinished();\n            assert needMerge != FALSE || needReplaceInner != FALSE;\n            assert tail != null;\n\n            if (needReplaceInner == TRUE)\n                return false; // Need to find inner page.\n\n            if (needReplaceInner == READY) {\n                assert needMerge == FALSE: needMerge;\n\n                // We increment remove ID in write lock on leaf page, thus it is guaranteed that\n                // any successor will get greater value than he had read at the beginning of the operation.\n                // Thus he is guaranteed to do a retry from root. Since inner replace takes locks on the whole branch\n                // and releases the locks only when the inner key is updated and the successor saw the updated removeId,\n                // then after retry from root, he will see updated inner key.\n                globalRmvId.incrementAndGet();\n\n                // Need to replace inner key with new max key for the left subtree.\n                doReplaceInner();\n\n                needReplaceInner = DONE;\n            }\n            else if (needMerge == READY) {\n                assert needReplaceInner == FALSE: needReplaceInner;\n                assert tail.down != null;\n\n                boolean needMergeMore = merge(tail.lvl - 1, true);\n\n                if (needMergeMore && !ignoreMergeMore) {\n                    needMerge = TRUE;\n\n                    return false;\n                }\n\n                needMerge = DONE;\n            }\n            else\n                return false;\n\n            releaseTail();\n            finish();\n\n            return true;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2466,
    "type": "Return",
    "comment": "@return ExplorerSettings The navigation sort mode",
    "code": "public static FileManagerSettings fromId(String id) {\n    FileManagerSettings[] values = values();\n    int cc = values.length;\n    for (int i = NUM; i < cc; i++) {\n        if (values[i].mId == id) {\n            return values[i];\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return FileManagerSettings The navigation sort mode"
  },
  {
    "id": 2467,
    "type": "Return",
    "comment": "@return Return the members of a set resulting from the difference between the first set provided and all the successive sets.",
    "code": "  public Set<byte[]> sdiff(final byte[]... keys) {\n    checkIsInMulti();\n    client.sdiff(keys);\n    return SetFromList.of(client.getBinaryMultiBulkReply());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2468,
    "type": "Return",
    "comment": "@return The filter string with which the service listener was added.",
    "code": "public String getFilter() {\n    if (filter != null) {\n        return filter.toString();\n    }\n    return getObjectClassFilterString(objectClass);\n}",
    "label": 1,
    "rec": "@return The filter string with which the listener was added. This may be <code>null</code> if the listener was added without a filter."
  },
  {
    "id": 2469,
    "type": "Return",
    "comment": "@return null.",
    "code": "    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).nullValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2470,
    "type": "Return",
    "comment": "@return an array of file input splits which have been assigned to this task",
    "code": "public Iterator<FileInputSplit> getFileInputSplits() {\n    final InputSplit[] inputSplits = getEnvironment().getInputSplits();\n    final List<FileInputSplit> fileInputSplits = new ArrayList<FileInputSplit>();\n    for (int i = NUM; i < inputSplits.length; i++) {\n        fileInputSplits.add((FileInputSplit) inputSplits[i]);\n    }\n    return fileInputSplits.iterator();\n}",
    "label": 1,
    "rec": "@return an iterator to a (possible empty) list of file input splits."
  },
  {
    "id": 2471,
    "type": "Return",
    "comment": "@return 0 for success, < 0 otherwise",
    "code": "    public int run() throws PulsarClientException {\n        if (mainOptions.size() != 1) {\n            throw (new ParameterException(\"Please provide one and only one topic name.\"));\n        }\n        if (this.numTimesProduce <= 0) {\n            throw (new ParameterException(\"Number of times need to be positive number.\"));\n        }\n        if (messages.size() == 0 && messageFileNames.size() == 0) {\n            throw (new ParameterException(\"Please supply message content with either --messages or --files\"));\n        }\n\n        int totalMessages = (messages.size() + messageFileNames.size()) * numTimesProduce;\n        if (totalMessages > MAX_MESSAGES) {\n            String msg = \"Attempting to send \" + totalMessages + \" messages. Please do not send more than \"\n                    + MAX_MESSAGES + \" messages\";\n            throw new ParameterException(msg);\n        }\n\n        String topic = this.mainOptions.get(0);\n\n        if (this.serviceURL.startsWith(\"ws\")) {\n            return publishToWebSocket(totalMessages, topic);\n        } else {\n            return publish(totalMessages, topic);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2472,
    "type": "Return",
    "comment": "@return string like \"dc=something,dc=org\" from the DN like \"uid=joe,dc=something,dc=org\"",
    "code": "public LDAPDn getParentDn() {\n    LinkedList<Entry> parentDnEntries = new LinkedList<>(entries);\n    parentDnEntries.remove();\n    return new LDAPDn(parentDnEntries);\n}",
    "label": 1,
    "rec": "@return DN like \"dc=something,dc=org\" from the DN like \"uid=joe,dc=something,dc=org\". Returned DN will be new clone not related to the original DN instance."
  },
  {
    "id": 2473,
    "type": "Return",
    "comment": "@return Whether node is failed.",
    "code": "    public boolean tryFailNode(UUID nodeId) {\n        if (!busyLock.enterBusy())\n            return false;\n\n        try {\n            if (!getSpi().pingNode(nodeId)) {\n                getSpi().failNode(nodeId);\n\n                return true;\n            }\n\n            return false;\n        }\n        finally {\n            busyLock.leaveBusy();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2474,
    "type": "Return",
    "comment": "@return <code>true</code> if the given model elements are either all library folders or source folder, and <code>false</code> otherwise",
    "code": "private boolean allOfSameKind(IFolder[] folders) {\n    int libraryFolderCount = NUM;\n    for (IResource folder : folders) {\n        if (LibraryFolderManager.getInstance().isInLibraryFolder(folder)) {\n            libraryFolderCount++;\n        }\n    }\n    return libraryFolderCount == NUM || libraryFolderCount == folders.length;\n}",
    "label": 1,
    "rec": "@return <code>true</code> if the given folders are either all library folders or source folder, and <code>false</code> otherwise"
  },
  {
    "id": 2475,
    "type": "Return",
    "comment": "@return result of invocation of fallback method or RuntimeException",
    "code": "    protected Object getFallback() {\n        if (getFallbackAction() != null) {\n            final CommandAction commandAction = getFallbackAction();\n            try {\n                return process(new Action() {\n                    @Override\n                    Object execute() {\n                        MetaHolder metaHolder = commandAction.getMetaHolder();\n                        Object[] args = createArgsForFallback(metaHolder, getFailedExecutionException());\n                        return commandAction.executeWithArgs(commandAction.getMetaHolder().getFallbackExecutionType(), args);\n                    }\n                });\n            } catch (Throwable e) {\n                LOGGER.error(FallbackErrorMessageBuilder.create()\n                        .append(commandAction, e).build());\n                throw new FallbackInvocationException(e.getCause());\n            }\n        } else {\n            return super.getFallback();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2476,
    "type": "Return",
    "comment": "@return  true a given time interval overlaps with any interval of this instance, otherwise  false.",
    "code": "\tpublic boolean isInRange(double low, double high) {\n\t\tif (low > high)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The left endpoint of the interval must be less than \" +\n\t\t\t\t\t\t\"the right endpoint.\");\n\n\t\treturn getLow() >= low && getHigh() <= high;\n\t}\n",
    "label": 1,
    "rec": "@return  true if and only if this instance.low >= low and this instance.right <= high, otherwise  false."
  },
  {
    "id": 2477,
    "type": "Return",
    "comment": "@return last invocation",
    "code": "    public InvocationImpl getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<InvocationImpl> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2478,
    "type": "Return",
    "comment": "@return the directory \"$(pwd)/uninstall\": This needs to be improved",
    "code": "protected static File getLibraryUninstallDir() {\n    String workingDir = System.getProperty(STR);\n    return new File(workingDir, STR);\n}",
    "label": 1,
    "rec": "@return the directory \"$(ControllerConfig.defaultDir)/uninstall\": This needs to be improved"
  },
  {
    "id": 2479,
    "type": "Return",
    "comment": "@return a service instance or null, if none could be found",
    "code": "\tstatic public TransformationService getTransformationService(BundleContext context, String transformationType) {\n\t\t\n\t\tif (cachedServices.containsKey(transformationType)) {\n\t\t\treturn cachedServices.get(transformationType);\n\t\t}\n\t\t\n\t\tif(context!=null) {\n\t\t\tString filter = \"(openhab.transform=\" + transformationType + \")\";\n\t\t\ttry {\n\t\t\t\tCollection<ServiceReference<TransformationService>> refs = context.getServiceReferences(TransformationService.class, filter);\n\t\t\t\tif(refs!=null && refs.size() > 0) {\n\t\t\t\t\tTransformationService service = (TransformationService) context.getService(refs.iterator().next());\n\t\t\t\t\tcachedServices.put(transformationType, service);\n\t\t\t\t\treturn service;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"Cannot get service reference for transformation service of type \" + transformationType);\n\t\t\t\t}\n\t\t\t} catch (InvalidSyntaxException e) {\n\t\t\t\tlogger.warn(\"Cannot get service reference for transformation service of type \" + transformationType, e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2480,
    "type": "Return",
    "comment": "@return a dense matrix with results of matrix multiplication",
    "code": "\tpublic DenseVector mult(DenseVector vec) {\n\t\tassert this.numColumns == vec.size;\n\n\t\tDenseVector result = new DenseVector(this.numRows);\n\t\tfor (int i = 0; i < this.numRows; i++)\n\t\t\tresult.set(i, row(i, false).inner(vec));\n\n\t\treturn result;\n\t}\n",
    "label": 1,
    "rec": "@return a dense vector with the results of  matrix x vector"
  },
  {
    "id": 2481,
    "type": "Return",
    "comment": "@return  True if active.",
    "code": "    public boolean activated(ClusterNode node) {\n        Snapshot snapshot = topSnap.get();\n\n        if (snapshot.discoCache == null)\n            return false;\n\n        return snapshot.discoCache.activatedNodes.contains(node);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2482,
    "type": "Return",
    "comment": "@return The String value of a named property, or null if no such property exists",
    "code": "public String getProperty(String name) {\n    if (hasProperties()) {\n        for (Property property : getProperties()) {\n            if (property.hasName() && property.getName().equalsIgnoreCase(name)) {\n                return property.getValue();\n            }\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return string value of the named property or null if it doesn't exist"
  },
  {
    "id": 2483,
    "type": "Return",
    "comment": "@return Collection of keys for which given cache is primary.",
    "code": "    protected List<String> primaryKeysForCache(IgniteCache<String, Integer> cache, int cnt)\n        throws IgniteCheckedException {\n        return primaryKeysForCache(cache, cnt, 1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2484,
    "type": "Return",
    "comment": "@return the new short array backed by a buffer or an array",
    "code": "    public static ShortIndexer create(final ShortPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new ShortRawIndexer(pointer, sizes, strides)\n                                             : new ShortBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            short[] array = new short[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new ShortArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 1,
    "rec": "@return the new short indexer backed by the raw memory interface, a buffer, or an array"
  },
  {
    "id": 2485,
    "type": "Return",
    "comment": "@return GGFS instance working mode.",
    "code": "    public IgfsMode mode() {\n        return mode;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2486,
    "type": "Return",
    "comment": "@return the request in progress, or <code>-1</code>.",
    "code": "public synchronized ConnectionHandlerRequest getRequestInProgress() {\n    return requestInProgress;\n}",
    "label": 1,
    "rec": "@return the request in progress, or <code>null</code>."
  },
  {
    "id": 2487,
    "type": "Return",
    "comment": "@return the  TopicPartitions currently assigned to this container, either explicitly or by Kafka; may be null if not assigned yet.",
    "code": "\tpublic Collection<TopicPartition> getAssignedPartitions() {\n\t\tListenerConsumer partitionsListenerConsumer = this.listenerConsumer;\n\t\tif (partitionsListenerConsumer != null) {\n\t\t\tif (partitionsListenerConsumer.definedPartitions != null) {\n\t\t\t\treturn Collections.unmodifiableCollection(partitionsListenerConsumer.definedPartitions.keySet());\n\t\t\t}\n\t\t\telse if (partitionsListenerConsumer.assignedPartitions != null) {\n\t\t\t\treturn Collections.unmodifiableCollection(partitionsListenerConsumer.assignedPartitions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2488,
    "type": "Return",
    "comment": "@return Length in seconds or -1 if not available.",
    "code": "public int length() {\n    if (this.oggPlayer != null) {\n        return this.oggPlayer.length();\n    }\n    return -NUM;\n}",
    "label": 1,
    "rec": "@return Length in milliseconds or -1 if not available."
  },
  {
    "id": 2489,
    "type": "Return",
    "comment": "@return the weighting to be used for route calculation",
    "code": "    public Weighting createWeighting( String weighting, FlagEncoder encoder )\n    {\n        // ignore case\n        weighting = weighting.toLowerCase();\n        if (\"fastest\".equals(weighting))\n        {\n            if (encoder instanceof BikeCommonFlagEncoder)\n                return new PriorityWeighting((BikeCommonFlagEncoder) encoder);\n            else\n                return new FastestWeighting(encoder);\n        }\n        return new ShortestWeighting();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2490,
    "type": "Return",
    "comment": "@return the Octect stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor",
    "code": "public InputStream getOctetStream() throws IOException {\n    if (inputOctetStreamProxy instanceof FileInputStream) {\n        return inputOctetStreamProxy;\n    } else {\n        return getResetableInputStream();\n    }\n}",
    "label": 1,
    "rec": "@return the Octet stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor"
  },
  {
    "id": 2491,
    "type": "Return",
    "comment": "@return Execution future.",
    "code": "    private IgniteInternalFuture<GridRestResponse> broadcast(String cacheName, Callable<Object> c) {\n        IgniteCompute comp = ctx.grid().compute(ctx.grid().forCacheNodes(cacheName)).withNoFailover().withAsync();\n\n        try {\n            comp.broadcast(c);\n\n            IgniteInternalFuture<Collection<Object>> fut = comp.future();\n\n            return fut.chain(new C1<IgniteInternalFuture<Collection<Object>>, GridRestResponse>() {\n                @Override public GridRestResponse apply(IgniteInternalFuture<Collection<Object>> fut) {\n                    try {\n                        fut.get();\n\n                        return new GridRestResponse();\n                    }\n                    catch (IgniteCheckedException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            });\n        }\n        catch (IgniteCheckedException e) {\n            // Should not be thrown since uses asynchronous execution.\n            return new GridFinishedFutureEx<>(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2492,
    "type": "Return",
    "comment": "@return the element at index idx",
    "code": "public E get(int index) {\n    return executables.get(index);\n}",
    "label": 1,
    "rec": "@return The element at specified index"
  },
  {
    "id": 2493,
    "type": "Return",
    "comment": "@return image",
    "code": "    protected Bitmap getImage(final User user) {\n        File avatarFile = new File(avatarDir, Integer.toString(user.getId()));\n\n        if (!avatarFile.exists() || avatarFile.length() == 0)\n            return null;\n\n        Bitmap bitmap = decode(avatarFile);\n        if (bitmap == null)\n            avatarFile.delete();\n        return bitmap;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2494,
    "type": "Return",
    "comment": "@return SocketStore object for storeName and donorNodeId",
    "code": "    private Node getNodeIfPresent(int proxyNodeId) {\n        try {\n            return metadata.getCluster().getNodeById(proxyNodeId);\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to get proxyNode \" + proxyNodeId\n                                         + \" from current cluster \" + metadata.getCluster()\n                                         + \" at node \" + metadata.getNodeId(), e);\n        }\n    }\n",
    "label": 1,
    "rec": "@return SocketStore object for storeName and proxyNodeId"
  },
  {
    "id": 2495,
    "type": "Return",
    "comment": "@return repository",
    "code": "    public Repository getRepository() {\n        return repository;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2496,
    "type": "Return",
    "comment": "@return upload token, returns {@code null} if not found",
    "code": "public static JSONObject getUploadToken(final RequestContext context) {\n    try {\n        final JSONObject currentUser = getCurrentUser(context.getRequest(), context.getResponse());\n        if (null == currentUser) {\n            return null;\n        }\n        final String userName = currentUser.optString(User.USER_NAME);\n        final String userB3Key = currentUser.optString(UserExt.USER_B3_KEY);\n        if (StringUtils.isBlank(userB3Key)) {\n            return null;\n        }\n        final JSONObject requestJSON = new JSONObject().put(User.USER_NAME, userName).put(UserExt.USER_B3_KEY, userB3Key);\n        final HttpResponse res = HttpRequest.post(STR).trustAllCerts(true).body(requestJSON.toString()).connectionTimeout(NUM).timeout(NUM).header(STR, Solos.USER_AGENT).send();\n        if (HttpServletResponse.SC_OK != res.statusCode()) {\n            return null;\n        }\n        res.charset(STR);\n        final JSONObject result = new JSONObject(res.bodyText());\n        if (NUM != result.optInt(Keys.CODE)) {\n            return null;\n        }\n        final JSONObject data = result.optJSONObject(Common.DATA);\n        return new JSONObject().put(Common.UPLOAD_TOKEN, data.optString(STR)).put(Common.UPLOAD_URL, data.optString(STR));\n    } catch (final Exception e) {\n        LOGGER.log(Level.ERROR, STR, e);\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return upload token and URL, returns {@code null} if not found"
  },
  {
    "id": 2497,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "    public SerialMessage getIntervalCapabilitiesMessage() {\n        if (isGetSupported == false) {\n            logger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n            return null;\n        }\n\n        logger.debug(\"NODE {}: Creating new message for application command WAKE_UP_INTERVAL_CAPABILITIES_GET\",\n                this.getNode().getNodeId());\n        SerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData,\n                SerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Config);\n        byte[] newPayload = { (byte) this.getNode().getNodeId(), 2, (byte) getCommandClass().getKey(),\n                (byte) WAKE_UP_INTERVAL_CAPABILITIES_GET };\n        result.setMessagePayload(newPayload);\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2498,
    "type": "Return",
    "comment": "@return The value of the command line argument named by the {@code longIdentifier}.",
    "code": "public Object get(String longIdentifier) {\n    if (longIdentifier == null) {\n        throw new NullPointerException(STR);\n    }\n    Object get = null;\n    Argument argument = getNamedArgument(longIdentifier);\n    if (argument == null)\n        return null;\n    if (argument.getClass() == StringArgument.class)\n        get = ((StringArgument) argument).getValue();\n    else if (argument.getClass() == DNArgument.class)\n        get = ((DNArgument) argument).getValue();\n    else if (argument.getClass() == IntegerArgument.class)\n        get = ((IntegerArgument) argument).getValue();\n    else if (argument.getClass() == BooleanArgument.class)\n        get = argument.isPresent();\n    else if (argument.getClass() == FilterArgument.class)\n        get = ((FilterArgument) argument).getValue();\n    else {\n        StringBuilder builder = new StringBuilder(argument.getClass().toString());\n        builder.append(STR);\n        throw new UnsupportedOperationException(builder.toString());\n    }\n    return get;\n}",
    "label": 1,
    "rec": "@return The value of the command line argument named by the {@code longIdentifier} or {@code null} if no such argument has been registered with the argument parser."
  },
  {
    "id": 2499,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).longValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2500,
    "type": "Return",
    "comment": "@return object that was found in resource or set to it, autoInsertValue - if there are no values with specified key",
    "code": "public Object getMessage(Object key, String bundleIdentifier, Locale locale) {\n    if (bundleIdentifier.equals(NO_BUNDLE))\n        return null;\n    try {\n        initialize(bundleIdentifier, locale);\n        return getBundleLocalizedString(String.valueOf(key));\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return object that was found in resource or null if nothing is found"
  },
  {
    "id": 2501,
    "type": "Return",
    "comment": "@return null.",
    "code": "    public static long[] aryEq(long[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2502,
    "type": "Return",
    "comment": "@return HystrixRuntimeException or HystrixBadRequestException",
    "code": "protected RuntimeException decomposeException(Exception e) {\n    if (e instanceof IllegalStateException) {\n        return (IllegalStateException) e;\n    }\n    if (e instanceof HystrixBadRequestException) {\n        return (HystrixBadRequestException) e;\n    }\n    if (e.getCause() instanceof HystrixBadRequestException) {\n        return (HystrixBadRequestException) e.getCause();\n    }\n    if (e instanceof HystrixRuntimeException) {\n        return (HystrixRuntimeException) e;\n    }\n    if (e.getCause() instanceof HystrixRuntimeException) {\n        return (HystrixRuntimeException) e.getCause();\n    }\n    String message = getLogMessagePrefix() + STR;\n    logger.debug(message, e);\n    return new HystrixRuntimeException(FailureType.COMMAND_EXCEPTION, this.getClass(), message, e, null);\n}",
    "label": 1,
    "rec": "@return HystrixRuntimeException, HystrixBadRequestException or IllegalStateException"
  },
  {
    "id": 2503,
    "type": "Return",
    "comment": "@return the default datapoint type id",
    "code": "    private String getDefaultDPTId(Class<? extends Type> typeClass) {\n        return ((KNXCoreTypeMapper) typeHelper).toDPTid(typeClass);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2504,
    "type": "Return",
    "comment": "@return encoding of DN",
    "code": "public byte[] getEncoded() {\n    if (encoded == null) {\n        encoded = ASN1.encode(this);\n    }\n    return encoded;\n}",
    "label": 1,
    "rec": "@return return encoding, no copying is performed"
  },
  {
    "id": 2505,
    "type": "Return",
    "comment": "@return Streamer configuration.",
    "code": "    private StreamerConfiguration streamerConfiguration() {\n        StreamerConfiguration cfg = new StreamerConfiguration();\n\n        cfg.setRouter(router);\n\n        GridStreamerBoundedTimeWindow window = new GridStreamerBoundedTimeWindow();\n\n        window.setName(\"window1\");\n        window.setTimeInterval(60000);\n\n        cfg.setWindows(F.asList((GridStreamerWindow)window));\n\n        cfg.setStages(stages);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2506,
    "type": "Return",
    "comment": "@return {@link org.apache.streams.pojo.json.Actor}",
    "code": "public static ActivityObject buildActor(Post post) {\n    ActivityObject actor = new ActivityObject();\n    try {\n        actor.setId(formatId(Optional.fromNullable(post.getFrom().getId()).or(Optional.of(post.getFrom().getId())).orNull()));\n        actor.setDisplayName(post.getFrom().getName());\n        actor.setAdditionalProperty(STR, post.getFrom().getName());\n    } catch (Exception e) {\n        LOGGER.error(STR, post, e);\n    }\n    return actor;\n}",
    "label": 1,
    "rec": "@return {@link org.apache.streams.pojo.json.ActivityObject}"
  },
  {
    "id": 2507,
    "type": "Return",
    "comment": "@return Value.",
    "code": "    @Nullable @Override public CacheObject unswap(boolean needVal)\n        throws IgniteCheckedException, GridCacheEntryRemovedException {\n        boolean swapEnabled = cctx.swap().swapEnabled();\n\n        if (!swapEnabled && !cctx.isOffHeapEnabled() && !cctx.isDatabaseEnabled())\n            return null;\n\n        synchronized (this) {\n            checkObsolete();\n\n            if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {\n                if (cctx.isDatabaseEnabled()) {\n                    IgniteBiTuple<CacheObject, GridCacheVersion> read = cctx.queries().read(key);\n\n                    flags |= IS_UNSWAPPED_MASK;\n\n                    if (read != null) {\n                        CacheObject idxVal = read.get1();\n\n                        // Set unswapped value.\n                        update(idxVal, 0, 0, read.get2());\n\n                        return idxVal;\n                    }\n                }\n                else {\n                    GridCacheSwapEntry e;\n\n                    if (cctx.offheapTiered()) {\n                        e = cctx.swap().readOffheapPointer(this);\n\n                        if (e != null) {\n                            if (e.offheapPointer() > 0) {\n                                offHeapPointer(e.offheapPointer());\n\n                                flags |= IS_OFFHEAP_PTR_MASK;\n\n                                if (needVal) {\n                                    CacheObject val = cctx.fromOffheap(offHeapPointer(), false);\n\n                                    e.value(val);\n                                }\n                            }\n                            else // Read from swap.\n                                offHeapPointer(0);\n                        }\n                    }\n                    else\n                        e = detached() ? cctx.swap().read(this, true, true, true, false) : cctx.swap().readAndRemove(this);\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Read swap entry [swapEntry=\" + e + \", cacheEntry=\" + this + ']');\n\n                    flags |= IS_UNSWAPPED_MASK;\n\n                    // If there is a value.\n                    if (e != null) {\n                        long delta = e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis();\n\n                        if (delta >= 0) {\n                            CacheObject val = e.value();\n\n                            val = cctx.kernalContext().cacheObjects().prepareForCache(val, cctx);\n\n                            // Set unswapped value.\n                            update(val, e.expireTime(), e.ttl(), e.version());\n\n                            // Must update valPtr again since update() will reset it.\n                            if (cctx.offheapTiered() && e.offheapPointer() > 0)\n                                offHeapPointer(e.offheapPointer());\n\n                            return val;\n                        }\n                        else\n                            clearIndex(e.value(), e.version());\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2508,
    "type": "Return",
    "comment": "@return true if this parent node has any child nodes besides text",
    "code": "public boolean hasChildren() {\n    return children().iterator().hasNext();\n}",
    "label": 1,
    "rec": "@return true if this parent node has any child nodes"
  },
  {
    "id": 2509,
    "type": "Return",
    "comment": "@return Collection of all nodes.",
    "code": "    public Collection<GridTcpDiscoveryNode> allNodes() {\n        rwLock.readLock().lock();\n\n        try {\n            return Collections.unmodifiableCollection(nodesMap.values());\n        }\n        finally {\n            rwLock.readLock().unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2510,
    "type": "Return",
    "comment": "@return a remote invocation object containing the current session ID.",
    "code": "    public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {\n        String sessionId = System.getProperty(SESSION_ID_SYSTEM_PROPERTY_NAME);\n        if( sessionId == null ) {\n            throw new IllegalStateException( \"System property [\" + SESSION_ID_SYSTEM_PROPERTY_NAME + \"] is not set.  \" +\n                    \"This property must be set to the JSecurity session ID for remote calls to function.\" );\n        }\n        RemoteInvocation ri = new RemoteInvocation(methodInvocation);\n        ri.addAttribute( SESSION_ID_KEY, sessionId );\n\n        return ri;\n    }\n",
    "label": 1,
    "rec": "@return a remote invocation object containing the current session ID as an attribute."
  },
  {
    "id": 2511,
    "type": "Return",
    "comment": "@return true if registration of  keyManager was successful, false if there already exisits a key manager for  keyManager.getKeyType().",
    "code": "  public static boolean registerKeyManager(final KeyManager<PublicKeyVerify> keyManager)\n      throws GeneralSecurityException {\n    return Registry.registerKeyManager(keyManager.getKeyType(), keyManager);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2512,
    "type": "Return",
    "comment": "@return A new empty context with no parent context.",
    "code": "static public IEclipseContext create() {\n    return new EclipseContext(null, null);\n}",
    "label": 1,
    "rec": "@return A new empty context."
  },
  {
    "id": 2513,
    "type": "Return",
    "comment": "@return Portable marshaller.",
    "code": "    protected BinaryMarshaller createMarshaller() throws Exception {\n        PortableContext ctx = new PortableContext(BinaryCachingMetadataHandler.create(), new IgniteConfiguration());\n\n        BinaryMarshaller marsh = new BinaryMarshaller();\n\n        BinaryConfiguration bCfg = new BinaryConfiguration();\n        \n        bCfg.setCompactFooter(compactFooter());\n\n        bCfg.setTypeConfigurations(Arrays.asList(\n            new BinaryTypeConfiguration(TestObject.class.getName()),\n            new BinaryTypeConfiguration(TestOuterObject.class.getName()),\n            new BinaryTypeConfiguration(TestInnerObject.class.getName())\n        ));\n\n        IgniteConfiguration iCfg = new IgniteConfiguration();\n\n        iCfg.setBinaryConfiguration(bCfg);\n\n        marsh.setContext(new MarshallerContextTestImpl(null));\n\n        IgniteUtils.invoke(BinaryMarshaller.class, marsh, \"setPortableContext\", ctx, iCfg);\n\n        return marsh;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2514,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "public static Collection<URL> forManifest(final Iterable<URL> urls) {\n    Collection<URL> result = new ArrayList<URL>();\n    for (URL url : urls) {\n        result.addAll(forManifest(url));\n    }\n    return distinctUrls(result);\n}",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 2515,
    "type": "Return",
    "comment": "@return  True if all locks are owned.",
    "code": "    private boolean checkLocks() {\n        boolean locked = lockKeys.isEmpty();\n\n        if (locked) {\n            if (log.isDebugEnabled())\n                log.debug(\"All locks are acquired for near prepare future: \" + this);\n        }\n        else {\n            if (log.isDebugEnabled())\n                log.debug(\"Still waiting for locks [fut=\" + this + \", keys=\" + lockKeys + ']');\n        }\n\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2516,
    "type": "Return",
    "comment": "@return height of each row",
    "code": "public int getItemHeight() {\n    checkWidget();\n    return itemHeight;\n}",
    "label": 1,
    "rec": "@return default height of items"
  },
  {
    "id": 2517,
    "type": "Return",
    "comment": "@return Prepare future.",
    "code": "            @Override public GridNearTxPrepareResponse apply(IgniteInternalFuture<GridNearTxPrepareResponse> f) {\n                try {\n                    return f.get();\n                }\n                catch (Exception e) {\n                    locTx.setRollbackOnly(); // Just in case.\n\n                    if (!X.hasCause(e, IgniteTxOptimisticCheckedException.class) &&\n                        !X.hasCause(e, IgniteFutureCancelledException.class))\n                        U.error(log, \"Failed to prepare DHT transaction: \" + locTx, e);\n\n                    return new GridNearTxPrepareResponse(\n                        req.version(),\n                        req.futureId(),\n                        req.miniId(),\n                        req.version(),\n                        req.version(),\n                        null,\n                        e,\n                        null,\n                        req.deployInfo() != null);\n                }\n            }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2518,
    "type": "Return",
    "comment": "@return The SQL date equivalent of the <code>c</code> Calendar.",
    "code": "static final Timestamp calendarToSqlDate(Calendar c) {\n    return c == null ? null : new Timestamp(c.getTimeInMillis());\n}",
    "label": 1,
    "rec": "@return The SQL timestamp equivalent of the <code>c</code> Calendar."
  },
  {
    "id": 2519,
    "type": "Return",
    "comment": "@return Nodes for the keys.",
    "code": "    public Collection<GridNode> remoteNodes(Iterable<? extends K> keys, long topVer) {\n        Collection<Collection<GridNode>> colcol = new GridLeanSet<>();\n\n        for (K key : keys)\n            colcol.add(nodes(key, topVer));\n\n        return F.view(F.flatCollections(colcol), F.remoteNodes(cctx.localNodeId()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2520,
    "type": "Return",
    "comment": "@return NIL, by default. Overridable by the receiver.",
    "code": "public ATObject prim_sendTo(ATMessage self, ATObject receiver, ATObject sender) throws InterpreterException {\n    return sender.meta_send(receiver, self.asAsyncMessage());\n}",
    "label": 1,
    "rec": "@return NIL, by default. Overridable by the sender."
  },
  {
    "id": 2521,
    "type": "Return",
    "comment": "@return Query with range.",
    "code": "        protected String loadCacheRangeQuery(boolean appendLowerBound, boolean appendUpperBound) {\n            return dialect.loadCacheRangeQuery(fullTblName, keyCols, cols, appendLowerBound, appendUpperBound);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2522,
    "type": "Return",
    "comment": "@return New session.",
    "code": "    private WebSession createSession(HttpServletRequest httpReq) {\n        HttpSession ses = httpReq.getSession(true);\n\n        String sesId = sesIdTransformer != null ? sesIdTransformer.apply(ses.getId()) : ses.getId();\n\n        if (log.isDebugEnabled())\n            log.debug(\"Session created: \" + sesId);\n\n        WebSession cached = new WebSession(ses, true);\n\n        for (int i = 0; i < retries; i++) {\n            try {\n                IgniteCache<String, WebSession> cache0;\n\n                if (cached.getMaxInactiveInterval() > 0) {\n                    long ttl = cached.getMaxInactiveInterval() * 1000;\n\n                    ExpiryPolicy plc = new ModifiedExpiryPolicy(new Duration(MILLISECONDS, ttl));\n\n                    cache0 = cache.withExpiryPolicy(plc);\n                }\n                else\n                    cache0 = cache;\n\n                WebSession old = cache0.getAndPutIfAbsent(sesId, cached);\n\n                if (old != null) {\n                    cached = old;\n\n                    if (cached.isNew())\n                        cached = new WebSession(cached, false);\n                }\n\n                break;\n            }\n            catch (CacheException | IgniteException e) {\n                if (log.isDebugEnabled())\n                    log.debug(e.getMessage());\n\n                if (i == retries - 1)\n                    throw new IgniteException(\"Failed to save session: \" + sesId, e);\n                else {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Failed to save session (will retry): \" + sesId);\n\n                    IgniteFuture<?> retryFut = null;\n\n                    if (X.hasCause(e, ClusterTopologyException.class)) {\n                        ClusterTopologyException cause = X.cause(e, ClusterTopologyException.class);\n\n                        assert cause != null : e;\n\n                        retryFut = cause.retryReadyFuture();\n                    }\n\n                    if (retryFut != null) {\n                        try {\n                            retryFut.get();\n                        }\n                        catch (IgniteException retryErr) {\n                            throw new IgniteException(\"Failed to save session: \" + sesId, retryErr);\n                        }\n                    }\n                }\n            }\n        }\n\n        return cached;\n    }\n",
    "label": 1,
    "rec": "@return Cached session."
  },
  {
    "id": 2523,
    "type": "Return",
    "comment": "@return Result code.",
    "code": "    private Result removeDown(final Remove r, final long pageId, final long backId, final long fwdId, final int lvl)\n        throws IgniteCheckedException {\n        assert lvl >= 0 : lvl;\n\n        if (r.isTail(pageId, lvl))\n            return FOUND; // We've already locked this page, so return that we are ok.\n\n        final Page page = page(pageId);\n\n        try {\n            for (;;) {\n                // Init args.\n                r.pageId = pageId;\n                r.fwdId = fwdId;\n                r.backId = backId;\n\n                Result res = readPage(pageId, page, search, r, lvl);\n\n                switch (res) {\n                    case GO_DOWN_X:\n                        assert backId != 0;\n\n                        // We need to get backId here for our child page, it must be the last child of our back.\n                        res = askNeighbor(backId, r, true);\n\n                        if (res != FOUND)\n                            return res; // Retry.\n\n                        // Intentional fallthrough.\n                    case GO_DOWN:\n                        res = removeDown(r, r.pageId, r.backId, r.fwdId, lvl - 1);\n\n                        switch (res) {\n                            case RETRY:\n                                checkInterrupted();\n\n                                continue;\n\n                            case RETRY_ROOT:\n                                return res;\n                        }\n\n                        if (!r.isFinished() && !r.finishTail())\n                            return r.lockTail(pageId, page, backId, fwdId, lvl);\n\n                        return res;\n\n                    case NOT_FOUND:\n                        // We are at the bottom.\n                        assert lvl == 0: lvl;\n\n                        if (!r.ceil) {\n                            r.finish();\n\n                            return res;\n                        }\n\n                        // Intentional fallthrough for ceiling remove.\n\n                    case FOUND:\n                        // We must be at the bottom here, just need to remove row from the current page.\n                        assert lvl == 0 : lvl;\n                        assert r.removed == null;\n\n                        res = r.removeFromLeaf(pageId, page, backId, fwdId);\n\n                        if (res == NOT_FOUND) {\n                            assert r.ceil: \"must be a retry if not a ceiling remove\";\n\n                            r.finish();\n                        }\n                        else if (res == FOUND && r.tail == null) {\n                            // Finish if we don't need to do any merges.\n                            r.finish();\n                        }\n\n                        return res;\n\n                    default:\n                        return res;\n                }\n            }\n        }\n        finally {\n            r.page = null;\n\n            if (r.canRelease(pageId, page, lvl))\n                page.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2524,
    "type": "Return",
    "comment": "@return a DefaultProcessorURI",
    "code": "protected CrawlURI defaultURI() throws Exception {\n    UURI uuri = UURIFactory.getInstance(STR);\n    return new CrawlURI(uuri, null, null, LinkContext.NAVLINK_MISC);\n}",
    "label": 1,
    "rec": "@return a CrawlURI"
  },
  {
    "id": 2525,
    "type": "Return",
    "comment": "@return result of invocation of fallback method or RuntimeException",
    "code": "    protected Object getFallback() {\n        if (getFallbackAction() != null) {\n            return process(new Action() {\n                @Override\n                Object execute() {\n                    return getFallbackAction().execute(ExecutionType.SYNCHRONOUS);\n                }\n            });\n\n        } else {\n            return super.getFallback();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2526,
    "type": "Return",
    "comment": "@return all types in a mapped with fully qualified type name (incl module spec) as key, the type info conly contains the types, no other information yet.",
    "code": "public Collection<SpecInfo> readN4JSDs(Collection<IN4JSProject> projects, Function<IN4JSProject, ResourceSet> resSetProvider, SubMonitorMsg monitor) throws InterruptedException {\n    Multimap<String, SpecInfo> specInfoByName = HashMultimap.create();\n    ResourceSet resSet = null;\n    SubMonitorMsg sub = monitor.convert(NUM * NUM * projects.size());\n    for (IN4JSProject project : projects) {\n        if (resSet == null) {\n            resSet = resSetProvider.apply(project);\n        }\n        readScripts(specInfoByName, project, resSet, sub.newChild(NUM));\n    }\n    for (IN4JSProject project : projects) {\n        if (resSet == null) {\n            resSet = resSetProvider.apply(project);\n        }\n        linkTests(specInfoByName, project, resSet, sub.newChild(NUM));\n    }\n    return specInfoByName.values();\n}",
    "label": 1,
    "rec": "@return all types in a mapped with fully qualified type name (inclusive module spec) as key, the type info only contains the types, no other information yet."
  },
  {
    "id": 2527,
    "type": "Return",
    "comment": "@return  org.apache.shiro.web.servlet.AbstractShiroFilter.class",
    "code": "    public Class getObjectType() {\n        return SpringShiroFilter.class;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2528,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder commandActions(CommandActions pCommandActions) {\n    this.commandActions = pCommandActions;\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 2529,
    "type": "Return",
    "comment": "@return result of execution",
    "code": "    public Object executeWithArgs(ExecutionType executionType, Object[] args) throws CommandActionExecutionException {\n        if (ExecutionType.SYNCHRONOUS.equals(executionType)) {\n            return execute(object, method, args);\n        } else {\n            Closure closure = ClosureFactoryRegistry.getFactory(executionType).createClosure(metaHolder, method, object, args);\n            return executeClj(closure.getClosureObj(), closure.getClosureMethod());\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2530,
    "type": "Return",
    "comment": "@return the in-vm tracer or null if it could not be loaded (perhaps because we're not on the server ?)",
    "code": "protected static ITracerFactory checkForServerTracer() {\n    try {\n        Class<?> clazz = Class.forName(SERVER_TRACER_NAME);\n        Method meth = clazz.getDeclaredMethod(STR);\n        ITracerFactory itf = (ITracerFactory) meth.invoke(null);\n        return itf;\n    } catch (Exception ex) {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return the in-vm tracer factory or null if it could not be loaded (perhaps because we're not on the server ?)"
  },
  {
    "id": 2531,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    protected CacheConfiguration cacheConfiguration(String gridName) throws Exception {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n\n        cfg.setSwapEnabled(swapEnabled());\n        cfg.setCacheMode(cacheMode());\n        cfg.setAtomicityMode(atomicityMode());\n\n        if (atomicityMode() == ATOMIC && cacheMode() != LOCAL) {\n            assert atomicWriteOrderMode() != null;\n\n            cfg.setAtomicWriteOrderMode(atomicWriteOrderMode());\n        }\n\n        cfg.setWriteSynchronizationMode(writeSynchronization());\n        cfg.setDistributionMode(distributionMode());\n        cfg.setPortableEnabled(portableEnabled());\n\n        cfg.setCacheLoaderFactory(loaderFactory());\n\n        if (cfg.getCacheLoaderFactory() != null)\n            cfg.setReadThrough(true);\n\n        cfg.setCacheWriterFactory(writerFactory());\n\n        if (cfg.getCacheWriterFactory() != null)\n            cfg.setWriteThrough(true);\n\n        CacheStore<?, ?> store = cacheStore();\n\n        if (store != null) {\n            cfg.setCacheStoreFactory(new FactoryBuilder.SingletonFactory(store));\n            cfg.setReadThrough(true);\n            cfg.setWriteThrough(true);\n            cfg.setLoadPreviousValue(true);\n        }\n\n        if (cacheMode() == PARTITIONED)\n            cfg.setBackups(1);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2532,
    "type": "Return",
    "comment": "@return The current IconExtDrawable for chaining.",
    "code": "public IconicsDrawable icon(Character icon) {\n    return iconText(icon.toString(), null);\n}",
    "label": 1,
    "rec": "@return The current IconicsDrawable for chaining."
  },
  {
    "id": 2533,
    "type": "Return",
    "comment": "@return Old value.",
    "code": "    CacheObject oldValue() {\n        return oldVal;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2534,
    "type": "Return",
    "comment": "@return the default options vector.",
    "code": "public static Map<String, Double> jp_jpoption(String name1, Double value1, String name2, Double value2, String name3, Double value3, String name4, Double value4, String name5, Double value5, String name6, Double value6, String name7, Double value7) {\n    return jp_jpoption(null, name1, value1, name2, value2, name3, value3, name4, value4, name5, value5, name6, value6, name7, value7);\n}",
    "label": 1,
    "rec": "@return the default options vector with new values for the given options"
  },
  {
    "id": 2535,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private ComputeJob job(final Callable<?> c) {\n        A.notNull(c, \"job\");\n\n        if (c instanceof ComputeJobMasterLeaveAware)\n            return new C2(c);\n        else {\n            return new ComputeJobAdapter() {\n                @Override public Object execute() {\n                    try {\n                        return c.call();\n                    }\n                    catch (Exception e) {\n                        throw new IgniteException(e);\n                    }\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2536,
    "type": "Return",
    "comment": "@return an ordered list of RestCall objects",
    "code": "public List<RestCall> getCalls() {\n    return Collections.unmodifiableList(itsCalls);\n}",
    "label": 1,
    "rec": "@return an ordered list of RestCall objects. This is not a modifibale list."
  },
  {
    "id": 2537,
    "type": "Return",
    "comment": "@return New message.",
    "code": "    private static GridTcpCommunicationMessageAdapter create0(byte type) {\n        switch (type) {\n            case 0:\n                return new GridJobCancelRequest();\n\n            case 1:\n                return new GridJobExecuteRequest();\n\n            case 2:\n                return new GridJobExecuteResponse();\n\n            case 3:\n                return new GridJobSiblingsRequest();\n\n            case 4:\n                return new GridJobSiblingsResponse();\n\n            case 5:\n                return new GridTaskCancelRequest();\n\n            case 6:\n                return new GridTaskSessionRequest();\n\n            case 7:\n                return new GridCheckpointRequest();\n\n            case 8:\n                return new GridIoMessage();\n\n            case 9:\n                return new GridIoUserMessage();\n\n            case 10:\n                return new GridDeploymentInfoBean();\n\n            case 11:\n                return new GridDeploymentRequest();\n\n            case 12:\n                return new GridDeploymentResponse();\n\n            case 13:\n                return new GridEventStorageMessage();\n\n            case 14:\n                return new GridCacheDgcRequest();\n\n            case 15:\n                return new GridCacheDgcResponse();\n\n            case 16:\n                return new GridCacheEvictionRequest();\n\n            case 17:\n                return new GridCacheEvictionResponse();\n\n            case 18:\n                return new GridCacheOptimisticCheckPreparedTxRequest();\n\n            case 19:\n                return new GridCacheOptimisticCheckPreparedTxResponse();\n\n            case 20:\n                return new GridCachePessimisticCheckCommittedTxRequest();\n\n            case 21:\n                return new GridCachePessimisticCheckCommittedTxResponse();\n\n            case 22:\n                return new GridDistributedLockRequest();\n\n            case 23:\n                return new GridDistributedLockResponse();\n\n            case 24:\n                return new GridDistributedTxFinishRequest();\n\n            case 25:\n                return new GridDistributedTxFinishResponse();\n\n            case 26:\n                return new GridDistributedTxPrepareRequest();\n\n            case 27:\n                return new GridDistributedTxPrepareResponse();\n\n            case 28:\n                return new GridDistributedUnlockRequest();\n\n            case 29:\n                return new GridDhtLockRequest();\n\n            case 30:\n                return new GridDhtLockResponse();\n\n            case 31:\n                return new GridDhtTxFinishRequest();\n\n            case 32:\n                return new GridDhtTxFinishResponse();\n\n            case 33:\n                return new GridDhtTxPrepareRequest();\n\n            case 34:\n                return new GridDhtTxPrepareResponse();\n\n            case 35:\n                return new GridDhtUnlockRequest();\n\n            case 36:\n                return new GridDhtAtomicDeferredUpdateResponse();\n\n            case 37:\n                return new GridDhtAtomicUpdateRequest();\n\n            case 38:\n                return new GridDhtAtomicUpdateResponse();\n\n            case 39:\n                return new GridNearAtomicUpdateRequest();\n\n            case 40:\n                return new GridNearAtomicUpdateResponse();\n\n            case 41:\n                return new GridDhtForceKeysRequest();\n\n            case 42:\n                return new GridDhtForceKeysResponse();\n\n            case 43:\n                return new GridDhtPartitionDemandMessage();\n\n            case 44:\n                return new GridDhtPartitionSupplyMessage();\n\n            case 45:\n                return new GridDhtPartitionsFullMessage();\n\n            case 46:\n                return new GridDhtPartitionsSingleMessage();\n\n            case 47:\n                return new GridDhtPartitionsSingleRequest();\n\n            case 48:\n                return new GridNearGetRequest();\n\n            case 49:\n                return new GridNearGetResponse();\n\n            case 50:\n                return new GridNearLockRequest();\n\n            case 51:\n                return new GridNearLockResponse();\n\n            case 52:\n                return new GridNearTxFinishRequest();\n\n            case 53:\n                return new GridNearTxFinishResponse();\n\n            case 54:\n                return new GridNearTxPrepareRequest();\n\n            case 55:\n                return new GridNearTxPrepareResponse();\n\n            case 56:\n                return new GridNearUnlockRequest();\n\n            case 57:\n                return new GridCacheQueryRequest();\n\n            case 58:\n                return new GridCacheQueryResponse();\n\n            case 59:\n                return new GridClockDeltaSnapshotMessage();\n\n            case 60:\n                return new GridContinuousMessage();\n\n            case 61:\n                return new GridDataLoadRequest();\n\n            case 62:\n                return new GridDataLoadResponse();\n\n            case 63:\n                return new GridDrInternalRequest();\n\n            case 64:\n                return new GridDrInternalResponse();\n\n            case 65:\n                return new GridGgfsAckMessage();\n\n            case 66:\n                return new GridGgfsBlockKey();\n\n            case 67:\n                return new GridGgfsBlocksMessage();\n\n            case 68:\n                return new GridGgfsDeleteMessage();\n\n            case 69:\n                return new GridGgfsFileAffinityRange();\n\n            case 70:\n                return new GridGgfsFragmentizerRequest();\n\n            case 71:\n                return new GridGgfsFragmentizerResponse();\n\n            case 72:\n                return new GridGgfsSyncMessage();\n\n            case 73:\n                return new GridTaskResultRequest();\n\n            case 74:\n                return new GridTaskResultResponse();\n\n            case 75:\n                return new GridStreamerCancelRequest();\n\n            case 76:\n                return new GridStreamerExecutionRequest();\n\n            case 77:\n                return new GridStreamerResponse();\n\n            case 78:\n                return new GridJobStealingRequest();\n\n            case 79:\n                return new GridDhtAffinityAssignmentRequest<>();\n\n            case 80:\n                return new GridDhtAffinityAssignmentResponse<>();\n\n            default:\n                return createCustom(type);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2538,
    "type": "Return",
    "comment": "@return TypeX for the annotation",
    "code": "public UnresolvedType getAnnotationTypeX() {\n    ensureAnnotationDiscovered();\n    return this.annotation.getSignature();\n}",
    "label": 1,
    "rec": "@return UnresolvedType for the annotation"
  },
  {
    "id": 2539,
    "type": "Return",
    "comment": "@return Exchange type.",
    "code": "    private ExchangeType onServerNodeEvent(boolean crd) throws IgniteCheckedException {\n        assert !CU.clientNode(discoEvt.eventNode()) : this;\n\n        if (discoEvt.type() == EVT_NODE_LEFT || discoEvt.type() == EVT_NODE_FAILED) {\n            onLeft();\n\n            warnNoAffinityNodes();\n\n            centralizedAff = cctx.affinity().onServerLeft(this);\n        }\n        else {\n            assert discoEvt.type() == EVT_NODE_JOINED : discoEvt;\n\n            cctx.affinity().onServerJoin(this, crd);\n        }\n\n        if (cctx.kernalContext().clientNode())\n            return ExchangeType.CLIENT;\n        else\n            return ExchangeType.ALL;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2540,
    "type": "Return",
    "comment": "@return Page ID.",
    "code": "    private long getLeftmostPageId(Page meta, int lvl) {\n        ByteBuffer buf = meta.getForRead();\n\n        try {\n            MetaPageIO io = MetaPageIO.forPage(buf);\n\n            if (lvl == Integer.MIN_VALUE)\n                lvl = io.getRootLevel(buf);\n            else\n                assert lvl <= io.getRootLevel(buf);\n\n            return io.getLeftmostPageId(buf, lvl);\n        }\n        finally {\n            meta.releaseRead();\n        }\n    }\n",
    "label": 1,
    "rec": "@return Root page ID."
  },
  {
    "id": 2541,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    private CacheConfiguration cacheConfiguration() {\n        CacheConfiguration cfg = new CacheConfiguration();\n\n        cfg.setBackups(backups);\n\n        cfg.setCacheMode(GridCacheMode.PARTITIONED);\n\n        cfg.setDistributionMode(GridCacheDistributionMode.PARTITIONED_ONLY);\n\n        cfg.setAffinity(new GridCachePartitionFairAffinity(parts));\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2542,
    "type": "Return",
    "comment": "@return a list of values whose time intervals overlap with a [ low,  high] time interval.",
    "code": "\tpublic List<T> getValues(Interval<T> interval) {\n\t\tList<T> result = new ArrayList<T>();\n\t\tfor (Interval<T> i : intervalTree.search(interval))\n\t\t\tresult.add(i.getValue());\n\t\treturn result;\n\t}\n",
    "label": 1,
    "rec": "@return a list of values whose time intervals overlap with a given time interval."
  },
  {
    "id": 2543,
    "type": "Return",
    "comment": "@return Configuration copy.",
    "code": "    private CacheConfiguration cloneCheckSerializable(CacheConfiguration val) throws IgniteCheckedException {\n        if (val == null)\n            return null;\n\n        IgniteCacheObjectProcessor objProc = ctx.cacheObjects();\n        BinaryContext oldCtx = null;\n\n        if (objProc instanceof CacheObjectBinaryProcessorImpl) {\n            GridBinaryMarshaller binMarsh = ((CacheObjectBinaryProcessorImpl)objProc).marshaller();\n\n            oldCtx = binMarsh == null ? null : binMarsh.pushContext();\n        }\n\n        try {\n            if (val.getCacheStoreFactory() != null) {\n                try {\n                    marshaller.unmarshal(marshaller.marshal(val.getCacheStoreFactory()),\n                        val.getCacheStoreFactory().getClass().getClassLoader());\n                }\n                catch (IgniteCheckedException e) {\n                    throw new IgniteCheckedException(\"Failed to validate cache configuration. \" +\n                        \"Cache store factory is not serializable. Cache name: \" + U.maskName(val.getName()), e);\n                }\n            }\n\n            try {\n                return marshaller.unmarshal(marshaller.marshal(val), U.resolveClassLoader(ctx.config().getClassLoader()));\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteCheckedException(\"Failed to validate cache configuration \" +\n                    \"(make sure all objects in cache configuration are serializable): \" + U.maskName(val.getName()), e);\n            }\n        }\n        finally {\n            if (objProc instanceof CacheObjectBinaryProcessorImpl)\n                GridBinaryMarshaller.popContext(oldCtx);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2544,
    "type": "Return",
    "comment": "@return A new empty context with the given parent and strategy",
    "code": "static public IEclipseContext create(String name) {\n    IEclipseContext result = create();\n    result.set(EclipseContext.DEBUG_STRING, name);\n    return result;\n}",
    "label": 1,
    "rec": "@return A new empty context."
  },
  {
    "id": 2545,
    "type": "Return",
    "comment": "@return Queue.",
    "code": "    private static IgniteQueue<String> initializeQueue(Ignite g, String queueName) throws IgniteCheckedException {\n        // Initialize new FIFO queue.\n        IgniteQueue<String> queue = g.cache(CACHE_NAME).dataStructures().queue(queueName, 0, false, true);\n\n        // Initialize queue items.\n        // We will be use blocking operation and queue size must be appropriated.\n        for (int i = 0; i < g.cluster().nodes().size() * RETRIES * 2; i++)\n            queue.put(Integer.toString(i));\n\n        System.out.println(\"Queue size after initializing: \" + queue.size());\n\n        return queue;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2546,
    "type": "Return",
    "comment": "@return modifiable list of attribute ids",
    "code": "public List<? extends GoogleBaseAttributeId> getAttributeIds() {\n    return getGmAttributesExtension().getAttributeIds();\n}",
    "label": 1,
    "rec": "@return unmodifiable list of attribute ids"
  },
  {
    "id": 2547,
    "type": "Return",
    "comment": "@return Indexing SPI implementation or null to use default implementation.",
    "code": "    public GridIndexingSpi getIndexingSpi() {\n        return indexingSpi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2548,
    "type": "Return",
    "comment": "@return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.",
    "code": "public Class<?>[] rawExtraInterfaces() {\n    List<Type> extraInterfaces = extraInterfaces();\n    List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n    for (Type extraInterface : extraInterfaces) {\n        Class<?> rawInterface = extractRawTypeOf(extraInterface);\n        if (!rawType().equals(rawInterface)) {\n            rawExtraInterfaces.add(rawInterface);\n        }\n    }\n    return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n}",
    "label": 1,
    "rec": "@return Returns an array with the extracted raw types of {@link #extraInterfaces()}."
  },
  {
    "id": 2549,
    "type": "Return",
    "comment": "@return  True if given node is client node (has flag  IgniteConfiguration#isClientMode() set).",
    "code": "    public static boolean clientNode(ClusterNode node) {\n        if (node instanceof TcpDiscoveryNode)\n            return ((TcpDiscoveryNode)node).isCacheClient();\n        else\n            return clientNodeDirect(node);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2550,
    "type": "Return",
    "comment": "@return the pathname",
    "code": "private static String getWebAppsPath() throws IOException {\n    URL url = StatusHttpServer.class.getClassLoader().getResource(STR);\n    if (url == null)\n        throw new IOException(STR);\n    return url.toString();\n}",
    "label": 1,
    "rec": "@return the pathname as a URL"
  },
  {
    "id": 2551,
    "type": "Return",
    "comment": "@return Future.",
    "code": "        public IgniteFuture future() {\n            return fut;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2552,
    "type": "Return",
    "comment": "@return RMSEs with first 1, 2, ..., regression trees.",
    "code": "    public double[][] test(DataFrame data) {\n        DataFrame x = formula.x(data);\n\n        int n = x.nrows();\n        double[] sum = new double[n];\n        int ntrees = trees.length;\n        double[][] prediction = new double[ntrees][n];\n\n        for (int j = 0; j < n; j++) {\n            Tuple xi = x.get(j);\n            double base = 0;\n            for (int i = 0; i < ntrees; i++) {\n                base = base + trees[i].predict(xi);\n                prediction[i][j] = base / (i+1);\n            }\n        }\n\n        return prediction;\n    }\n",
    "label": 1,
    "rec": "@return the predictions with first 1, 2, ..., regression trees."
  },
  {
    "id": 2553,
    "type": "Return",
    "comment": "@return true if two double values equals to each other in the system precision",
    "code": "    public static boolean equals(double a, double b) {\n        if (a == b) {\n            return true;\n        }\n        \n        double absa = abs(a);\n        double absb = abs(b);\n        return abs(a - b) <= Math.min(absa, absb) * 2.2204460492503131e-16;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2554,
    "type": "Return",
    "comment": "@return the argument.",
    "code": "String getArgument(int index) {\n    if (index < this.Arguments.size()) {\n        return this.Arguments.get(index);\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return the argument or null if there is no argument at the specified index."
  },
  {
    "id": 2555,
    "type": "Return",
    "comment": "@return Marshalled byte array.",
    "code": "    private byte[] marshal(Object obj) throws GridException {\n        return cctx.portableEnabled() ?\n            cctx.portable().marshal(obj).array() :\n            cctx.marshaller().marshal(obj);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2556,
    "type": "Return",
    "comment": "@return if the server is configured to use signed pushes.",
    "code": "public boolean enabled() {\n    return enabled;\n}",
    "label": 1,
    "rec": "@return if the repository is configured to use signed pushes in this context."
  },
  {
    "id": 2557,
    "type": "Return",
    "comment": "@return Pointer.",
    "code": "    protected long allocate(int cap) {\n        return GridUnsafe.allocateMemory(cap);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2558,
    "type": "Return",
    "comment": "@return B - the build or null",
    "code": "@SuppressWarnings(UNUSED)\n@CheckForNull\n@Exported\npublic Run getFirstBuild() {\n    Run retVal = null;\n    for (Job job : getAllJobs()) {\n        Run run = job.getFirstBuild();\n        if (run != null && (retVal == null || run.getTimestamp().before(retVal.getTimestamp()))) {\n            retVal = run;\n        }\n    }\n    return retVal;\n}",
    "label": 1,
    "rec": "@return the build or null"
  },
  {
    "id": 2559,
    "type": "Return",
    "comment": "@return Permission object",
    "code": "    public static Permission loadPermission(String name, Map<?, ?> data, PermissionDefault def, List<Permission> output) {\n        Validate.notNull(name, \"Name cannot be null\");\n        Validate.notNull(data, \"Data cannot be null\");\n\n        String desc = null;\n        Map<String, Boolean> children = null;\n\n        if (data.get(\"default\") != null) {\n            PermissionDefault value = PermissionDefault.getByName(data.get(\"default\").toString());\n            if (value != null) {\n                def = value;\n            } else {\n                throw new IllegalArgumentException(\"'default' key contained unknown value\");\n            }\n        }\n\n        if (data.get(\"children\") != null) {\n            Object childrenNode = data.get(\"children\");\n            if (childrenNode instanceof Iterable) {\n                children = new LinkedHashMap<String, Boolean>();\n                for (Object child : (Iterable<?>) childrenNode) {\n                    if (child != null) {\n                        children.put(child.toString(), Boolean.TRUE);\n                    }\n                }\n            } else if (childrenNode instanceof Map) {\n                children = extractChildren((Map<?,?>) childrenNode, name, def, output);\n            } else {\n                throw new IllegalArgumentException(\"'children' key is of wrong type\");\n            }\n        }\n\n        if (data.get(\"description\") != null) {\n            desc = data.get(\"description\").toString();\n        }\n\n        return new Permission(name, desc, def, children);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2560,
    "type": "Return",
    "comment": "@return the sliding average elapsed time in ms. of the last 15 catalog calls",
    "code": "@ManagedMetric(category = STR, displayName = STR, metricType = org.springframework.jmx.support.MetricType.GAUGE, description = STR)\npublic long getAverageCallTimeMs() {\n    return TimeUnit.MILLISECONDS.convert(getAverageCallTimeNs(), TimeUnit.NANOSECONDS);\n}",
    "label": 1,
    "rec": "@return the sliding average elapsed time in ms. of the last 50 catalog calls"
  },
  {
    "id": 2561,
    "type": "Return",
    "comment": "@return Return value.",
    "code": "    public GridCacheReturn<Object> returnValue() {\n        return retVal;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2562,
    "type": "Return",
    "comment": "@return the name of relation.",
    "code": "    private void readHeader() throws IOException, ParseException {\n        List<StructField> fields = new ArrayList<>();\n\n        // Get name of relation.\n        getFirstToken();\n        if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n            throw new ParseException(PREMATURE_END_OF_FILE, tokenizer.lineno());\n        }\n        if (ARFF_RELATION.equalsIgnoreCase(tokenizer.sval)) {\n            getNextToken();\n            name = tokenizer.sval;\n            logger.info(\"Read ARFF relation {}\", name);\n            getLastToken(false);\n        } else {\n            throw new ParseException(\"keyword \" + ARFF_RELATION + \" expected\", tokenizer.lineno());\n        }\n\n        // Get attribute declarations.\n        getFirstToken();\n        if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n            throw new ParseException(PREMATURE_END_OF_FILE, tokenizer.lineno());\n        }\n\n        while (ARFF_ATTRIBUTE.equalsIgnoreCase(tokenizer.sval)) {\n            StructField attribute = parseAttribute();\n            // We may meet an relational attribute, which parseAttribute returns null\n            // as it flats the relational attribute out.\n            if (attribute != null) {\n                fields.add(parseAttribute());\n            }\n        }\n\n        // Check if data part follows. We can't easily check for EOL.\n        if (!ARFF_DATA.equalsIgnoreCase(tokenizer.sval)) {\n            throw new ParseException(\"keyword \" + ARFF_DATA + \" expected\", tokenizer.lineno());\n        }\n\n        // Check if any attributes have been declared.\n        if (fields.isEmpty()) {\n            throw new ParseException(\"no attributes declared\", tokenizer.lineno());\n        }\n        \n        schema = DataTypes.struct(fields);\n    }\n",
    "label": 1,
    "rec": "@return the schema of relation."
  },
  {
    "id": 2563,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static byte anyByte() {\n        return reportMatcher(Any.ANY).byteValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2564,
    "type": "Return",
    "comment": "@return set view of the entity-to-copy mappings contained in this EventCache",
    "code": "public Set entrySet() {\n    return Collections.unmodifiableSet(entityToCopyMap.entrySet());\n}",
    "label": 1,
    "rec": "@return an unmodifiable set view of the entity-to-copy mappings contained in this EventCache"
  },
  {
    "id": 2565,
    "type": "Return",
    "comment": "@return an XML date string.",
    "code": "    public static String getXMLDateStringFromDouble(double d) {\n        if (d == Double.NEGATIVE_INFINITY) {\n            return \"-Infinity\";\n        } else if (d == Double.POSITIVE_INFINITY) {\n            return \"Infinity\";\n        }\n        GregorianCalendar gc = new GregorianCalendar();\n        gc.setTimeInMillis((long) d);\n        String s = dateFactory.newXMLGregorianCalendar(gc).toXMLFormat().substring(0, 23);\n        s = s.endsWith(\"T00:00:00.000\") ? s.substring(0, 10) : s;\n        return s;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2566,
    "type": "Return",
    "comment": "@return a dataMap that will not have the \"fields\" query param, to ensure it does not get encoded twice",
    "code": "public static DataMap processProjections(DataMap dataMap, Map<String, List<String>> result) {\n    for (final String parameterName : RestConstants.PROJECTION_PARAMETERS) {\n        if (dataMap.containsKey(parameterName)) {\n            dataMap = processIndividualProjection(dataMap, result, parameterName);\n        }\n    }\n    return dataMap;\n}",
    "label": 1,
    "rec": "@return a dataMap that will not have any of the projection fields query parameters set, to ensure they do not get encoded twice"
  },
  {
    "id": 2567,
    "type": "Return",
    "comment": "@return a new selector",
    "code": "    public static SizeSelector minHeight(final int height) {\n        return withFilter(new Filter() {\n            @Override\n            public boolean accepts(@NonNull Size size) {\n                return size.getHeight() >= height;\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2568,
    "type": "Return",
    "comment": "@return This dependency for chaining, never {@code null}.",
    "code": "public Dependency setScope(String scope) {\n    if (this.scope.equals(scope) || (scope == null && this.scope.length() <= NUM)) {\n        return this;\n    }\n    return new Dependency(artifact, scope, optional, exclusions);\n}",
    "label": 1,
    "rec": "@return The new dependency, never {@code null}."
  },
  {
    "id": 2569,
    "type": "Return",
    "comment": "@return Ignite instance.",
    "code": "    protected Ignite ignite(int idx) {\n        return grid(idx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2570,
    "type": "Return",
    "comment": "@return Page ID.",
    "code": "    public long take(BPlusTree<?,?> client, ReuseBag bag) throws IgniteCheckedException {\n        if (trees == null)\n            return 0;\n\n        // Remove and return page at min possible position.\n        Long pageId = tree(client).removeCeil(0L, bag);\n\n        return pageId != null ? pageId : 0;\n    }\n",
    "label": 1,
    "rec": "@return Page ID or  0 if none available."
  },
  {
    "id": 2571,
    "type": "Return",
    "comment": "@return List of configurations.",
    "code": "    private static Iterable<IgniteConfiguration> getConfigurations(String springCfgPath, String log) throws GridException {\n        File path = GridTestUtils.resolveGridGainPath(springCfgPath);\n\n        if (path == null) {\n            throw new GridException(\"Spring XML configuration file path is invalid: \" + new File(springCfgPath) +\n                \". Note that this path should be either absolute path or a relative path to GRIDGAIN_HOME.\");\n        }\n\n        if (!path.isFile())\n            throw new GridException(\"Provided file path is not a file: \" + path);\n\n        // Add no-op logger to remove no-appender warning.\n        Appender app = new NullAppender();\n\n        Logger.getRootLogger().addAppender(app);\n\n        ApplicationContext springCtx;\n\n        try {\n            springCtx = new FileSystemXmlApplicationContext(path.toURI().toURL().toString());\n        }\n        catch (BeansException | MalformedURLException e) {\n            throw new GridException(\"Failed to instantiate Spring XML application context: \" + e.getMessage(), e);\n        }\n\n        Map cfgMap;\n\n        try {\n            // Note: Spring is not generics-friendly.\n            cfgMap = springCtx.getBeansOfType(IgniteConfiguration.class);\n        }\n        catch (BeansException e) {\n            throw new GridException(\"Failed to instantiate bean [type=\" + IgniteConfiguration.class + \", err=\" +\n                e.getMessage() + ']', e);\n        }\n\n        if (cfgMap == null)\n            throw new GridException(\"Failed to find a single grid factory configuration in: \" + path);\n\n        // Remove previously added no-op logger.\n        Logger.getRootLogger().removeAppender(app);\n\n        if (cfgMap.isEmpty())\n            throw new GridException(\"Can't find grid factory configuration in: \" + path);\n\n        Collection<IgniteConfiguration> res = new ArrayList<>();\n\n        for (IgniteConfiguration cfg : (Collection<IgniteConfiguration>)cfgMap.values()) {\n            UUID nodeId = UUID.randomUUID();\n\n            cfg.setNodeId(nodeId);\n\n            cfg.setGridLogger(initLogger(log));\n\n            res.add(cfg);\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2572,
    "type": "Return",
    "comment": "@return either \"dev\" or \"production\" based on the runtime platfrom",
    "code": "public static String getEnv() {\n    return TextExtractorModule.isDev ? ENV_DEV_NAME : ENV_PRODUCTION_NAME;\n}",
    "label": 1,
    "rec": "@return either \"dev\" or \"production\" based on the environment"
  },
  {
    "id": 2573,
    "type": "Return",
    "comment": "@return Current client metrics.",
    "code": "        ClusterNodeMetricsMBean metrics() {\n            return metrics;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2574,
    "type": "Return",
    "comment": "@return the actual keyset data.",
    "code": "public EncryptedKeyset getEncryptedKeyset() {\n    return encryptedKeyset;\n}",
    "label": 1,
    "rec": "@return the encrypted keyset data."
  },
  {
    "id": 2575,
    "type": "Return",
    "comment": "@return Multi bulk reply, specifically the list of common elements.",
    "code": "    public Set<String> sunion(final String... keys) {\n        runChecks();\n        client.sunion(keys);\n        final List<String> members = client.getMultiBulkReply();\n        return new HashSet<String>(members);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2576,
    "type": "Return",
    "comment": "@return Current date",
    "code": "public Calendar getDate() {\n    checkWidget();\n    if (!isReadOnly)\n        setDateBasedOnComboText();\n    return mStartDate;\n}",
    "label": 1,
    "rec": "@return Calendar of date selection or null."
  },
  {
    "id": 2577,
    "type": "Return",
    "comment": "@return a collection of the users",
    "code": "    public Collection<User> getUserList() {\n        return getUsers().values();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2578,
    "type": "Return",
    "comment": "@return object that was found in resource or set to it, autoInsertValue - if there are no values with specified key",
    "code": "public Object getMessage(Object key, String bundleIdentifier) {\n    if (bundleIdentifier.equals(NO_BUNDLE))\n        return null;\n    try {\n        initialize(bundleIdentifier, null);\n        return getBundleLocalizedString(String.valueOf(key));\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return object that was found in resource or null if nothing is found"
  },
  {
    "id": 2579,
    "type": "Return",
    "comment": "@return 0.",
    "code": "    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2580,
    "type": "Return",
    "comment": "@return Found Client-Object or null, if there isn't client with such id.",
    "code": "public static Client searchId(String id) throws SearchException {\n    if (clients.isEmpty()) {\n        throw new SearchException(STR);\n    } else {\n        for (Client client : clients) {\n            if (client.getId().equals(id)) {\n                return client;\n            }\n        }\n        throw new SearchException(STR);\n    }\n}",
    "label": 1,
    "rec": "@return Found Client-Object."
  },
  {
    "id": 2581,
    "type": "Return",
    "comment": "@return A new instance of ZuulFilter",
    "code": "    public BaseFilter newInstance(Class clazz) throws InstantiationException, IllegalAccessException {\n        return (BaseFilter) clazz.newInstance();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2582,
    "type": "Return",
    "comment": "@return A BaseLuminanceSource subclass.",
    "code": "  public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {\n    Rect rect = getFramingRect();\n    switch (previewFormat) {\n      // This is the standard Android format which all devices are REQUIRED to support.\n      // In theory, it's the only one we should ever care about.\n      case PixelFormat.YCbCr_420_SP:\n        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n      // This format has never been seen in the wild, but is compatible as we only care\n      // about the Y channel, so allow it.\n      case PixelFormat.YCbCr_422_SP:\n        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n      default:\n        // The Samsung Moment incorrectly uses this variant instead of the 'sp' version.\n        // Fortunately, it too has all the Y data up front, so we can read it.\n        if (previewFormatString.equals(\"yuv420p\")) {\n          return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n        }\n    }\n    throw new IllegalArgumentException(\"Unsupported picture format: \" +\n        previewFormat + '/' + previewFormatString);\n  }\n",
    "label": 1,
    "rec": "@return A PlanarYUVLuminanceSource instance."
  },
  {
    "id": 2583,
    "type": "Return",
    "comment": "@return the entity if successful, null otherwise",
    "code": "\tpublic static ClientDetailsEntity parse(String jsonString) {\n\t\tJsonElement jsonEl = parser.parse(jsonString);\n\t\treturn parse(jsonEl);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2584,
    "type": "Return",
    "comment": "@return true if the method has a JSecurity RolesRequired or PermissionRequired annotation, false otherwise.",
    "code": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n",
    "label": 1,
    "rec": "@return true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise."
  },
  {
    "id": 2585,
    "type": "Return",
    "comment": "@return  true if we need to check this class.",
    "code": "    private static boolean isGgfsOrGgHadoop(String cls) {\n        String gg = \"org.apache.ignite\";\n        int len = gg.length();\n\n        return cls.startsWith(gg) && (cls.indexOf(\"ggfs.\", len) != -1 || cls.indexOf(\".fs.\", len) != -1 || cls.indexOf(\"hadoop.\", len) != -1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2586,
    "type": "Return",
    "comment": "@return The result fetched from the result vector, null if the result could not be found",
    "code": "public static WSSecurityEngineResult fetchActionResult(List resultList, int action) {\n    for (int i = NUM; i < resultList.size(); i++) {\n        WSSecurityEngineResult result = (WSSecurityEngineResult) resultList.get(i);\n        int resultAction = ((java.lang.Integer) result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n        if (resultAction == action) {\n            return result;\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return The first result fetched from the result list, null if the result could not be found"
  },
  {
    "id": 2587,
    "type": "Return",
    "comment": "@return user object",
    "code": "    public User surpassOverload(String userName) {\n        if (!isOverloaded(userName)) {\n            return getUser(userName);\n        }\n        if (getUsers().containsKey(userName.toLowerCase())) {\n            return getUsers().get(userName.toLowerCase());\n        }\n        User newUser = createUser(userName);\n        return newUser;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2588,
    "type": "Return",
    "comment": "@return an AssertionWrapper object",
    "code": "public static SamlAssertionWrapper getAssertionFromKeyIdentifier(SecurityTokenReference secRef, Element strElement, RequestData request, WSDocInfo wsDocInfo) throws WSSecurityException {\n    String keyIdentifierValue = secRef.getKeyIdentifierValue();\n    String type = secRef.getKeyIdentifierValueType();\n    WSSecurityEngineResult result = wsDocInfo.getResult(keyIdentifierValue);\n    SamlAssertionWrapper samlAssertion = null;\n    Element token = null;\n    if (result != null) {\n        samlAssertion = (SamlAssertionWrapper) result.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        return samlAssertion;\n    } else {\n        token = secRef.findProcessedTokenElement(strElement.getOwnerDocument(), wsDocInfo, request.getCallbackHandler(), keyIdentifierValue, type);\n        if (token != null) {\n            if (!STR.equals(token.getLocalName())) {\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, STR);\n            }\n            return new SamlAssertionWrapper(token);\n        }\n        token = secRef.findUnprocessedTokenElement(strElement.getOwnerDocument(), wsDocInfo, request.getCallbackHandler(), keyIdentifierValue, type);\n        if (token == null || !STR.equals(token.getLocalName())) {\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, STR);\n        }\n        Processor proc = request.getWssConfig().getProcessor(WSSecurityEngine.SAML_TOKEN);\n        List<WSSecurityEngineResult> samlResult = proc.handleToken(token, request, wsDocInfo);\n        return (SamlAssertionWrapper) samlResult.get(NUM).get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n    }\n}",
    "label": 1,
    "rec": "@return an SamlAssertionWrapper object"
  },
  {
    "id": 2589,
    "type": "Return",
    "comment": "@return the response body or NULL when the request went wrong",
    "code": "\tpublic static String executeUrl(String httpMethod, String url, InputStream content, String contentType, int timeout) {\n\t\t\n\t\tString proxySet = System.getProperty(\"http.proxySet\");\n\t\t\n\t\tString proxyHost = null;\n\t\tint proxyPort = 80;\n\t\tString proxyUser = null;\n\t\tString proxyPassword = null;\n\t\tString nonProxyHosts = null;\n\t\t\n\t\tif (\"true\".equalsIgnoreCase(proxySet)) {\n\t\t\tproxyHost = System.getProperty(\"http.proxyHost\");\n\t\t\tString proxyPortString = System.getProperty(\"http.proxyPort\");\n\t\t\tif (StringUtils.isNotBlank(proxyPortString)) {\n\t\t\t\ttry {\n\t\t\t\t\tproxyPort = Integer.valueOf(proxyPortString);\n\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\tlogger.warn(\"'{}' is not a valid proxy port - using port 80 instead\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tproxyUser = System.getProperty(\"http.proxyUser\");\n\t\t\tproxyPassword = System.getProperty(\"http.proxyPassword\");\n\t\t\tnonProxyHosts = System.getProperty(\"http.nonProxyHosts\");\n\t\t}\n\t\t\n\t\treturn executeUrl(httpMethod, url, content, contentType, timeout, proxyHost, proxyPort, proxyUser, proxyPassword, nonProxyHosts);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2590,
    "type": "Return",
    "comment": "@return boolean true if the method should be filtered away",
    "code": "private String methodFilter(final ClassGen cg, final Method method) {\n    MethodMetaData methodMetaData = TransformationUtil.createMethodMetaData(method);\n    String uuid = null;\n    if (methodMetaData.getName().equals(STR) || methodMetaData.getName().equals(STR) || methodMetaData.getName().startsWith(TransformationUtil.ORIGINAL_METHOD_PREFIX) || methodMetaData.getName().equals(TransformationUtil.GET_META_DATA_METHOD) || methodMetaData.getName().equals(TransformationUtil.SET_META_DATA_METHOD) || methodMetaData.getName().equals(TransformationUtil.GET_UUID_METHOD)) {\n        uuid = null;\n    } else {\n        if (m_weaveModel.hasMethodPointcut(cg.getClassName(), methodMetaData)) {\n            uuid = m_weaveModel.getUuid();\n        }\n        if (m_weaveModel.hasThrowsPointcut(cg.getClassName(), methodMetaData)) {\n            uuid = m_weaveModel.getUuid();\n        }\n    }\n    return uuid;\n}",
    "label": 1,
    "rec": "@return the UUID for the weave model"
  },
  {
    "id": 2591,
    "type": "Return",
    "comment": "@return Peeked value.",
    "code": "    @Nullable public V peekNearOnly(K key) {\n        try {\n            return localPeek(key, new CachePeekMode[] {CachePeekMode.ONHEAP}, null);\n        }\n        catch (IgniteCheckedException ignored) {\n            if (log.isDebugEnabled())\n                log.debug(\"Filter validation failed for key: \" + key);\n\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2592,
    "type": "Return",
    "comment": "@return {@link AbstractTaskContainer category} where the new task must be added to, or null if it must not be added to the task list",
    "code": "@SuppressWarnings(STR)\nprotected AbstractTaskListElement getCategory() {\n    int index = categoryChooser.getSelectionIndex();\n    if (addToCategory.getSelection() && index != -NUM) {\n        if (index == NUM) {\n            return TasksUiPlugin.getTaskListManager().getTaskList().getUncategorizedCategory();\n        }\n        return ((List<AbstractTaskListElement>) categoryChooser.getData()).get(index - NUM);\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return {@link AbstractTaskListElement category} where the new task must be added to, or null if it must not be added to the task list"
  },
  {
    "id": 2593,
    "type": "Return",
    "comment": "@return Grid job made out of closure.",
    "code": "    private static ComputeJob job(final Runnable r) {\n        A.notNull(r, \"job\");\n\n        return r instanceof ComputeJobMasterLeaveAware ? new C4MLAV2(r) : new C4V2(r);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2594,
    "type": "Return",
    "comment": "@return the keys for an object or the indexes for an array",
    "code": "    public Collection<String> getPropertyKeys(Object obj) {\n        if (isArray(obj)) {\n          throw new UnsupportedOperationException();\n        } else {\n            return ((Map) obj).keySet();\n        }\n    }\n",
    "label": 1,
    "rec": "@return the keys for an object"
  },
  {
    "id": 2595,
    "type": "Return",
    "comment": "@return the index",
    "code": "\tpublic Integer getIndex() {\n\t\treturn index;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2596,
    "type": "Return",
    "comment": "@return the minimum number of edges to be used in edge buffer",
    "code": "    int calculateEdges(int maxNodes) {\n        // the more edges we inline the less memory we need to reserve => \" / edgeEmbedded\"\n        // if we provide too few memory => BufferUnderflowException will be thrown without calling ensureEdgesCapacity\n        return Math.max(nextEdgePos / bytesEdgeSize + 2, maxNodes / edgeNumEmbedded / 4);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2597,
    "type": "Return",
    "comment": "@return The current {@link SContext context} used for this request, or <code>null</code> if {@link #setContext} has not yet been called.",
    "code": "public Context getContext() {\n    return _context;\n}",
    "label": 1,
    "rec": "@return The current {@link Context context} used for this request, or <code>null</code> if {@link #setContext} has not yet been called."
  },
  {
    "id": 2598,
    "type": "Return",
    "comment": "@return view name",
    "code": "    public String enable(Long id, HttpServletRequest request, HttpSession session, ModelMap model) {\n        SysAppClient entity = service.getEntity(id);\n        if (null != entity) {\n            SysSite site = siteComponent.getSite(request.getServerName());\n            if (ControllerUtils.verifyNotEquals(\"siteId\", site.getId(), entity.getSiteId(), model)) {\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n            service.updateStatus(id, false);\n            logOperateService.save(new LogOperate(site.getId(), ControllerUtils.getAdminFromSession(session).getId(),\n                    LogLoginService.CHANNEL_WEB_MANAGER, \"enable.appclient\", RequestUtils.getIpAddress(request),\n                    CommonUtils.getDate(), JsonUtils.getString(entity)));\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2599,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder cacheResultInvocationContext(CacheInvocationContext<CacheResult> pCacheResultInvocationContext) {\n    this.cacheResultInvocationContext = pCacheResultInvocationContext;\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 2600,
    "type": "Return",
    "comment": "@return the key.",
    "code": "\tprotected CorrelationKey createCorrelationId(ProducerRecord<K, V> record) {\n\t\treturn this.correlationStrategy.apply(record);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2601,
    "type": "Return",
    "comment": "@return  SecureHttpContext if SECURITY_SYSTEM_PROPERTY is set or DefaultHttpContext in all other cases.",
    "code": "\tprotected HttpContext createHttpContext() {\n\t\tHttpContext defaultHttpContext = httpService.createDefaultHttpContext();\n\t\treturn new SecureHttpContext(defaultHttpContext, \"openHAB.org\");\n\t}\n",
    "label": 1,
    "rec": "@return a  SecureHttpContext"
  },
  {
    "id": 2602,
    "type": "Return",
    "comment": "@return IP finder for IP addresses sharing and storing.",
    "code": "    public TcpDiscoveryIpFinder getIpFinder() {\n        return ipFinder;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2603,
    "type": "Return",
    "comment": "@return a Vector of users that have access to the system",
    "code": "public List<User> getUsers() {\n    return this.users;\n}",
    "label": 1,
    "rec": "@return a List of users that have access to the system"
  },
  {
    "id": 2604,
    "type": "Return",
    "comment": "@return encoded url if requested with params appended if any available",
    "code": "    public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {\n        if (url == null)\n            return null;\n        \n        if (shouldEncodeUrl)\n            url = url.replace(\" \", \"%20\");\n\n        if (params != null) {\n            // Construct the query string and trim it, in case it\n            // includes any excessive white spaces.\n            String paramString = params.getParamString().trim();\n\n            // Only add the query string if it isn't empty and it\n            // isn't equal to '?'.\n            if (!paramString.equals(\"\") && !paramString.equals(\"?\")) {\n                url += url.contains(\"?\") ? \"&\" : \"?\";\n                url += paramString;\n            }\n        }\n\n        return url;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2605,
    "type": "Return",
    "comment": "@return This proxy for chaining, never {@code null}.",
    "code": "public Proxy setHost(String host) {\n    return new Proxy(type, host, port, auth);\n}",
    "label": 1,
    "rec": "@return The new proxy, never {@code null}."
  },
  {
    "id": 2606,
    "type": "Return",
    "comment": "@return Associative  Difficulty with the given value, or null if it doesn't exist",
    "code": "    public static Difficulty getByValue(final int value) {\n        return BY_ID.get(value);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2607,
    "type": "Return",
    "comment": "@return A {@link Where} statement with the specified {@link ConditionQueryBuilder}.",
    "code": "public Where<ModelClass> where(SQLCondition... conditions) {\n    return where().andThese(conditions);\n}",
    "label": 1,
    "rec": "@return A {@link Where} statement with the specified array of {@link Condition}."
  },
  {
    "id": 2608,
    "type": "Return",
    "comment": "@return channel - or null - of type  VeluxBridgeFirmware.Channel describing the overall result of this interaction.",
    "code": "    public Channel retrieve(VeluxBridgeProvider bridge) {\n        logger.trace(\"retrieve() called.\");\n\n        return channel;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2609,
    "type": "Return",
    "comment": "@return Object Referent to which reference refers, or null if object has been cleared.",
    "code": "public T get() {\n    return null;\n}",
    "label": 1,
    "rec": "@return Referent to which reference refers, or null if object has been cleared."
  },
  {
    "id": 2610,
    "type": "Return",
    "comment": "@return the joint probability P(o, s | H) given the model H.",
    "code": "    public double p(int[] o, int[] s) {\n        return MathEx.exp(logp(o, s));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2611,
    "type": "Return",
    "comment": "@return a  KeysetHandle of an encrypted keyset.",
    "code": "  public KeysetHandle getKeysetHandle() throws GeneralSecurityException {\n    if (masterKey == null) {\n      return new KeysetHandle(keysetBuilder.build());\n    }\n    Keyset keyset = keysetBuilder.build();\n    byte[] encryptedKeyset = masterKey.encrypt(keyset.toByteArray(),\n        new byte[0] /* aad */);\n    // Check if we can decrypt, to detect errors\n    try {\n      final Keyset keyset2 = Keyset.parseFrom(masterKey.decrypt(\n          encryptedKeyset, new byte[0] /* aad */));\n      if (!keyset2.equals(keyset)) {\n        throw new GeneralSecurityException(\"cannot encrypt keyset\");\n      }\n    } catch (InvalidProtocolBufferException e) {\n      throw new GeneralSecurityException(\"invalid keyset, corrupted key material\");\n    }\n    EncryptedKeyset proto = EncryptedKeyset.newBuilder()\n        .setEncryptedKeyset(ByteString.copyFrom(encryptedKeyset))\n        .setKeysetInfo(Util.getKeysetInfo(keyset))\n        .build();\n    return new KeysetHandle(keyset, proto);\n  }\n",
    "label": 1,
    "rec": "@return return  KeysetHandle of the managed keyset."
  },
  {
    "id": 2612,
    "type": "Return",
    "comment": "@return Class name of base throwable object.",
    "code": "    public String getClassName() {\n        return clsName;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2613,
    "type": "Return",
    "comment": "@return the token credentials hash",
    "code": "    protected Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations) {\n        String hashAlgorithmName = assertHashAlgorithmName();\n        return new SimpleHash(hashAlgorithmName, credentials, salt, hashIterations);\n    }\n",
    "label": 1,
    "rec": "@return the hashed value of the provided credentials, according to the specified salt and hash iterations."
  },
  {
    "id": 2614,
    "type": "Return",
    "comment": "@return the result",
    "code": "    public SessionContext getResult() {\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2615,
    "type": "Return",
    "comment": "@return the predicted class label. For MULTINOMIAL and BERNOULLI models, returns -1 if the instance does not contain any feature words.",
    "code": "    public int predict(double[] x, double[] posteriori) {\n        if (x.length != p) {\n            throw new IllegalArgumentException(String.format(\"Invalid input vector size: %d\", x.length));\n        }\n\n        if (posteriori == null) {\n            posteriori = new double[k];\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob = Math.log(priori[i]);\n\n            for (int j = 0; j < p; j++) {\n                logprob += prob[i][j].logp(x[j]);\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        double Z = 0.0;\n        double max = MathEx.max(posteriori);\n        for (int i = 0; i < k; i++) {\n            posteriori[i] = Math.exp(posteriori[i] - max);\n            Z += posteriori[i];\n        }\n\n        for (int i = 0; i < k; i++) {\n            posteriori[i] /= Z;\n        }\n\n        return labels.label(MathEx.whichMax(posteriori));\n    }\n",
    "label": 1,
    "rec": "@return the predicted class label."
  },
  {
    "id": 2616,
    "type": "Return",
    "comment": "@return  True if synchronous preloading.",
    "code": "    private boolean isSync(GridCache<?, ?> c) {\n        return c.configuration().getRebalanceMode() == SYNC;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2617,
    "type": "Return",
    "comment": "@return The deserialized H2MetricValueDomain",
    "code": "public static H2TimeSeries deserialize(byte[] arr) throws IOException, ClassNotFoundException {\n    ByteArrayInputStream bais = new ByteArrayInputStream(arr);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    return (H2TimeSeries) ois.readObject();\n}",
    "label": 1,
    "rec": "@return The deserialized H2TimeSeries"
  },
  {
    "id": 2618,
    "type": "Return",
    "comment": "@return SVMLightPArser instance or null",
    "code": "  public static PSetupGuess guessSetup(byte [] bits){\n    InputStream is = new ByteArrayInputStream(bits);\n    SVMLightParser p = new SVMLightParser(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, false));\n    InspectDataOut dout = new InspectDataOut();\n    try{p.streamParse(is, dout);}catch(Exception e){throw new RuntimeException(e);}\n    return new PSetupGuess(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, dout._ncols,false,null,false),dout._nlines,dout._invalidLines,dout.data(),dout._ncols > 0 && dout._nlines > 0 && dout._nlines > dout._invalidLines,dout.errors());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2619,
    "type": "Return",
    "comment": "@return the mode",
    "code": "public String getMode() {\n    return modeName;\n}",
    "label": 1,
    "rec": "@return the modeName"
  },
  {
    "id": 2620,
    "type": "Return",
    "comment": "@return Unwrapped object.",
    "code": "    public Object unwrapPortableIfNeeded(Object o, boolean keepPortable) throws GridException {\n        if (!config().isPortableEnabled())\n            return o;\n\n        if (o instanceof Map.Entry) {\n            Map.Entry entry = (Map.Entry)o;\n\n            Object key = entry.getKey();\n\n            if (key instanceof GridPortableObject && !keepPortable)\n                key = ((GridPortableObject)key).deserialize();\n\n            Object val = entry.getValue();\n\n            if (val instanceof GridPortableObject && !keepPortable)\n                val = ((GridPortableObject)val).deserialize();\n\n            return F.t(key, val);\n        }\n        else if (!keepPortable) {\n            if (o instanceof Collection)\n                return unwrapPortablesIfNeeded((Collection<Object>)o, keepPortable);\n            else if (o instanceof GridPortableObject)\n                return ((GridPortableObject)o).deserialize();\n            else\n                return o;\n        }\n        else\n            return o;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2621,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder cacheRemoveInvocationContext(CacheInvocationContext<CacheRemove> pCacheRemoveInvocationContext) {\n    this.cacheRemoveInvocationContext = pCacheRemoveInvocationContext;\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 2622,
    "type": "Return",
    "comment": "@return Indexes.",
    "code": "    ArrayList<GridH2IndexBase> indexes() {\n        ArrayList<GridH2IndexBase> res = new ArrayList<>(idxs.size() - 1);\n\n        for (int i = 1, len = idxs.size(); i < len ; i++)\n            res.add(index(i));\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2623,
    "type": "Return",
    "comment": "@return boolean If the mount point can be mounted",
    "code": "public static boolean isMountAllowed(MountPoint mp) {\n    return !RESTRICTED_FS_TYPE.contains(mp.getType());\n}",
    "label": 1,
    "rec": "@return boolean If the mount point can be mounted/unmount (rw/ro)"
  },
  {
    "id": 2624,
    "type": "Return",
    "comment": "@return Return value.",
    "code": "        private GridCacheReturn<Object> returnValue() {\n            return retVal;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2625,
    "type": "Return",
    "comment": "@return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters (including '=') isn't divideable by 4. (I.e. definitely corrupted).",
    "code": "public static String decode(String base64) {\n    StringBuilder sb = new StringBuilder(base64);\n    sb.append(Strings.dup(STR, NUM - base64.length() % NUM - NUM));\n    byte[] decode = Base64.decode(sb.toString().replace(STR, STR).replace(STR, STR));\n    if (decode.length != NUM || decode == null) {\n        return new String(decode);\n    } else {\n        return STR;\n    }\n}",
    "label": 1,
    "rec": "@return URL "
  },
  {
    "id": 2626,
    "type": "Return",
    "comment": "@return TreeSpecies of this tree",
    "code": "    public TreeSpecies getSpecies() {\n        return TreeSpecies.getByData((byte) (getData() & 0x3));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2627,
    "type": "Return",
    "comment": "@return field object with given name, or null",
    "code": "public Field containsField(String name) {\n    for (Field field : fieldsList) {\n        if (field.getName().equals(name)) {\n            return field;\n        }\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return field object with given name, or null if not found"
  },
  {
    "id": 2628,
    "type": "Return",
    "comment": "@return the requested key.",
    "code": "    public DeterministicKey deriveChild(List<ChildNumber> parentPath, boolean relative, boolean createParent, ChildNumber createChildNumber) {\n        return deriveChild(get(parentPath, relative, createParent), createChildNumber);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2629,
    "type": "Return",
    "comment": "@return the duration of the execution in seconds (or null if the duration is still running, or has been aborted)",
    "code": "public Long getDurationInSeconds() {\n    Long durationInMillis = getDurationInMillis();\n    return durationInMillis != null ? TimeUnit.MILLISECONDS.toSeconds(durationInMillis) : null;\n}",
    "label": 1,
    "rec": "@return the duration of the execution in seconds (or null if the execution is still running, or has been aborted)"
  },
  {
    "id": 2630,
    "type": "Return",
    "comment": "@return stage",
    "code": "    public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, ZPath path)\n    {\n        return asyncEnsureContainers(client, path, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2631,
    "type": "Return",
    "comment": "@return the editing domain's cross-reference adapter",
    "code": "public static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {\n    if (resourceSet == null) {\n        return null;\n    }\n    CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);\n    if (result == null) {\n        result = new CrossReferenceAdapter();\n        resourceSet.eAdapters().add(result);\n    }\n    return result;\n}",
    "label": 1,
    "rec": "@return the resourceSet's cross-reference adapter"
  },
  {
    "id": 2632,
    "type": "Return",
    "comment": "@return Execution pool.",
    "code": "    private Executor pool(GridIoPolicy plc) {\n        switch (plc) {\n            case P2P_POOL:\n                return p2pPool;\n            case SYSTEM_POOL:\n                return sysPool;\n            case PUBLIC_POOL:\n                return pubPool;\n            case MANAGEMENT_POOL:\n                return mgmtPool;\n            case DR_POOL:\n                assert drPool != null : \"DR pool is not configured.\";\n\n                return drPool;\n\n            default: {\n                assert false : \"Invalid communication policy: \" + plc;\n\n                // Never reached.\n                return null;\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2633,
    "type": "Return",
    "comment": "@return An {@link Image} object.",
    "code": "private String parseImage() throws XMLStreamException, XMLParserException {\n    String id = null;\n    String name;\n    int type;\n    while ((type = this.reader.next()) == START_ELEMENT) {\n        name = this.reader.getLocalName();\n        if (name.equals(STR)) {\n            id = this.getElementString();\n        } else if (name.equals(STR)) {\n            this.getElementString();\n        } else if (name.equals(STR)) {\n            this.getElementString();\n        } else {\n            throw new XMLParserException(STR + name + STR, this.reader.getLocation());\n        }\n    }\n    if (type != END_ELEMENT) {\n        id = this.reader.getText().trim();\n        this.reader.next();\n    }\n    return id;\n}",
    "label": 1,
    "rec": "@return The image id."
  },
  {
    "id": 2634,
    "type": "Return",
    "comment": "@return all retrieved authority rules",
    "code": "    public List<AuthorityRuleEntity> fetchAuthorityRulesOfMachine(String app, String ip, int port) {\n        AssertUtil.notEmpty(app, \"Bad app name\");\n        AssertUtil.notEmpty(ip, \"Bad machine IP\");\n        AssertUtil.isTrue(port > 0, \"Bad machine port\");\n        Map<String, String> params = new HashMap<>(1);\n        params.put(\"type\", AUTHORITY_TYPE);\n        List<AuthorityRule> rules = fetchRules(ip, port, AUTHORITY_TYPE, AuthorityRule.class);\n        return Optional.ofNullable(rules).map(r -> r.stream()\n                    .map(e -> AuthorityRuleEntity.fromAuthorityRule(app, ip, port, e))\n                    .collect(Collectors.toList())\n                ).orElse(null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2635,
    "type": "Return",
    "comment": "@return a new EqualFilter",
    "code": "public static <E> Predicates.EqualsPredicate<E> equal(E object) {\n    return new Predicates.EqualsPredicate<E>(object);\n}",
    "label": 1,
    "rec": "@return a new EqualPredicate"
  },
  {
    "id": 2636,
    "type": "Return",
    "comment": "@return The view for this  Crouton;",
    "code": "\tpublic static View viewForCrouton(Crouton crouton) {\n\t\tif (viewHolder == null) {\n\t\t\tviewHolder = new ViewHolder(crouton);\n\t\t} else {\n\t\t\tviewHolder.text.setText(crouton.getText());\n\t\t}\n\t\tviewHolder.view.setBackgroundColor(crouton.getActivity().getResources().getColor(crouton.getStyle().color));\n\n\t\tif (crouton.getStyle().textColor != 0) {\n\t\t\tviewHolder.text.setTextColor(crouton.getActivity().getResources()\n\t\t\t\t\t.getColor(crouton.getStyle().textColor));\n\t\t} else {\n\t\t\tviewHolder.text.setTextColor(defaultTextColor);\n\t\t}\n\n\t\tif (crouton.getStyle().background != 0) {\n\t\t\tBitmap bm = BitmapFactory.decodeResource(crouton.getActivity().getResources(),\n\t\t\t\t\tcrouton.getStyle().background);\n\t\t\tBitmapDrawable bd = new BitmapDrawable(crouton.getActivity().getResources(), bm);\n\n\t\t\tif (crouton.getStyle().tile)\n\t\t\t\tbd.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);\n\n\t\t\tviewHolder.background.setBackgroundDrawable(bd);\n\t\t} else {\n\t\t\tviewHolder.background.setBackgroundDrawable(null);\n\t\t}\n\n        if (crouton.getStyle().image != null) {\n            viewHolder.image.setImageDrawable(crouton.getStyle().image);\n        }\n\n\t\treturn viewHolder.view;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2637,
    "type": "Return",
    "comment": "@return a {@link PagedCollection}",
    "code": "public ResourceCollection<Customer> all(int pageNumber) {\n    String queryString = new QueryString().append(STR, pageNumber).toString();\n    NodeWrapper response = http.get(STR + queryString);\n    return new ResourceCollection<Customer>(new CustomerPager(this), response, Customer.class);\n}",
    "label": 1,
    "rec": "@return a {@link ResourceCollection}"
  },
  {
    "id": 2638,
    "type": "Return",
    "comment": "@return  True in case the entry really was deleted form the file system by this call.",
    "code": "    private boolean delete(IgniteUuid trashId, String name, IgniteUuid id) throws IgniteCheckedException {\n        assert name != null;\n        assert id != null;\n\n        while (true) {\n            IgfsEntryInfo info = meta.info(id);\n\n            if (info != null) {\n                if (info.isDirectory()) {\n                    if (!deleteDirectoryContents(trashId, id))\n                        return false;\n\n                    if (meta.delete(trashId, name, id))\n                        return true;\n                }\n                else {\n                    assert info.isFile();\n\n                    // Lock the file with special lock Id to prevent concurrent writing:\n                    IgfsEntryInfo lockedInfo = meta.lock(id, true);\n\n                    if (lockedInfo == null)\n                        return false; // File is locked, we cannot delete it.\n\n                    assert id.equals(lockedInfo.id());\n\n                    // Delete file content first.\n                    // In case this node crashes, other node will re-delete the file.\n                    data.delete(lockedInfo).get();\n\n                    boolean ret = meta.delete(trashId, name, id);\n\n                    if (ret) {\n                        IgfsPath path = IgfsUtils.extractOriginalPathFromTrash(name);\n\n                        assert path != null;\n\n                        IgfsUtils.sendEvents(igfsCtx.kernalContext(), path, EVT_IGFS_FILE_PURGED);\n                    }\n\n                    return ret;\n                }\n            }\n            else\n                return false; // Entry was deleted concurrently.\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2639,
    "type": "Return",
    "comment": "@return the selected working set or null if the scope is not WORKING_SET_SCOPE",
    "code": "public IWorkingSet getSelectedWorkingSet() {\n    if (getSelectedScope() == WORKING_SET_SCOPE)\n        return fWorkingSet;\n    else\n        return null;\n}",
    "label": 1,
    "rec": "@return the selected working set or null - if the scope is not WORKING_SET_SCOPE - if there is no working set selected"
  },
  {
    "id": 2640,
    "type": "Return",
    "comment": "@return Wrapped future that is aware of cloning behaviour.",
    "code": "    public IgniteFuture<V> wrapClone(IgniteFuture<V> f) {\n        if (!hasFlag(CLONE))\n            return f;\n\n        return f.chain(new CX1<IgniteFuture<V>, V>() {\n            @Override public V applyx(IgniteFuture<V> f) throws GridException {\n                return cloneValue(f.get());\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2641,
    "type": "Return",
    "comment": "@return the compatible AttributeType, or null",
    "code": "    public static AttributeType parse(Object obj) {\n        if(obj==null){\n            return null;\n        }\n        Class<?> c = obj.getClass();\n\n        for (AttributeType attributeType : AttributeType.values()) {\n            if (c.equals(attributeType.getType())) {\n                return attributeType;\n            }\n        }\n\n        return null;\n    }\n",
    "label": 1,
    "rec": "@return the compatible AttributeType, or null if no type is found or the input object is null"
  },
  {
    "id": 2642,
    "type": "Return",
    "comment": "@return a recommender to be run",
    "code": "\tprivate static Recommender getRecommender(SparseMatrix[] data, int fold)\n\t\t\tthrows Exception {\n\n\t\tSparseMatrix trainMatrix = data[0], testMatrix = data[1];\n\t\talgorithm = cf.getString(\"recommender\");\n\n\t\tswitch (algorithm.toLowerCase()) {\n\n\t\t/* baselines */\n\t\tcase \"globalavg\":\n\t\t\treturn new GlobalAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"useravg\":\n\t\t\treturn new UserAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"itemavg\":\n\t\t\treturn new ItemAverage(trainMatrix, testMatrix, fold);\n\t\tcase \"random\":\n\t\t\treturn new RandomGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"constant\":\n\t\t\treturn new ConstantGuess(trainMatrix, testMatrix, fold);\n\t\tcase \"mostpop\":\n\t\t\treturn new MostPopular(trainMatrix, testMatrix, fold);\n\n\t\t\t/* rating prediction */\n\t\tcase \"userknn\":\n\t\t\treturn new UserKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"itemknn\":\n\t\t\treturn new ItemKNN(trainMatrix, testMatrix, fold);\n\t\tcase \"regsvd\":\n\t\t\treturn new RegSVD(trainMatrix, testMatrix, fold);\n\t\tcase \"biasedmf\":\n\t\t\treturn new BiasedMF(trainMatrix, testMatrix, fold);\n\t\tcase \"svd++\":\n\t\t\treturn new SVDPlusPlus(trainMatrix, testMatrix, fold);\n\t\tcase \"pmf\":\n\t\t\treturn new PMF(trainMatrix, testMatrix, fold);\n\t\tcase \"bpmf\":\n\t\t\treturn new BPMF(trainMatrix, testMatrix, fold);\n\t\tcase \"socialmf\":\n\t\t\treturn new SocialMF(trainMatrix, testMatrix, fold);\n\t\tcase \"trustmf\":\n\t\t\treturn new TrustMF(trainMatrix, testMatrix, fold);\n\t\tcase \"sorec\":\n\t\t\treturn new SoRec(trainMatrix, testMatrix, fold);\n\t\tcase \"soreg\":\n\t\t\treturn new SoReg(trainMatrix, testMatrix, fold);\n\t\tcase \"rste\":\n\t\t\treturn new RSTE(trainMatrix, testMatrix, fold);\n\n\t\t\t/* item ranking */\n\t\tcase \"climf\":\n\t\t\treturn new CLiMF(trainMatrix, testMatrix, fold);\n\t\tcase \"rankals\":\n\t\t\treturn new RankALS(trainMatrix, testMatrix, fold);\n\t\tcase \"ranksgd\":\n\t\t\treturn new RankSGD(trainMatrix, testMatrix, fold);\n\t\tcase \"wrmf\":\n\t\t\treturn new WRMF(trainMatrix, testMatrix, fold);\n\t\tcase \"bpr\":\n\t\t\treturn new BPR(trainMatrix, testMatrix, fold);\n\t\tcase \"gbpr\":\n\t\t\treturn new GBPR(trainMatrix, testMatrix, fold);\n\t\tcase \"slim\":\n\t\t\treturn new SLIM(trainMatrix, testMatrix, fold);\n\n\t\t\t/* extension */\n\t\tcase \"nmf\":\n\t\t\treturn new NMF(trainMatrix, testMatrix, fold);\n\t\tcase \"hybrid\":\n\t\t\treturn new Hybrid(trainMatrix, testMatrix, fold);\n\t\tcase \"slopeone\":\n\t\t\treturn new SlopeOne(trainMatrix, testMatrix, fold);\n\t\tcase \"pd\":\n\t\t\treturn new PD(trainMatrix, testMatrix, fold);\n\t\tcase \"ar\":\n\t\t\treturn new AR(trainMatrix, testMatrix, fold);\n\t\tcase \"prankd\":\n\t\t\treturn new PRankD(trainMatrix, testMatrix, fold);\n\n\t\tdefault:\n\t\t\tthrow new Exception(\"No recommender is specified!\");\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2643,
    "type": "Return",
    "comment": "@return <code>URL</code> of the web application class path",
    "code": "protected String createURLFromWARFile() throws Exception {\n    if (servletContext == null) {\n        return null;\n    }\n    URL url = servletContext.getResource(STR);\n    if (url != null) {\n        addWebBeansXmlLocation(url.toExternalForm());\n        URL resourceUrl = WarUrlFinder.findWebInfClassesPath(this.servletContext);\n        if (resourceUrl == null) {\n            return null;\n        }\n        AnnotationDB annotationDB = getAnnotationDB();\n        if (annotationDB instanceof BeansXmlAnnotationDB) {\n            ((BeansXmlAnnotationDB) annotationDB).setResourceBeansXml(resourceUrl.toExternalForm(), url.toExternalForm());\n        }\n        return resourceUrl.toExternalForm();\n    }\n    return null;\n}",
    "label": 1,
    "rec": "@return the web application class path"
  },
  {
    "id": 2644,
    "type": "Return",
    "comment": "@return Data transfer object for given cache.",
    "code": "    public static VisorCache from(Ignite ignite, String cacheName, int sample) throws IgniteCheckedException {\n        assert ignite != null;\n\n        GridCacheAdapter ca = ((IgniteKernal)ignite).internalCache(cacheName);\n\n        // Cache was not started.\n        if (ca == null)\n            return null;\n\n        long swapSize;\n        long swapKeys;\n\n        try {\n            swapSize = ca.swapSize();\n            swapKeys = ca.swapKeys();\n        }\n        catch (IgniteCheckedException ignored) {\n            swapSize = -1;\n            swapKeys = -1;\n        }\n\n        Collection<IgnitePair<Integer>> pps = Collections.emptyList();\n        Collection<IgnitePair<Integer>> bps = Collections.emptyList();\n        GridDhtPartitionMap partsMap = null;\n\n        CacheConfiguration cfg = ca.configuration();\n\n        CacheMode mode = cfg.getCacheMode();\n\n\n        boolean partitioned = (mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED)\n            && ca.context().affinityNode();\n\n        if (partitioned) {\n            GridDhtCacheAdapter dca = null;\n\n            if (ca instanceof GridNearCacheAdapter)\n                dca = ((GridNearCacheAdapter)ca).dht();\n            else if (ca instanceof GridDhtCacheAdapter)\n                dca = (GridDhtCacheAdapter)ca;\n\n            if (dca != null) {\n                GridDhtPartitionTopology top = dca.topology();\n\n                if (cfg.getCacheMode() != CacheMode.LOCAL && cfg.getBackups() > 0)\n                    partsMap = top.localPartitionMap();\n\n                List<GridDhtLocalPartition> parts = top.localPartitions();\n\n                pps = new ArrayList<>(parts.size());\n                bps = new ArrayList<>(parts.size());\n\n                for (GridDhtLocalPartition part : parts) {\n                    int p = part.id();\n\n                    int sz = part.size();\n\n                    if (part.primary(AffinityTopologyVersion.NONE)) // Pass -1 as topology version in order not to wait for topology version.\n                        pps.add(new IgnitePair<>(p, sz));\n                    else\n                        bps.add(new IgnitePair<>(p, sz));\n                }\n            }\n            else {\n                // Old way of collecting partitions info.\n                ClusterNode node = ignite.cluster().localNode();\n\n                int[] pp = ca.affinity().primaryPartitions(node);\n\n                pps = new ArrayList<>(pp.length);\n\n                for (int p : pp) {\n                    Set set = ca.entrySet(p);\n\n                    pps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n\n                int[] bp = ca.affinity().backupPartitions(node);\n\n                bps = new ArrayList<>(bp.length);\n\n                for (int p : bp) {\n                    Set set = ca.entrySet(p);\n\n                    bps.add(new IgnitePair<>(p, set != null ? set.size() : 0));\n                }\n            }\n        }\n\n        int size = ca.size();\n        int near = ca.nearSize();\n\n        Set<GridCacheEntryEx> set = ca.map().entries0();\n\n        long memSz = 0;\n\n        Iterator<GridCacheEntryEx> it = set.iterator();\n\n        int sz = sample > 0 ? sample : DFLT_CACHE_SIZE_SAMPLING;\n\n        int cnt = 0;\n\n        while (it.hasNext() && cnt < sz) {\n            memSz += it.next().memorySize();\n\n            cnt++;\n        }\n\n        if (cnt > 0)\n            memSz = (long)((double)memSz / cnt * size);\n\n        VisorCache cache = new VisorCache();\n\n        cache.name = cacheName;\n        cache.mode = mode;\n        cache.memorySize = memSz;\n        cache.size = size;\n        cache.nearSize = near;\n        cache.dhtSize = size - near;\n        cache.primarySize = ca.primarySize();\n        cache.offHeapAllocatedSize = ca.offHeapAllocatedSize();\n        cache.offHeapEntriesCnt = ca.offHeapEntriesCount();\n        cache.swapSize = swapSize;\n        cache.swapKeys = swapKeys;\n        cache.partitions = ca.affinity().partitions();\n        cache.primaryPartitions = pps;\n        cache.backupPartitions = bps;\n        cache.metrics = VisorCacheMetrics.from(ca);\n        cache.partitionsMap = partsMap;\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2645,
    "type": "Return",
    "comment": "@return the Subject instance that represents the account and session data for the newly authenticated user.",
    "code": "    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\n        assertPrincipals(info);\n\n        //get any existing session that may exist - we don't want to lose it:\n        Subject subject = getSubject();\n        Session session = null;\n        if (subject != null) {\n            session = subject.getSession(false);\n        }\n\n        InetAddress authcSourceIP = null;\n        if (token instanceof InetAuthenticationToken) {\n            authcSourceIP = ((InetAuthenticationToken) token).getInetAddress();\n        }\n        if (authcSourceIP == null) {\n            //try the thread local:\n            authcSourceIP = ThreadContext.getInetAddress();\n        }\n\n        return createSubject(info.getPrincipals(), session, true, authcSourceIP);\n    }\n",
    "label": 1,
    "rec": "@return the Subject instance that represents the user and session data for the newly authenticated user."
  },
  {
    "id": 2646,
    "type": "Return",
    "comment": "@return Response.",
    "code": "    public OdbcResponse handle(OdbcRequest req) {\n        assert req != null;\n\n        if (!busyLock.enterBusy())\n            return new OdbcResponse(OdbcResponse.STATUS_FAILED,\n                    \"Failed to handle ODBC request because node is stopping: \" + req);\n\n        try {\n            switch (req.command()) {\n                case HANDSHAKE:\n                    return performHandshake((OdbcHandshakeRequest) req);\n\n                case EXECUTE_SQL_QUERY:\n                    return executeQuery((OdbcQueryExecuteRequest) req);\n\n                case FETCH_SQL_QUERY:\n                    return fetchQuery((OdbcQueryFetchRequest) req);\n\n                case CLOSE_SQL_QUERY:\n                    return closeQuery((OdbcQueryCloseRequest) req);\n\n                case GET_COLUMNS_META:\n                    return getColumnsMeta((OdbcQueryGetColumnsMetaRequest) req);\n\n                case GET_TABLES_META:\n                    return getTablesMeta((OdbcQueryGetTablesMetaRequest) req);\n            }\n\n            return new OdbcResponse(OdbcResponse.STATUS_FAILED, \"Unsupported ODBC request: \" + req);\n        }\n        finally {\n            busyLock.leaveBusy();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2647,
    "type": "Return",
    "comment": "@return an empty {@link List} if the key is not found",
    "code": "public <T> List<T> getList(String key) {\n    @SuppressWarnings(STR)\n    List<T> list = (List<T>) get(key);\n    return list;\n}",
    "label": 1,
    "rec": "@return <code>null</code> if the key is not found"
  },
  {
    "id": 2648,
    "type": "Return",
    "comment": "@return the new leases or null if time ran out",
    "code": "    public Collection<Lease> acquire(int qty, long time, TimeUnit unit) throws Exception\n    {\n        long startMs = System.currentTimeMillis();\n        boolean hasWait = (unit != null);\n        long waitMs = hasWait ? TimeUnit.MILLISECONDS.convert(time, unit) : 0;\n\n        Preconditions.checkArgument(qty > 0, \"qty cannot be 0\");\n\n        ImmutableList.Builder<Lease> builder = ImmutableList.builder();\n        boolean success = false;\n        try\n        {\n            while ( qty-- > 0 )\n            {\n                int retryCount = 0;\n                long startMillis = System.currentTimeMillis();\n                boolean isDone = false;\n                while ( !isDone )\n                {\n                    switch ( internalAcquire1Lease(builder, startMs, hasWait, waitMs) )\n                    {\n                        case CONTINUE:\n                        {\n                            isDone = true;\n                            break;\n                        }\n\n                        case RETURN_NULL:\n                        {\n                            return null;\n                        }\n\n                        case RETRY_DUE_TO_MISSING_NODE:\n                        {\n                            // gets thrown by internalAcquire1Lease when it can't find the lock node\n                            // this can happen when the session expires, etc. So, if the retry allows, just try it all again\n                            if ( !client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )\n                            {\n                                throw new KeeperException.NoNodeException(\"Sequential path not found - possible session loss\");\n                            }\n                            // try again\n                            break;\n                        }\n                    }\n                }\n            }\n            success = true;\n        }\n        finally\n        {\n            if ( !success )\n            {\n                returnAll(builder.build());\n            }\n        }\n\n        return builder.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2649,
    "type": "Return",
    "comment": "@return a resolved {@link Maybe} representation of a given lifecycle, targeting the given event",
    "code": "public static <E> CompletableSource resolveScopeFromLifecycle(Observable<E> lifecycle, final E endEvent, @Nullable final Comparator<E> comparator) {\n    Predicate<E> equalityPredicate;\n    if (comparator != null) {\n        equalityPredicate = new Predicate<E>() {\n\n            @Override\n            public boolean test(E e) {\n                return comparator.compare(e, endEvent) >= NUM;\n            }\n        };\n    } else {\n        equalityPredicate = new Predicate<E>() {\n\n            @Override\n            public boolean test(E e) {\n                return e.equals(endEvent);\n            }\n        };\n    }\n    return lifecycle.skip(NUM).takeUntil(equalityPredicate).ignoreElements();\n}",
    "label": 1,
    "rec": "@return a resolved {@link Completable} representation of a given lifecycle, targeting the given event"
  },
  {
    "id": 2650,
    "type": "Return",
    "comment": "@return Integer reply, specifically: 1 if the key was moved 0 if the key was not moved because already present on the target DB or was not found in the current DB.",
    "code": "    public Long move(final byte[] key, final int dbIndex) {\n        checkIsInMulti();\n        client.move(key, dbIndex);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2651,
    "type": "Return",
    "comment": "@return TVector merged row",
    "code": "public static Vector combineRowSplitsPipeline(GetRowPipelineCache cache, int matrixId, int rowIndex) throws Exception {\n    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n    RowType rowType = matrixMeta.getRowType();\n    switch(rowType) {\n        case T_DOUBLE_DENSE:\n            return combineServerDenseDoubleRowSplitsPipeline(cache, matrixMeta, rowIndex);\n        case T_FLOAT_DENSE:\n            return combineServerDenseFloatRowSplitsPipeline(cache, matrixMeta, rowIndex);\n        case T_INT_DENSE:\n            return combineServerDenseIntRowSplitsPipeline(cache, matrixMeta, rowIndex);\n        case T_LONG_DENSE:\n            return combineServerDenseLongRowSplitsPipeline(cache, matrixMeta, rowIndex);\n        default:\n            return combineServerRowSplits(getAllRowSplitsFromCache(cache), matrixId, rowIndex);\n    }\n}",
    "label": 1,
    "rec": "@return Vector merged row"
  },
  {
    "id": 2652,
    "type": "Return",
    "comment": "@return Predicate converted to closure.",
    "code": "    public static IgniteOutClosure<Boolean> as(final GridAbsPredicate p) {\n        A.notNull(p, \"p\");\n\n        return new CO<Boolean>() {\n            @Override public Boolean apply() {\n                return p.apply();\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2653,
    "type": "Return",
    "comment": "@return size of the directory in bytes",
    "code": "public static long getDirectorySize(Path path, FileSystem fs) throws IOException {\n    ContentSummary cs = fs.getContentSummary(path);\n    return cs.getLength();\n}",
    "label": 1,
    "rec": "@return size of the directory's contents in bytes"
  },
  {
    "id": 2654,
    "type": "Return",
    "comment": "@return  True if there is a persistent storage.",
    "code": "    public boolean removeAllFromStore(@Nullable GridCacheTx tx, Collection<? extends K> keys) throws GridException {\n        if (F.isEmpty(keys))\n            return true;\n\n        if (keys.size() == 1) {\n            K key = keys.iterator().next();\n\n            return removeFromStore(tx, key);\n        }\n\n        if (store != null) {\n            if (log.isDebugEnabled())\n                log.debug(\"Removing values from cache store [keys=\" + keys + ']');\n\n            try {\n                store.removeAll(tx, keys);\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"Removed values from cache store [keys=\" + keys + ']');\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2655,
    "type": "Return",
    "comment": "@return the shared instance of <code>PresentationPropertiesPlugin</code>",
    "code": "public static DiagramPropertiesPlugin getDefault() {\n    return plugin;\n}",
    "label": 1,
    "rec": "@return the shared instance of <code>DiagramPropertiesPlugin</code>"
  },
  {
    "id": 2656,
    "type": "Return",
    "comment": "@return a notification used to tell user that the SpiceService is still running and processing requests.",
    "code": "    public Notification createDefaultNotification() {\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2657,
    "type": "Return",
    "comment": "@return true if file is of size 0",
    "code": "public boolean isEmpty() {\n    return data == null;\n}",
    "label": 1,
    "rec": "@return Whether the file empty or not present."
  },
  {
    "id": 2658,
    "type": "Return",
    "comment": "@return block z",
    "code": "    public int getBlockZ() {\n        return NumberConversions.floor(z);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2659,
    "type": "Return",
    "comment": "@return A non-null array of the {@see WorkbenchModule}s that match the given module type id",
    "code": "public WorkbenchComponent[] findWorkbenchModuleByType(String aModuleTypeId) {\n    WorkbenchComponent[] availableModules = getWorkbenchModules();\n    ComponentType moduleType;\n    List results = new ArrayList();\n    for (int i = NUM; i < availableModules.length; i++) {\n        moduleType = availableModules[i].getModuleType();\n        if (moduleType != null && aModuleTypeId.equals(moduleType.getModuleTypeId()))\n            results.add(availableModules[i]);\n    }\n    if (results.size() == NUM)\n        return NO_MODULES;\n    return (WorkbenchComponent[]) results.toArray(new WorkbenchComponent[results.size()]);\n}",
    "label": 1,
    "rec": "@return A non-null array of the {@see WorkbenchComponent}s that match the given module type id"
  },
  {
    "id": 2660,
    "type": "Return",
    "comment": "@return returns true on success.",
    "code": "    public boolean saveExisting(TYPE item) {\n        ContentValues values = item.getSetValues();\n        if(values == null || values.size() == 0) // nothing changed\n            return true;\n        boolean result = database.update(table.name, values,\n                AbstractModel.ID_PROPERTY.eq(item.getId()).toString(), null) > 0;\n        if(result) {\n            onModelUpdated(item);\n            item.markSaved();\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2661,
    "type": "Return",
    "comment": "@return object associated with the given configuration key.",
    "code": "public Object getProperty(String key) {\n    if (overrideProperties.containsKey(key)) {\n        return overrideProperties.getProperty(key);\n    }\n    Configuration firstMatchingConfiguration = null;\n    for (Configuration config : configList) {\n        if (config.containsKey(key)) {\n            firstMatchingConfiguration = config;\n            break;\n        }\n    }\n    if (firstMatchingConfiguration != null) {\n        return firstMatchingConfiguration.getProperty(key);\n    } else {\n        return null;\n    }\n}",
    "label": 1,
    "rec": "@return object associated with the given configuration key. null if it does not exist."
  },
  {
    "id": 2662,
    "type": "Return",
    "comment": "@return Continuous query manager.",
    "code": "    private CacheContinuousQueryManager manager(GridKernalContext ctx) {\n        GridCacheContext<K, V> cacheCtx = cacheContext(ctx);\n\n        return cacheCtx == null ? null : cacheCtx.continuousQueries();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2663,
    "type": "Return",
    "comment": "@return the flags",
    "code": "public int getFlags() {\n    return _flags;\n}",
    "label": 1,
    "rec": "@return message flags"
  },
  {
    "id": 2664,
    "type": "Return",
    "comment": "@return Cached value.",
    "code": "    @Nullable public V get(K key, boolean deserializePortable, @Nullable IgnitePredicate<Entry<K, V>> filter)\n        throws IgniteCheckedException {\n        return getAllAsync(F.asList(key), deserializePortable, filter).get().get(key);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2665,
    "type": "Return",
    "comment": "@return a resolved {@link Maybe} representation of a given provider",
    "code": "public static <E> CompletableSource resolveScopeFromLifecycle(final LifecycleScopeProvider<E> provider) throws OutsideScopeException {\n    return resolveScopeFromLifecycle(provider, true);\n}",
    "label": 1,
    "rec": "@return a resolved {@link CompletableSource} representation of a given provider"
  },
  {
    "id": 2666,
    "type": "Return",
    "comment": "@return Last generated version.",
    "code": "    public GridCacheVersion last() {\n        return last;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2667,
    "type": "Return",
    "comment": "@return an HttpEntity containing all request parameters",
    "code": "    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {\n        if (streamParams.isEmpty() && fileParams.isEmpty()) {\n            return createFormEntity();\n        } else {\n            return createMultipartEntity(progressHandler);\n        }\n    }\n",
    "label": 1,
    "rec": "@return HttpEntity resulting HttpEntity to be included along with  org.apache.http.client.methods.HttpEntityEnclosingRequestBase"
  },
  {
    "id": 2668,
    "type": "Return",
    "comment": "@return resources",
    "code": "    public List<E> getResources() {\n        return new ArrayList<>(resources.values());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2669,
    "type": "Return",
    "comment": "@return a set of property identifiers, or an empty set, if the entity provides no properties.",
    "code": "public Set<String> getPropertyNames() {\n    return getProperties().keySet();\n}",
    "label": 1,
    "rec": "@return an immutable set of property names, or an empty set, if the entity has no properties."
  },
  {
    "id": 2670,
    "type": "Return",
    "comment": "@return A copy of the input string, without any coloring",
    "code": "    public static String stripColor(final String input) {\n        if (input == null)\n            return null;\n        \n        return input.replaceAll(\"(?i)\\u00A7[0-F]\", \"\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2671,
    "type": "Return",
    "comment": "@return accuracies with first 1, 2, ..., decision trees.",
    "code": "    public int[][] test(DataFrame data) {\n        DataFrame x = formula.x(data);\n\n        int n = x.size();\n        int ntrees = trees.size();\n        int[] p = new int[k];\n        int[][] prediction = new int[ntrees][n];\n\n        for (int j = 0; j < n; j++) {\n            Tuple xj = x.get(j);\n            Arrays.fill(p, 0);\n            for (int i = 0; i < ntrees; i++) {\n                p[trees.get(i).tree.predict(xj)]++;\n                prediction[i][j] = MathEx.whichMax(p);\n            }\n        }\n\n        return prediction;\n    }\n",
    "label": 1,
    "rec": "@return the predictions with first 1, 2, ..., decision trees."
  },
  {
    "id": 2672,
    "type": "Return",
    "comment": "@return configured dragged view margin right configured.",
    "code": "    private float getDragViewMarginRight() {\n        return transformer.getMarginRight();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2673,
    "type": "Return",
    "comment": "@return whether there has been a registered provider",
    "code": "public <T> boolean isProvidedFor(Class<T> service) {\n    synchronized (providers) {\n        return providers.containsKey(service);\n    }\n}",
    "label": 1,
    "rec": "@return true if and only if there are registered providers"
  },
  {
    "id": 2674,
    "type": "Return",
    "comment": "@return Default cache transaction concurrency.",
    "code": "    public IgniteTxConcurrency getDefaultTxConcurrency() {\n        return dfltConcurrency;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2675,
    "type": "Return",
    "comment": "@return form handler return value.",
    "code": "protected Object getFormReturn() {\n    return true;\n}",
    "label": 1,
    "rec": "@return form handler return value. By default, returns true."
  },
  {
    "id": 2676,
    "type": "Return",
    "comment": "@return the strictMatch",
    "code": "\tpublic boolean isStrictMatch() {\n\t\tif (config.isHeartMode()) {\n\t\t\t// HEART mode enforces strict matching\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn strictMatch;\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2677,
    "type": "Return",
    "comment": "@return the Collection of File produced",
    "code": "public File[] build() throws IOException, InterruptedException {\n    if (classScanner.getClasses().isEmpty()) {\n        return null;\n    }\n    LinkedList<File> outputFiles = new LinkedList<File>();\n    Map<String, LinkedList<Class>> map = new LinkedHashMap<String, LinkedList<Class>>();\n    for (Class c : classScanner.getClasses()) {\n        if (Loader.getEnclosingClass(c) != c) {\n            continue;\n        }\n        Loader.ClassProperties p = Loader.loadProperties(c, properties, false);\n        String libraryName = outputName != null ? outputName : p.getProperty(STR, STR);\n        if (libraryName.length() == NUM) {\n            continue;\n        }\n        LinkedList<Class> classList = map.get(libraryName);\n        if (classList == null) {\n            map.put(libraryName, classList = new LinkedList<Class>());\n        }\n        classList.add(c);\n    }\n    for (String libraryName : map.keySet()) {\n        LinkedList<Class> classList = map.get(libraryName);\n        Class[] classArray = classList.toArray(new Class[classList.size()]);\n        File f = generateAndCompile(classArray, libraryName);\n        if (f != null) {\n            outputFiles.add(f);\n            if (copylibs) {\n                Loader.ClassProperties p = Loader.loadProperties(classArray, properties, false);\n                LinkedList<String> preloads = new LinkedList<String>();\n                preloads.addAll(p.get(STR));\n                preloads.addAll(p.get(STR));\n                p = Loader.loadProperties(classArray, properties, true);\n                File directory = f.getParentFile();\n                for (String s : preloads) {\n                    URL[] urls = Loader.findLibrary(null, p, s);\n                    File fi;\n                    try {\n                        fi = new File(urls[NUM].toURI());\n                    } catch (Exception e) {\n                        continue;\n                    }\n                    File fo = new File(directory, fi.getName());\n                    if (fi.exists() && !outputFiles.contains(fo)) {\n                        System.out.println(STR + fi);\n                        FileInputStream fis = new FileInputStream(fi);\n                        FileOutputStream fos = new FileOutputStream(fo);\n                        byte[] buffer = new byte[NUM];\n                        int length;\n                        while ((length = fis.read(buffer)) != -NUM) {\n                            fos.write(buffer, NUM, length);\n                        }\n                        fos.close();\n                        fis.close();\n                        outputFiles.add(fo);\n                    }\n                }\n            }\n        }\n    }\n    File[] files = outputFiles.toArray(new File[outputFiles.size()]);\n    if (jarPrefix != null && files.length > NUM) {\n        File jarFile = new File(jarPrefix + STR + properties.get(STR) + STR);\n        File d = jarFile.getParentFile();\n        if (d != null && !d.exists()) {\n            d.mkdir();\n        }\n        createJar(jarFile, outputDirectory == null ? classScanner.getClassLoader().getPaths() : null, files);\n    }\n    return files;\n}",
    "label": 1,
    "rec": "@return the array of File produced"
  },
  {
    "id": 2678,
    "type": "Return",
    "comment": "@return an instance of the type of this AttributeType.",
    "code": "    public Object parse(String str) {\n        switch (this) {\n            case BYTE:\n                return new Byte(removeDecimalDigitsFromString(str));\n            case SHORT:\n                return new Short(removeDecimalDigitsFromString(str));\n            case INT:\n                return new Integer(removeDecimalDigitsFromString(str));\n            case LONG:\n                return new Long(removeDecimalDigitsFromString(str));\n            case FLOAT:\n                return new Float(str);\n            case DOUBLE:\n                return new Double(str);\n            case BOOLEAN:\n                return new Boolean(str);\n            case CHAR:\n                return new Character(str.charAt(0));\n            case BIGINTEGER:\n                return new BigInteger(removeDecimalDigitsFromString(str));\n            case BIGDECIMAL:\n                return new BigDecimal(str);\n            case DYNAMIC_BYTE:\n            case DYNAMIC_SHORT:\n            case DYNAMIC_INT:\n            case DYNAMIC_LONG:\n            case DYNAMIC_FLOAT:\n            case DYNAMIC_DOUBLE:\n            case DYNAMIC_BOOLEAN:\n            case DYNAMIC_CHAR:\n            case DYNAMIC_STRING:\n            case DYNAMIC_BIGINTEGER:\n            case DYNAMIC_BIGDECIMAL:\n            case TIME_INTERVAL:\n                return parseDynamic(str);\n            case LIST_BYTE:\n                return new ByteList(removeDecimalDigitsFromString(str));\n            case LIST_SHORT:\n                return new ShortList(removeDecimalDigitsFromString(str));\n            case LIST_INTEGER:\n                return new IntegerList(removeDecimalDigitsFromString(str));\n            case LIST_LONG:\n                return new LongList(removeDecimalDigitsFromString(str));\n            case LIST_FLOAT:\n                return new FloatList(str);\n            case LIST_DOUBLE:\n                return new DoubleList(str);\n            case LIST_BOOLEAN:\n                return new BooleanList(str);\n            case LIST_CHARACTER:\n                return new CharacterList(str);\n            case LIST_STRING:\n                return new StringList(str);\n            case LIST_BIGINTEGER:\n                return new BigIntegerList(removeDecimalDigitsFromString(str));\n            case LIST_BIGDECIMAL:\n                return new BigDecimalList(str);\n        }\n        return str;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2679,
    "type": "Return",
    "comment": "@return the  Subject instance reflecting the specified initialization data.",
    "code": "    public Subject createSubject(SubjectContext subjectContext) {\n        //create a copy so we don't modify the argument's backing map:\n        SubjectContext context = copy(subjectContext);\n\n        //ensure that the context has a SecurityManager instance, and if not, add one:\n        context = ensureSecurityManager(context);\n\n        //Resolve an associated Session (usually based on a referenced session ID), and place it in the context before\n        //sending to the SubjectFactory.  The SubjectFactory should not need to know how to acquire sessions as the\n        //process is often environment specific - better to shield the SF from these details:\n        context = resolveSession(context);\n\n        //Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first\n        //if possible before handing off to the SubjectFactory:\n        context = resolvePrincipals(context);\n\n        Subject subject = doCreateSubject(context);\n\n        //save this subject for future reference if necessary:\n        //(this is needed here in case rememberMe principals were resolved and they need to be stored in the\n        //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).\n        //Added in 1.2:\n        save(subject);\n\n        return subject;\n    }\n",
    "label": 1,
    "rec": "@return the  Subject instance reflecting the specified contextual data."
  },
  {
    "id": 2680,
    "type": "Return",
    "comment": "@return Remote candidates.",
    "code": "    public Collection<GridCacheMvccCandidate> remoteCandidates() {\n        Collection<GridCacheMvccCandidate> rmtCands = new LinkedList<>();\n\n        for (GridDistributedCacheEntry entry : locked()) {\n            rmtCands.addAll(entry.remoteMvccSnapshot());\n        }\n\n        return rmtCands;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2681,
    "type": "Return",
    "comment": "@return an <code>InputStream</code> from the managed target or <code>null</code> if the given target is not managed.",
    "code": "public InputStream getInputStream(String managedFile) throws IOException {\n    return getInputStream(managedFile, ReliableFile.OPEN_BEST_AVAILABLE);\n}",
    "label": 1,
    "rec": "@return an input stream to the managed file or <code>null</code> if the given name is not managed."
  },
  {
    "id": 2682,
    "type": "Return",
    "comment": "@return a read context",
    "code": "    public static DocumentContext parse(String json) {\n        return new JsonContext().parse(json);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2683,
    "type": "Return",
    "comment": "@return null on failure. Otherwise, a uri for an audio file.",
    "code": "public Uri getUriToPlay() {\n    final Intent received = getIntent();\n    final Bundle data = received.getExtras();\n    final String uriText = data.getString(Keys.URI);\n    return Uri.parse(uriText);\n}",
    "label": 1,
    "rec": "@return A uri for an audio file."
  },
  {
    "id": 2684,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage setValueMessage(int level) {\n\t\tif(isGetSupported == false) {\n\t\t\tlogger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n\t\t\treturn null;\n\t\t}\n\n\t\tlogger.debug(\"NODE {}: Creating new message for application command SWITCH_BINARY_SET\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.SendData, SerialMessagePriority.Set);\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \n    \t\t\t\t\t\t\t3, \n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \n\t\t\t\t\t\t\t\t(byte) SWITCH_BINARY_SET,\n\t\t\t\t\t\t\t\t(byte) (level > 0 ? 0xFF : 0x00)\n\t\t\t\t\t\t\t\t};\n    \tresult.setMessagePayload(newPayload);\n    \treturn result;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2685,
    "type": "Return",
    "comment": "@return true if there is a chain of projection operators; false otherwise",
    "code": "public static LOProject chainOfProjects(LogicalPlan plan) {\n    LOProject topProject = null;\n    if (plan == null) {\n        return null;\n    }\n    List<LogicalOperator> leaves = plan.getLeaves();\n    if (leaves == null) {\n        return null;\n    }\n    if (leaves.size() > NUM) {\n        return null;\n    }\n    LogicalOperator node = leaves.get(NUM);\n    while (true) {\n        if (node == null) {\n            return null;\n        }\n        if (node instanceof LOProject) {\n            topProject = (LOProject) node;\n        } else if (node instanceof LOCast) {\n        } else {\n            return null;\n        }\n        List<LogicalOperator> predecessors = plan.getPredecessors(node);\n        if (predecessors == null) {\n            return topProject;\n        }\n        if (predecessors.size() > NUM) {\n            return null;\n        }\n        node = predecessors.get(NUM);\n    }\n}",
    "label": 1,
    "rec": "@return the top most projection operator if there is a chain of projection operators with or without casts; null otherwise"
  },
  {
    "id": 2686,
    "type": "Return",
    "comment": "@return mongoClient instance, which will be shared for whole Keycloak",
    "code": "    protected MongoClient createMongoClient() throws UnknownHostException {\n        operationalInfo = new LinkedHashMap<>();\n        String dbName = config.get(\"db\", \"keycloak\");\n\n        String uriString = config.get(\"uri\");\n        if (uriString != null) {\n            MongoClientURI uri = new MongoClientURI(uriString);\n            MongoClient client = new MongoClient(uri);\n\n            String hosts = String.join(\", \", uri.getHosts());\n            operationalInfo.put(\"mongoHosts\", hosts);\n            operationalInfo.put(\"mongoDatabaseName\", dbName);\n            operationalInfo.put(\"mongoUser\", uri.getUsername());\n            operationalInfo.put(\"mongoDriverVersion\", client.getVersion());\n\n            logger.debugv(\"Initialized mongo model. host(s): %s, db: %s\", uri.getHosts(), dbName);\n            return client;\n        } else {\n            String host = config.get(\"host\", ServerAddress.defaultHost());\n            int port = config.getInt(\"port\", ServerAddress.defaultPort());\n\n            String user = config.get(\"user\");\n            String password = config.get(\"password\");\n\n            MongoClientOptions clientOptions = getClientOptions();\n\n            MongoClient client;\n            if (user != null && password != null) {\n                MongoCredential credential = MongoCredential.createMongoCRCredential(user, dbName, password.toCharArray());\n                client = new MongoClient(new ServerAddress(host, port), Collections.singletonList(credential), clientOptions);\n            } else {\n                client = new MongoClient(new ServerAddress(host, port), clientOptions);\n            }\n\n            operationalInfo.put(\"mongoServerAddress\", client.getAddress().toString());\n            operationalInfo.put(\"mongoDatabaseName\", dbName);\n            operationalInfo.put(\"mongoUser\", user);\n            operationalInfo.put(\"mongoDriverVersion\", client.getVersion());\n\n            logger.debugv(\"Initialized mongo model. host: %s, port: %d, db: %s\", host, port, dbName);\n            return client;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2687,
    "type": "Return",
    "comment": "@return the  Integer,  Float,  Long,  Double,  String or  Type corresponding to the given constant pool item.",
    "code": "    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch (b[index - 1]) {\n        case ClassWriter.INT:\n            return readInt(index);\n        case ClassWriter.FLOAT:\n            return Float.intBitsToFloat(readInt(index));\n        case ClassWriter.LONG:\n            return readLong(index);\n        case ClassWriter.DOUBLE:\n            return Double.longBitsToDouble(readLong(index));\n        case ClassWriter.CLASS:\n            return Type.getObjectType(readUTF8(index, buf));\n        case ClassWriter.STR:\n            return readUTF8(index, buf);\n        case ClassWriter.MTYPE:\n            return Type.getMethodType(readUTF8(index, buf));\n        default: // case ClassWriter.HANDLE_BASE + [1..9]:\n            int tag = readByte(index);\n            int[] items = this.items;\n            int cpIndex = items[readUnsignedShort(index + 1)];\n            String owner = readClass(cpIndex, buf);\n            cpIndex = items[readUnsignedShort(cpIndex + 2)];\n            String name = readUTF8(cpIndex, buf);\n            String desc = readUTF8(cpIndex + 2, buf);\n            return new Handle(tag, owner, name, desc);\n        }\n    }\n",
    "label": 1,
    "rec": "@return the  Integer,  Float,  Long,  Double,  String,  Type or  Handle corresponding to the given constant pool item."
  },
  {
    "id": 2688,
    "type": "Return",
    "comment": "@return the SortingParams Object",
    "code": "    public SortingParams by(final String pattern) {\n\treturn by(pattern.getBytes(Protocol.UTF8));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2689,
    "type": "Return",
    "comment": "@return null if the inputstream is null, a string otherwise",
    "code": "public static String toString(InputStream inputStream, boolean close) throws IOException {\n    if (inputStream == null) {\n        throw new NullPointerException(STR);\n    }\n    String string;\n    StringBuilder outputBuilder = new StringBuilder();\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, STR));\n        while (null != (string = reader.readLine())) {\n            outputBuilder.append(string).append(STR);\n        }\n    } finally {\n        if (close) {\n            close(inputStream);\n        }\n    }\n    return outputBuilder.toString();\n}",
    "label": 1,
    "rec": "@return a string"
  },
  {
    "id": 2690,
    "type": "Return",
    "comment": "@return  True if entries should not be deleted from cache immediately.",
    "code": "    public boolean deferredDelete() {\n        GridCacheAdapter<K, V> cache = this.cache;\n\n        if (cache == null)\n            throw new IllegalStateException(\"Cache stopped: \" + cacheName);\n\n        return deferredDelete(cache);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2691,
    "type": "Return",
    "comment": "@return true if the current View represents a question in the form",
    "code": "private boolean currentPromptIsQuestion() {\n    return (mFormEntryModel.getEvent() == FormEntryController.EVENT_QUESTION) || currentPromptIsGroupFolio();\n}",
    "label": 1,
    "rec": "@return true if the current View represents a question or group folio in the form"
  },
  {
    "id": 2692,
    "type": "Return",
    "comment": "@return Login.",
    "code": "    public Object getLogin() {\n        return login;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2693,
    "type": "Return",
    "comment": "@return -1 if the factor doesn't exist or the weight value specified is invalid, the original value before update otherwise.",
    "code": "  public int adjustFactorWeight(String factorName, int weight){\n    // shortcut if the input is invalid.\n    if (factorName == null ||\n        factorName.length() == 0||\n        weight < 0 ||\n        Integer.MAX_VALUE - this.getTotalWeight() < weight){\n      throw new IllegalArgumentException(\"unable to adjust factor weight as one or more of the input parameters are invalid\");\n    }\n\n    FactorComparator<T> value = this.factorComparatorList.get(factorName);\n\n    // shortcut if the key doesn't exist.\n    if (null == value){\n      throw new IllegalArgumentException(String.format(\n          \"unable to udpate weight as the specified factorName %s doesn't exist\",\n          factorName));\n    }\n\n    int returnVal = value.getWeight();\n    value.updateWeight(weight);\n    return returnVal;\n  }\n",
    "label": 1,
    "rec": "@return the original value before update."
  },
  {
    "id": 2694,
    "type": "Return",
    "comment": "@return Cache configuration for atomic data structures.",
    "code": "        private static CacheConfiguration atomicsSystemCache(AtomicConfiguration cfg, boolean client) {\n            CacheConfiguration ccfg = new CacheConfiguration();\n\n            ccfg.setName(CU.ATOMICS_CACHE_NAME);\n            ccfg.setAtomicityMode(TRANSACTIONAL);\n            ccfg.setSwapEnabled(false);\n            ccfg.setQueryIndexEnabled(false);\n            ccfg.setRebalanceMode(SYNC);\n            ccfg.setWriteSynchronizationMode(FULL_SYNC);\n            ccfg.setCacheMode(cfg.getCacheMode());\n\n            if (cfg.getCacheMode() == PARTITIONED) {\n                ccfg.setBackups(cfg.getBackups());\n\n                ccfg.setDistributionMode(client ? NEAR_ONLY : NEAR_PARTITIONED);\n            }\n            else\n                ccfg.setDistributionMode(client ? NEAR_ONLY : PARTITIONED_ONLY);\n\n            return ccfg;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2695,
    "type": "Return",
    "comment": "@return the correct {@link RestLiMethodAdapter} for the provided {@link ResourceMethod}",
    "code": "public static RestLiArgumentBuilder getMethodAdapter(final ResourceMethod resourceMethod) {\n    return _adapters.get(resourceMethod);\n}",
    "label": 1,
    "rec": "@return the correct {@link RestLiArgumentBuilder} for the provided {@link ResourceMethod}"
  },
  {
    "id": 2696,
    "type": "Return",
    "comment": "@return rolling max active threads",
    "code": "    public long getRollingMaxActiveThreads() {\n        return getRollingMax(HystrixRollingNumberEvent.THREAD_MAX_ACTIVE);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2697,
    "type": "Return",
    "comment": "@return Query object.",
    "code": "public Select where(String selection) {\n    this.selection = selection;\n    return this;\n}",
    "label": 1,
    "rec": "@return Select object."
  },
  {
    "id": 2698,
    "type": "Return",
    "comment": "@return  True if this is trash ID.",
    "code": "    private static boolean isTrashId(IgniteUuid id) {\n        if (id == null)\n            return false;\n\n        UUID gid = id.globalId();\n\n        return id.localId() == 0 && gid.getMostSignificantBits() == 0 &&\n            gid.getLeastSignificantBits() > 0 && gid.getLeastSignificantBits() <= TRASH_CONCURRENCY;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2699,
    "type": "Return",
    "comment": "@return this {@link HystrixCommandBuilder}",
    "code": "public Builder ignoreExceptions(Class<? extends Throwable>[] pIgnoreExceptions) {\n    this.ignoreExceptions = ImmutableList.copyOf(pIgnoreExceptions);\n    return this;\n}",
    "label": 1,
    "rec": "@return this {@link HystrixCommandBuilder.Builder}"
  },
  {
    "id": 2700,
    "type": "Return",
    "comment": "@return Callable for execution in async and sync mode.",
    "code": "    private Callable<Long> internalUpdate(final long l, final boolean updated) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteTx tx = CU.txStartInternal(ctx, seqView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicSequenceValue seq = seqView.get(key);\n\n                    checkRemoved();\n\n                    assert seq != null;\n\n                    long curLocVal;\n\n                    long newUpBound;\n\n                    lock.lock();\n\n                    try {\n                        curLocVal = locVal;\n\n                        // If local range was already reserved in another thread.\n                        if (locVal + l <= upBound) {\n                            long retVal = locVal;\n\n                            locVal += l;\n\n                            return updated ? locVal : retVal;\n                        }\n\n                        long curGlobalVal = seq.get();\n\n                        long newLocVal;\n\n                        /* We should use offset because we already reserved left side of range.*/\n                        long off = batchSize > 1 ? batchSize - 1 : 1;\n\n                        // Calculate new values for local counter, global counter and upper bound.\n                        if (curLocVal + l >= curGlobalVal) {\n                            newLocVal = curLocVal + l;\n\n                            newUpBound = newLocVal + off;\n                        }\n                        else {\n                            newLocVal = curGlobalVal;\n\n                            newUpBound = newLocVal + off;\n                        }\n\n                        locVal = newLocVal;\n                        upBound = newUpBound;\n\n                        if (updated)\n                            curLocVal = newLocVal;\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n\n                    // Global counter must be more than reserved upper bound.\n                    seq.set(newUpBound + 1);\n\n                    seqView.put(key, seq);\n\n                    tx.commit();\n\n                    return curLocVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to get and add: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2701,
    "type": "Return",
    "comment": "@return the predicted class label. If the instance is of all zeros, return returns Integer.MIN_VALUE.",
    "code": "    public int predict(int[] x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob;\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    logprob = Math.log(priori[i]);\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += x[j] * logcondprob[i][j];\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    logprob = Math.log(priori[i]);\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += logcondprob[i][j];\n                        } else {\n                            logprob += Math.log(1.0 - Math.exp(logcondprob[i][j]));\n                        }\n                    }\n                    break;\n\n                case CNB:\n                case WCNB:\n                case TWCNB:\n                    logprob = 0.0;\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob -= x[j] * logcondprob[i][j];\n                        }\n                    }\n                    break;\n\n                default:\n                    // we should never reach here\n                    throw new IllegalStateException(\"Unknown model: \" + model);\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        MathEx.softmax(posteriori);\n        return MathEx.whichMax(posteriori);\n    }\n",
    "label": 1,
    "rec": "@return the predicted class label. If the instance is of all zeros, returns Integer.MIN_VALUE."
  },
  {
    "id": 2702,
    "type": "Return",
    "comment": "@return topic rest path",
    "code": "    public String getRestPath() {\n        if (isV2()) {\n            return String.format(\"%s/%s/%s\", tenant, namespacePortion, getEncodedLocalName());\n        } else {\n            return String.format(\"%s/%s/%s/%s\", tenant, cluster, namespacePortion, getEncodedLocalName());\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2703,
    "type": "Return",
    "comment": "@return int, the next handle to represent the next cyclic reference",
    "code": "private Integer nextHandle() {\n    return Integer.valueOf(this.currentHandle++);\n}",
    "label": 1,
    "rec": "@return the next handle to represent the next cyclic reference"
  },
  {
    "id": 2704,
    "type": "Return",
    "comment": "@return the serial message",
    "code": "\tpublic SerialMessage getValueMessage() {\n\t\tif(isGetSupported == false) {\n\t\t\tlogger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n\t\t\treturn null;\n\t\t}\n\n\t\tlogger.debug(\"Creating new message for application command BASIC_GET for node {}\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Get);\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \n    \t\t\t\t\t\t\t2, \n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \n\t\t\t\t\t\t\t\t(byte) BASIC_GET };\n    \tresult.setMessagePayload(newPayload);\n    \treturn result;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2705,
    "type": "Return",
    "comment": "@return the Maven coordinates stored in the given descriptor, or <code>null</code>",
    "code": "public static MavenRepositoryCoordinates readMavenCoordinateProperties(IArtifactDescriptor descriptor) {\n    GAV gav = RepositoryLayoutHelper.getGAV(descriptor.getProperties());\n    if (gav == null) {\n        return null;\n    }\n    String classifier = RepositoryLayoutHelper.getClassifier(descriptor.getProperties());\n    String extension = RepositoryLayoutHelper.getExtension(descriptor.getProperties());\n    return new MavenRepositoryCoordinates(gav, classifier, extension);\n}",
    "label": 1,
    "rec": "@return the Maven coordinates stored in the properties of the given descriptor, or <code>null</code>"
  },
  {
    "id": 2706,
    "type": "Return",
    "comment": "@return word statistics",
    "code": "    public CmsWordStatistics search(short siteId, String word) {\n        if (CommonUtils.notEmpty(word)) {\n            CmsWord entity = wordService.getEntity(siteId, word);\n            if (null == entity) {\n                entity = new CmsWord();\n                entity.setName(word);\n                entity.setSiteId(siteId);\n                entity.setHidden(true);\n                entity.setSearchCount(1);\n                wordService.save(entity);\n            }\n            CmsWordStatistics wordStatistics = wordCache.get(entity.getId());\n            if (null == wordStatistics) {\n                wordStatistics = new CmsWordStatistics(entity.getId(), 1, entity);\n            } else {\n                wordStatistics.setSearchCounts(wordStatistics.getSearchCounts() + 1);\n            }\n            List<CmsWordStatistics> list = wordCache.put(entity.getId(), wordStatistics);\n            if (CommonUtils.notEmpty(list)) {\n                wordService.updateStatistics(list);\n            }\n            return wordStatistics;\n        } else {\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2707,
    "type": "Return",
    "comment": "@return the icon default color",
    "code": "@ColorInt\npublic int getColor() {\n    return mIconBrush.getColorForCurrentState();\n}",
    "label": 1,
    "rec": "@return the icon color"
  },
  {
    "id": 2708,
    "type": "Return",
    "comment": "@return true if the element and method should be generated",
    "code": "    public boolean generateInsert() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        return tableConfiguration.isInsertStatementEnabled();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2709,
    "type": "Return",
    "comment": "@return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.",
    "code": "public Object writeReplace(Object mockitoMock) throws ObjectStreamException {\n    mutex.lock();\n    try {\n        if (mockIsCurrentlyBeingReplaced()) {\n            return mockitoMock;\n        }\n        mockReplacementStarted();\n        return new CrossClassLoaderSerializationProxy(mockitoMock);\n    } catch (IOException ioe) {\n        MockUtil mockUtil = new MockUtil();\n        MockName mockName = mockUtil.getMockName(mockitoMock);\n        String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n        throw new MockitoSerializationIssue(join(STR + mockName + STR + mockedType + STR, STR + ioe.getClass().getSimpleName() + STR, STR + ioe.getMessage()), ioe);\n    } finally {\n        mockReplacementCompleted();\n        mutex.unlock();\n    }\n}",
    "label": 1,
    "rec": "@return A wrapper ({@link CrossClassLoaderSerializationProxy}) to be serialized by the calling ObjectOutputStream."
  },
  {
    "id": 2710,
    "type": "Return",
    "comment": "@return Response.",
    "code": "    private OdbcResponse performHandshake(long reqId, OdbcHandshakeRequest req) {\n        OdbcHandshakeResult res;\n\n        if (req.version() == OdbcMessageParser.PROTO_VER)\n            res = new OdbcHandshakeResult(true, null, null);\n        else {\n            IgniteProductVersion ver = ctx.grid().version();\n\n            String verStr = Byte.toString(ver.major()) + '.' + ver.minor() + '.' + ver.maintenance();\n\n            res = new OdbcHandshakeResult(false, OdbcMessageParser.PROTO_VER_SINCE, verStr);\n        }\n\n        return new OdbcResponse(res);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2711,
    "type": "Return",
    "comment": "@return Orientation in interval -pi to +pi where 0 is north and pi is south",
    "code": "@Deprecated\npublic double calcOrientation(double lat1, double lon1, double lat2, double lon2) {\n    return Math.atan2(lat2 - lat1, lon2 - lon1);\n}",
    "label": 1,
    "rec": "@return Orientation in interval -pi to +pi where 0 is east <p>"
  },
  {
    "id": 2712,
    "type": "Return",
    "comment": "@return  True in case the entry really was deleted form the file system by this call.",
    "code": "    private boolean delete(String name, IgniteUuid id) throws IgniteCheckedException {\n        assert name != null;\n        assert id != null;\n\n        while (true) {\n            IgfsFileInfo info = meta.info(id);\n\n            if (info != null) {\n                if (info.isDirectory()) {\n                    if (!deleteDirectoryContents(TRASH_ID, id))\n                        return false;\n\n                    if (meta.delete(TRASH_ID, name, id))\n                        return true;\n                }\n                else {\n                    assert info.isFile();\n\n                    // Lock the file with special lock Id to prevent concurrent writing:\n                    IgfsFileInfo lockedInfo = meta.lock(id, true);\n\n                    if (lockedInfo == null)\n                        return false; // File is locked, we cannot delete it.\n\n                    assert id.equals(lockedInfo.id());\n\n                    // Delete file content first.\n                    // In case this node crashes, other node will re-delete the file.\n                    data.delete(lockedInfo).get();\n\n                    boolean ret = meta.delete(TRASH_ID, name, id);\n\n                    if (info.path() != null)\n                        IgfsUtils.sendEvents(igfsCtx.kernalContext(), info.path(), EVT_IGFS_FILE_PURGED);\n\n                    return ret;\n                }\n            }\n            else\n                return false; // Entry was deleted concurrently.\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2713,
    "type": "Return",
    "comment": "@return the set of URLs, not null",
    "code": "    public static Collection<URL> forManifest(final URL url) {\n        final Collection<URL> result = new ArrayList<URL>();\n        result.add(url);\n        try {\n            final String part = cleanPath(url);\n            File jarFile = new File(part);\n            JarFile myJar = new JarFile(part);\n            URL validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), part);\n            if (validUrl != null) { result.add(validUrl); }\n            final Manifest manifest = myJar.getManifest();\n            if (manifest != null) {\n                final String classPath = manifest.getMainAttributes().getValue(new Attributes.Name(\"Class-Path\"));\n                if (classPath != null) {\n                    for (String jar : classPath.split(\" \")) {\n                        validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), jar);\n                        if (validUrl != null) { result.add(validUrl); }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            // don't do anything, we're going on the assumption it is a jar, which could be wrong\n        }\n        return distinctUrls(result);\n    }\n",
    "label": 1,
    "rec": "@return the collection of URLs, not null"
  },
  {
    "id": 2714,
    "type": "Return",
    "comment": "@return Client.",
    "code": "    protected GridCommunicationClient createTcpClient(ClusterNode node) throws GridException {\n        Collection<String> rmtAddrs0 = node.attribute(createSpiAttributeName(ATTR_ADDRS));\n        Collection<String> rmtHostNames0 = node.attribute(createSpiAttributeName(ATTR_HOST_NAMES));\n        Integer boundPort = node.attribute(createSpiAttributeName(ATTR_PORT));\n        Collection<InetSocketAddress> extAddrs = node.attribute(createSpiAttributeName(ATTR_EXT_ADDRS));\n\n        boolean isRmtAddrsExist = (!F.isEmpty(rmtAddrs0) && boundPort != null);\n        boolean isExtAddrsExist = !F.isEmpty(extAddrs);\n\n        if (!isRmtAddrsExist && !isExtAddrsExist)\n            throw new GridException(\"Failed to send message to the destination node. Node doesn't have any \" +\n                \"TCP communication addresses or mapped external addresses. Check configuration and make sure \" +\n                \"that you use the same communication SPI on all nodes. Remote node id: \" + node.id());\n\n        List<InetSocketAddress> addrs;\n\n        // Try to connect first on bound addresses.\n        if (isRmtAddrsExist) {\n            addrs = new ArrayList<>(U.toSocketAddresses(rmtAddrs0, rmtHostNames0, boundPort));\n\n            boolean sameHost = U.sameMacs(getSpiContext().localNode(), node);\n\n            Collections.sort(addrs, U.inetAddressesComparator(sameHost));\n        }\n        else\n            addrs = new ArrayList<>();\n\n        // Then on mapped external addresses.\n        if (isExtAddrsExist)\n            addrs.addAll(extAddrs);\n\n        boolean conn = false;\n        GridCommunicationClient client = null;\n        GridException errs = null;\n\n        int connectAttempts = 1;\n\n        for (InetSocketAddress addr : addrs) {\n            long connTimeout0 = connTimeout;\n\n            int attempt = 1;\n\n            while (!conn) { // Reconnection on handshake timeout.\n                try {\n                    SocketChannel ch = SocketChannel.open();\n\n                    ch.configureBlocking(true);\n\n                    ch.socket().setTcpNoDelay(tcpNoDelay);\n                    ch.socket().setKeepAlive(true);\n\n                    if (sockRcvBuf > 0)\n                        ch.socket().setReceiveBufferSize(sockRcvBuf);\n\n                    if (sockSndBuf > 0)\n                        ch.socket().setSendBufferSize(sockSndBuf);\n\n                    GridNioRecoveryDescriptor recoveryDesc = recoveryDescriptor(node);\n\n                    if (!recoveryDesc.reserve()) {\n                        U.closeQuiet(ch);\n\n                        return null;\n                    }\n\n                    long rcvCnt = -1;\n\n                    try {\n                        ch.socket().connect(addr, (int)connTimeout);\n\n                        rcvCnt = safeHandshake(ch, recoveryDesc, node.id(), connTimeout0);\n\n                        if (rcvCnt == -1)\n                            return null;\n                    }\n                    finally {\n                        if (recoveryDesc != null && rcvCnt == -1)\n                            recoveryDesc.release();\n                    }\n\n                    UUID diffVerNodeId = null;\n\n                    IgniteProductVersion locVer = getSpiContext().localNode().version();\n                    IgniteProductVersion rmtVer = node.version();\n\n                    if (!locVer.equals(rmtVer))\n                        diffVerNodeId = node.id();\n\n                    try {\n                        Map<Integer, Object> meta = new HashMap<>();\n\n                        meta.put(NODE_ID_META, node.id());\n                        meta.put(GridNioServer.DIFF_VER_NODE_ID_META_KEY, diffVerNodeId);\n\n                        if (recoveryDesc != null) {\n                            recoveryDesc.onHandshake(rcvCnt);\n\n                            meta.put(-1, recoveryDesc);\n                        }\n\n                        GridNioSession ses = nioSrvr.createSession(ch, meta).get();\n\n                        client = new GridTcpNioCommunicationClient(ses, log);\n\n                        conn = true;\n                    }\n                    finally {\n                        if (!conn) {\n                            if (recoveryDesc != null)\n                                recoveryDesc.release();\n                        }\n                    }\n                }\n                catch (HandshakeTimeoutException e) {\n                    if (client != null) {\n                        client.forceClose();\n\n                        client = null;\n                    }\n\n                    if (log.isDebugEnabled())\n                        log.debug(\n                            \"Handshake timedout (will retry with increased timeout) [timeout=\" + connTimeout0 +\n                                \", addr=\" + addr + \", err=\" + e + ']');\n\n                    if (attempt == reconCnt || connTimeout0 > maxConnTimeout) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Handshake timedout (will stop attempts to perform the handshake) \" +\n                                \"[timeout=\" + connTimeout0 + \", maxConnTimeout=\" + maxConnTimeout +\n                                \", attempt=\" + attempt + \", reconCnt=\" + reconCnt +\n                                \", err=\" + e.getMessage() + \", addr=\" + addr + ']');\n\n                        if (errs == null)\n                            errs = new GridException(\"Failed to connect to node (is node still alive?). \" +\n                                \"Make sure that each GridComputeTask and GridCacheTransaction has a timeout set \" +\n                                \"in order to prevent parties from waiting forever in case of network issues \" +\n                                \"[nodeId=\" + node.id() + \", addrs=\" + addrs + ']');\n\n                        errs.addSuppressed(new GridException(\"Failed to connect to address: \" + addr, e));\n\n                        break;\n                    }\n                    else {\n                        attempt++;\n\n                        connTimeout0 *= 2;\n\n                        // Continue loop.\n                    }\n                }\n                catch (Exception e) {\n                    if (client != null) {\n                        client.forceClose();\n\n                        client = null;\n                    }\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Client creation failed [addr=\" + addr + \", err=\" + e + ']');\n\n                    if (X.hasCause(e, SocketTimeoutException.class))\n                        LT.warn(log, null, \"Connect timed out (consider increasing 'connTimeout' \" +\n                            \"configuration property) [addr=\" + addr + ']');\n\n                    if (errs == null)\n                        errs = new GridException(\"Failed to connect to node (is node still alive?). \" +\n                            \"Make sure that each GridComputeTask and GridCacheTransaction has a timeout set \" +\n                            \"in order to prevent parties from waiting forever in case of network issues \" +\n                            \"[nodeId=\" + node.id() + \", addrs=\" + addrs + ']');\n\n                    errs.addSuppressed(new GridException(\"Failed to connect to address: \" + addr, e));\n\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2 &&\n                        (e instanceof ConnectException || X.hasCause(e, ConnectException.class))) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break;\n                }\n            }\n\n            if (conn)\n                break;\n        }\n\n        if (client == null) {\n            assert errs != null;\n\n            if (X.hasCause(errs, ConnectException.class))\n                LT.warn(log, null, \"Failed to connect to a remote node \" +\n                    \"(make sure that destination node is alive and \" +\n                    \"operating system firewall is disabled on local and remote hosts) \" +\n                    \"[addrs=\" + addrs + ']');\n\n            throw errs;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Created client: \" + client);\n\n        return client;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2715,
    "type": "Return",
    "comment": "@return a NetworkParameters representing the network the address is intended for, or null if unknown.",
    "code": "public NetworkParameters getParameters() {\n    return params;\n}",
    "label": 1,
    "rec": "@return a NetworkParameters representing the network the address is intended for."
  },
  {
    "id": 2716,
    "type": "Return",
    "comment": "@return sum in nanocoins.",
    "code": "    public Coin getValueSentFromMe(Wallet wallet) throws ScriptException {\n        maybeParse();\n        // This is tested in WalletTest.\n        Coin v = Coin.ZERO;\n        for (TransactionInput input : inputs) {\n            // This input is taking value from a transaction in our wallet. To discover the value,\n            // we must find the connected transaction.\n            TransactionOutput connected = input.getConnectedOutput(wallet.unspent);\n            if (connected == null)\n                connected = input.getConnectedOutput(wallet.spent);\n            if (connected == null)\n                connected = input.getConnectedOutput(wallet.pending);\n            if (connected == null)\n                continue;\n            // The connected output may be the change to the sender of a previous input sent to this wallet. In this\n            // case we ignore it.\n            if (!connected.isMineOrWatched(wallet))\n                continue;\n            v = v.add(connected.getValue());\n        }\n        return v;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2717,
    "type": "Return",
    "comment": "@return this request",
    "code": "public Request setURI(final URI uri) {\n    if (uri == null) {\n        throw new NullPointerException(STR);\n    }\n    final String host = uri.getHost() == null ? STR : uri.getHost();\n    try {\n        InetAddress destAddress = InetAddress.getByName(host);\n        setDestination(destAddress);\n        return setOptions(new URI(uri.getScheme(), null, host, uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment()));\n    } catch (UnknownHostException e) {\n        throw new IllegalArgumentException(STR + host);\n    } catch (URISyntaxException e) {\n        LOGGER.log(Level.WARNING, STR, e);\n        throw new IllegalArgumentException(e);\n    }\n}",
    "label": 1,
    "rec": "@return This request for command chaining."
  },
  {
    "id": 2718,
    "type": "Return",
    "comment": "@return Cache configuration.",
    "code": "    private CacheConfiguration cacheConfiguration() {\n        CacheConfiguration cc = defaultCacheConfiguration();\n\n        cc.setCacheMode(PARTITIONED);\n        cc.setBackups(1);\n        cc.setPreloadMode(SYNC);\n        cc.setWriteSynchronizationMode(FULL_SYNC);\n        cc.setSwapEnabled(true);\n        cc.setEvictNearSynchronized(false);\n        cc.setEvictSynchronized(false);\n        cc.setDistributionMode(PARTITIONED_ONLY);\n\n        return cc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2719,
    "type": "Return",
    "comment": "@return the timed task created",
    "code": "public static TimedTask createTask(String taskName, boolean accumulativity) {\n    previousTask = new TimedTask(taskName, previousTask, globalPerformanceMetrics, accumulativity);\n    return previousTask;\n}",
    "label": 1,
    "rec": "@return the created timed task"
  },
  {
    "id": 2720,
    "type": "Return",
    "comment": "@return Parsed select.",
    "code": "    public static GridSqlQuery parse(JdbcPreparedStatement stmt) {\n        Command cmd = COMMAND.get(stmt);\n\n        Getter<Command,Prepared> p = prepared;\n\n        if (p == null) {\n            Class<? extends Command> cls = cmd.getClass();\n\n            assert cls.getSimpleName().equals(\"CommandContainer\");\n\n            prepared = p = getter(cls, \"prepared\");\n        }\n\n        Prepared select = p.get(cmd);\n\n        return new GridSqlQueryParser().parse((Select)select);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2721,
    "type": "Return",
    "comment": "@return SharedObjectDescription to be associated with given receiver. A non-null SharedObjectDescription <b>must</b> be returned.",
    "code": "protected RemoteSharedObjectDescription getReplicaDescription(ID receiver) {\n    return new RemoteSharedObjectDescription(getID(), getClass().getName(), getConfig().getProperties());\n}",
    "label": 1,
    "rec": "@return RemoteSharedObjectDescription to be associated with given receiver. A non-null RemoteSharedObjectDescription <b>must</b> be returned."
  },
  {
    "id": 2722,
    "type": "Summary",
    "comment": "Return SQL selector query for getting tasks with a given tag",
    "code": "        public static QueryTemplate queryTemplate(Criterion criterion, TagData tagData) {\n            return new QueryTemplate().join(Join.inner(Metadata.TABLE,\n                    Task.ID.eq(Metadata.TASK))).where(tagEqIgnoreCase(tagData.getValue(TagData.NAME), criterion));\n        }\n",
    "label": 1,
    "rec": "Return SQL selector query for getting tasks with a given tagData"
  },
  {
    "id": 2723,
    "type": "Summary",
    "comment": "Return period of ghost connections cleanup task call",
    "code": "    public int getGhostConnsCleanupPeriod() {\n        return -1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2724,
    "type": "Summary",
    "comment": "Allocates an initialized and initially unlocked spin lock",
    "code": "\tpublic static SpinLock allocateSpinLock() {\r\n\t\tlong address = allocateAlignedMemory(UnsafeAdapter.LONG_SIZE);\r\n\t\tputLong(address, NO_LOCK);\r\n\t\treturn new MemSpinLock(address);\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Allocates an initialized and initially unlocked memory based spin lock"
  },
  {
    "id": 2725,
    "type": "Summary",
    "comment": "Rebalance a frame for load balancing",
    "code": "  private static Frame reBalance(final Frame fr, long seed, boolean local, boolean force_load_balance, boolean shuffle_training_data) {\n    return force_load_balance || shuffle_training_data ? MRUtils.shuffleAndBalance(fr, seed, local, shuffle_training_data) : fr;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2726,
    "type": "Summary",
    "comment": "Sets the host of this proxy.",
    "code": "    public Proxy setHost( String host )\n    {\n        return new Proxy( type, host, port, auth );\n    }\n\n",
    "label": 1,
    "rec": "Sets the host of the proxy."
  },
  {
    "id": 2727,
    "type": "Summary",
    "comment": "Creates a binary parser for a TCP command",
    "code": "  public BinaryCommandParser createParser(byte opcode, Channel channel, ByteOrder byteOrder)\n  {\n    BinaryCommandParserFactory factory = _binaryParsers.get(opcode);\n    return (null != factory) ? factory.createParser(channel, byteOrder) : null;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2728,
    "type": "Summary",
    "comment": "Build an unsafe version of the URI.",
    "code": "  public String buildUnsafe() {\n    return new StringBuilder(host) //\n        .append(\"/\") //\n        .append(PREFIX_UNSAFE) //\n        .append(\"/\") //\n        .append(assembleConfig()) //\n        .append(target) //\n        .toString();\n  }\n\n",
    "label": 1,
    "rec": "Build an unsafe version of the URL."
  },
  {
    "id": 2729,
    "type": "Summary",
    "comment": "Method returns callable for execution all update operations in async and sync mode.",
    "code": "    private Callable<Long> internalUpdate(final long l, final boolean updated) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteTxEx tx = CU.txStartInternal(ctx, seqView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicSequenceValue seq = seqView.get(key);\n\n                    checkRemoved();\n\n                    assert seq != null;\n\n                    long curLocVal;\n\n                    long newUpBound;\n\n                    lock.lock();\n\n                    try {\n                        curLocVal = locVal;\n\n                        // If local range was already reserved in another thread.\n                        if (locVal + l <= upBound) {\n                            long retVal = locVal;\n\n                            locVal += l;\n\n                            return updated ? locVal : retVal;\n                        }\n\n                        long curGlobalVal = seq.get();\n\n                        long newLocVal;\n\n                        /* We should use offset because we already reserved left side of range.*/\n                        long off = batchSize > 1 ? batchSize - 1 : 1;\n\n                        // Calculate new values for local counter, global counter and upper bound.\n                        if (curLocVal + l >= curGlobalVal) {\n                            newLocVal = curLocVal + l;\n\n                            newUpBound = newLocVal + off;\n                        }\n                        else {\n                            newLocVal = curGlobalVal;\n\n                            newUpBound = newLocVal + off;\n                        }\n\n                        locVal = newLocVal;\n                        upBound = newUpBound;\n\n                        if (updated)\n                            curLocVal = newLocVal;\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n\n                    // Global counter must be more than reserved upper bound.\n                    seq.set(newUpBound + 1);\n\n                    seqView.put(key, seq);\n\n                    tx.commit();\n\n                    return curLocVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to get and add: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2730,
    "type": "Summary",
    "comment": "If the project has preferences answer them.",
    "code": "\tpublic boolean loadProjectPreferences(ProjectPreferences pp) {\n\t\tIEclipsePreferences pref = getPreferences();\n\t\t\n\t\tif (pref == null)return false;\n\t\tint version = pref.getInt(PrefConstants.frameworkVersion, 0);\n\t\tif (version == 0)return false;\n\n\t\tpp.setOverride(pref.getBoolean(PrefConstants.override, ProjectPreferences.DefaultOverride));\n\t\tpp.setSuspend(pref.getBoolean(PrefConstants.suspend, ProjectPreferences.DefaultSuspend));\n\t\t\n\t\tValidator[] vals = ValManager.getDefault().getValidators2(_project);\n\t\tloadPreferences(vals, pref);\n\t\tpp.setValidators(vals);\n\t\treturn true;\n\t}\n\n",
    "label": 1,
    "rec": "Update the project preferences from the preference store."
  },
  {
    "id": 2731,
    "type": "Summary",
    "comment": "Compare two clusters to see if they have the equal number of partitions, equal number of nodes and each node hosts the same partition ids.",
    "code": "    private boolean areTwoClustersEqual(final Cluster lhs, final Cluster rhs) {\n        // There is no way for us to support pushing to multiple clusters with\n        // different numbers of partitions from a single BnP job.\n        if (lhs.getNumberOfPartitions() != rhs.getNumberOfPartitions())\n            return false;\n\n        if (buildPrimaryReplicasOnly) {\n            // In 'build.primary.replicas.only' mode, we can support pushing to\n            // clusters with different number of nodes and different partition\n            // assignments.\n            return true;\n        }\n\n        // Otherwise, we need every corresponding node in each cluster to be identical.\n        if (!lhs.getNodeIds().equals(rhs.getNodeIds()))\n            return false;\n        for (Node lhsNode: lhs.getNodes()) {\n            Node rhsNode = rhs.getNodeById(lhsNode.getId());\n            if (!rhsNode.getPartitionIds().equals(lhsNode.getPartitionIds())) {\n                return false;\n            }\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2732,
    "type": "Summary",
    "comment": "Return a string representation of this WSUsernameTokenPrincipal.",
    "code": "    public String toString() {\n        return (\"WSUsernameTokenPrincipalImpl:  \" + name);\n    }\n\n",
    "label": 1,
    "rec": "Return a string representation of this WSUsernameTokenPrincipalImpl."
  },
  {
    "id": 2733,
    "type": "Summary",
    "comment": "Get account information.",
    "code": "    public Response accountPage() {\n        if (session.getContext().getRequestHeaders().getAcceptableMediaTypes().contains(MediaType.APPLICATION_JSON_TYPE)) {\n            requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);\n\n            UserRepresentation rep = ModelToRepresentation.toRepresentation(session, realm, auth.getUser());\n            if (rep.getAttributes() != null) {\n                Iterator<String> itr = rep.getAttributes().keySet().iterator();\n                while (itr.hasNext()) {\n                    if (itr.next().startsWith(\"keycloak.\")) {\n                        itr.remove();\n                    }\n                }\n            }\n\n            return Cors.add(request, Response.ok(rep).type(MediaType.APPLICATION_JSON_TYPE)).auth().allowedOrigins(auth.getToken()).build();\n        } else {\n            return forwardToPage(null, AccountPages.ACCOUNT);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2734,
    "type": "Summary",
    "comment": "Returns true if the method has a JSecurity HasRole or HasPermission annotation, false otherwise.",
    "code": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( Implies.class ) != null ) ||\n                 (method.getAnnotation( HasRole.class ) != null ) );\n    }\n",
    "label": 1,
    "rec": "Returns true if the method has a JSecurity HasRole or Implies annotation, false otherwise."
  },
  {
    "id": 2735,
    "type": "Summary",
    "comment": "Test if two ints are equal.",
    "code": "    public EqualsBuilder append(int lhs, int rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2736,
    "type": "Summary",
    "comment": "Returns a set view of the entity-to-copy mappings contained in this EventCache.",
    "code": "\tpublic Set entrySet() {\n\t\treturn Collections.unmodifiableSet( entityToCopyMap.entrySet() );\n\t}\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable set view of the entity-to-copy mappings contained in this EventCache."
  },
  {
    "id": 2737,
    "type": "Summary",
    "comment": "Assembles an avro format string that contains multiple fat client configs from map of store to properties",
    "code": "    public static String writeMultipleClientConfigAvro(Map<String, Properties> mapStoreToProps) {\n        // FIXME: This sucks. We shouldn't be manually manipulating json...\n        String avroConfig = new String();\n        Boolean firstStore = true;\n        for(String storeName: mapStoreToProps.keySet()) {\n            if(firstStore) {\n                firstStore = false;\n            } else {\n                avroConfig = avroConfig + \",\\n\";\n            }\n            Properties props = mapStoreToProps.get(storeName);\n            avroConfig = avroConfig + \"\\t\\\"\" + storeName + \"\\\": \"\n                         + writeSingleClientConfigAvro(props);\n\n        }\n        return \"{\\n\" + avroConfig + \"\\n}\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2738,
    "type": "Summary",
    "comment": "It does nothing.",
    "code": "  @NotNull\n  @Override\n  public ExitCode build(CompileContext context,\n                        ModuleChunk chunk,\n                        DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                        OutputConsumer outputConsumer) throws ProjectBuildException {\n    JpsAndroidGradleModuleExtension extension = AndroidGradleJps.getFirstExtension(chunk);\n    if (extension == null) {\n      if (LOG.isDebugEnabled()) {\n        String format = \"Project '%1$s' does not have the '%2$s' facet. Nothing done.\";\n        LOG.info(String.format(format, getProjectName(context), AndroidGradleFacet.NAME));\n      }\n      return ExitCode.NOTHING_DONE;\n    }\n\n    String[] buildTasks = getBuildTasks(context, chunk);\n    if (buildTasks.length == 0) {\n      String format = \"No build tasks found for project '%1$s'. Nothing done.\";\n      LOG.info(String.format(format, getProjectName(context)));\n      return ExitCode.NOTHING_DONE;\n    }\n\n    String msg = \"Gradle build using tasks: \" + Arrays.toString(buildTasks);\n    context.processMessage(new ProgressMessage(msg));\n    LOG.info(msg);\n\n    ensureTempDirExists();\n\n    BuilderExecutionSettings executionSettings;\n    try {\n      executionSettings = new BuilderExecutionSettings();\n    } catch (RuntimeException e) {\n      throw new ProjectBuildException(e);\n    }\n\n    LOG.info(\"Using execution settings: \" + executionSettings);\n\n    String androidHome = null;\n    if (!isAndroidHomeKnown(executionSettings)) {\n      androidHome = getAndroidHomeFromModuleSdk(context, chunk);\n    }\n\n    String format = \"About to build project '%1$s' located at %2$s\";\n    LOG.info(String.format(format, getProjectName(context), executionSettings.getProjectDir().getAbsolutePath()));\n\n    return doBuild(context, buildTasks, executionSettings, androidHome);\n  }\n\n",
    "label": 1,
    "rec": "Builds a project using Gradle."
  },
  {
    "id": 2739,
    "type": "Summary",
    "comment": "Bind text view to HTML string",
    "code": "    public HttpImageGetter bind(final TextView view, final String html, final Object id) {\n        view.setText(HtmlUtils.encode(html, loading));\n        view.setTag(id);\n        new RoboAsyncTask<CharSequence>(context) {\n\n            public CharSequence call() throws Exception {\n                if (html.indexOf(\"<img\") != -1)\n                    return HtmlUtils.encode(html, HttpImageGetter.this);\n                else\n                    return null;\n            }\n\n            protected void onSuccess(CharSequence html) throws Exception {\n                if (html == null)\n                    return;\n                if (!id.equals(view.getTag()))\n                    return;\n                view.setText(html);\n                view.setTag(null);\n            }\n        }.execute();\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2740,
    "type": "Summary",
    "comment": "Loads an existing weave model from disk.",
    "code": "    public static AspectWerkzDefinition loadDefinitionAsResource() {\r\n        InputStream stream = getDefinitionInputStream();\r\n        if (stream == null) throw new RuntimeException(\"either you have to specify an XML definition file using the -Daspectwerkz.definition.file=... option or you have to have the XML definition file <aspectwerkz.xml> somewhere on the classpath\");\r\n        return AspectWerkzDefinition.loadDefinitionAsStream(stream);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Loads a definition from disk."
  },
  {
    "id": 2741,
    "type": "Summary",
    "comment": "Test the model on a validation dataset.",
    "code": "    public int[][] test(DataFrame data) {\n        DataFrame x = formula.x(data);\n\n        int n = x.size();\n        int ntrees = trees.size();\n        int[] p = new int[k];\n        int[][] prediction = new int[ntrees][n];\n\n        for (int j = 0; j < n; j++) {\n            Tuple xj = x.get(j);\n            Arrays.fill(p, 0);\n            for (int i = 0; i < ntrees; i++) {\n                p[trees.get(i).tree.predict(xj)]++;\n                prediction[i][j] = MathEx.whichMax(p);\n            }\n        }\n\n        return prediction;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2742,
    "type": "Summary",
    "comment": "Toggles the flash mode between  CameraConstants#FLASH_OFF,  CameraConstants#FLASH_ON and  CameraConstants#FLASH_AUTO, in this order.",
    "code": "    public Flash toggleFlash() {\n        Flash flash = mCameraController.getFlash();\n        switch (flash) {\n            case OFF:\n                setFlash(Flash.ON);\n                break;\n\n            case ON:\n                setFlash(Flash.AUTO);\n                break;\n\n            case AUTO:\n            case TORCH:\n                setFlash(Flash.OFF);\n                break;\n        }\n\n        return mCameraController.getFlash();\n    }\n",
    "label": 1,
    "rec": "Toggles the flash mode between  Flash#OFF,  Flash#ON and  Flash#AUTO, in this order."
  },
  {
    "id": 2743,
    "type": "Summary",
    "comment": "A factory method to build the appropriate LuminanceSource object based on the format of the preview buffers, as described by Camera.Parameters.",
    "code": "  public BaseLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {\n    Rect rect = getFramingRect();\n    switch (previewFormat) {\n      case PixelFormat.YCbCr_420_SP:\n        return new PlanarYUV420LuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n      case PixelFormat.YCbCr_422_SP:\n        return new PlanarYUV422LuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n      default:\n        // Handle some non-standard values:\n        // There's no PixelFormat constant for this buffer format yet.\n        if (previewFormatString.equals(\"yuv422i-yuyv\")) {\n          return new InterleavedYUV422LuminanceSource(data, width, height, rect.left, rect.top,\n              rect.width(), rect.height());\n        } else if (previewFormatString.equals(\"yuv420p\")) {\n          // Assume this is a synonym for YUV420SP -- note the lack of 's'\n          return new PlanarYUV420LuminanceSource(data, width, height, rect.left, rect.top,\n            rect.width(), rect.height());\n        }   \n    }\n    throw new IllegalArgumentException(\"Unsupported picture format: \" +\n            previewFormat + '/' + previewFormatString);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2744,
    "type": "Summary",
    "comment": "Returns a copy of itself.",
    "code": "    protected <T extends Dom> T copy(T parent) {\n        return (T) new Dom(this, parent);\n    }\n\n",
    "label": 1,
    "rec": "Returns a copy of itself providing the parent for the new copy."
  },
  {
    "id": 2745,
    "type": "Summary",
    "comment": "Checks if near cache is enabled for cache configuration.",
    "code": "    public static boolean isNearEnabled(GridCacheConfiguration cfg) {\n        if (cfg.getCacheMode() == LOCAL)\n            return false;\n\n        return cfg.getDistributionMode() == NEAR_PARTITIONED ||\n            cfg.getDistributionMode() == GridCacheDistributionMode.NEAR_ONLY;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2746,
    "type": "Summary",
    "comment": "Attempts to persist a long to the  android.content.SharedPreferences.",
    "code": "    protected boolean persistLong(long value) {\n        if (!shouldPersist()) {\n            return false;\n        }\n\n        if (value == getPersistedLong(~value)) {\n            // It's already there, so the same as persisting\n            return true;\n        }\n\n        PreferenceDataStore dataStore = getPreferenceDataStore();\n        if (dataStore != null) {\n            dataStore.putLong(mKey, value);\n        } else {\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putLong(mKey, value);\n            tryCommit(editor);\n        }\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist a  Long if this Preference is persistent."
  },
  {
    "id": 2747,
    "type": "Summary",
    "comment": "Puts key-value pair into storage.",
    "code": "    public boolean putAllToStore(@Nullable IgniteTx tx, Map<K, IgniteBiTuple<V, GridCacheVersion>> map)\n        throws IgniteCheckedException {\n        if (F.isEmpty(map))\n            return true;\n\n        if (map.size() == 1) {\n            Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e = map.entrySet().iterator().next();\n\n            return putToStore(tx, e.getKey(), e.getValue().get1(), e.getValue().get2());\n        }\n        else {\n            if (store != null) {\n                Map<K, IgniteBiTuple<V, GridCacheVersion>> map0;\n\n                if (convertPortable) {\n                    map0 = U.newHashMap(map.size());\n\n                    for (Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e : map.entrySet()) {\n                        IgniteBiTuple<V, GridCacheVersion> t = e.getValue();\n\n                        map0.put((K)cctx.unwrapPortableIfNeeded(e.getKey(), false),\n                            F.t((V)cctx.unwrapPortableIfNeeded(t.get1(), false), t.get2()));\n                    }\n                }\n                else\n                    map0 = map;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Storing values in cache store [map=\" + map0 + ']');\n\n                boolean ses = initSession(tx);\n\n                try {\n                    /*\n                    C1<Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>>, Cache.Entry<? extends K, ?>> c =\n                        new C1<Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>>, Cache.Entry<? extends K, ?>>() {\n                            @Override public Cache.Entry<? extends K, ?> apply(Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e) {\n                                return new CacheEntryImpl<>(e.getKey(), locStore ? e.getValue() : e.getValue().get1());\n                            }\n                        };\n\n\n                    Collection<Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>>> col = map.entrySet();\n                    */\n                    Collection<Cache.Entry<? extends K, ? extends Object>> entries = new ArrayList<>(map.size());\n\n                    for (Map.Entry<K, IgniteBiTuple<V, GridCacheVersion>> e : map.entrySet())\n                        entries.add(new CacheEntryImpl<>(e.getKey(), locStore ? e.getValue() : e.getValue().get1()));\n\n                    store.writeAll(entries);\n                }\n                catch (ClassCastException e) {\n                    handleClassCastException(e);\n                }\n                finally {\n                    if (ses)\n                        sesHolder.set(null);\n                }\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Stored value in cache store [map=\" + map0 + ']');\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2748,
    "type": "Summary",
    "comment": "Get the custom expression.",
    "code": "\tprotected Optional<String> getCustomExpression(String customExpressionId) {\n\t\tOptional<String> optionalCustomExpression = this.getDescription().getCustomExpressions().stream().filter(eefCustomExpression -> {\n\t\t\treturn customExpressionId != null && customExpressionId.equals(eefCustomExpression.getIdentifier());\n\t\t}).map(EEFCustomExpression::getCustomExpression).findFirst();\n\n\t\treturn optionalCustomExpression;\n\t}\n\n",
    "label": 1,
    "rec": "Get the custom expression with the given id."
  },
  {
    "id": 2749,
    "type": "Summary",
    "comment": "Get predicate which allows task execution on all nodes except the last one.",
    "code": "    private GridPredicate<ClusterNode> excludeLastPredicate() {\n        return new GridPredicate<ClusterNode>() {\n            @Override public boolean apply(ClusterNode e) {\n                return !e.id().equals(grid(GRID_CNT - 1).localNode().id());\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2750,
    "type": "Summary",
    "comment": "Import messages from the messages app's table and puts them in SMSSync's outbox table.",
    "code": "    public int importMessages() {\n        Logger.log(CLASS_TAG,\n                \"importMessages(): import messages from messages app\");\n        if (Util.isKitKat()) {\n            return importMessageKitKat();\n        }\n        Uri uriSms = Uri.parse(SMS_CONTENT_INBOX);\n        uriSms = uriSms.buildUpon().appendQueryParameter(\"LIMIT\", \"10\").build();\n        String[] projection = {\n                \"_id\", \"address\", \"date\", \"body\"\n        };\n\n        Cursor c = context.getContentResolver().query(uriSms, projection, null,\n                null, \"date DESC\");\n\n        if (c != null && c.getCount() > 0) {\n            try {\n                if (c.moveToFirst()) {\n                    List<Message> messages = new ArrayList<>();\n                    do {\n                        Message message = new Message();\n\n                        final long messageDate = c.getLong(c\n                                .getColumnIndex(\"date\"));\n                        message.setDate(new Date(messageDate));\n\n                        message.setPhoneNumber(c.getString(c\n                                .getColumnIndex(\"address\")));\n                        message.setBody(c.getString(c.getColumnIndex(\"body\")));\n                        message.setUuid(getUuid());\n                        messages.add(message);\n                    } while (c.moveToNext());\n                    saveMessage(messages);\n                }\n            } finally {\n                if (c != null) {\n                    c.close();\n                }\n            }\n            return 0;\n\n        } else {\n            return 1;\n        }\n\n    }\n\n",
    "label": 1,
    "rec": "TODO:// refactor so this method return boolean  Import messages from the messages app's table and puts them in SMSSync's outbox table."
  },
  {
    "id": 2751,
    "type": "Summary",
    "comment": "For testing purposes only.",
    "code": "    public InvocationImpl getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<InvocationImpl> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2752,
    "type": "Summary",
    "comment": "A utility method to check if a plan contains a chain of projection operators",
    "code": "    public static LOProject chainOfProjects(LogicalPlan plan) {\n\n        LOProject topProject = null;\n\n        if (plan == null) {\n            return null;\n        }\n\n        List<LogicalOperator> leaves = plan.getLeaves();\n\n        if (leaves == null) {\n            return null;\n        }\n\n        if (leaves.size() > 1) {\n            return null;\n        }\n\n        LogicalOperator node = leaves.get(0);\n\n        while (true) {\n            if (node == null) {\n                //a node cannot be null\n                return null;\n            }\n\n            if (node instanceof LOProject) {\n                topProject = (LOProject) node;\n            } else if (node instanceof LOCast) {\n                // continue\n            } else {\n                // not a projection or a cast return null\n                return null;\n            }\n\n            List<LogicalOperator> predecessors = plan.getPredecessors(node);\n\n            if (predecessors == null) {\n                // we have reached the root\n                return topProject;\n            }\n\n            if (predecessors.size() > 1) {\n                // a project or cast cannot have multiple inputs\n                return null;\n            }\n\n            node = predecessors.get(0);\n        }\n    }\n\n",
    "label": 1,
    "rec": "A utility method to check if a plan contains a chain of projection operators with or without casts"
  },
  {
    "id": 2753,
    "type": "Summary",
    "comment": "Get all methods in a class hierarchy! Both declared an non-declared (no duplicates).",
    "code": "    public static Method[] getAllMethods(Class<?> clazz) {\n        if (clazz == null) {\n            throw new IllegalArgumentException(\"You must specify a class in order to get the methods.\");\n        }\n        Set<Method> methods = new LinkedHashSet<Method>();\n\n        Class<?> thisType = clazz;\n\n        while (thisType != null) {\n            final Class<?> type = thisType;\n            final Method[] declaredMethods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return type.getDeclaredMethods();\n                }\n\n            });\n            for (Method method : declaredMethods) {\n                method.setAccessible(true);\n                methods.add(method);\n            }\n            Collections.addAll(methods, type.getMethods());\n            thisType = thisType.getSuperclass();\n        }\n        return methods.toArray(new Method[methods.size()]);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2754,
    "type": "Summary",
    "comment": "Creates a \"null object\" which implements the proxyInterfaces.",
    "code": "    public static Object createNullObject( ProxyFactory proxyFactory, Class... proxyClasses )\n    {\n        return proxyFactory.createInvocationHandlerProxy( new NullInvocationHandler(), proxyClasses );\n    }\n\n",
    "label": 1,
    "rec": "Creates a \"null object\" which implements the proxyClasses."
  },
  {
    "id": 2755,
    "type": "Summary",
    "comment": "!!! This method must be invoked in read or write lock of referring index page.",
    "code": "    private GridH2Row getRow(long link) throws IgniteCheckedException {\n        try (Page page = page(pageId(link))) {\n            ByteBuffer buf = page.getForRead();\n\n            try {\n                GridH2RowDescriptor desc = ((GridH2Table)table).rowDescriptor();\n\n                GridH2Row existing = desc.cachedRow(link);\n\n                if (existing != null)\n                    return existing;\n\n                DataPageIO io = DataPageIO.forPage(buf);\n\n                int dataOff = io.getDataOffset(buf, dwordsOffset(link));\n\n                buf.position(dataOff);\n\n                // Skip key-value size.\n                buf.getShort();\n\n                CacheObject key = coctx.processor().toCacheObject(coctx, buf);\n                CacheObject val = coctx.processor().toCacheObject(coctx, buf);\n\n                int topVer = buf.getInt();\n                int nodeOrderDrId = buf.getInt();\n                long globalTime = buf.getLong();\n                long order = buf.getLong();\n\n                GridCacheVersion ver = new GridCacheVersion(topVer, nodeOrderDrId, globalTime, order);\n\n                GridH2Row res;\n\n                try {\n                    res = ((GridH2Table)getTable()).rowDescriptor().createRow(key, PageIdUtils.partId(link), val, ver, 0);\n\n                    res.link = link;\n                }\n                catch (IgniteCheckedException e) {\n                    throw new IgniteException(e);\n                }\n\n                assert res.ver != null;\n\n                desc.cache(res);\n\n                return res;\n            }\n            finally {\n                page.releaseRead();\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2756,
    "type": "Summary",
    "comment": "Returns a PriorityQueue of RegisteredListener for the specified event type creating a new queue if needed",
    "code": "    private SortedSet<RegisteredListener> getEventListeners(Event.Type type) {\n        SortedSet<RegisteredListener> eventListeners = listeners.get(type);\n\n        if (eventListeners != null) {\n            return eventListeners;\n        }\n\n        eventListeners = new TreeSet<RegisteredListener>(comparer);\n        listeners.put(type, eventListeners);\n        return eventListeners;\n    }\n\n",
    "label": 1,
    "rec": "Returns a SortedSet of RegisteredListener for the specified event type creating a new queue if needed"
  },
  {
    "id": 2757,
    "type": "Summary",
    "comment": "byte argument that matches both given argument matchers.",
    "code": "    public static byte and(byte first, byte second) {\n        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2758,
    "type": "Summary",
    "comment": "Returns the VoicemailGreeting list - Lazy",
    "code": "\tpublic List<Greeting> getVoicemailList(boolean forceUpdate) throws IOException {\r\n\t\treturn getSettings(forceUpdate).getVoicemailGreetingsList();\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Returns the Greeting list - Lazy"
  },
  {
    "id": 2759,
    "type": "Summary",
    "comment": "Implements the rule for generating the delete by example SQL Map element and DAO method.",
    "code": "    public boolean generateDeleteByExample() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        boolean rc = tableConfiguration.isDeleteByExampleStatementEnabled();\n\n        return rc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2760,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_REVERB;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2761,
    "type": "Summary",
    "comment": "Run consistency check on connected key-value iterators",
    "code": "    public Reporter execute() throws IOException {\n        Map<ClusterNode, Iterator<Pair<ByteArray, Versioned<byte[]>>>> nodeFetchIteratorMap;\n        nodeFetchIteratorMap = new HashMap<ClusterNode, Iterator<Pair<ByteArray, Versioned<byte[]>>>>();\n        /* start fetch from each node */\n        for(ClusterNode clusterNode: clusterNodeList) {\n            AdminClient adminClient = adminClients.get(clusterNode.getPrefixId());\n            List<Integer> singlePartition = new ArrayList<Integer>();\n            singlePartition.add(partitionId);\n            if(logger.isDebugEnabled()) {\n                logger.debug(\"Start fetch request to Node[\" + clusterNode.toString()\n                             + \"] for partition[\" + partitionId + \"] of store[\" + storeName + \"]\");\n            }\n\n            Iterator<Pair<ByteArray, Versioned<byte[]>>> fetchIterator;\n            fetchIterator = adminClient.bulkFetchOps.fetchEntries(clusterNode.getNode().getId(),\n                                                                  storeName,\n                                                                  singlePartition,\n                                                                  null,\n                                                                  false);\n            nodeFetchIteratorMap.put(clusterNode, fetchIterator);\n        }\n        keyFetchTracker = new KeyFetchTracker(clusterNodeList.size());\n\n        /* start to fetch */\n        boolean fetchFinished;\n        do {\n            fetchFinished = true;\n            for(Map.Entry<ClusterNode, Iterator<Pair<ByteArray, Versioned<byte[]>>>> nodeFetchIteratorMapEntry: nodeFetchIteratorMap.entrySet()) {\n                ClusterNode clusterNode = nodeFetchIteratorMapEntry.getKey();\n                Iterator<Pair<ByteArray, Versioned<byte[]>>> fetchIterator = nodeFetchIteratorMapEntry.getValue();\n                if(fetchIterator.hasNext()) {\n                    fetchFinished = false;\n                    reporter.recordScans(1);\n\n                    Pair<ByteArray, Versioned<byte[]>> fetchedEntry = fetchIterator.next();\n                    ByteArray key = fetchedEntry.getFirst();\n                    Versioned<byte[]> versioned = fetchedEntry.getSecond();\n\n                    // record fetch\n                    recordFetch(clusterNode, key, versioned);\n\n                    // try sweep last key fetched by this iterator\n                    keyFetchTracker.recordFetch(clusterNode, key);\n                    if(logger.isTraceEnabled()) {\n                        logger.trace(\"fetched \" + new String(key.get()));\n                        logger.trace(\"map has keys: \" + keyVersionNodeSetMap.size());\n                    }\n                    trySweepAll();\n                    if(logger.isTraceEnabled()) {\n                        logger.trace(\"sweeped; keys left: \" + keyVersionNodeSetMap.size());\n                    }\n                }\n            }\n\n            // stats reporting\n            if(logger.isInfoEnabled()) {\n                String report = reporter.tryProgressReport();\n                if(report != null) {\n                    for(String line: report.split(\"\\n\")) {\n                        logger.info(line);\n                    }\n                }\n            }\n        } while(!fetchFinished);\n\n        /* adminClient shutdown */\n        for(AdminClient adminClient: adminClients) {\n            if(adminClient != null) {\n                adminClient.stop();\n            }\n        }\n\n        // clean keys not sufficient for write\n        cleanIneligibleKeys(keyVersionNodeSetMap, requiredWrites);\n\n        keyFetchTracker.finishAll();\n        trySweepAll();\n\n        reporter.processInconsistentKeys(storeName, partitionId, keyVersionNodeSetMap);\n\n        return reporter;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2762,
    "type": "Summary",
    "comment": "Calls toString for all DataType objects and creates a string with a new line character.",
    "code": "    public String toString()\n    {\n        return getBriefDescription();\n    }\n\n",
    "label": 1,
    "rec": "Return brief description of FrameBody"
  },
  {
    "id": 2763,
    "type": "Summary",
    "comment": "Requests  CacheAffinityFunction and  CacheAffinityKeyMapper from remote node.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, AffinityTopologyVersion topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        CacheAffinityFunction f = (CacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        CacheAffinityKeyMapper m = (CacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(n, cacheName, null));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2764,
    "type": "Summary",
    "comment": "Creates and returns an  ExternalFileDecorator for a file that has the given pathString.",
    "code": "\tpublic synchronized static IFile createFile(String pathString) {\n\t\tif (File.separatorChar != '\\\\') {\n\t\t\tpathString = pathString.replace('\\\\', '/');\n\t\t}\n\t\treturn new ExternalFileWrapper(pathString);\n\t}\n\n",
    "label": 1,
    "rec": "Creates and returns an  ExternalFileWrapper for a file that has the given pathString."
  },
  {
    "id": 2765,
    "type": "Summary",
    "comment": "Implements the rule for generating the SQL example where clause element.",
    "code": "    public boolean generateSQLExampleWhereClause() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        boolean rc = tableConfiguration.isSelectByExampleStatementEnabled()\n                || tableConfiguration.isDeleteByExampleStatementEnabled()\n                || tableConfiguration.isCountByExampleStatementEnabled();\n\n        if (introspectedTable.getTargetRuntime() == TargetRuntime.IBATIS2) {\n            rc |= tableConfiguration.isUpdateByExampleStatementEnabled();\n        }\n\n        return rc;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2766,
    "type": "Summary",
    "comment": "Read property from underlying composite",
    "code": "    public Object getProperty(String key)\n    {\n        if (overrideProperties.containsKey(key)) {\n            return overrideProperties.getProperty(key);\n        }\n        Configuration firstMatchingConfiguration = null;\n        for (Configuration config : configList)\n        {\n            if (config.containsKey(key))\n            {\n                firstMatchingConfiguration = config;\n                break;\n            }\n        }\n\n        if (firstMatchingConfiguration != null)\n        {\n            return firstMatchingConfiguration.getProperty(key);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Read property from underlying composite."
  },
  {
    "id": 2767,
    "type": "Summary",
    "comment": "Recreates tpcSrvr socket instance.",
    "code": "    private GridNioServer<MessageAdapter> resetNioServer() throws IgniteCheckedException {\n        if (boundTcpPort >= 0)\n            throw new IgniteCheckedException(\"Tcp NIO server was already created on port \" + boundTcpPort);\n\n        IgniteCheckedException lastEx = null;\n\n        // If configured TCP port is busy, find first available in range.\n        for (int port = locPort; port < locPort + locPortRange; port++) {\n            try {\n                MessageFactory messageFactory = new MessageFactory() {\n                    private MessageFactory impl;\n\n                    @Nullable @Override public MessageAdapter create(byte type) {\n                        if (impl == null)\n                            impl = getSpiContext().messageFactory();\n\n                        assert impl != null;\n\n                        return impl.create(type);\n                    }\n                };\n\n                MessageFormatter messageFormatter = new MessageFormatter() {\n                    private MessageFormatter impl;\n\n                    @Override public MessageWriter writer() {\n                        if (impl == null)\n                            impl = getSpiContext().messageFormatter();\n\n                        assert impl != null;\n\n                        return impl.writer();\n                    }\n\n                    @Override public MessageReader reader() {\n                        if (impl == null)\n                            impl = getSpiContext().messageFormatter();\n\n                        assert impl != null;\n\n                        return impl.reader();\n                    }\n                };\n\n                GridNioServer<MessageAdapter> srvr =\n                    GridNioServer.<MessageAdapter>builder()\n                        .address(locHost)\n                        .port(port)\n                        .listener(srvLsnr)\n                        .logger(log)\n                        .selectorCount(selectorsCnt)\n                        .gridName(gridName)\n                        .tcpNoDelay(tcpNoDelay)\n                        .directBuffer(directBuf)\n                        .byteOrder(ByteOrder.nativeOrder())\n                        .socketSendBufferSize(sockSndBuf)\n                        .socketReceiveBufferSize(sockRcvBuf)\n                        .sendQueueLimit(msgQueueLimit)\n                        .directMode(true)\n                        .metricsListener(metricsLsnr)\n                        .writeTimeout(sockWriteTimeout)\n                        .filters(new GridNioCodecFilter(new GridDirectParser(messageFactory), log, true),\n                            new GridConnectionBytesVerifyFilter(log))\n                        .messageFormatter(messageFormatter)\n                        .build();\n\n                boundTcpPort = port;\n\n                // Ack Port the TCP server was bound to.\n                if (log.isInfoEnabled())\n                    log.info(\"Successfully bound to TCP port [port=\" + boundTcpPort +\n                        \", locHost=\" + locHost + ']');\n\n                srvr.idleTimeout(idleConnTimeout);\n\n                return srvr;\n            }\n            catch (IgniteCheckedException e) {\n                lastEx = e;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to bind to local port (will try next port within range) [port=\" + port +\n                        \", locHost=\" + locHost + ']');\n            }\n        }\n\n        // If free port wasn't found.\n        throw new IgniteCheckedException(\"Failed to bind to any port within range [startPort=\" + locPort +\n            \", portRange=\" + locPortRange + \", locHost=\" + locHost + ']', lastEx);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2768,
    "type": "Summary",
    "comment": "Returns URL of the web application class path.",
    "code": "    protected String createURLFromWARFile() throws Exception\n    {\n        if (servletContext == null)\n        {\n            // this may happen if we are running in a test container, in IDE development, etc\n            return null;\n        }\n        \n        URL url = servletContext.getResource(\"/WEB-INF/beans.xml\");\n\n        if (url != null)\n        {\n            addWebBeansXmlLocation(url.toExternalForm());\n            URL resourceUrl = WarUrlFinder.findWebInfClassesPath(this.servletContext);\n\n            if (resourceUrl == null)\n            {\n                return null;\n            }\n\n            //set resource to beans.xml mapping\n            AnnotationDB annotationDB = getAnnotationDB();\n\n            if(annotationDB instanceof BeansXmlAnnotationDB)\n            {\n                ((BeansXmlAnnotationDB)annotationDB).setResourceBeansXml(resourceUrl.toExternalForm(), url.toExternalForm());\n            }\n            return resourceUrl.toExternalForm();\n        }\n\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Returns the web application class path if it contains a beans.xml marker file."
  },
  {
    "id": 2769,
    "type": "Summary",
    "comment": "Gets oldest alive node for specified topology version.",
    "code": "    public static ClusterNode oldest(GridCacheContext cctx, long topOrder) {\n        ClusterNode oldest = null;\n\n        for (ClusterNode n : aliveNodes(cctx, topOrder))\n            if (oldest == null || n.order() < oldest.order())\n                oldest = n;\n\n        assert oldest != null;\n        assert oldest.order() <= topOrder || topOrder < 0;\n\n        return oldest;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2770,
    "type": "Summary",
    "comment": "Given a  org.apache.solr.schema.SchemaField, create one or more  org.apache.lucene.document.Fieldable instances",
    "code": "  public IndexableField[] createFields(SchemaField field, Object value, float boost) {\n    IndexableField f = createField( field, value, boost);\n    return f==null ? new IndexableField[]{} : new IndexableField[]{f};\n  }\n\n",
    "label": 1,
    "rec": "Given a  org.apache.solr.schema.SchemaField, create one or more  org.apache.lucene.index.IndexableField instances"
  },
  {
    "id": 2771,
    "type": "Summary",
    "comment": "Check if OpenShift is available.",
    "code": "    static boolean isOpenShift(Client client) {\n      return isOpenShiftAPIGroups(client);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2772,
    "type": "Summary",
    "comment": "ReadForecast",
    "code": "    @Processor\n    @InvalidateConnectionOn(exception = NotAuthenticatedException.class)\n    public ForeCast readForecast(String objectId) {\n        return (ForeCast) read(ServiceSourceCollection.Forecasts, objectId);\n    }\n\n",
    "label": 1,
    "rec": "Fetches the forecast identified by the object id in the collection."
  },
  {
    "id": 2773,
    "type": "Summary",
    "comment": "A convenience method for running a scan for a period of time and repeat in five seconds intervals.",
    "code": "            public Observable<RxBleInternalScanResult> apply(final Observable<RxBleInternalScanResult> rxBleInternalScanResultObservable) {\n                return rxBleInternalScanResultObservable.take(windowInMillis, TimeUnit.MILLISECONDS, scheduler)\n                        .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {\n                            @Override\n                            public ObservableSource<?> apply(Observable<Object> observable) {\n                                return observable.delay(delayToNextWindow, TimeUnit.MILLISECONDS, scheduler\n                                );\n                            }\n                        });\n            }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2774,
    "type": "Summary",
    "comment": "Returns true if the method has any Shiro annotations, false otherwise.",
    "code": "    public boolean matches(Method method, Class targetClass) {\n        Method m = method;\n\n        if ( isAuthzAnnotationPresent(m) ) {\n            return true;\n        }\n\n        //The 'method' parameter could be from an interface that doesn't have the annotation.\n        //Check to see if the implementation has it.\n        if ( targetClass != null) {\n            try {\n                m = targetClass.getMethod(m.getName(), m.getParameterTypes());\n                return isAuthzAnnotationPresent(m) || isAuthzAnnotationPresent(targetClass);\n            } catch (NoSuchMethodException ignored) {\n                //default return value is false.  If we can't find the method, then obviously\n                //there is no annotation, so just use the default return value.\n            }\n        }\n\n        return false;\n    }\n",
    "label": 1,
    "rec": "Returns true if the method or the class has any Shiro annotations, false otherwise."
  },
  {
    "id": 2775,
    "type": "Summary",
    "comment": "Derives a String name for the given principal.",
    "code": "\tprotected String name(Object principal) {\n\t\t// We are reusing the logic from AbstractAuthenticationToken#getName\n\t\treturn new TestingAuthenticationToken(principal, null).getName();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2776,
    "type": "Summary",
    "comment": "Build a URI for fetching Thumbor metadata.",
    "code": "  public String buildMeta() {\n    return new StringBuilder(host) //\n        .append(\"/\") //\n        .append(PREFIX_META) //\n        .append(\"/\") //\n        .append(assembleConfig()) //\n        .append(target) //\n        .toString();\n  }\n\n",
    "label": 1,
    "rec": "Build a URL for fetching Thumbor metadata."
  },
  {
    "id": 2777,
    "type": "Summary",
    "comment": "Finds the resource with the specified name on the search path.",
    "code": "    protected URL findResource(String name) {\n        try {\n            return Whitebox.invokeMethod(deferTo, \"findResource\", name);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2778,
    "type": "Summary",
    "comment": "Returns a set of partitions that were added to the target list getAddedInTarget(cluster, null) - nothing was added, returns null.",
    "code": "    public static <T> Set<T> getAddedInTarget(Set<T> current, Set<T> target) {\n        if(current == null || target == null) {\n            return new HashSet<T>();\n        }\n        return getDiff(target, current);\n    }\n\n",
    "label": 1,
    "rec": "Returns a set of objects that were added to the target list getAddedInTarget(current, null) - nothing was added, returns null."
  },
  {
    "id": 2779,
    "type": "Summary",
    "comment": "Path of the file or directory, on which event has occurred.",
    "code": "    public IgniteFsPath path() {\n        return path;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2780,
    "type": "Summary",
    "comment": "Gets the element type for o.",
    "code": "\tpublic IElementType getElementType(Object o) {\n\n\t\tif (o instanceof EClass) {\n\t\t\treturn getElementType((EClass) o);\n\t\t\t\n\t\t} else if (o instanceof EObject) {\n\t\t\treturn getElementType((EObject) o);\n\n\t\t} else if (o instanceof IElementType) {\n\t\t\treturn (IElementType) o;\n\t\t}\n\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Convenience method to get an element type for o."
  },
  {
    "id": 2781,
    "type": "Summary",
    "comment": "Returns the command class that provides the best suitable converter to convert between the Z-Wave API and the binding.",
    "code": "\tprivate ZWaveCommandClass resolveConverter(Item item, ZWaveNode node, int endpointId) {\n\t\tif(item == null)\n\t\t\treturn null;\n\n\t\tZWaveMultiInstanceCommandClass multiInstanceCommandClass = null;\n\t\tZWaveCommandClass result = null;\n\t\t\n\t\tif (endpointId != 1)\n\t\t\tmultiInstanceCommandClass = (ZWaveMultiInstanceCommandClass)node.getCommandClass(CommandClass.MULTI_INSTANCE);\n\n\t\tif (!preferredCommandClasses.containsKey(item.getClass())) {\n\t\t\tlogger.warn(\"No preferred command classes found for item class = {}\", item.getClass().toString());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tfor (CommandClass commandClass : preferredCommandClasses.get(item.getClass())) {\n\t\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 2) {\n\t\t\t\tZWaveEndpoint endpoint = multiInstanceCommandClass.getEndpoint(endpointId);\n\t\t\t\t\n\t\t\t\tif (endpoint != null) { \n\t\t\t\t\tresult = endpoint.getCommandClass(commandClass);\n\t\t\t\t} \n\t\t\t}\n\t\t\t\n\t\t\tif (result == null)\n\t\t\t\tresult = node.getCommandClass(commandClass);\n\t\t\t\n\t\t\tif (result == null)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (multiInstanceCommandClass != null && multiInstanceCommandClass.getVersion() == 1 &&\n\t\t\t\t\tresult.getInstances() < endpointId)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (converters.containsKey(commandClass))\n\t\t\t\treturn result;\n\t\t}\n\t\t\n\t\tlogger.warn(\"No matching command classes found for item class = {}, node id = {}, endpoint id = {}\", \n\t\t\t\titem.getClass().toString(), node.getNodeId(), endpointId);\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2782,
    "type": "Summary",
    "comment": "Given a parent path and a child node, create a combined full path",
    "code": "    public static String makePath(String parent, String... children)\n    {\n        StringBuilder path = new StringBuilder();\n\n        // Add parent piece, with no trailing slash.\n        if ( (parent != null) && (parent.length() > 0) )\n        {\n            if ( !parent.startsWith(PATH_SEPARATOR) )\n            {\n                path.append(PATH_SEPARATOR);\n            }\n            if ( parent.endsWith(PATH_SEPARATOR) )\n            {\n                path.append(parent.substring(0, parent.length() - 1));\n            }\n            else\n            {\n                path.append(parent);\n            }\n        }\n\n        if (children == null || children.length == 0)\n        {\n            // Special case, empty parent and child\n            if ( path.length() == 0 )\n            {\n                return PATH_SEPARATOR;\n            }\n            return path.toString();\n        }\n\n        for (String child : children)\n        {\n            if ( (child == null) || (child.length() == 0) || (child.equals(PATH_SEPARATOR)) )\n            {\n                // Special case, empty parent and child\n                if ( path.length() == 0 )\n                {\n                    path.append(PATH_SEPARATOR);\n                }\n\n                continue;\n            }\n\n            // Now add the separator between parent and child.\n            path.append(PATH_SEPARATOR);\n\n            if ( child.startsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(1);\n            }\n\n            if ( child.endsWith(PATH_SEPARATOR) )\n            {\n                child = child.substring(0, child.length() - 1);\n            }\n\n            // Finally, add the child.\n            path.append(child);\n        }\n\n        return path.toString();\n    }\n",
    "label": 1,
    "rec": "Given a parent path and a list of children nodes, create a combined full path"
  },
  {
    "id": 2783,
    "type": "Summary",
    "comment": "Get lines for file path",
    "code": "    public List<CharSequence> get(final String file) {\n        if (TextUtils.isEmpty(file)) {\n            return Collections.emptyList();\n        }\n        List<CharSequence> lines = diffs.get(file);\n        return lines != null ? lines : Collections.emptyList();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2784,
    "type": "Summary",
    "comment": "Add path to source path and return result.",
    "code": "    protected Path incPath(Path source, Path toAdd) {\n        if (null == source) {\n            source = new Path(project); \n        }\n        if (null != toAdd) {\n            source.append(toAdd);\n        }\n        return source;\n    }\n\n",
    "label": 1,
    "rec": "Add path elements to source path and return result."
  },
  {
    "id": 2785,
    "type": "Summary",
    "comment": "Returns the id of this tone.",
    "code": "        public byte getId(boolean sharped) {\n            byte id = (byte) (sharped && sharpable ? this.id + 1 : this.id);\n\n            return (byte) (id % TONES_COUNT);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2786,
    "type": "Summary",
    "comment": "Returns Web components names in a project",
    "code": "\tpublic static IVirtualComponent[] getWebComponents(IProject project){\n\t\t\n\t\t//get all components in the project\n\t\tVector v = new Vector();\n\t\ttry {\n\t\t\tIFlexibleProject flex = ComponentCore.createFlexibleProject(project);\n\t\t\tIVirtualComponent[] components = flex.getComponents();\n\t\t\tfor (int i=0;i<components.length;i++){\n\t\t\t\tif (isWebComponent(project, components[i].getName())){\n\t\t\t\t\tv.add(components[i]);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\n\t\t}\n\t\tcatch (Exception e){\n\t\t\t//handle exception\n\t\t}\n\t\t\n\t\treturn (IVirtualComponent[])v.toArray(new IVirtualComponent[0]);\n\t} \n\n",
    "label": 1,
    "rec": "Returns Web components in a project"
  },
  {
    "id": 2787,
    "type": "Summary",
    "comment": "double argument greater than the given value.",
    "code": "    public static double gt(double value) {\n        reportMatcher(new GreaterThan<Double>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2788,
    "type": "Summary",
    "comment": "Adds a chunk with the given  chunkIdx to the batch file with the given  idx.",
    "code": "    public String addChunk(String index, InputStream is, int chunkCount, int chunkIndex, String fileName,\n            String mimeType, long fileSize) throws IOException {\n        BatchManager bm = Framework.getService(BatchManager.class);\n        Blob blob = Blobs.createBlob(is);\n\n        String fileEntryKey = key + \"_\" + index;\n        BatchFileEntry fileEntry = getFileEntry(index);\n        if (fileEntry == null) {\n            fileEntry = new BatchFileEntry(fileEntryKey, chunkCount, fileName, mimeType, fileSize);\n            bm.getTransientStore().putParameters(fileEntryKey, fileEntry.getParams());\n            bm.getTransientStore().putParameter(key, index, fileEntryKey);\n        }\n        fileEntry.addChunk(chunkIndex, blob);\n\n        return fileEntryKey;\n    }\n\n",
    "label": 1,
    "rec": "Adds a chunk with the given  chunkIndex to the batch file with the given  index."
  },
  {
    "id": 2789,
    "type": "Summary",
    "comment": "The mean (average) execution time (in milliseconds) for  HystrixCommand#execute() or  HystrixCommand#queue().",
    "code": "    public int getTotalTimeMean() {\n        return rollingCommandUserLatencyDistributionStream.getLatestMean();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2790,
    "type": "Summary",
    "comment": "Returns the SentryScheduler instance",
    "code": "\tpublic static Sentry getInstance() {\n\t\tif(instance==null) {\n\t\t\tsynchronized(lock) {\n\t\t\t\tif(instance==null) {\n\t\t\t\t\tinstance = new Sentry();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the Sentry instance"
  },
  {
    "id": 2791,
    "type": "Summary",
    "comment": "OAuth grant page.",
    "code": "    public Response processConsent(final MultivaluedMap<String, String> formData) {\n        event.event(EventType.LOGIN);\n        String code = formData.getFirst(\"code\");\n        Checks checks = new Checks();\n        if (!checks.verifyRequiredAction(code, ClientSessionModel.Action.OAUTH_GRANT.name())) {\n            return checks.response;\n        }\n        ClientSessionCode<LoginSessionModel> accessCode = checks.clientCode;\n        LoginSessionModel loginSession = accessCode.getClientSession();\n\n        initLoginEvent(loginSession);\n\n        UserModel user = loginSession.getAuthenticatedUser();\n        ClientModel client = loginSession.getClient();\n\n\n        if (formData.containsKey(\"cancel\")) {\n            LoginProtocol protocol = session.getProvider(LoginProtocol.class, loginSession.getProtocol());\n            protocol.setRealm(realm)\n                    .setHttpHeaders(headers)\n                    .setUriInfo(uriInfo)\n                    .setEventBuilder(event);\n            Response response = protocol.sendError(loginSession, Error.CONSENT_DENIED);\n            event.error(Errors.REJECTED_BY_USER);\n            return response;\n        }\n\n        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n        if (grantedConsent == null) {\n            grantedConsent = new UserConsentModel(client);\n            session.users().addConsent(realm, user.getId(), grantedConsent);\n        }\n        for (RoleModel role : accessCode.getRequestedRoles()) {\n            grantedConsent.addGrantedRole(role);\n        }\n        for (ProtocolMapperModel protocolMapper : accessCode.getRequestedProtocolMappers()) {\n            if (protocolMapper.isConsentRequired() && protocolMapper.getConsentText() != null) {\n                grantedConsent.addGrantedProtocolMapper(protocolMapper);\n            }\n        }\n        session.users().updateConsent(realm, user.getId(), grantedConsent);\n\n        event.detail(Details.CONSENT, Details.CONSENT_VALUE_CONSENT_GRANTED);\n        event.success();\n\n        // TODO:mposolda So assume that requiredActions were already done in this stage. Doublecheck...\n        ClientLoginSessionModel clientSession = AuthenticationProcessor.attachSession(loginSession, null, session, realm, clientConnection, event);\n        return AuthenticationManager.redirectAfterSuccessfulFlow(session, realm, clientSession.getUserSession(), clientSession, request, uriInfo, clientConnection, event, loginSession.getProtocol());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2792,
    "type": "Summary",
    "comment": "Finds by name resources using the  ClassLoader of the specified  Class.",
    "code": "    public static URL[] findResources(Class cls, String name, int maxLength) throws IOException {\n        while (name.contains(\"//\")) {\n            name = name.replace(\"//\", \"/\");\n        }\n\n        // Under JPMS, Class.getResource() and ClassLoader.getResources() do not return the same URLs\n        URL url = cls.getResource(name);\n        if (url != null && maxLength == 1) {\n            return new URL[] {url};\n        }\n\n        String path = \"\";\n        if (!name.startsWith(\"/\")) {\n            String s = cls.getName().replace('.', '/');\n            int n = s.lastIndexOf('/');\n            if (n >= 0) {\n                path = s.substring(0, n + 1);\n            }\n        } else {\n            name = name.substring(1);\n        }\n        Enumeration<URL> urls = cls.getClassLoader().getResources(path + name);\n        ArrayList<URL> array = new ArrayList<URL>();\n        if (url != null) {\n            array.add(url);\n        }\n        while (url == null && !urls.hasMoreElements() && path.length() > 0) {\n            int n = path.lastIndexOf('/', path.length() - 2);\n            if (n >= 0) {\n                path = path.substring(0, n + 1);\n            } else {\n                path = \"\";\n            }\n            urls = cls.getClassLoader().getResources(path + name);\n        }\n        while (urls.hasMoreElements() && array.size() < maxLength) {\n            url = urls.nextElement();\n            if (!array.contains(url)) {\n                array.add(url);\n            }\n        }\n        return array.toArray(new URL[array.size()]);\n    }\n",
    "label": 1,
    "rec": "Finds by name resources using the  Class and its  ClassLoader."
  },
  {
    "id": 2793,
    "type": "Summary",
    "comment": "Return the cached value if available.",
    "code": "    public int getValueAtPercentile(double percentile) {\n        int permyriad = (int) percentile * 100;\n        switch (permyriad) {\n            case 0: return p0;\n            case 500: return p5;\n            case 1000: return p10;\n            case 1500: return p15;\n            case 2000: return p20;\n            case 2500: return p25;\n            case 3000: return p30;\n            case 3500: return p35;\n            case 4000: return p40;\n            case 4500: return p45;\n            case 5000: return p50;\n            case 5500: return p55;\n            case 6000: return p60;\n            case 6500: return p65;\n            case 7000: return p70;\n            case 7500: return p75;\n            case 8000: return p80;\n            case 8500: return p85;\n            case 9000: return p90;\n            case 9500: return p95;\n            case 9900: return p99;\n            case 9950: return p99_5;\n            case 9990: return p99_9;\n            case 9995: return p99_95;\n            case 9999: return p99_99;\n            case 10000: return p100;\n            default: throw new IllegalArgumentException(\"Percentile (\" + percentile + \") is not currently cached\");\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2794,
    "type": "Summary",
    "comment": "Returns a ManagedOutputStream for a managed target.",
    "code": "\tpublic ManagedOutputStream getOutputStream(String managedFile) throws IOException {\n\t\tif (useReliableFiles) {\n\t\t\tReliableFileOutputStream out = new ReliableFileOutputStream(new File(getBase(), managedFile));\n\t\t\treturn new ManagedOutputStream(out, this, managedFile, null);\n\t\t}\n\t\tFile tmpFile = createTempFile(managedFile);\n\t\treturn new ManagedOutputStream(new FileOutputStream(tmpFile), this, managedFile, tmpFile);\n\t}\n\n",
    "label": 1,
    "rec": "Returns a ManagedOutputStream for a managed file."
  },
  {
    "id": 2795,
    "type": "Summary",
    "comment": "Implements the rule for generating the select by example with BLOBs SQL",
    "code": "    public boolean generateSelectByExampleWithBLOBs() {\n        if (isModelOnly) {\n            return false;\n        }\n        \n        return tableConfiguration.isSelectByExampleStatementEnabled()\n                && introspectedTable.hasBLOBColumns();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2796,
    "type": "Summary",
    "comment": "Submits execution of Hadoop job to grid.",
    "code": "    public GridFuture<GridHadoopJobId> submit(GridHadoopJobId jobId, GridHadoopJobInfo info) {\n        if (!busyLock.tryReadLock()) {\n            return new GridFinishedFutureEx<>(new GridException(\"Failed to execute map-reduce job \" +\n                \"(grid is stopping): \" + info));\n        }\n\n        try {\n            GridHadoopJob job = ctx.jobFactory().createJob(jobId, info);\n\n            Collection<GridHadoopFileBlock> blocks = job.input();\n\n            GridHadoopMapReducePlan mrPlan = mrPlanner.preparePlan(blocks, ctx.nodes(), job, null);\n\n            GridHadoopJobMetadata meta = new GridHadoopJobMetadata(jobId, info);\n\n            meta.mapReducePlan(mrPlan);\n\n            meta.pendingBlocks(allBlocks(mrPlan));\n            meta.pendingReducers(allReducers(job));\n\n            GridFutureAdapter<GridHadoopJobId> completeFut = new GridFutureAdapter<>();\n\n            GridFutureAdapter<GridHadoopJobId> old = activeFinishFuts.put(jobId, completeFut);\n\n            assert old == null : \"Duplicate completion future [jobId=\" + jobId + \", old=\" + old + ']';\n\n            if (log.isDebugEnabled())\n                log.debug(\"Submitting job metadata [jobId=\" + jobId + \", meta=\" + meta + ']');\n\n            jobMetaPrj.put(jobId, meta);\n\n            return completeFut;\n        }\n        catch (GridException e) {\n            return new GridFinishedFutureEx<>(e);\n        }\n        finally {\n            busyLock.readUnlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2797,
    "type": "Summary",
    "comment": "Looks up a channel on this connection.",
    "code": "    public ChannelN getChannel(int channelNumber) {\n        ChannelN result = _channelMap.get(channelNumber);\n        if(result == null) throw new UnknownChannelException(channelNumber);\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "Public API - Looks up an existing channel associated with this connection."
  },
  {
    "id": 2798,
    "type": "Summary",
    "comment": "Base path for managing the scope mappings for this client",
    "code": "    public ScopeMappedResource getScopeMappedResource() {\n        return new ScopeMappedResource(realm, auth, client, session, adminEvent);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2799,
    "type": "Summary",
    "comment": "Returns a collection of all refs and additional refs (e.g.",
    "code": "\tprivate Map<String, Ref> getAllRefs() throws IOException {\n\t\tMap<String, Ref> ret = repo.getRefDatabase().getRefs(ALL);\n\t\tfor (Ref ref : repo.getRefDatabase().getAdditionalRefs())\n\t\t\tret.put(ref.getName(), ref);\n\t\treturn ret;\n\t}\n\n",
    "label": 1,
    "rec": "Returns a map of all refs and additional refs (e.g."
  },
  {
    "id": 2800,
    "type": "Summary",
    "comment": "Instantiate new file system.",
    "code": "    private IgfsHadoopFileSystem fileSystem() throws Exception {\n        Configuration fsCfg = new Configuration();\n\n        fsCfg.addResource(U.resolveIgniteUrl(\"modules/core/src/test/config/hadoop/core-site-loopback.xml\"));\n\n        fsCfg.setBoolean(\"fs.ggfs.impl.disable.cache\", true);\n\n        if (logging)\n            fsCfg.setBoolean(String.format(PARAM_GGFS_LOG_ENABLED, \"ggfs:ggfs-grid@\"), logging);\n\n        fsCfg.setStrings(String.format(PARAM_GGFS_LOG_DIR, \"ggfs:ggfs-grid@\"), U.getIgniteHome());\n\n        return (IgfsHadoopFileSystem)FileSystem.get(new URI(\"ggfs://ggfs:ggfs-grid@/\"), fsCfg);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2801,
    "type": "Summary",
    "comment": "Either provides a pass thru function when the function cannot be properly mapped or otherwise returns the function implementation based on the name using the internal FUNCTION map",
    "code": "    public static PathFunction newFunction(String name) throws InvalidPathException {\n        Class functionClazz = FUNCTIONS.get(name);\n        if(functionClazz == null){\n            throw new InvalidPathException(\"Function with name: \" + name + \" does not exists.\");\n        } else {\n            try {\n                return (PathFunction)functionClazz.newInstance();\n            } catch (Exception e) {\n                throw new InvalidPathException(\"Function of name: \" + name + \" cannot be created\", e);\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "Returns the function by name or throws InvalidPathException if function not found."
  },
  {
    "id": 2802,
    "type": "Summary",
    "comment": "Aspect implementation which executes grid-enabled methods on remote nodes.",
    "code": "    public Object gridify(ProceedingJoinPoint joinPnt) throws Throwable {\n        Method mtd = ((MethodSignature) joinPnt.getSignature()).getMethod();\n\n        GridifySetToSet ann = mtd.getAnnotation(GridifySetToSet.class);\n\n        assert ann != null : \"Intercepted method does not have gridify annotation.\";\n\n        // Since annotations in Java don't allow 'null' as default value\n        // we have accept an empty string and convert it here.\n        // NOTE: there's unintended behavior when user specifies an empty\n        // string as intended grid name.\n        // NOTE: the 'ann.gridName() == null' check is added to mitigate\n        // annotation bugs in some scripting languages (e.g. Groovy).\n        String gridName = F.isEmpty(ann.gridName()) ? null : ann.gridName();\n\n        if (G.state(gridName) != STARTED)\n            throw new GridException(\"Grid is not locally started: \" + gridName);\n\n        GridifyNodeFilter nodeFilter = null;\n\n        if (!ann.nodeFilter().equals(GridifyNodeFilter.class))\n            nodeFilter = ann.nodeFilter().newInstance();\n\n        // Check method return type.\n        checkMethodSignature(mtd);\n\n        GridifyArgumentBuilder argBuilder = new GridifyArgumentBuilder();\n\n        // Creates task argument.\n        GridifyRangeArgument arg = argBuilder.createTaskArgument(\n            mtd.getDeclaringClass(),\n            mtd.getName(),\n            mtd.getReturnType(),\n            mtd.getParameterTypes(),\n            mtd.getParameterAnnotations(),\n            joinPnt.getArgs(),\n            joinPnt.getTarget());\n\n        if (!ann.interceptor().equals(GridifyInterceptor.class)) {\n            // Check interceptor first.\n            if (!ann.interceptor().newInstance().isGridify(ann, arg))\n                return joinPnt.proceed();\n        }\n\n        // Proceed locally for negative threshold parameter.\n        if (ann.threshold() < 0)\n            return joinPnt.proceed();\n\n        // Analyse where to execute method (remotely or locally).\n        if (arg.getInputSize() != UNKNOWN_SIZE && arg.getInputSize() <= ann.threshold())\n            return joinPnt.proceed();\n\n        // Check is split to jobs allowed for input method argument with declared splitSize.\n        checkIsSplitToJobsAllowed(arg, ann);\n\n        try {\n            Ignite ignite = G.grid(gridName);\n\n            return execute(ignite.compute(), joinPnt.getSignature().getDeclaringType(), arg, nodeFilter,\n                ann.threshold(), ann.splitSize(), ann.timeout());\n        }\n        catch (Throwable e) {\n            for (Class<?> ex : ((MethodSignature) joinPnt.getSignature()).getMethod().getExceptionTypes()) {\n                // Descend all levels down.\n                Throwable cause = e.getCause();\n\n                while (cause != null) {\n                    if (ex.isAssignableFrom(cause.getClass()))\n                        throw cause;\n\n                    cause = cause.getCause();\n                }\n\n                if (ex.isAssignableFrom(e.getClass()))\n                    throw e;\n            }\n\n            throw new GridifyRuntimeException(\"Undeclared exception thrown: \" + e.getMessage(), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2803,
    "type": "Summary",
    "comment": "Returns a set of URLs based on the  WEB-INF/lib folder.",
    "code": "    public static Collection<URL> forWebInfLib(final ServletContext servletContext) {\n        final Collection<URL> urls = new ArrayList<URL>();\n        for (Object urlString : servletContext.getResourcePaths(\"/WEB-INF/lib\")) {\n            try {\n                urls.add(servletContext.getResource((String) urlString));\n            } catch (MalformedURLException e) { /*fuck off*/ }\n        }\n        return distinctUrls(urls);\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs based on the  WEB-INF/lib folder."
  },
  {
    "id": 2804,
    "type": "Summary",
    "comment": "Returns the largest eigen pair of matrix with the power iteration under the assumptions A has an eigenvalue that is strictly greater in magnitude than its other its other eigenvalues and the starting vector has a nonzero component in the direction of an eigenvector associated with the dominant eigenvalue.",
    "code": "    public static double eigen(Matrix A, double[] v, double tol) {\n        return PowerIteration.eigen(A, v, tol);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2805,
    "type": "Summary",
    "comment": "Determine the uri that we should play.",
    "code": "    public Uri getUriToPlay() {\n        final Intent received = getIntent();\n        final Bundle data = received.getExtras();\n\n        // we must receive the URI value or we can't do anything\n        final String uriText = data.getString(Keys.URI);\n\n        return Uri.parse(uriText);\n    }\n\n",
    "label": 1,
    "rec": "Determine the uri that we should play from the Intent."
  },
  {
    "id": 2806,
    "type": "Summary",
    "comment": "double argument that matches both given argument matchers.",
    "code": "    public static double and(double first, double second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2807,
    "type": "Summary",
    "comment": "Use doReturn() in those rare occasions when you cannot use  Mockito#when(Object).",
    "code": "    public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {\n        return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);\n    }\n",
    "label": 1,
    "rec": "Same as  #doReturn(Object) but sets consecutive values to be returned."
  },
  {
    "id": 2808,
    "type": "Summary",
    "comment": "THIS METHOD IS USED ONLY FOR TESTING.",
    "code": "    List<ClusterNode> getNodes() {\n        synchronized (mux) {\n            return Collections.unmodifiableList(new ArrayList<>(nodeQueue));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2809,
    "type": "Summary",
    "comment": "This is a wrapper around  AdminClient#getMaxVersion(int, String) where-in we find the max versions on each machine and then return the max of all of them",
    "code": "    public Map<String, Long> getROGlobalMaxVersion(List<String> storeNames) {\n        Map<String, Long> storeToMaxVersion = Maps.newHashMapWithExpectedSize(storeNames.size());\n        for(String storeName: storeNames) {\n            storeToMaxVersion.put(storeName, 0L);\n        }\n\n        for(Node node: currentCluster.getNodes()) {\n            Map<String, Long> currentNodeVersions = getROMaxVersion(node.getId(), storeNames);\n            for(String storeName: currentNodeVersions.keySet()) {\n                Long maxVersion = storeToMaxVersion.get(storeName);\n                if(maxVersion != null && maxVersion < currentNodeVersions.get(storeName)) {\n                    storeToMaxVersion.put(storeName, currentNodeVersions.get(storeName));\n                }\n            }\n        }\n        return storeToMaxVersion;\n    }\n\n",
    "label": 1,
    "rec": "This is a wrapper around  voldemort.client.protocol.admin.AdminClient#getROMaxVersion(int, List) where-in we find the max versions on each machine and then return the max of all of them"
  },
  {
    "id": 2810,
    "type": "Summary",
    "comment": "Calculate the vertical drag range between the custom view and dragged view.",
    "code": "    private float getVerticalDragRange() {\n        return getHeight() - transformer.getHeightPlusMarginTop();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2811,
    "type": "Summary",
    "comment": "Get the living entity that entered the vehicle.",
    "code": "    public Entity getEntered() {\n        return entered;\n    }\n",
    "label": 1,
    "rec": "Get the entity that entered the vehicle."
  },
  {
    "id": 2812,
    "type": "Summary",
    "comment": "Tells whether provided type is binary.",
    "code": "    public static boolean isBinaryType(Class<?> cls) {\n        assert cls != null;\n\n        return BinaryObject.class.isAssignableFrom(cls) ||\n            Proxy.class.isAssignableFrom(cls) ||\n            BINARY_CLS.contains(cls);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2813,
    "type": "Summary",
    "comment": "Returns  true if the environment does not specify any labels.",
    "code": "    public boolean isUnspecified() {\n        return labels.isEmpty() && variables.isEmpty();\n    }\n\n",
    "label": 1,
    "rec": "Returns  true if the environment does not specify any labels nor environment variables."
  },
  {
    "id": 2814,
    "type": "Summary",
    "comment": "Sort a Set or a List and Store the Result at dstkey.",
    "code": "    public Long sort(final byte[] key, final byte[] dstkey) {\n        checkIsInMulti();\n        client.sort(key, dstkey);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2815,
    "type": "Summary",
    "comment": "Use doReturn() in those rare occasions when you cannot use  Mockito#when(Object).",
    "code": "    public static PowerMockitoStubber doReturn(Object toBeReturned) {\n        return POWERMOCKITO_CORE.doReturn(toBeReturned);\n    }\n",
    "label": 1,
    "rec": "Use doReturn() in those rare occasions when you cannot use  PowerMockito#when(Object)."
  },
  {
    "id": 2816,
    "type": "Summary",
    "comment": "Extracts a page index from the given pageId.",
    "code": "    public static long pageIdx(long pageId) {\n        return pageId & PAGE_IDX_MASK;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2817,
    "type": "Summary",
    "comment": "Gets the average and the variance of the buffer.",
    "code": "  public double[] getAverageAndVariance() {\n    int numberOfEntries = isFull ? buffer.length : index;\n    if (numberOfEntries == 0) {\n      return new double[]{0, 0};\n    }\n\n    double sum = 0;\n    double sumSquares = 0;\n    for (int i = 0; i < numberOfEntries; i++) {\n      sum += buffer[i];\n      sumSquares += Math.pow(buffer[i], 2);\n    }\n\n    double average = sum / numberOfEntries;\n    return new double[]{average,\n      sumSquares / numberOfEntries  - Math.pow(average, 2)};\n  }\n\n",
    "label": 1,
    "rec": "Gets the average and standard deviation of the buffer."
  },
  {
    "id": 2818,
    "type": "Summary",
    "comment": "Constructs a page link by the given page ID and bytes offset within the page.",
    "code": "    public static long linkFromBytesOffset(long pageId, int bytesOffset) {\n        assert (bytesOffset & 0x7) == 0;\n        assert (pageId >> (PAGE_IDX_SIZE + FILE_ID_SIZE)) == 0;\n\n        // (bytesOffset >> 3) << PAGE_IDX_SIZE\n        return pageId | (((long)bytesOffset) << (FILE_ID_SIZE + PAGE_IDX_SIZE - 3));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2819,
    "type": "Summary",
    "comment": "Returns a filter that will accept any String that starts with the specified String.",
    "code": "    public static Predicate<String> startsWith(String startsWith) {\r\n        return new StartsWithFilter(startsWith);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns a predicate that will accept any String that starts with the specified"
  },
  {
    "id": 2820,
    "type": "Summary",
    "comment": "Cast IO exception to GGFS exception.",
    "code": "    public static IgniteFsException cast(String msg, IOException e) {\n        if (e instanceof FileNotFoundException)\n            return new IgniteFsFileNotFoundException(e);\n        else if (e instanceof ParentNotDirectoryException)\n            return new IgniteFsParentNotDirectoryException(msg, e);\n        else if (e instanceof PathIsNotEmptyDirectoryException)\n            return new GridGgfsDirectoryNotEmptyException(e);\n        else if (e instanceof PathExistsException)\n            return new IgniteFsPathAlreadyExistsException(msg, e);\n        else\n            return new IgniteFsException(msg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2821,
    "type": "Summary",
    "comment": "Returns the actual file location to use when reading the given managed target.",
    "code": "\tpublic File lookup(String managedFile, boolean add) throws IOException {\n\t\tif (!open)\n\t\t\tthrow new IOException(EclipseAdaptorMsg.fileManager_notOpen);\n\t\tEntry entry = (Entry) table.get(managedFile);\n\t\tif (entry == null) {\n\t\t\tif (add) {\n\t\t\t\tadd(managedFile);\n\t\t\t\tentry = (Entry) table.get(managedFile);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn new File(getAbsolutePath(managedFile + '.' + entry.getReadId()));\n\t}\n\n",
    "label": 1,
    "rec": "Returns the actual file location to use when reading the given managed file."
  },
  {
    "id": 2822,
    "type": "Summary",
    "comment": "float array argument that is equal to the given array, i.e.",
    "code": "    public static float[] aryEq(float[] value) {\n        reportMatcher(new ArrayEquals(value));\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2823,
    "type": "Summary",
    "comment": "Creates and returns a new empty context with no parent, using the default context strategy.",
    "code": "\tstatic public IEclipseContext create() {\n\t\treturn new EclipseContext(null, null);\n\t}\n\n",
    "label": 1,
    "rec": "Creates and returns a new empty context."
  },
  {
    "id": 2824,
    "type": "Summary",
    "comment": "Checks that node is activated.",
    "code": "    public boolean activated(ClusterNode node, AffinityTopologyVersion topVer) {\n        if (topVer.equals(AffinityTopologyVersion.NONE))\n            return activated(node);\n\n        return discoCache(topVer).activatedNodes.contains(node);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2825,
    "type": "Summary",
    "comment": "Create a TypeLiteral representing Iterable&lt;T&gt;.",
    "code": "  @SuppressWarnings(\"unchecked\")\n  public static <T> TypeLiteral<Iterable<? extends T>> iterable(final Class<T> clazz) {\n    return (TypeLiteral<Iterable<? extends T>>) TypeLiteral.get(new ParameterizedType() {\n\n      public Type[] getActualTypeArguments() {\n        return new Type[] {clazz};\n      }\n\n      public Type getRawType() {\n        return Iterable.class;\n      }\n\n      public Type getOwnerType() {\n        return null;\n      }\n    });\n  }\n\n",
    "label": 1,
    "rec": "Create a type-literal representing an iterable sequence of the given type."
  },
  {
    "id": 2826,
    "type": "Summary",
    "comment": "set a deadline",
    "code": "    public JSONArray tasksSetDeadline(long idTask, String deadline) throws ApiServiceException, IOException {\n        return getResponse(invokeGet(\"tasks/set_deadline.json\",\n                \"token\", token,\n                \"id_task\", idTask,\n                \"deadline\", deadline), \"tasks\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2827,
    "type": "Summary",
    "comment": "Mask out query string details in a URL.",
    "code": "    public static String sanitize(URL url) {\n        try {\n            URI orig = url.toURI();\n            return new URI(orig.getScheme(), orig.getUserInfo() != null ? \"\u2026\" : null, orig.getHost(), orig.getPort(), orig.getPath(), orig.getQuery() != null ? \"\u2026\" : null, orig.getFragment()).toString();\n        } catch (URISyntaxException x) {\n            assert false : x;\n            return url.toString();\n        }\n    }\n\n",
    "label": 1,
    "rec": "Mask out query string or user info details in a URL."
  },
  {
    "id": 2828,
    "type": "Summary",
    "comment": "Creates a new ExecutionResult by adding the defined 'event' to the ones on the current instance.",
    "code": "    public ExecutionResult addEvent(HystrixEventType eventType) {\n        return new ExecutionResult(eventCounts.plus(eventType), startTimestamp, executionLatency,\n                userThreadLatency, failedExecutionException, executionException,\n                executionOccurred, isExecutedInThread, collapserKey);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2829,
    "type": "Summary",
    "comment": "Returns true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.",
    "code": "    public boolean matches(Method method, Class targetClass) {\n        return ((method.getAnnotation(RequiresPermissions.class) != null) ||\n                (method.getAnnotation(RequiresRoles.class) != null) ||\n                (method.getAnnotation(RequiresUser.class) != null) ||\n                (method.getAnnotation(RequiresGuest.class) != null ) ||\n                (method.getAnnotation(RequiresAuthentication.class) != null ));\n    }\n",
    "label": 1,
    "rec": "Returns true if the method has any JSecurity annotations, false otherwise."
  },
  {
    "id": 2830,
    "type": "Summary",
    "comment": "Return the all the elements in the sorted set at key with a score between min and max (including elements with score equal to min or max).",
    "code": "  public Set<String> zrangeByScore(final String key, final double min, final double max) {\n    checkIsInMulti();\n    client.zrangeByScore(key, min, max);\n    final List<String> members = client.getMultiBulkReply();\n    if (members == null) {\n      return null;\n    }\n    return SetFromList.of(members);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2831,
    "type": "Summary",
    "comment": "Encode \"fields\" query param, if it exists, and put the result into result.",
    "code": "  public static DataMap processProjections(DataMap dataMap, Map<String, List<String>> result)\n  {\n    //We send this through the pipeline and migrate from the dataMap into the result\n    for (final String parameterName : RestConstants.PROJECTION_PARAMETERS)\n    {\n      if (dataMap.containsKey(parameterName))\n      {\n        dataMap = processIndividualProjection(dataMap, result, parameterName);\n      }\n    }\n\n    //If there were no projection parameters, we simply return the unmodified dataMap\n    return dataMap;\n  }\n\n",
    "label": 1,
    "rec": "Encode any of the projection fields query parameters, if they exist, and place them into result."
  },
  {
    "id": 2832,
    "type": "Summary",
    "comment": "Generates a 1 hour expiring code.",
    "code": "    public static ExpiringCode getExpiringCode(ExpiringCodeStore codeStore, String userId, String email, String clientId, String redirectUri, ExpiringCodeType intent) {\n        Assert.notNull(codeStore);\n        Assert.notNull(userId);\n        Assert.notNull(email);\n        Assert.notNull(intent);\n\n        Map<String, String> codeData = new HashMap<>();\n        codeData.put(\"user_id\", userId);\n        codeData.put(\"email\", email);\n        codeData.put(\"client_id\", clientId);\n        if (redirectUri != null) {\n            codeData.put(\"redirect_uri\", redirectUri);\n        }\n        String codeDataString = JsonUtils.writeValueAsString(codeData);\n\n        Timestamp expiresAt = new Timestamp(System.currentTimeMillis() + (60 * 60 * 1000)); // 1 hour\n        return codeStore.generateCode(codeDataString, expiresAt, intent.name());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2833,
    "type": "Summary",
    "comment": "Gets the class describing the input format.",
    "code": "\t@Override\n\tpublic Class<? extends OutputFormat> getUserCodeClass()\n\t{\n\t\treturn this.clazz;\n\t}\n\n",
    "label": 1,
    "rec": "Gets the class describing the output format."
  },
  {
    "id": 2834,
    "type": "Summary",
    "comment": "Unmarshalls credentials with discovery SPI marshaller (will not replace attribute value).",
    "code": "    private SecurityCredentials unmarshalCredentials(TcpDiscoveryNode node) throws IgniteSpiException {\n        try {\n            byte[] credBytes = (byte[])node.getAttributes().get(IgniteNodeAttributes.ATTR_SECURITY_CREDENTIALS);\n\n            if (credBytes == null)\n                return null;\n\n            return marsh.unmarshal(credBytes, null);\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteSpiException(\"Failed to unmarshal node security credentials: \" + node.id(), e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2835,
    "type": "Summary",
    "comment": "Compute the correlation between two vectors",
    "code": "\tprotected double correlation(SparseVector iv, SparseVector jv) {\n\t\treturn correlation(iv, jv, cf.getString(\"similarity\"));\n\t}\n",
    "label": 1,
    "rec": "Compute the correlation between two vectors using method specified by configuration key \"similarity\""
  },
  {
    "id": 2836,
    "type": "Summary",
    "comment": "Uses the principal found in the Account parameter (not the authentication token) to construct a  org.jsecurity.authc.event.SuccessfulAuthenticationEvent",
    "code": "    public AuthenticationEvent createSuccessEvent( AuthenticationToken token, Account account ) {\n        return new SuccessfulAuthenticationEvent( token, account );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2837,
    "type": "Summary",
    "comment": "Creates a  InfinispanKeyValueEntityManagerFactory from infinispan config",
    "code": "    public InfinispanBucketManagerFactory get(org.infinispan.configuration.cache.Configuration config)throws NullPointerException {\n        requireNonNull(config, \"config is required\");\n\n        return new InfinispanBucketManagerFactory(new DefaultCacheManager(config));\n    }\n\n",
    "label": 1,
    "rec": "Creates a  InfinispanBucketManagerFactory from infinispan config"
  },
  {
    "id": 2838,
    "type": "Summary",
    "comment": "Gets tasks that were modified since last sync",
    "code": "    public TodorooCursor<Task> getLocallyUpdated(Property<?>[] properties) {\n        long lastSyncDate = actFmPreferenceService.getLastSyncDate();\n        if(lastSyncDate == 0)\n            return taskDao.query(Query.select(properties).where(Criterion.none));\n        return\n            taskDao.query(Query.select(properties).\n                    where(Criterion.and(Task.REMOTE_ID.isNotNull(),\n                            Task.MODIFICATION_DATE.gt(lastSyncDate),\n                            Task.MODIFICATION_DATE.gt(Task.LAST_SYNC))).groupBy(Task.ID));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2839,
    "type": "Summary",
    "comment": "Checks for skip build phrase in the passed string",
    "code": "    private String checkSkipBuildInString(Map<Pattern, String> patterns, String string ) {\n        // check for skip build phrase in the passed string\n        if (!patterns.isEmpty() && StringUtils.isNotBlank(string)) {\n            for(Map.Entry<Pattern, String> e: patterns.entrySet()){\n                if(e.getKey().matcher(string).matches()){\n                    return e.getValue();\n                }\n            }\n        }\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Checks for skip pattern in the passed string"
  },
  {
    "id": 2840,
    "type": "Summary",
    "comment": "Calculates type names for writing into generated Java.",
    "code": "    public static String calculateTypeName(CompilationUnit compilationUnit, FullyQualifiedJavaType fqjt) {\n\n        if (fqjt.isArray()) {\n            // if array, then calculate the name of the base (non-array) type\n            // then add the array indicators back in\n            String fqn = fqjt.getFullyQualifiedName();\n            String typeName = calculateTypeName(compilationUnit,\n                    new FullyQualifiedJavaType(fqn.substring(0, fqn.indexOf('['))));\n            return typeName + fqn.substring(fqn.indexOf('['));\n        }\n        \n        if (!fqjt.getTypeArguments().isEmpty()) {\n            return calculateParameterizedTypeName(compilationUnit, fqjt);\n        }\n        \n        if (compilationUnit == null\n                || typeDoesNotRequireImport(fqjt)\n                || typeIsInSamePackage(compilationUnit, fqjt) \n                || typeIsAlreadyImported(compilationUnit, fqjt)) {\n            return fqjt.getShortName();\n        } else {\n            return fqjt.getFullyQualifiedName();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2841,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_INITIAL_KEY ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2842,
    "type": "Summary",
    "comment": "Returns true if  #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed, otherwise returns the result of  #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied.",
    "code": "    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        //mapped value is ignored - not needed for most (if not all) authc Filters.\n        return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2843,
    "type": "Summary",
    "comment": "ReadAddress",
    "code": "    @Processor\n    @InvalidateConnectionOn(exception = NotAuthenticatedException.class)\n    public Address readAddress(String objectId) {\n        return (Address) read(ServiceSourceCollection.Addresses, objectId);\n    }\n\n",
    "label": 1,
    "rec": "Fetches the address identified by the object id in the collection."
  },
  {
    "id": 2844,
    "type": "Summary",
    "comment": "Gets session ID of the task that triggered the event.",
    "code": "    public IgniteUuid taskSessionId() {\n        return sesId;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2845,
    "type": "Summary",
    "comment": "Any byte or non-null Byte.",
    "code": "    public static byte anyByte() {\n        reportMatcher(new InstanceOf(Byte.class));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2846,
    "type": "Summary",
    "comment": "Gets array of node IDs this predicate is based on.",
    "code": "    public Set<UUID> nodeIds(){\n        return ids;\n    }\n",
    "label": 1,
    "rec": "Gets set of node IDs this predicate is based on."
  },
  {
    "id": 2847,
    "type": "Summary",
    "comment": "Execute a command if it is registered, else return false.",
    "code": "    public boolean dispatchCommand(CommandSender sender, String commandLine)\n    {\n        String[] split = argsSplit.split( commandLine );\n        String commandName = split[0].toLowerCase();\n        if ( proxy.getDisabledCommands().contains( commandName ) )\n        {\n            return false;\n        }\n        Command command = commandMap.get( commandName );\n        if ( command == null )\n        {\n            return false;\n        }\n\n        String permission = command.getPermission();\n        if ( permission != null && !permission.isEmpty() && !sender.hasPermission( permission ) )\n        {\n            sender.sendMessage( proxy.getTranslation( \"no_permission\" ) );\n            return true;\n        }\n\n        String[] args = Arrays.copyOfRange( split, 1, split.length );\n        try\n        {\n            command.execute( sender, args );\n        } catch ( Exception ex )\n        {\n            sender.sendMessage( ChatColor.RED + \"An internal error occurred whilst executing this command, please check the console log for details.\" );\n            ProxyServer.getInstance().getLogger().log( Level.WARNING, \"Error in dispatching command\", ex );\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2848,
    "type": "Summary",
    "comment": "Builds an  org.apache.streams.pojo.json.Actor object from the  Post",
    "code": "    public static ActivityObject buildActor(Post post) {\n        ActivityObject actor = new ActivityObject();\n\n        try {\n            actor.setId(formatId(\n                    Optional.fromNullable(\n                            post.getFrom().getId())\n                            .or(Optional.of(post.getFrom().getId()))\n                            .orNull()\n            ));\n\n            actor.setDisplayName(post.getFrom().getName());\n            actor.setAdditionalProperty(\"handle\", post.getFrom().getName());\n        } catch (Exception e) {\n            LOGGER.error(\"Exception trying to build actor for Post: {}, {}\", post, e);\n        }\n\n        return actor;\n    }\n\n",
    "label": 1,
    "rec": "Builds an  org.apache.streams.pojo.json.ActivityObject object from the  Post"
  },
  {
    "id": 2849,
    "type": "Summary",
    "comment": "Calls  Parser#parse(File, Class) after creating an instance of the",
    "code": "    public File parse(Class cls) throws IOException, Parser.Exception {\n        return new Parser(properties).parse(outputDirectory, cls);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2850,
    "type": "Summary",
    "comment": "Returns whether the given integer has the AccDefaultFlag bit set.",
    "code": "\tpublic static boolean isDefaultMethod(int flags) {\n\t\treturn (flags & AccDefaultMethod) != 0;\n\t}\n\n",
    "label": 1,
    "rec": "Returns whether the given integer has the AccDefaultMethod bit set."
  },
  {
    "id": 2851,
    "type": "Summary",
    "comment": "C = A + B",
    "code": "    public DenseMatrix add(DenseMatrix b, DenseMatrix c) {\n        if (nrows() != b.nrows() || ncols() != b.ncols()) {\n            throw new IllegalArgumentException(\"Matrix is not of same size.\");\n        }\n\n        if (nrows() != c.nrows() || ncols() != c.ncols()) {\n            throw new IllegalArgumentException(\"Matrix is not of same size.\");\n        }\n\n        int m = nrows();\n        int n = ncols();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                c.set(i, j, get(i, j) + b.get(i, j));\n            }\n        }\n        return c;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2852,
    "type": "Summary",
    "comment": "Returns a map of module types to lists of modules.",
    "code": "    public Map<String, List<ModuleBean>> getModules()\n    {\n        Map<String, List<ModuleBean>> modules = new HashMap<>();\n        for (Map.Entry<String, Supplier<List<ModuleBean>>> moduleListEntry : this.modules.entrySet())\n        {\n            modules.put(moduleListEntry.getKey(), moduleListEntry.getValue().get());\n        }\n        return modules;\n    }\n\n",
    "label": 1,
    "rec": "Returns the map of modules, indexed by key."
  },
  {
    "id": 2853,
    "type": "Summary",
    "comment": "Saves the given item.",
    "code": "    public boolean saveExisting(final TYPE item) {\n        final ContentValues values = item.getSetValues();\n        if(values == null || values.size() == 0) // nothing changed\n            return true;\n        DatabaseChangeOp update = new DatabaseChangeOp() {\n            @Override\n            public boolean makeChange() {\n                return database.update(table.name, values,\n                        AbstractModel.ID_PROPERTY.eq(item.getId()).toString(), null) > 0;\n            }\n        };\n        return insertOrUpdateAndRecordChanges(item, values, update);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2854,
    "type": "Summary",
    "comment": "Returns the  AbstractTaskListElement category the new task belongs to",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tprotected AbstractTaskCategory getCategory() {\n\t\tint index = categoryChooser.getSelectionIndex();\n\t\tif (addToCategory.getSelection() && index != -1) {\n\t\t\tif (index == 0) {\n\t\t\t\treturn TasksUiPlugin.getTaskListManager().getTaskList().getAutomaticCategory();\n\t\t\t}\n\t\t\treturn ((List<AbstractTaskCategory>) categoryChooser.getData()).get(index - 1);\n\t\t}\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the  AbstractTaskContainer category the new task belongs to"
  },
  {
    "id": 2855,
    "type": "Summary",
    "comment": "Parse given file into the form of frame represented by the given key.",
    "code": "  public static Frame parseFrame(Key okey, File file) {\n    if( !file.exists() )\n      throw new RuntimeException(\"File not found \" + file);\n    if(okey == null)\n      okey = Key.make(file.getName());\n    Key fkey = NFSFileVec.make(file);\n    return ParseDataset2.parse(okey, new Key[] { fkey });\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2856,
    "type": "Summary",
    "comment": "Connects this input to the relevant output of the referenced transaction if it's in the given map.",
    "code": "    public ConnectionResult connect(Transaction transaction, ConnectMode mode) {\n        if (!transaction.getHash().equals(outpoint.getHash()))\n            return ConnectionResult.NO_SUCH_TX;\n        checkElementIndex((int) outpoint.getIndex(), transaction.getOutputs().size(), \"Corrupt transaction\");\n        TransactionOutput out = transaction.getOutput((int) outpoint.getIndex());\n        if (!out.isAvailableForSpending()) {\n            if (mode == ConnectMode.DISCONNECT_ON_CONFLICT) {\n                out.markAsUnspent();\n            } else if (mode == ConnectMode.ABORT_ON_CONFLICT) {\n                outpoint.fromTx = checkNotNull(out.parentTransaction);\n                return TransactionInput.ConnectionResult.ALREADY_SPENT;\n            }\n        }\n        connect(out);\n        return TransactionInput.ConnectionResult.SUCCESS;\n    }\n",
    "label": 1,
    "rec": "Connects this input to the relevant output of the referenced transaction."
  },
  {
    "id": 2857,
    "type": "Summary",
    "comment": "Unwraps collection.",
    "code": "    public Collection<Object> unwrapPortablesIfNeeded(Collection<Object> col, boolean keepPortable)\n        throws GridException {\n        if (!config().isPortableEnabled())\n            return col;\n\n        Collection<Object> unwrapped = new ArrayList<>(col.size());\n\n        for (Object o : col) {\n            unwrapped.add(unwrapPortableIfNeeded(o, keepPortable));\n        }\n\n        return unwrapped;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2858,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_EQUALISATION2;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2859,
    "type": "Summary",
    "comment": "Returns  true if the  tokenCredentials argument is logically equal to the  accountCredentials argument.",
    "code": "    protected boolean equals(Object tokenCredentials, Object accountCredentials) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Performing credentials equality check for tokenCredentials of type [\" +\n                    tokenCredentials.getClass().getName() + \" and accountCredentials of type [\" +\n                    accountCredentials.getClass().getName() + \"]\");\n        }\n        if (isByteSource(tokenCredentials) && isByteSource(accountCredentials)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Both credentials arguments can be easily converted to byte arrays.  Performing \" +\n                        \"array equals comparison\");\n            }\n            byte[] tokenBytes = toBytes(tokenCredentials);\n            byte[] accountBytes = toBytes(accountCredentials);\n            return MessageDigest.isEqual(tokenBytes, accountBytes);\n        } else {\n            return accountCredentials.equals(tokenCredentials);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2860,
    "type": "Summary",
    "comment": "Return the  IInstallableUnit that are installed in the running instance of eclipse.",
    "code": "\tpublic IQueryResult<IInstallableUnit> listInstalledElements(boolean rootsOnly, IProgressMonitor monitor) {\n\t\tIProfileRegistry registry = (IProfileRegistry) getAgent().getService(IProfileRegistry.SERVICE_NAME);\n\t\tIProfile profile = registry.getProfile(IProfileRegistry.SELF);\n\t\tif (profile == null)\n\t\t\treturn new CollectionResult<IInstallableUnit>(null);\n\t\tif (rootsOnly)\n\t\t\treturn profile.query(new UserVisibleRootQuery(), monitor);\n\t\treturn profile.query(QueryUtil.ALL_UNITS, monitor);\n\t}\n\n",
    "label": 1,
    "rec": "Returns the  IInstallableUnits that are installed in the running instance of Eclipse."
  },
  {
    "id": 2861,
    "type": "Summary",
    "comment": "Establishes connection to an address, sends message and returns the response (if any).",
    "code": "    @Nullable private Integer sendMessageDirectly(TcpDiscoveryAbstractMessage msg, InetSocketAddress addr)\n        throws IgniteSpiException {\n        assert msg != null;\n        assert addr != null;\n\n        Collection<Throwable> errs = null;\n\n        long ackTimeout0 = spi.getAckTimeout();\n\n        int connectAttempts = 1;\n\n        boolean joinReqSent;\n\n        UUID locNodeId = getLocalNodeId();\n\n        IgniteSpiOperationTimeoutHelper timeoutHelper = new IgniteSpiOperationTimeoutHelper(spi);\n\n        int reconCnt = 0;\n\n        while (true){\n            // Need to set to false on each new iteration,\n            // since remote node may leave in the middle of the first iteration.\n            joinReqSent = false;\n\n            boolean openSock = false;\n\n            Socket sock = null;\n\n            try {\n                long tstamp = U.currentTimeMillis();\n\n                sock = spi.openSocket(addr, timeoutHelper);\n\n                openSock = true;\n\n                // Handshake.\n                spi.writeToSocket(sock, new TcpDiscoveryHandshakeRequest(locNodeId), timeoutHelper.nextTimeoutChunk(\n                    spi.getSocketTimeout()));\n\n                TcpDiscoveryHandshakeResponse res = spi.readMessage(sock, null, timeoutHelper.nextTimeoutChunk(\n                    ackTimeout0));\n\n                if (locNodeId.equals(res.creatorNodeId())) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Handshake response from local node: \" + res);\n\n                    break;\n                }\n\n                spi.stats.onClientSocketInitialized(U.currentTimeMillis() - tstamp);\n\n                // Send message.\n                tstamp = U.currentTimeMillis();\n\n                spi.writeToSocket(sock, msg, timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout()));\n\n                spi.stats.onMessageSent(msg, U.currentTimeMillis() - tstamp);\n\n                if (debugMode)\n                    debugLog(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Message has been sent directly to address [msg=\" + msg + \", addr=\" + addr +\n                        \", rmtNodeId=\" + res.creatorNodeId() + ']');\n\n                // Connection has been established, but\n                // join request may not be unmarshalled on remote host.\n                // E.g. due to class not found issue.\n                joinReqSent = msg instanceof TcpDiscoveryJoinRequestMessage;\n\n                return spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n            }\n            catch (ClassCastException e) {\n                // This issue is rarely reproducible on AmazonEC2, but never\n                // on dedicated machines.\n                if (log.isDebugEnabled())\n                    U.error(log, \"Class cast exception on direct send: \" + addr, e);\n\n                onException(\"Class cast exception on direct send: \" + addr, e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n            }\n            catch (IOException | IgniteCheckedException e) {\n                if (log.isDebugEnabled())\n                    log.error(\"Exception on direct send: \" + e.getMessage(), e);\n\n                onException(\"Exception on direct send: \" + e.getMessage(), e);\n\n                if (errs == null)\n                    errs = new ArrayList<>();\n\n                errs.add(e);\n\n                if (timeoutHelper.checkFailureTimeoutReached(e))\n                    break;\n\n                if (!spi.failureDetectionTimeoutEnabled() && ++reconCnt == spi.getReconnectCount())\n                    break;\n\n                if (!openSock) {\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break; // Don't retry if we can not establish connection.\n                }\n\n                if (!spi.failureDetectionTimeoutEnabled() && (e instanceof SocketTimeoutException ||\n                    X.hasCause(e, SocketTimeoutException.class))) {\n                    ackTimeout0 *= 2;\n\n                    if (!checkAckTimeout(ackTimeout0))\n                        break;\n                }\n            }\n            finally {\n                U.closeQuiet(sock);\n            }\n        }\n\n        if (joinReqSent) {\n            if (log.isDebugEnabled())\n                log.debug(\"Join request has been sent, but receipt has not been read (returning RES_WAIT).\");\n\n            // Topology will not include this node,\n            // however, warning on timed out join will be output.\n            return RES_OK;\n        }\n\n        throw new IgniteSpiException(\n            \"Failed to send message to address [addr=\" + addr + \", msg=\" + msg + ']',\n            U.exceptionWithSuppressed(\"Failed to send message to address \" +\n                \"[addr=\" + addr + \", msg=\" + msg + ']', errs));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2862,
    "type": "Summary",
    "comment": "Returns either the value of the \"com.googlecode.javacpp.platform\" system property, or  #platform when the former is not set.",
    "code": "    public static String getPlatform() {\n        return System.getProperty(\"org.bytedeco.javacpp.platform\", platform);\n    }\n\n",
    "label": 1,
    "rec": "Returns either the value of the \"org.bytedeco.javacpp.platform\" system property, or  #platform when the former is not set."
  },
  {
    "id": 2863,
    "type": "Summary",
    "comment": "Creates a future that will wait for all ongoing transactions that maybe affected by topology update to be finished.",
    "code": "    public IgniteFuture<Boolean> finishTxs(long topVer) {\n        GridCompoundFuture<GridCacheTx, Boolean> res =\n            new GridCompoundFuture<>(context().kernalContext(),\n                new IgniteReducer<GridCacheTx, Boolean>() {\n                    @Override public boolean collect(GridCacheTx e) {\n                        return true;\n                    }\n\n                    @Override public Boolean reduce() {\n                        return true;\n                    }\n                });\n\n        for (GridCacheTxEx<K, V> tx : txs()) {\n            // Must wait for all transactions, even for DHT local and DHT remote since preloading may acquire\n            // values pending to be overwritten by prepared transaction.\n\n            if (tx.concurrency() == PESSIMISTIC) {\n                if (tx.topologyVersion() > 0 && tx.topologyVersion() < topVer)\n                    // For PESSIMISTIC mode we must wait for all uncompleted txs\n                    // as we do not know in advance which keys will participate in tx.\n                    res.add(tx.finishFuture());\n            }\n            else if (tx.concurrency() == OPTIMISTIC) {\n                // For OPTIMISTIC mode we wait only for txs in PREPARING state that\n                // have keys for given partitions.\n                GridCacheTxState state = tx.state();\n                long txTopVer = tx.topologyVersion();\n\n                if ((state == PREPARING || state == PREPARED || state == COMMITTING)\n                    && txTopVer > 0 && txTopVer < topVer) {\n                    res.add(tx.finishFuture());\n                }\n            }\n        }\n\n        res.markInitialized();\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2864,
    "type": "Summary",
    "comment": "Returns a set of URLs based on URLs derived from class loaders.",
    "code": "    public static Collection<URL> forClassLoader() {\n        return forClassLoader(classLoaders());\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs based on URLs derived from class loaders."
  },
  {
    "id": 2865,
    "type": "Summary",
    "comment": "helper method that returns current state of data structure used to track acks for batch messages",
    "code": "    public boolean isBatchingAckTrackerEmpty() {\n        return consumers.stream().allMatch(ConsumerImpl::isBatchingAckTrackerEmpty);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2866,
    "type": "Summary",
    "comment": "Creates a  Command out of the given commandAsString incorporating the  TypeParser.",
    "code": "\tprivate Command createCommandFromString(Item item, String commandAsString) throws BindingConfigParseException {\n\t\t\n\t\tif (CHANGED_COMMAND_KEY.equals(commandAsString)) {\n\t\t\treturn CHANGED_COMMAND_KEY;\n\t\t}\n\t\telse if (WILDCARD_COMMAND_KEY.equals(commandAsString)) {\n\t\t\treturn WILDCARD_COMMAND_KEY;\n\t\t} else {\n\t\t\tCommand command = TypeParser.parseCommand(\n\t\t\t\titem.getAcceptedCommandTypes(), commandAsString);\n\t\t\t\n\t\t\tif (command == null) {\n\t\t\t\tthrow new BindingConfigParseException(\"couldn't create Command from '\" + commandAsString + \"' \");\n\t\t\t}\n\t\t\t\n\t\t\treturn command;\n\t\t}\n\t}\n",
    "label": 1,
    "rec": "Creates a  Command out of the given commandAsString taking the special Commands \"CHANGED\" and \"\" into account and incorporating the  TypeParser."
  },
  {
    "id": 2867,
    "type": "Summary",
    "comment": "Implements the rule for generating an example class.",
    "code": "    public boolean generateExampleClass() {\n        if (introspectedTable.getContext().getSqlMapGeneratorConfiguration() == null\n                && introspectedTable.getContext().getJavaClientGeneratorConfiguration() == null) {\n            // this is a model only context - don't generate the example class\n            return false;\n        }\n\n        if (isModelOnly) {\n            return false;\n        }\n\n        return tableConfiguration.isSelectByExampleStatementEnabled()\n                || tableConfiguration.isDeleteByExampleStatementEnabled()\n                || tableConfiguration.isCountByExampleStatementEnabled()\n                || tableConfiguration.isUpdateByExampleStatementEnabled();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2868,
    "type": "Summary",
    "comment": "Decorates the given  Buffer to ignore calls to  Buffer#close.",
    "code": "  public static ReadableBuffer ignoreClose(ReadableBuffer buffer) {\n    return new ForwardingReadableBuffer(buffer) {\n      @Override\n      public void close() {\n        // Ignore.\n      }\n    };\n  }\n\n",
    "label": 1,
    "rec": "Decorates the given  ReadableBuffer to ignore calls to  ReadableBuffer#close."
  },
  {
    "id": 2869,
    "type": "Summary",
    "comment": "Gets all file IDs for components of specified path possibly skipping existing transaction.",
    "code": "    private List<IgniteUuid> fileIds(GridGgfsPath path, boolean skipTx) throws GridException {\n        assert path != null;\n\n        // Path components.\n        Collection<String> components = path.components();\n\n        // Collection of file IDs for components of specified path.\n        List<IgniteUuid> ids = new ArrayList<>(components.size() + 1);\n\n        ids.add(ROOT_ID); // Always add root ID.\n\n        IgniteUuid fileId = ROOT_ID;\n\n        for (String s : components) {\n            assert !s.isEmpty();\n\n            if (fileId != null)\n                fileId = fileId(fileId, s, skipTx);\n\n            ids.add(fileId);\n        }\n\n        return ids;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2870,
    "type": "Summary",
    "comment": "This method will return current value only if clearIndex(V) will require previous value (this is the case for Mongo caches).",
    "code": "    protected CacheObject saveValueForIndexUnlocked() throws IgniteCheckedException {\n        assert Thread.holdsLock(this);\n\n        if (cctx.queries() == null)\n            return null;\n\n        CacheObject val = rawGetOrUnmarshalUnlocked(false);\n\n        if (val == null) {\n            GridCacheSwapEntry swapEntry = cctx.swap().read(key, true, true);\n\n            if (swapEntry == null)\n                return null;\n\n            return swapEntry.value();\n        }\n\n        return val;\n    }\n",
    "label": 1,
    "rec": "This method will return current value only if clearIndex(V) will require previous value."
  },
  {
    "id": 2871,
    "type": "Summary",
    "comment": "Creates a Processing font from a classic font.",
    "code": "    private PFont createFont(Font font) {\n        return createFont(font.getName(), 1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2872,
    "type": "Summary",
    "comment": "Casts this throwable as  GridException.",
    "code": "    public static IgniteCheckedException cast(Throwable t) {\n        assert t != null;\n\n        while (true) {\n            if (t instanceof Error)\n                throw (Error)t;\n\n            if (t instanceof GridClosureException) {\n                t = ((GridClosureException)t).unwrap();\n\n                continue;\n            }\n\n            if (t instanceof IgniteCheckedException)\n                return (IgniteCheckedException)t;\n\n            if (!(t instanceof IgniteException) || t.getCause() == null)\n                return new IgniteCheckedException(t);\n\n            assert t.getCause() != null; // ...and it is IgniteException.\n\n            t = t.getCause();\n        }\n    }\n",
    "label": 1,
    "rec": "Casts this throwable as  IgniteCheckedException."
  },
  {
    "id": 2873,
    "type": "Summary",
    "comment": "Scope of collapsing.",
    "code": "    public Scope getScope() {\n        return collapserFactory.getScope();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2874,
    "type": "Summary",
    "comment": "A shortcut method for calling getHelp(80).",
    "code": "    public String getHelp() {\n        return (getHelp(DEFAULT_SCREENWIDTH, DEFAULT_PARAM_HELP_SEPARATOR));\n    }\n\n",
    "label": 1,
    "rec": "A shortcut method for calling getHelp(80, \"\\n\")."
  },
  {
    "id": 2875,
    "type": "Summary",
    "comment": "Internal routine to read enum for named field.",
    "code": "    private Object[] readEnumArray0(@Nullable Class<?> cls) throws BinaryObjectException {\n        switch (checkFlag(ENUM_ARR)) {\n            case NORMAL:\n                // Read class even if we know it in advance to set correct stream position.\n                Class<?> cls0 = BinaryUtils.doReadClass(in, ctx, ldr);\n\n                if (cls == null)\n                    cls = cls0;\n\n                return BinaryUtils.doReadEnumArray(in, ctx, ldr, cls);\n\n            case HANDLE:\n                return readHandleField();\n\n            default:\n                return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2876,
    "type": "Summary",
    "comment": "Receive a set of characters; process one chunksize worth.",
    "code": "  @Override\n  public final boolean dealWithCharacters(Reader reader)\n    throws IOException, ManifoldCFException\n  {\n    while (true)\n    {\n      int amt = reader.read(charBuffer);\n      if (amt == -1)\n        return false;\n      for (int i = 0; i < amt; i++)\n      {\n        if (dealWithCharacter(charBuffer[i]))\n          return true;\n      }\n    }\n  }\n\n",
    "label": 1,
    "rec": "Receive a stream of characters."
  },
  {
    "id": 2877,
    "type": "Summary",
    "comment": "Tells whether the Java version is 6.",
    "code": "  public boolean isJava6() {\n    return \"1.6\".equals(javaSpecVersion);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2878,
    "type": "Summary",
    "comment": "Returns the RedeemData identified in the connected output, for either P2PKH scripts, P2PK or P2SH scripts.",
    "code": "    public RedeemData getConnectedRedeemData(KeyBag keyBag) throws ScriptException {\n        TransactionOutput connectedOutput = getConnectedOutput();\n        checkNotNull(connectedOutput, \"Input is not connected so cannot retrieve key\");\n        Script connectedScript = connectedOutput.getScriptPubKey();\n        if (ScriptPattern.isPayToPubKeyHash(connectedScript)) {\n            byte[] addressBytes = ScriptPattern.extractHashFromPayToPubKeyHash(connectedScript);\n            return RedeemData.of(keyBag.findKeyFromPubKeyHash(addressBytes, Script.ScriptType.P2PKH), connectedScript);\n        } else if (ScriptPattern.isPayToWitnessPubKeyHash(connectedScript)) {\n            byte[] addressBytes = ScriptPattern.extractHashFromPayToWitnessHash(connectedScript);\n            return RedeemData.of(keyBag.findKeyFromPubKeyHash(addressBytes, Script.ScriptType.P2WPKH), connectedScript);\n        } else if (ScriptPattern.isPayToPubKey(connectedScript)) {\n            byte[] pubkeyBytes = ScriptPattern.extractKeyFromPayToPubKey(connectedScript);\n            return RedeemData.of(keyBag.findKeyFromPubKey(pubkeyBytes), connectedScript);\n        } else if (ScriptPattern.isPayToScriptHash(connectedScript)) {\n            byte[] scriptHash = ScriptPattern.extractHashFromPayToScriptHash(connectedScript);\n            return keyBag.findRedeemDataFromScriptHash(scriptHash);\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Could not understand form of connected output script: \" + connectedScript);\n        }\n    }\n",
    "label": 1,
    "rec": "Returns the RedeemData identified in the connected output, for either P2PKH, P2WPKH, P2PK or P2SH scripts."
  },
  {
    "id": 2879,
    "type": "Summary",
    "comment": "Send the byte values.",
    "code": "    private boolean send(byte[] request) {\n        logger.trace(\"send DATA: {}\", dumpData(request));\n\n        try {\n            outputStream.write(request);\n\n            return true;\n\n        } catch (IOException e) {\n            logger.debug(\"Error writing to serial port {}: {}\", port, e.getLocalizedMessage());\n            return false;\n        } catch (NullPointerException e) {\n            logger.debug(\"Error writing to serial port {}: {}\", port, e.getLocalizedMessage());\n            return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2880,
    "type": "Summary",
    "comment": "Returns the root of a function whose derivative is available known to lie between x1 and x2 by Newton-Raphson method.",
    "code": "    public double find(Function func, double x1, double x2) {\n        double a = x1, b = x2, c = x2, d = 0, e = 0, fa = func.apply(a), fb = func.apply(b), fc, p, q, r, s, xm;\n        if ((fa > 0.0 && fb > 0.0) || (fa < 0.0 && fb < 0.0)) {\n            throw new IllegalArgumentException(\"Root must be bracketed.\");\n        }\n\n        fc = fb;\n        for (int iter = 1; iter <= maxIter; iter++) {\n            if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) {\n                c = a;\n                fc = fa;\n                e = d = b - a;\n            }\n\n            if (Math.abs(fc) < Math.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            tol = 2.0 * MathEx.EPSILON * Math.abs(b) + 0.5 * tol;\n            xm = 0.5 * (c - b);\n\n            if (iter % 10 == 0) {\n                logger.info(String.format(\"Brent: the root after %3d iterations: %.5g, error = %.5g\", iter, b, xm));\n            }\n\n            if (Math.abs(xm) <= tol || fb == 0.0) {\n                logger.info(String.format(\"Brent finds the root after %d iterations: %.5g, error = %.5g\", iter, b, xm));\n                return b;\n            }\n\n            if (Math.abs(e) >= tol && Math.abs(fa) > Math.abs(fb)) {\n                s = fb / fa;\n                if (a == c) {\n                    p = 2.0 * xm * s;\n                    q = 1.0 - s;\n                } else {\n                    q = fa / fc;\n                    r = fb / fc;\n                    p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0));\n                    q = (q - 1.0) * (r - 1.0) * (s - 1.0);\n                }\n\n                if (p > 0.0) {\n                    q = -q;\n                }\n\n                p = Math.abs(p);\n                double min1 = 3.0 * xm * q - Math.abs(tol * q);\n                double min2 = Math.abs(e * q);\n                if (2.0 * p < (min1 < min2 ? min1 : min2)) {\n                    e = d;\n                    d = p / q;\n                } else {\n                    d = xm;\n                    e = d;\n                }\n            } else {\n                d = xm;\n                e = d;\n            }\n\n            a = b;\n            fa = fb;\n            if (Math.abs(d) > tol) {\n                b += d;\n            } else {\n                b += Math.copySign(tol, xm);\n            }\n            fb = func.apply(b);\n        }\n\n        logger.error(\"Brent exceeded the maximum number of iterations.\");\n        return b;\n    }\n",
    "label": 1,
    "rec": "Brent's method for root-finding."
  },
  {
    "id": 2881,
    "type": "Summary",
    "comment": "Returns the default group of the file",
    "code": "    public Group getDefaultGroup() {\n        return groups.getDefaultGroup();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2882,
    "type": "Summary",
    "comment": "Returns true immediately if the latch is open.",
    "code": "    public Completion await(long timeout, TimeUnit unit) throws InterruptedException {\n        if (sync.tryAcquireSharedNanos(0, unit.toNanos(timeout)))\n            return new Completion();\n        else\n            return null;\n    }\n\n",
    "label": 1,
    "rec": "Returns  Completion object immediately if the latch is open."
  },
  {
    "id": 2883,
    "type": "Summary",
    "comment": "Returns the registered  PolicyProviderFactory.",
    "code": "    public Collection<PolicyProviderFactory> getProviderFactories() {\n        return this.policyProviderFactories.values();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2884,
    "type": "Summary",
    "comment": "Create a schema instance that accepts a serialized payload and validates it against the topic schema.",
    "code": "    static Schema<byte[]> AUTO_PRODUCE_BYTES(Schema<?> schema) {\n        return DefaultImplementation.newAutoProduceSchema(schema);\n    }\n",
    "label": 1,
    "rec": "Create a schema instance that accepts a serialized payload and validates it against the schema specified."
  },
  {
    "id": 2885,
    "type": "Summary",
    "comment": "Get the cluster info AdminClient is using.",
    "code": "    public Cluster getAdminClientCluster() {\n        return currentCluster;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2886,
    "type": "Summary",
    "comment": "Gets the project's build configurations.",
    "code": "    public Map<String, BuildConfiguration> getBuildConfigurations()\n    {\n        return this.buildConfigurations;\n    }\n\n",
    "label": 1,
    "rec": "Gets the project's build configurations indexed by name."
  },
  {
    "id": 2887,
    "type": "Summary",
    "comment": "Should return fully configured event SPI implementation.",
    "code": "    public EventStorageSpi getEventStorageSpi() {\n        return evtSpi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2888,
    "type": "Summary",
    "comment": "Get the  ContainerRequest instance bound to the current thread.",
    "code": "\tpublic static ExecutionContext getContainerRequest() {\n\t\treturn (ExecutionContext)requestThreadLocal.get();\n\t}\n\n",
    "label": 1,
    "rec": "Get the  ExecutionContext instance bound to the current thread."
  },
  {
    "id": 2889,
    "type": "Summary",
    "comment": "Convenient method to group paths.",
    "code": "    protected IgniteFsPath[] paths(IgniteFsPath... paths) {\n        return paths;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2890,
    "type": "Summary",
    "comment": "Returns the copy-entity mappings",
    "code": "\tpublic Map invertMap() {\n\t\treturn Collections.unmodifiableMap( copyToEntityMap );\n\t}\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable map view of the copy-entity mappings"
  },
  {
    "id": 2891,
    "type": "Summary",
    "comment": "Get the events provider configuration",
    "code": "    public RealmEventsConfigRepresentation getRealmEventsConfig() {\n        auth.init(RealmAuth.Resource.EVENTS).requireView();\n\n        RealmEventsConfigRepresentation config = ModelToRepresentation.toEventsConfigReprensetation(realm);\n        if (config.getEnabledEventTypes() == null || config.getEnabledEventTypes().isEmpty()) {\n            config.setEnabledEventTypes(new LinkedList<String>());\n            for (EventType e : EventType.values()) {\n                if (e.isSaveByDefault()) {\n                    config.getEnabledEventTypes().add(e.name());\n                }\n            }\n        }\n        return config;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2892,
    "type": "Summary",
    "comment": "Transform from valid json string to Collection of  UserEntity.",
    "code": "  public List<UserEntity> transformUserEntityCollection(String userListJsonResponse)\n      throws JsonSyntaxException {\n\n    List<UserEntity> userEntityCollection;\n    try {\n      Type listOfUserEntityType = new TypeToken<List<UserEntity>>() {}.getType();\n      userEntityCollection = this.gson.fromJson(userListJsonResponse, listOfUserEntityType);\n\n      return userEntityCollection;\n    } catch (JsonSyntaxException jsonException) {\n      throw jsonException;\n    }\n  }\n\n",
    "label": 1,
    "rec": "Transform from valid json string to List of  UserEntity."
  },
  {
    "id": 2893,
    "type": "Summary",
    "comment": "Get the input material.",
    "code": "    public MaterialData getInput() {\n        return ingredient;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2894,
    "type": "Summary",
    "comment": "Given a  com.google.api.services.plus.model.Activity.Actor object, return a fully fleshed out  org.apache.streams.pojo.json.Actor object",
    "code": "    private static ActivityObject buildActor(com.google.api.services.plus.model.Activity.Actor gPlusActor) {\n        ActivityObject actor = new ActivityObject();\n\n        actor.setDisplayName(gPlusActor.getDisplayName());\n        actor.setId(formatId(String.valueOf(gPlusActor.getId())));\n        actor.setUrl(gPlusActor.getUrl());\n\n        Image image = new Image();\n        com.google.api.services.plus.model.Activity.Actor.Image googlePlusImage = gPlusActor.getImage();\n\n        if(googlePlusImage != null) {\n            image.setUrl(googlePlusImage.getUrl());\n        }\n        actor.setImage(image);\n\n        return actor;\n    }\n\n",
    "label": 1,
    "rec": "Given a  com.google.api.services.plus.model.Activity.Actor object, return a fully fleshed out  org.apache.streams.pojo.json.ActivityObject actor"
  },
  {
    "id": 2895,
    "type": "Summary",
    "comment": "Dispatch a command by formatting the arguments and then executing it.",
    "code": "    public boolean dispatchCommand(String commandLine, CommandSender sender)\n    {\n        String[] split = commandLine.trim().split(\" \");\n        String commandName = split[0].toLowerCase();\n        Command command = commandMap.get(commandName);\n        if (config.disabledCommands == null || !config.disabledCommands.contains(commandName))\n        {\n            return false;\n        } else if (command != null)\n        {\n            String[] args = Arrays.copyOfRange(split, 1, split.length);\n            try\n            {\n                command.execute(sender, args);\n            } catch (Exception ex)\n            {\n                sender.sendMessage(ChatColor.RED + \"An error occurred while executing this command!\");\n                $().severe(\"----------------------- [Start of command error] -----------------------\");\n                $().log(Level.SEVERE, \"\", ex);\n                $().severe(\"----------------------- [End of command error] -----------------------\");\n            }\n        }\n\n        return command != null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2896,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v22Frames.FRAME_ID_V2_ATTACHED_PICTURE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2897,
    "type": "Summary",
    "comment": "Gets the current node stage",
    "code": "\tpublic ZWaveNodeInitStage getCurrentStage() {\n\t\treturn currentStage;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2898,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_ENCRYPTION;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2899,
    "type": "Summary",
    "comment": "Rebalance a frame for load balancing",
    "code": "  private Frame reBalance(final Frame fr, boolean local) {\n    final int chunks = (int)Math.min( 4 * H2O.NUMCPUS * (local ? 1 : H2O.CLOUD.size()), fr.numRows());\n    if (fr.anyVec().nChunks() > chunks) {\n      Log.info(\"Dataset already contains \" + fr.anyVec().nChunks() + \" chunks. No need to rebalance.\");\n      return fr;\n    }\n    Log.info(\"Starting load balancing into (at least) \" + chunks + \" chunks.\");\n//      return MRUtils.shuffleAndBalance(fr, chunks, seed, local, shuffle_training_data);\n    Key newKey = fr._key != null ? Key.make(fr._key.toString() + \".balanced\") : Key.make();\n    RebalanceDataSet rb = new RebalanceDataSet(fr, newKey, chunks);\n    H2O.submitTask(rb);\n    rb.join();\n    Frame rebalanced = UKV.get(newKey);\n    Log.info(\"Load balancing done.\");\n    return rebalanced;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2900,
    "type": "Summary",
    "comment": "Build up the arguments necessary for a brief history command.",
    "code": "    public MaskedArgumentListBuilder getBriefHistoryArguments(Calendar fromTimestamp, Calendar toTimestamp) {\r\n        return getHistoryArguments(fromTimestamp, toTimestamp, \"brief\");\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns arguments for the \"history /format:brief\" command"
  },
  {
    "id": 2901,
    "type": "Summary",
    "comment": "Looks up the  SecurityManager instance in the backing map without performing any non-null guarantees.",
    "code": "    protected SecurityManager lookupSecurityManager() {\n        String name = getSecurityManagerName();\n        return getObject(name, SecurityManager.class);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2902,
    "type": "Summary",
    "comment": "Returns the channel selector that is used for by the output gate",
    "code": "\tpublic ChannelSelector<T> getChannelSelector() {\n\n\t\treturn this.channelSelector;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the output gate's channel selector."
  },
  {
    "id": 2903,
    "type": "Summary",
    "comment": "Invokes API method using HTTP GET",
    "code": "    public JSONObject invoke(String method, Object... getParameters) throws IOException,\n            ActFmServiceException {\n        return invokeWithApi(null, method, getParameters);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2904,
    "type": "Summary",
    "comment": "Gets the  LayoutlibVersion from  this.",
    "code": "  @Nullable\n  public SdkManager.LayoutlibVersion getLayoutlibVersion() {\n    if (mLayoutlibVersion.getFirst() != LAYOUTLIB_API_NOT_SPECIFIED || mLayoutlibVersion.getSecond() != LAYOUTLIB_REV_NOT_SPECIFIED) {\n      return new SdkManager.LayoutlibVersion(mLayoutlibVersion.getFirst(), mLayoutlibVersion.getSecond());\n    }\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Gets the  com.android.sdklib.SdkManager.LayoutlibVersion from  this."
  },
  {
    "id": 2905,
    "type": "Summary",
    "comment": "Detects a PDF417 Code in an image.",
    "code": "  public DetectorResult detect(Map<DecodeHintType,?> hints) throws NotFoundException {\n    // Fetch the 1 bit matrix once up front.\n    BitMatrix matrix = image.getBlackMatrix();\n\n    // Try to find the vertices assuming the image is upright.\n    int rowStep = 8;\n    ResultPoint[] vertices = findVertices(matrix, rowStep);\n    if (vertices == null) {\n      // Maybe the image is rotated 180 degrees?\n      vertices = findVertices180(matrix, rowStep);\n      if (vertices != null) {\n        correctVertices(matrix, vertices, true);\n      }\n    } else {\n      correctVertices(matrix, vertices, false);\n    }\n\n    if (vertices == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    float moduleWidth = computeModuleWidth(vertices);\n    if (moduleWidth < 1.0f) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    int dimension = computeDimension(vertices[12], vertices[14],\n        vertices[13], vertices[15], moduleWidth);\n    if (dimension < 1) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    int yDimension = Math.max(computeYDimension(vertices[12], vertices[14],\n        vertices[13], vertices[15], moduleWidth), dimension);\n\n    // Deskew and over-sample image.\n    BitMatrix linesMatrix = sampleLines(vertices, dimension, yDimension);\n    BitMatrix linesGrid = new LinesSampler(linesMatrix, dimension).sample();\n\n    //TODO: verify vertex indices.\n    return new DetectorResult(linesGrid, new ResultPoint[]{ \n        vertices[5], vertices[4], vertices[6], vertices[7]});\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2906,
    "type": "Summary",
    "comment": "Returns a set of URLs from a single URL based on the Manifest information.",
    "code": "    public static Collection<URL> forManifest(final URL url) {\n        final Collection<URL> result = new ArrayList<URL>();\n        result.add(url);\n        try {\n            final String part = cleanPath(url);\n            File jarFile = new File(part);\n            JarFile myJar = new JarFile(part);\n            URL validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), part);\n            if (validUrl != null) { result.add(validUrl); }\n            final Manifest manifest = myJar.getManifest();\n            if (manifest != null) {\n                final String classPath = manifest.getMainAttributes().getValue(new Attributes.Name(\"Class-Path\"));\n                if (classPath != null) {\n                    for (String jar : classPath.split(\" \")) {\n                        validUrl = tryToGetValidUrl(jarFile.getPath(), new File(part).getParent(), jar);\n                        if (validUrl != null) { result.add(validUrl); }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            // don't do anything, we're going on the assumption it is a jar, which could be wrong\n        }\n        return distinctUrls(result);\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs from a single URL based on the Manifest information."
  },
  {
    "id": 2907,
    "type": "Summary",
    "comment": "Get statistic value from bucket for provided timestamp.",
    "code": "    public T getWindowValue(long time) {\n        if (time < 0) {\n            return null;\n        }\n        long timeId = time / windowLengthInMs;\n        int idx = (int)(timeId % array.length());\n\n        WindowWrap<T> old = array.get(idx);\n        if (old == null || isWindowDeprecated(old)) {\n            return null;\n        }\n\n        return old.value();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2908,
    "type": "Summary",
    "comment": "Get seal status from Vault",
    "code": "    public VaultStatus getStatus() {\n\n        WebTarget target = baseTarget.path(\"/v1/sys/seal-status\");\n        Response response = null;\n        try {\n            response = target.request()\n                    .accept(\"application/json\")\n                    .header(\"X-Vault-Token\", this.vaultToken)\n                    .get();\n            if (response.getStatus() != 200) {\n                ErrorResponse error = response.readEntity(ErrorResponse.class);\n                throw new VaultException(response.getStatus(), error.getErrors());\n            }\n            return response.readEntity(VaultStatus.class);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get status from Vault"
  },
  {
    "id": 2909,
    "type": "Summary",
    "comment": "Get a field from a class.",
    "code": "\tpublic static Field field(Class<?> declaringClass, String fieldName) {\n\t\treturn Whitebox.getField(declaringClass, fieldName);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2910,
    "type": "Summary",
    "comment": "Returns an injection resolver for this AnnotatedElement",
    "code": "    public static InjectionResolver<?> getInjectionResolver(\n            ServiceLocatorImpl locator, Injectee injectee) throws IllegalStateException {\n        return getInjectionResolver(locator, injectee.getParent(), injectee.getPosition());\n\n    }\n\n",
    "label": 1,
    "rec": "Returns an injection resolver for the injectee"
  },
  {
    "id": 2911,
    "type": "Summary",
    "comment": "Kills the given server.",
    "code": "    public boolean killServer(InstanceSpec instance) throws Exception\n    {\n        for ( TestingZooKeeperServer server : servers )\n        {\n            if ( server.getInstanceSpec().equals(instance) )\n            {\n                server.kill();\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2912,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_RECOMMENDED_BUFFER_SIZE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2913,
    "type": "Summary",
    "comment": "Releases an instance of the given  SslContextProvider.",
    "code": "  public SslContextProvider<K> release(final SslContextProvider<K> value) {\n    checkNotNull(value, \"value\");\n    K key = value.getSource();\n    return releaseInternal(key, value);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2914,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_ORIG_LYRICIST ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2915,
    "type": "Summary",
    "comment": "Return an item from the cache",
    "code": "    public Optional<T> get(final String path) throws Exception {\n        return getAsync(path).get(zkOperationTimeoutSeconds, TimeUnit.SECONDS);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2916,
    "type": "Summary",
    "comment": "Returns the annotation type.",
    "code": "  public String getAnnotations() {\n    return (m_annotations != null ? m_annotations : m_defaultAnnotations).toString();\n  }\n\n",
    "label": 1,
    "rec": "Returns the annotation type for the suite."
  },
  {
    "id": 2917,
    "type": "Summary",
    "comment": "Get maximum batch size for delete and delete operations.",
    "code": "    public int getBatchSize() {\n        return batchSize;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2918,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_POPULARIMETER;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2919,
    "type": "Summary",
    "comment": "Wraps object to respective  Value.",
    "code": "    private static Value wrap(Object obj, int type) throws GridSpiException {\n        switch (type) {\n            case Value.BOOLEAN:\n                return ValueBoolean.get((Boolean)obj);\n            case Value.BYTE:\n                return ValueByte.get((Byte)obj);\n            case Value.SHORT:\n                return ValueShort.get((Short)obj);\n            case Value.INT:\n                return ValueInt.get((Integer)obj);\n            case Value.FLOAT:\n                return ValueFloat.get((Float)obj);\n            case Value.LONG:\n                return ValueLong.get((Long)obj);\n            case Value.DOUBLE:\n                return ValueDouble.get((Double)obj);\n            case Value.UUID:\n                UUID uuid = (UUID)obj;\n                return ValueUuid.get(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits());\n            case Value.DATE:\n                return ValueDate.get((Date)obj);\n            case Value.TIME:\n                return ValueTime.get((Time)obj);\n            case Value.TIMESTAMP:\n                if (obj instanceof java.util.Date && !(obj instanceof Timestamp))\n                    obj = new Timestamp(((java.util.Date) obj).getTime());\n\n                return GridH2Utils.get((Timestamp)obj);\n            case Value.DECIMAL:\n                return ValueDecimal.get((BigDecimal)obj);\n            case Value.STRING:\n                return ValueString.get(obj.toString());\n            case Value.BYTES:\n                return ValueBytes.get((byte[])obj);\n            case Value.JAVA_OBJECT:\n                return ValueJavaObject.getNoCopy(obj, null, null);\n            case Value.ARRAY:\n                Object[] arr = (Object[])obj;\n\n                Value[] valArr = new Value[arr.length];\n\n                for (int i = 0; i < arr.length; i++) {\n                    Object o = arr[i];\n\n                    valArr[i] = o == null ? ValueNull.INSTANCE : wrap(o, DataType.getTypeFromClass(o.getClass()));\n                }\n\n                return ValueArray.get(valArr);\n\n            case Value.GEOMETRY:\n                return ValueGeometry.getFromGeometry(obj);\n        }\n\n        throw new GridSpiException(\"Failed to wrap value[type=\" + type + \", value=\" + obj + \"]\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2920,
    "type": "Summary",
    "comment": "Creates a unique id for a given AssetManager and asset path.",
    "code": "    private static String createAssetUid(final Resources resources, int id, int style) {\n        return resources.getResourcePackageName(id) + \"-\" + id + \"-\" + style;\n    }\n\n",
    "label": 1,
    "rec": "Creates a unique id for a given AssetManager and asset id"
  },
  {
    "id": 2921,
    "type": "Summary",
    "comment": "Should return fully configured discovery SPI implementation.",
    "code": "    public DiscoverySpi getDiscoverySpi() {\n        return discoSpi;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2922,
    "type": "Summary",
    "comment": "Finds where the library may be extracted and loaded among the  Class resources.",
    "code": "    public static URL[] findLibrary(Class cls, ClassProperties properties, String libnameversion, boolean pathsFirst) {\n        String[] s = libnameversion.split(\"@\");\n        String libname = s[0];\n        String version = s.length > 1 ? s[s.length-1] : \"\";\n\n        // If we do not already have the native library file ...\n        String filename = loadedLibraries.get(libnameversion);\n        if (filename != null) {\n            try {\n                return new URL[] { new File(filename).toURI().toURL() };\n            } catch (IOException ex) {\n                return new URL[] { };\n            }\n        }\n\n        String subdir = properties.getProperty(\"platform\") + '/';\n        String prefix = properties.getProperty(\"platform.library.prefix\", \"\") + libname;\n        String suffix = properties.getProperty(\"platform.library.suffix\", \"\");\n        String[] styles = {\n            prefix + suffix + version, // Linux style\n            prefix + version + suffix, // Mac OS X style\n            prefix + suffix            // without version\n        };\n\n        String[] suffixes = properties.get(\"platform.library.suffix\").toArray(new String[0]);\n        if (suffixes.length > 1) {\n            styles = new String[3 * suffixes.length];\n            for (int i = 0; i < suffixes.length; i++) {\n                styles[3 * i    ] = prefix + suffixes[i] + version; // Linux style\n                styles[3 * i + 1] = prefix + version + suffixes[i]; // Mac OS X style\n                styles[3 * i + 2] = prefix + suffixes[i];           // without version\n            }\n        }\n\n        List<String> paths = new ArrayList<String>();\n        paths.addAll(properties.get(\"platform.preloadpath\"));\n        paths.addAll(properties.get(\"platform.linkpath\"));\n        String libpath = System.getProperty(\"java.library.path\", \"\");\n        if (libpath.length() > 0) {\n            paths.addAll(Arrays.asList(libpath.split(File.pathSeparator)));\n        }\n        ArrayList<URL> urls = new ArrayList<URL>(styles.length * (1 + paths.size()));\n        for (int i = 0; cls != null && i < styles.length; i++) {\n            // ... then find it from in our resources ...\n            URL u = cls.getResource(subdir + styles[i]);\n            if (u != null) {\n                urls.add(u);\n            }\n        }\n        // ... and in case of bad resources search the paths last, or first on user request.\n        int k = pathsFirst ? 0 : urls.size();\n        for (int i = 0; paths.size() > 0 && i < styles.length; i++) {\n            for (String path : paths) {\n                File file = new File(path, styles[i]);\n                if (file.exists()) {\n                    try {\n                        urls.add(k++, file.toURI().toURL());\n                    } catch (IOException ex) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            }\n        }\n        return urls.toArray(new URL[urls.size()]);\n    }\n",
    "label": 1,
    "rec": "Finds from where the library may be extracted and loaded among the  Class resources."
  },
  {
    "id": 2923,
    "type": "Summary",
    "comment": "Return the value to use for ZK session timeout",
    "code": "    public int  session()\n    {\n        return multiple(SESSION_MULTIPLE).milliseconds();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2924,
    "type": "Summary",
    "comment": "Returns the sum of mapped elements",
    "code": "        public double sum() {\r\n            return reduce(Ops.doubleAdder(), 0);\r\n        }\r\n\n",
    "label": 1,
    "rec": "Returns the sum of elements"
  },
  {
    "id": 2925,
    "type": "Summary",
    "comment": "Locates a keypair from the wallet given the corresponding address.",
    "code": "    public ECKey findKeyFromAddress(Address address) {\n        final ScriptType scriptType = address.getOutputScriptType();\n        if (scriptType == ScriptType.P2PKH || scriptType == ScriptType.P2WPKH)\n            return findKeyFromPubKeyHash(address.getHash(), scriptType);\n        else\n            return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2926,
    "type": "Summary",
    "comment": "Converts length string into px / user units in the current user coordinate system",
    "code": "    static double fromRelative(SVGLength length, double relative, double offset, double scale, double fontSize) {\n        /*\n            TODO list\n\n            unit  relative to\n            em    font size of the element\n            ex    x-height of the element\u00e2\u0080\u0099s font\n            ch    width of the \"0\" (ZERO, U+0030) glyph in the element\u00e2\u0080\u0099s font\n            rem   font size of the root element\n            vw    1% of viewport\u00e2\u0080\u0099s width\n            vh    1% of viewport\u00e2\u0080\u0099s height\n            vmin  1% of viewport\u00e2\u0080\u0099s smaller dimension\n            vmax  1% of viewport\u00e2\u0080\u0099s larger dimension\n\n            relative-size [ larger | smaller ]\n            absolute-size: [ xx-small | x-small | small | medium | large | x-large | xx-large ]\n\n            https://www.w3.org/TR/css3-values/#relative-lengths\n            https://www.w3.org/TR/css3-values/#absolute-lengths\n            https://drafts.csswg.org/css-cascade-4/#computed-value\n            https://drafts.csswg.org/css-fonts-3/#propdef-font-size\n            https://drafts.csswg.org/css2/fonts.html#propdef-font-size\n        */\n        SVGLengthUnitType unitType = length.unit;\n        double value = length.value;\n        double unit = 1;\n        switch (unitType) {\n            case SVG_LENGTHTYPE_NUMBER:\n            case SVG_LENGTHTYPE_PX:\n                break;\n\n            case SVG_LENGTHTYPE_PERCENTAGE:\n                return value / 100 * relative + offset;\n\n            case SVG_LENGTHTYPE_EMS:\n                unit = fontSize;\n                break;\n            case SVG_LENGTHTYPE_EXS:\n                unit = fontSize / 2;\n                break;\n\n            case SVG_LENGTHTYPE_CM:\n                unit = 35.43307;\n                break;\n            case SVG_LENGTHTYPE_MM:\n                unit = 3.543307;\n                break;\n            case SVG_LENGTHTYPE_IN:\n                unit = 90;\n                break;\n            case SVG_LENGTHTYPE_PT:\n                unit = 1.25;\n                break;\n            case SVG_LENGTHTYPE_PC:\n                unit = 15;\n                break;\n\n            default:\n            case SVG_LENGTHTYPE_UNKNOWN:\n                return value * scale + offset;\n        }\n        return value * unit * scale + offset;\n    }\n",
    "label": 1,
    "rec": "Converts SVGLength into px / user units in the current user coordinate system"
  },
  {
    "id": 2927,
    "type": "Summary",
    "comment": "Return a sorted list of all current nodes participating in the lock",
    "code": "    public Collection<String>   getParticipantNodes() throws Exception\n    {\n        return LockInternals.getParticipantNodes(internals.getClient(), basePath, internals.getLockName(), internals.getDriver());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2928,
    "type": "Summary",
    "comment": "Attempts to persist a  Boolean if this Preference is persistent.",
    "code": "    protected boolean persistBoolean(boolean value) {\n        if (shouldPersist()) {\n            if (value == getPersistedBoolean(!value)) {\n                // It's already there, so the same as persisting\n                return true;\n            }\n\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putBoolean(mKey, value);\n            tryCommit(editor);\n            return true;\n        }\n        return false;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist a boolean to the  android.content.SharedPreferences."
  },
  {
    "id": 2929,
    "type": "Summary",
    "comment": "Return the all the elements in the sorted set at key with a score between min and max (including elements with score equal to min or max).",
    "code": "  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {\n    checkIsInMultiOrPipeline();\n    client.zrangeByScoreWithScores(key, min, max);\n    return getBinaryTupledSet();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2930,
    "type": "Summary",
    "comment": "Based on the weightingParameters and the specified vehicle a Weighting instance can be created.",
    "code": "    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder) {\n        String weighting = hintsMap.getWeighting().toLowerCase();\n\n        if (encoder.supports(GenericWeighting.class)) {\n            DataFlagEncoder dataEncoder = (DataFlagEncoder) encoder;\n            return new GenericWeighting(dataEncoder, dataEncoder.readStringMap(hintsMap));\n        } else if (\"shortest\".equalsIgnoreCase(weighting)) {\n            return new ShortestWeighting(encoder);\n        } else if (\"fastest\".equalsIgnoreCase(weighting) || weighting.isEmpty()) {\n            if (encoder.supports(PriorityWeighting.class))\n                return new PriorityWeighting(encoder, hintsMap);\n            else\n                return new FastestWeighting(encoder, hintsMap);\n        } else if (\"curvature\".equalsIgnoreCase(weighting)) {\n            if (encoder.supports(CurvatureWeighting.class))\n                return new CurvatureWeighting(encoder, hintsMap);\n\n        } else if (\"short_fastest\".equalsIgnoreCase(weighting)) {\n            return new ShortFastestWeighting(encoder, hintsMap);\n        }\n\n        throw new IllegalArgumentException(\"weighting \" + weighting + \" not supported\");\n    }\n",
    "label": 1,
    "rec": "Based on the hintsMap and the specified encoder a Weighting instance can be created."
  },
  {
    "id": 2931,
    "type": "Summary",
    "comment": "Gets cache configuration.",
    "code": "    protected CacheConfiguration[] getCacheConfiguration(String gridName) {\n        CacheConfiguration cacheCfg = defaultCacheConfiguration();\n\n        cacheCfg.setName(\"dataCache\");\n        cacheCfg.setCacheMode(PARTITIONED);\n        cacheCfg.setDistributionMode(PARTITIONED_ONLY);\n        cacheCfg.setWriteSynchronizationMode(FULL_SYNC);\n        cacheCfg.setEvictionPolicy(null);\n        cacheCfg.setAffinityMapper(new IgniteFsGroupDataBlocksKeyMapper(128));\n        cacheCfg.setBackups(0);\n        cacheCfg.setQueryIndexEnabled(false);\n        cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n        CacheConfiguration metaCacheCfg = defaultCacheConfiguration();\n\n        metaCacheCfg.setName(\"metaCache\");\n        metaCacheCfg.setCacheMode(REPLICATED);\n        metaCacheCfg.setWriteSynchronizationMode(FULL_SYNC);\n        metaCacheCfg.setEvictionPolicy(null);\n        metaCacheCfg.setQueryIndexEnabled(false);\n        metaCacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n        return new CacheConfiguration[] {cacheCfg, metaCacheCfg};\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2932,
    "type": "Summary",
    "comment": "Create an new MockitoGenericMetadata from a  Type.",
    "code": "    public static GenericMetadataSupport from(Type type) {\r\n        Checks.checkNotNull(type, \"type\");\r\n        if (type instanceof Class) {\r\n            return new FromClassGenericMetadataSupport((Class<?>) type);\r\n        }\r\n        if (type instanceof ParameterizedType) {\r\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\r\n        }\r\n\r\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Create an new GenericMetadataSupport from a  Type."
  },
  {
    "id": 2933,
    "type": "Summary",
    "comment": "Get list name by list id",
    "code": "    public String getList(String listId) {\n        TodorooCursor<MilkList> cursor = milkListDao.query(Query.select(\n                MilkList.NAME).where(MilkList.ID.eq(listId)));\n        try {\n            if(cursor.getCount() == 0)\n                return null;\n            cursor.moveToFirst();\n            return cursor.get(MilkList.NAME);\n        } finally {\n            cursor.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2934,
    "type": "Summary",
    "comment": "Resolve current method generic return type to a  MockitoGenericMetadata.",
    "code": "    public GenericMetadataSupport resolveGenericReturnType(Method method) {\r\n        Type genericReturnType = method.getGenericReturnType();\r\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\r\n\r\n        if (genericReturnType instanceof Class) {\r\n            return new NotGenericReturnTypeSupport(genericReturnType);\r\n        }\r\n        if (genericReturnType instanceof ParameterizedType) {\r\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\r\n        }\r\n        if (genericReturnType instanceof TypeVariable) {\r\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\r\n        }\r\n\r\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Resolve current method generic return type to a  GenericMetadataSupport."
  },
  {
    "id": 2935,
    "type": "Summary",
    "comment": "Establish TCP connection to remote node and returns client.",
    "code": "    protected GridCommunicationClient createTcpClient(ClusterNode node) throws GridException {\n        Collection<String> rmtAddrs0 = node.attribute(createSpiAttributeName(ATTR_ADDRS));\n        Collection<String> rmtHostNames0 = node.attribute(createSpiAttributeName(ATTR_HOST_NAMES));\n        Integer boundPort = node.attribute(createSpiAttributeName(ATTR_PORT));\n        Collection<InetSocketAddress> extAddrs = node.attribute(createSpiAttributeName(ATTR_EXT_ADDRS));\n\n        boolean isRmtAddrsExist = (!F.isEmpty(rmtAddrs0) && boundPort != null);\n        boolean isExtAddrsExist = !F.isEmpty(extAddrs);\n\n        if (!isRmtAddrsExist && !isExtAddrsExist)\n            throw new GridException(\"Failed to send message to the destination node. Node doesn't have any \" +\n                \"TCP communication addresses or mapped external addresses. Check configuration and make sure \" +\n                \"that you use the same communication SPI on all nodes. Remote node id: \" + node.id());\n\n        List<InetSocketAddress> addrs;\n\n        // Try to connect first on bound addresses.\n        if (isRmtAddrsExist) {\n            addrs = new ArrayList<>(U.toSocketAddresses(rmtAddrs0, rmtHostNames0, boundPort));\n\n            boolean sameHost = U.sameMacs(getSpiContext().localNode(), node);\n\n            Collections.sort(addrs, U.inetAddressesComparator(sameHost));\n        }\n        else\n            addrs = new ArrayList<>();\n\n        // Then on mapped external addresses.\n        if (isExtAddrsExist)\n            addrs.addAll(extAddrs);\n\n        boolean conn = false;\n        GridCommunicationClient client = null;\n        GridException errs = null;\n\n        int connectAttempts = 1;\n\n        for (InetSocketAddress addr : addrs) {\n            long connTimeout0 = connTimeout;\n\n            int attempt = 1;\n\n            while (!conn) { // Reconnection on handshake timeout.\n                try {\n                    SocketChannel ch = SocketChannel.open();\n\n                    ch.configureBlocking(true);\n\n                    ch.socket().setTcpNoDelay(tcpNoDelay);\n                    ch.socket().setKeepAlive(true);\n\n                    if (sockRcvBuf > 0)\n                        ch.socket().setReceiveBufferSize(sockRcvBuf);\n\n                    if (sockSndBuf > 0)\n                        ch.socket().setSendBufferSize(sockSndBuf);\n\n                    GridNioRecoveryDescriptor recoveryDesc = recoveryDescriptor(node);\n\n                    if (!recoveryDesc.reserve()) {\n                        U.closeQuiet(ch);\n\n                        return null;\n                    }\n\n                    long rcvCnt = -1;\n\n                    try {\n                        ch.socket().connect(addr, (int)connTimeout);\n\n                        rcvCnt = safeHandshake(ch, recoveryDesc, node.id(), connTimeout0);\n\n                        if (rcvCnt == -1)\n                            return null;\n                    }\n                    finally {\n                        if (recoveryDesc != null && rcvCnt == -1)\n                            recoveryDesc.release();\n                    }\n\n                    UUID diffVerNodeId = null;\n\n                    IgniteProductVersion locVer = getSpiContext().localNode().version();\n                    IgniteProductVersion rmtVer = node.version();\n\n                    if (!locVer.equals(rmtVer))\n                        diffVerNodeId = node.id();\n\n                    try {\n                        Map<Integer, Object> meta = new HashMap<>();\n\n                        meta.put(NODE_ID_META, node.id());\n                        meta.put(GridNioServer.DIFF_VER_NODE_ID_META_KEY, diffVerNodeId);\n\n                        if (recoveryDesc != null) {\n                            recoveryDesc.onHandshake(rcvCnt);\n\n                            meta.put(-1, recoveryDesc);\n                        }\n\n                        GridNioSession ses = nioSrvr.createSession(ch, meta).get();\n\n                        client = new GridTcpNioCommunicationClient(ses, log);\n\n                        conn = true;\n                    }\n                    finally {\n                        if (!conn) {\n                            if (recoveryDesc != null)\n                                recoveryDesc.release();\n                        }\n                    }\n                }\n                catch (HandshakeTimeoutException e) {\n                    if (client != null) {\n                        client.forceClose();\n\n                        client = null;\n                    }\n\n                    if (log.isDebugEnabled())\n                        log.debug(\n                            \"Handshake timedout (will retry with increased timeout) [timeout=\" + connTimeout0 +\n                                \", addr=\" + addr + \", err=\" + e + ']');\n\n                    if (attempt == reconCnt || connTimeout0 > maxConnTimeout) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Handshake timedout (will stop attempts to perform the handshake) \" +\n                                \"[timeout=\" + connTimeout0 + \", maxConnTimeout=\" + maxConnTimeout +\n                                \", attempt=\" + attempt + \", reconCnt=\" + reconCnt +\n                                \", err=\" + e.getMessage() + \", addr=\" + addr + ']');\n\n                        if (errs == null)\n                            errs = new GridException(\"Failed to connect to node (is node still alive?). \" +\n                                \"Make sure that each GridComputeTask and GridCacheTransaction has a timeout set \" +\n                                \"in order to prevent parties from waiting forever in case of network issues \" +\n                                \"[nodeId=\" + node.id() + \", addrs=\" + addrs + ']');\n\n                        errs.addSuppressed(new GridException(\"Failed to connect to address: \" + addr, e));\n\n                        break;\n                    }\n                    else {\n                        attempt++;\n\n                        connTimeout0 *= 2;\n\n                        // Continue loop.\n                    }\n                }\n                catch (Exception e) {\n                    if (client != null) {\n                        client.forceClose();\n\n                        client = null;\n                    }\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Client creation failed [addr=\" + addr + \", err=\" + e + ']');\n\n                    if (X.hasCause(e, SocketTimeoutException.class))\n                        LT.warn(log, null, \"Connect timed out (consider increasing 'connTimeout' \" +\n                            \"configuration property) [addr=\" + addr + ']');\n\n                    if (errs == null)\n                        errs = new GridException(\"Failed to connect to node (is node still alive?). \" +\n                            \"Make sure that each GridComputeTask and GridCacheTransaction has a timeout set \" +\n                            \"in order to prevent parties from waiting forever in case of network issues \" +\n                            \"[nodeId=\" + node.id() + \", addrs=\" + addrs + ']');\n\n                    errs.addSuppressed(new GridException(\"Failed to connect to address: \" + addr, e));\n\n                    // Reconnect for the second time, if connection is not established.\n                    if (connectAttempts < 2 &&\n                        (e instanceof ConnectException || X.hasCause(e, ConnectException.class))) {\n                        connectAttempts++;\n\n                        continue;\n                    }\n\n                    break;\n                }\n            }\n\n            if (conn)\n                break;\n        }\n\n        if (client == null) {\n            assert errs != null;\n\n            if (X.hasCause(errs, ConnectException.class))\n                LT.warn(log, null, \"Failed to connect to a remote node \" +\n                    \"(make sure that destination node is alive and \" +\n                    \"operating system firewall is disabled on local and remote hosts) \" +\n                    \"[addrs=\" + addrs + ']');\n\n            throw errs;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Created client: \" + client);\n\n        return client;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2936,
    "type": "Summary",
    "comment": "Build a safe version of the URI.",
    "code": "  public String buildSafe() {\n    if (key == null) {\n      throw new IllegalStateException(\"Cannot build safe URL without a key.\");\n    }\n\n    // Assemble config and an MD5 of the target image.\n    StringBuilder config = assembleConfig().append(md5(target));\n    final byte[] encrypted = aes128Encrypt(config, normalizeString(key, 16));\n\n    // URL-safe Base64 encode.\n    final String encoded = Utilities.base64Encode(encrypted);\n\n    return new StringBuilder(host).append(\"/\").append(encoded).append(\"/\").append(target).toString();\n  }\n\n",
    "label": 1,
    "rec": "Build a safe version of the URL."
  },
  {
    "id": 2937,
    "type": "Summary",
    "comment": "Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2).",
    "code": "    public double length() {\n        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2938,
    "type": "Summary",
    "comment": "Wraps the original HttpServletRequest in a  KiHttpServletRequest, which is required for supporting",
    "code": "    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {\n        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());\n    }\n\n",
    "label": 1,
    "rec": "Wraps the original HttpServletRequest in a  ShiroHttpServletRequest, which is required for supporting"
  },
  {
    "id": 2939,
    "type": "Summary",
    "comment": "Returns time in milliseconds for a time in seconds.",
    "code": "    public static long toMillis(int time) {\n        return time * 1000L;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2940,
    "type": "Summary",
    "comment": "Fetch the result of a given action from a given result vector ",
    "code": "    public static WSSecurityEngineResult fetchActionResult(List resultList, int action) {\n\n        for (int i = 0; i < resultList.size(); i++) {\n            //\n            // Check the result of every action whether it matches the given action\n            //\n            WSSecurityEngineResult result = \n                (WSSecurityEngineResult) resultList.get(i);\n            int resultAction = \n                ((java.lang.Integer)result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n            if (resultAction == action) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Fetch the result of a given action from a given result list"
  },
  {
    "id": 2941,
    "type": "Summary",
    "comment": "Removes one node from the toVisit set and returns that node.",
    "code": "      private Node removeOneNodeFromToVisitSet() {\n        final Iterator<Node> iterator = this.toVisit.iterator();\n        final Node node = iterator.next();\n        iterator.remove();\n        return node;\n      }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2942,
    "type": "Summary",
    "comment": "Returns the wrapped OMElement.",
    "code": "    public Element getValue() {\n        return element;\n    }\n\n",
    "label": 1,
    "rec": "Returns the wrapped Element."
  },
  {
    "id": 2943,
    "type": "Summary",
    "comment": "Return orientation of line relative to north.",
    "code": "    public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )\n    {\n        return Math.atan2(lat2 - lat1, lon2 - lon1);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2944,
    "type": "Summary",
    "comment": "Return an Avro representation of the bytes in this  ByteString.",
    "code": "  @Override\n  public String toString()\n  {\n    final int NUM_BYTES = 4;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"ByteString(length=\");\n    sb.append(length());\n    if (_bytes.length > 0)\n    {\n      sb.append(\",bytes=\");\n      for (int i = 0; i < Math.min(_bytes.length, NUM_BYTES); i++)\n      {\n        sb.append(String.format(\"%02x\", (int) _bytes[i] & 0xff));\n      }\n      if (_bytes.length > NUM_BYTES * 2)\n      {\n        sb.append(\"...\");\n      }\n      for (int i = Math.max(NUM_BYTES, _bytes.length - NUM_BYTES); i < _bytes.length; i++)\n      {\n        sb.append(String.format(\"%02x\", (int)_bytes[i] & 0xff));\n      }\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }\n\n",
    "label": 1,
    "rec": "Return a summary of the contents of this  ByteString."
  },
  {
    "id": 2945,
    "type": "Summary",
    "comment": "Adds write future at the front of the queue without acquiring back pressure semaphore.",
    "code": "    int offerSystemFuture(GridNioFuture<?> writeFut) {\n        writeFut.messageThread(true);\n\n        boolean res = queue.offerFirst(writeFut);\n\n        assert res : \"Future was not added to queue\";\n\n        return queue.sizex();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2946,
    "type": "Summary",
    "comment": "Note that this method does not treat empty value as an absent value.",
    "code": "    private static String systemOrEnv(String name, String dflt) {\n        String res = System.getProperty(name);\n\n        if (res == null)\n            res = System.getenv(name);\n\n        return res != null ? res : dflt;\n    }\n",
    "label": 1,
    "rec": "Get system property or environment variable with the given name."
  },
  {
    "id": 2947,
    "type": "Summary",
    "comment": "This method can be overriden in order to create a foreground",
    "code": "    public Notification createDefaultNotification() {\n        Notification notification = new Notification();\n        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH && android.os.Build.VERSION.SDK_INT <= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {\n            notification.icon = getApplicationInfo().icon;\n        } else {\n            notification.icon = 0;\n        }\n        notification.tickerText = null;\n        notification.when = System.currentTimeMillis();\n        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            notification.priority = Notification.PRIORITY_MIN;\n        }\n        return notification;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2948,
    "type": "Summary",
    "comment": "Converts this this string to uppercase, using the rules of the user's default locale.",
    "code": "    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n",
    "label": 1,
    "rec": "Converts the characters in this string to uppercase, using the default"
  },
  {
    "id": 2949,
    "type": "Summary",
    "comment": "update implementation.",
    "code": "  public int update(final String updateClause, final Object... params) throws SQLException {\n    try {\n      return this.queryRunner.update(updateClause, params);\n    } catch (final SQLException ex) {\n      // todo kunkun-tang: Retry logics should be implemented here.\n      logger.error(\"update failed\", ex);\n      throw ex;\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2950,
    "type": "Summary",
    "comment": "Unswaps an entry.",
    "code": "    @Nullable protected CacheObject unswap(boolean needVal, boolean checkExpire)\n        throws IgniteCheckedException, GridCacheEntryRemovedException {\n        if (!cctx.isSwapOrOffheapEnabled())\n            return null;\n\n        assert !detached() : this;\n\n        boolean obsolete = false;\n        boolean deferred = false;\n        GridCacheVersion ver0 = null;\n\n        synchronized (this) {\n            checkObsolete();\n\n            if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {\n                GridCacheSwapEntry e;\n\n                if (cctx.offheapTiered()) {\n                    e = cctx.swap().readOffheapPointer(this);\n\n                    if (log.isTraceEnabled()) {\n                        if (e != null) {\n                            log.trace(\"Read offheap pointer [key=\" + key +\n                                \", entry=\" + System.identityHashCode(this) +\n                                \", ptr=\" + e.offheapPointer() +\n                                ']');\n                        }\n                        else {\n                            log.trace(\"Read offheap pointer [key=\" + key +\n                                \", entry=\" + System.identityHashCode(this) +\n                                \", val=\" + null +\n                                ']');\n                        }\n                    }\n\n                    if (e != null) {\n                        if (e.offheapPointer() > 0) {\n                            offHeapPointer(e.offheapPointer());\n\n                            flags |= IS_OFFHEAP_PTR_MASK;\n\n                            if (needVal) {\n                                CacheObject val = cctx.fromOffheap(e.offheapPointer(), false);\n\n                                e.value(val);\n                            }\n                        }\n                        else // Read from swap.\n                            offHeapPointer(0);\n                    }\n                }\n                else {\n                    e = cctx.swap().readAndRemove(this);\n\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"unswap readAndRemove [key=\" + key +\n                            \", entry=\" + System.identityHashCode(this) +\n                            \", found=\" + (e != null) +\n                            ']');\n                    }\n                }\n\n                flags |= IS_UNSWAPPED_MASK;\n\n                // If there is a value.\n                if (e != null) {\n                    long delta = checkExpire ? (e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis()) : 0;\n\n                    CacheObject val = e.value();\n\n                    val = cctx.kernalContext().cacheObjects().prepareForCache(val, cctx);\n\n                    // Set unswapped value.\n                    update(val, e.expireTime(), e.ttl(), e.version(), false);\n\n                    // Must update valPtr again since update() will reset it.\n                    if (cctx.offheapTiered() && e.offheapPointer() > 0)\n                        offHeapPointer(e.offheapPointer());\n\n                    if (delta >= 0)\n                        return val;\n                    else {\n                        CacheObject expiredVal = rawGetOrUnmarshal(false);\n\n                        if (onExpired(expiredVal, null)) {\n                            if (cctx.deferredDelete()) {\n                                deferred = true;\n                                ver0 = ver;\n                            }\n                            else\n                                obsolete = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (obsolete) {\n            onMarkedObsolete();\n\n            cctx.cache().removeEntry(this);\n        }\n\n        if (deferred) {\n            assert ver0 != null;\n\n            cctx.onDeferredDelete(this, ver0);\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2951,
    "type": "Summary",
    "comment": "Find next broke  LoadReport in round-robin fashion.",
    "code": "    LoadManagerReport nextBroker() throws PulsarServerException {\n        List<LoadManagerReport> availableBrokers = localZkCache.getAvailableBrokers();\n\n        if (availableBrokers.isEmpty()) {\n            throw new PulsarServerException(\"No active broker is available\");\n        } else {\n            int brokersCount = availableBrokers.size();\n            int nextIdx = signSafeMod(counter.getAndIncrement(), brokersCount);\n            return availableBrokers.get(nextIdx);\n        }\n    }\n",
    "label": 1,
    "rec": "Find next broker  LoadManagerReport in round-robin fashion."
  },
  {
    "id": 2952,
    "type": "Summary",
    "comment": "Update account information.",
    "code": "    public Response processAccountUpdate(final MultivaluedMap<String, String> formData) {\n        if (auth == null) {\n            return login(null);\n        }\n\n        auth.require(AccountRoles.MANAGE_ACCOUNT);\n\n        String action = formData.getFirst(\"submitAction\");\n        if (action != null && action.equals(\"Cancel\")) {\n            setReferrerOnPage();\n            return account.createResponse(AccountPages.ACCOUNT);\n        }\n\n        csrfCheck(formData);\n\n        UserModel user = auth.getUser();\n\n        event.event(EventType.UPDATE_PROFILE).client(auth.getClient()).user(auth.getUser());\n\n        List<FormMessage> errors = Validation.validateUpdateProfileForm(realm, formData);\n        if (errors != null && !errors.isEmpty()) {\n            setReferrerOnPage();\n            return account.setErrors(Status.OK, errors).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);\n        }\n\n        try {\n            updateUsername(formData.getFirst(\"username\"), user, session);\n            updateEmail(formData.getFirst(\"email\"), user, session, event);\n\n            user.setFirstName(formData.getFirst(\"firstName\"));\n            user.setLastName(formData.getFirst(\"lastName\"));\n\n            AttributeFormDataProcessor.process(formData, realm, user);\n\n            event.success();\n\n            setReferrerOnPage();\n            return account.setSuccess(Messages.ACCOUNT_UPDATED).createResponse(AccountPages.ACCOUNT);\n        } catch (ReadOnlyException roe) {\n            setReferrerOnPage();\n            return account.setError(Response.Status.BAD_REQUEST, Messages.READ_ONLY_USER).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);\n        } catch (ModelDuplicateException mde) {\n            setReferrerOnPage();\n            return account.setError(Response.Status.CONFLICT, mde.getMessage()).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2953,
    "type": "Summary",
    "comment": "Returns a Filter that accepts all elements that are  Object#equals equal to the specified object.",
    "code": "    public static <E> Predicates.EqualsPredicate<E> equal(E object) {\r\n        return new Predicates.EqualsPredicate<E>(object);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns a Predicate that accepts all elements that are  Object#equals equal to the specified object."
  },
  {
    "id": 2954,
    "type": "Summary",
    "comment": "Returns the entity that damaged the player.",
    "code": "    public Entity getDamager()\n    {\n        return damager;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2955,
    "type": "Summary",
    "comment": "Parse request.",
    "code": "    public CallbackRequest handle(HttpServletRequest req) throws LineBotCallbackException, IOException {\n        // validate signature\n        final String signature = req.getHeader(\"X-Line-Signature\");\n        final byte[] json = ByteStreams.toByteArray(req.getInputStream());\n        try {\n            return parser.handle(signature, json);\n        } catch (WebhookParseException e) {\n            throw new LineBotCallbackException(e.getMessage());\n        }\n    }\n",
    "label": 1,
    "rec": "Parses a request."
  },
  {
    "id": 2956,
    "type": "Summary",
    "comment": "There should only be one fetch request in flight at any give time.",
    "code": "    Observable<Parsed> fetchAndPersist(@NonNull final BarCode barCode) {\n        try {\n            return inFlightRequests.get(barCode, new Callable<Observable<Parsed>>() {\n                @NonNull\n                @Override\n                public Observable<Parsed> call() {\n                    return response(barCode);\n                }\n            });\n        } catch (ExecutionException e) {\n            return Observable.empty();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2957,
    "type": "Summary",
    "comment": "Returns a DefaultProcessorURI for testing purposes.",
    "code": "    protected CrawlURI defaultURI() throws Exception {\n        UURI uuri = UURIFactory.getInstance(\"http://www.archive.org/start/\");\n        return new CrawlURI(uuri, null, null, LinkContext.NAVLINK_MISC);\n    }\n\n",
    "label": 1,
    "rec": "Returns a CrawlURI for testing purposes."
  },
  {
    "id": 2958,
    "type": "Summary",
    "comment": "Initializes configurations.",
    "code": "    private static Iterable<IgniteConfiguration> getConfigurations(String springCfgPath)\n        throws GridException {\n        File path = GridTestUtils.resolveGridGainPath(springCfgPath);\n\n        if (path == null)\n            throw new GridException(\"Spring XML configuration file path is invalid: \" + new File(springCfgPath) +\n                \". Note that this path should be either absolute path or a relative path to GRIDGAIN_HOME.\");\n\n        if (!path.isFile())\n            throw new GridException(\"Provided file path is not a file: \" + path);\n\n        // Add no-op logger to remove no-appender warning.\n        Appender app = new NullAppender();\n\n        Logger.getRootLogger().addAppender(app);\n\n        ApplicationContext springCtx;\n\n        try {\n            springCtx = new FileSystemXmlApplicationContext(path.toURI().toURL().toString());\n        }\n        catch (BeansException | MalformedURLException e) {\n            throw new GridException(\"Failed to instantiate Spring XML application context: \" + e.getMessage(), e);\n        }\n\n        Map cfgMap;\n\n        try {\n            // Note: Spring is not generics-friendly.\n            cfgMap = springCtx.getBeansOfType(IgniteConfiguration.class);\n        }\n        catch (BeansException e) {\n            throw new GridException(\"Failed to instantiate bean [type=\" + IgniteConfiguration.class + \", err=\" +\n                e.getMessage() + ']', e);\n        }\n\n        if (cfgMap == null)\n            throw new GridException(\"Failed to find a single grid factory configuration in: \" + path);\n\n        // Remove previously added no-op logger.\n        Logger.getRootLogger().removeAppender(app);\n\n        if (cfgMap.isEmpty())\n            throw new GridException(\"Can't find grid factory configuration in: \" + path);\n\n        Collection<IgniteConfiguration> res = new ArrayList<>();\n\n        for (IgniteConfiguration cfg : (Collection<IgniteConfiguration>)cfgMap.values()) {\n            res.add(cfg);\n\n            cfg.setGridName(GRID_NAME_PREF + gridCnt.incrementAndGet());\n        }\n\n        return res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2959,
    "type": "Summary",
    "comment": "Create intent to view Gist",
    "code": "    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        imageGetter = new HttpImageGetter(this);\n        setContentView(layout.gist_view);\n\n        gistIdText.setText(getString(string.gist) + \" \" + gistId);\n\n        loadGist(false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2960,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v22Frames.FRAME_ID_V2_ENCRYPTED_FRAME;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2961,
    "type": "Summary",
    "comment": "Passthrough JavaBeans property that will get the underyling rememberMe cookie's name.",
    "code": "    public String getCookieName() {\n        return getCookieAttribute().getName();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2962,
    "type": "Summary",
    "comment": "Creates a time interval graphic representation with the indicated fill, border and background colors (or null to use default colors).",
    "code": "    public BufferedImage createTimeIntervalImage(double start, double end, int width, int height, Color fill, Color border, Color background) {\n        if (start > end) {\n            throw new IllegalArgumentException(\"start should be less or equal than end\");\n        }\n        return createTimeIntervalImage(new double[]{start}, new double[]{end}, width, height, fill, border, background);\n    }\n",
    "label": 1,
    "rec": "Creates a time interval graphic representation with the indicated fill and border colors (or null to use default colors)."
  },
  {
    "id": 2963,
    "type": "Summary",
    "comment": "Resolves a command class for this node.",
    "code": "\tpublic ZWaveCommandClass resolveCommandClass(CommandClass commandClass, int endpointId)\n\t{\n\t\tif (commandClass == null)\n\t\t\treturn null;\n\t\t\n\t\tif (endpointId == 0)\n\t\t\treturn getCommandClass(commandClass);\n\t\t\n\t\tZWaveMultiInstanceCommandClass multiInstanceCommandClass = (ZWaveMultiInstanceCommandClass) supportedCommandClasses.get(CommandClass.MULTI_INSTANCE);\n\t\tif (multiInstanceCommandClass == null) {\n\t\t\treturn null;\n\t\t\t\n\t\t} else if (multiInstanceCommandClass.getVersion() == 2) {\n\t\t\tZWaveEndpoint endpoint = multiInstanceCommandClass.getEndpoint(endpointId);\n\t\t\t\n\t\t\tif (endpoint != null) { \n\t\t\t\tZWaveCommandClass result = endpoint.getCommandClass(commandClass);\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t} else if (multiInstanceCommandClass.getVersion() == 1) {\n\t\t\tZWaveCommandClass result = getCommandClass(commandClass);\n\t\t\tif (endpointId <= result.getInstances())\n\t\t\t\treturn result;\n\t\t} else {\n\t\t\tlogger.warn(\"NODE {}: Unsupported multi instance command version: {}.\", nodeId, multiInstanceCommandClass.getVersion());\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2964,
    "type": "Summary",
    "comment": "Obtains the cross-reference adapter for the specified editing domain's resource set, if necessary creating it and attaching it.",
    "code": "\tpublic static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {\n\t\tif ( resourceSet == null ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tCrossReferenceAdapter result = getExistingCrossReferenceAdapter(\n\t\t\tresourceSet);\n\t\t\n\t\tif (result == null) {\n\t\t\tresult = new CrossReferenceAdapter();\n\t\t\tresourceSet.eAdapters().add(result);\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\n",
    "label": 1,
    "rec": "Obtains the cross-reference adapter for the specified resource set, if necessary creating it and attaching it."
  },
  {
    "id": 2965,
    "type": "Summary",
    "comment": "Checks whether the requests remote address is external or internal.",
    "code": "\tprivate boolean isExternalRequest(HttpServletRequest request) {\n\t\tlong startTime = System.currentTimeMillis();\n\t\t\n\t\tString remoteAddr = request.getRemoteAddr();\n\t\t\n\t\ttry {\n\t\t\tInetAddress remoteIp = InetAddress.getByName(remoteAddr);\n\t\t\tif (remoteIp.isLoopbackAddress()) {\n\t\t\t\t// by definition: the loopback address is NOT external!\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tboolean isExternal = !subnetUtils.isInRange(remoteAddr);\n\t\t\tlogger.trace(\"http request is originated by '{}' which is identified as '{}'\",\n\t\t\t\t\tremoteAddr, isExternal ? \"external\" : \"internal\");\n\t\t\t\n\t\t\treturn isExternal;\n\t\t} catch (UnknownHostException uhe) {\n\t\t\tlogger.error(uhe.getLocalizedMessage());\n\t\t}\n\t\tfinally {\n\t\t\tlogger.debug(\"checking ip is in range took {}ms\", System.currentTimeMillis() - startTime);\n\t\t}\n\t\t\n\t\t// if there are any doubts we assume this request to be external!\n\t\treturn true; \n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2966,
    "type": "Summary",
    "comment": "Check whether the AES key can decrypt the first encrypted key in the wallet.",
    "code": "    public boolean checkAESKey(KeyParameter aesKey) {\n        keyChainGroupLock.lock();\n        try {\n            return keyChainGroup.checkAESKey(aesKey);\n        } finally {\n            keyChainGroupLock.unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2967,
    "type": "Summary",
    "comment": "Returns the name of the class corresponding to this type.",
    "code": "    public String getClassName() {\n        switch (sort) {\n        case VOID:\n            return \"void\";\n        case BOOLEAN:\n            return \"boolean\";\n        case CHAR:\n            return \"char\";\n        case BYTE:\n            return \"byte\";\n        case SHORT:\n            return \"short\";\n        case INT:\n            return \"int\";\n        case FLOAT:\n            return \"float\";\n        case LONG:\n            return \"long\";\n        case DOUBLE:\n            return \"double\";\n        case ARRAY:\n            StringBuilder sb = new StringBuilder(getElementType().getClassName());\n            for (int i = getDimensions(); i > 0; --i) {\n                sb.append(\"[]\");\n            }\n            return sb.toString();\n        case OBJECT:\n            return new String(buf, off, len).replace('/', '.');\n        default:\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Returns the binary name of the class corresponding to this type."
  },
  {
    "id": 2968,
    "type": "Summary",
    "comment": "Calculates the framing rect which the UI should draw to show the user where to place the barcode.",
    "code": "  public Rect getFramingRect() {\n    if (framingRect == null) {\n      if (camera == null) {\n        return null;\n      }\n      int width = cameraResolution.x * 3 / 4;\n      if (width < MIN_FRAME_WIDTH) {\n        width = MIN_FRAME_WIDTH;\n      } else if (width > MAX_FRAME_WIDTH) {\n        width = MAX_FRAME_WIDTH;\n      }\n      int height = cameraResolution.y * 3 / 4;\n      if (height < MIN_FRAME_HEIGHT) {\n        height = MIN_FRAME_HEIGHT;\n      } else if (height > MAX_FRAME_HEIGHT) {\n        height = MAX_FRAME_HEIGHT;\n      }\n      int leftOffset = (cameraResolution.x - width) / 2;\n      int topOffset = (cameraResolution.y - height) / 2;\n      framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\n      Log.v(TAG, \"Calculated framing rect: \" + framingRect);\n    }\n    return framingRect;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2969,
    "type": "Summary",
    "comment": "Return ahe  org.apache.tez.runtime.api.TezRootInputInitializerContext for this specific instance of the Initializer.",
    "code": "  public final InputInitializerContext getContext() {\n    return this.initializerContext;\n  }\n\n",
    "label": 1,
    "rec": "Return ahe  org.apache.tez.runtime.api.InputInitializerContext for this specific instance of the Initializer."
  },
  {
    "id": 2970,
    "type": "Summary",
    "comment": "Retrieves the value of the designated column in the current row of this ResultSet object and will convert to the requested Java data type.",
    "code": "    protected Object getColumnValue(ResultSet rs, int colIdx, Class<?> type) throws SQLException {\n        if (type == int.class)\n            return rs.getInt(colIdx);\n\n        if (type == long.class)\n            return rs.getLong(colIdx);\n\n        if (type == double.class)\n            return rs.getDouble(colIdx);\n\n        if (type == boolean.class)\n            return rs.getBoolean(colIdx);\n\n        if (type == byte.class)\n            return rs.getByte(colIdx);\n\n        if (type == short.class)\n            return rs.getShort(colIdx);\n\n        if (type == float.class)\n            return rs.getFloat(colIdx);\n\n        if (type == Integer.class || type == Long.class || type == Double.class ||\n            type == Byte.class || type == Short.class ||  type == Float.class) {\n            Object val = rs.getObject(colIdx);\n\n            if (val != null) {\n                Number num = (Number)val;\n\n                if (type == Integer.class)\n                    return num.intValue();\n                else if (type == Long.class)\n                    return num.longValue();\n                else if (type == Double.class)\n                    return num.doubleValue();\n                else if (type == Byte.class)\n                    return num.byteValue();\n                else if (type == Short.class)\n                    return num.shortValue();\n                else if (type == Float.class)\n                    return num.floatValue();\n            }\n            else\n                return EMPTY_COLUMN_VALUE;\n        }\n\n        Object val = rs.getObject(colIdx);\n\n        if (type == UUID.class && val != null) {\n            if (val instanceof UUID)\n                return val;\n\n            if (val instanceof byte[]) {\n                ByteBuffer bb = ByteBuffer.wrap((byte[])val);\n\n                long most = bb.getLong();\n                long least = bb.getLong();\n\n                return new UUID(most, least);\n            }\n\n            if (val instanceof String)\n                return UUID.fromString((String)val);\n        }\n\n        return val;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2971,
    "type": "Summary",
    "comment": "Returns the column after which the new column should be added.",
    "code": "    public String getPreviousColumn()\r\n    {\r\n        return _previousColumnName;\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns the name of the column after which the new column should be added."
  },
  {
    "id": 2972,
    "type": "Summary",
    "comment": "Gets affinity nodes for specified partition.",
    "code": "    public List<ClusterNode> nodes(int part, long topVer) {\n        // Resolve cached affinity nodes.\n        return cachedAffinity(topVer).get(part);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2973,
    "type": "Summary",
    "comment": "Read alias data and populate a Hashtable.",
    "code": "\tprotected static Map<String, Object> initAliases(InputStream in) {\n\t\tMap<String, Object> aliases = new HashMap<String, Object>(37);\n\t\ttry {\n\t\t\tBufferedReader br;\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(in, \"UTF8\")); //$NON-NLS-1$\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tString line = br.readLine();\n\t\t\t\tif (line == null) /* EOF */{\n\t\t\t\t\tbreak; /* done */\n\t\t\t\t}\n\t\t\t\tTokenizer tokenizer = new Tokenizer(line);\n\t\t\t\tString master = tokenizer.getString(\"# \\t\"); //$NON-NLS-1$\n\t\t\t\tif (master != null) {\n\t\t\t\t\taliases.put(master.toLowerCase(), master);\n\t\t\t\t\tparseloop: while (true) {\n\t\t\t\t\t\tString alias = tokenizer.getString(\"# \\t\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (alias == null) {\n\t\t\t\t\t\t\tbreak parseloop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString lowerCaseAlias = alias.toLowerCase();\n\t\t\t\t\t\tObject storedMaster = aliases.get(lowerCaseAlias);\n\t\t\t\t\t\tif (storedMaster == null) {\n\t\t\t\t\t\t\taliases.put(lowerCaseAlias, master);\n\t\t\t\t\t\t} else if (storedMaster instanceof String) {\n\t\t\t\t\t\t\tList<String> newMaster = new ArrayList<String>();\n\t\t\t\t\t\t\tnewMaster.add((String) storedMaster);\n\t\t\t\t\t\t\tnewMaster.add(master);\n\t\t\t\t\t\t\taliases.put(lowerCaseAlias, newMaster);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tList<String> newMaster = ((List<String>) storedMaster);\n\t\t\t\t\t\t\tnewMaster.add(master);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tif (Debug.DEBUG_GENERAL) {\n\t\t\t\tDebug.printStackTrace(e);\n\t\t\t}\n\t\t}\n\t\treturn aliases;\n\t}\n\n",
    "label": 1,
    "rec": "Read alias data and populate a Map."
  },
  {
    "id": 2974,
    "type": "Summary",
    "comment": "Method returns callable for execution  #addAndGet(long) operation in async and sync mode.",
    "code": "    private Callable<Long> internalAddAndGet(final long l) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteTxEx tx = CU.txStartInternal(ctx, atomicView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicLongValue val = atomicView.get(key);\n\n                    if (val == null)\n                        throw new IgniteCheckedException(\"Failed to find atomic long with given name: \" + name);\n\n                    long retVal = val.get() + l;\n\n                    val.set(retVal);\n\n                    atomicView.put(key, val);\n\n                    tx.commit();\n\n                    return retVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to add and get: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2975,
    "type": "Summary",
    "comment": "Creates a copy of the given object by an in-memory serialization and subsequent deserialization.",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static IOReadableWritable createCopy(IOReadableWritable original) {\n\n\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tfinal DataOutputStream dos = new DataOutputStream(baos);\n\n\t\ttry {\n\t\t\toriginal.write(dos);\n\t\t} catch (IOException ioe) {\n\t\t\tfail(ioe.getMessage());\n\t\t}\n\n\t\tfinal String className = original.getClass().getName();\n\t\tif (className == null) {\n\t\t\tfail(\"Class name is null\");\n\t\t}\n\n\t\tClass<? extends IOReadableWritable> clazz = null;\n\n\t\ttry {\n\t\t\tclazz = (Class<? extends IOReadableWritable>) Class.forName(className);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (clazz == null) {\n\t\t\tfail(\"Cannot find class with name \" + className);\n\t\t}\n\n\t\tIOReadableWritable copy = null;\n\t\ttry {\n\t\t\tcopy = clazz.newInstance();\n\t\t} catch (InstantiationException e) {\n\t\t\tfail(e.getMessage());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (copy == null) {\n\t\t\tfail(\"Copy of object of type \" + className + \" is null\");\n\t\t}\n\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\t\tfinal DataInputStream dis = new DataInputStream(bais);\n\n\t\ttry {\n\t\t\tcopy.read(dis);\n\t\t} catch (IOException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\treturn copy;\n\t}\n\n",
    "label": 1,
    "rec": "Creates a copy of the given  IOReadableWritable object by an in-memory serialization and subsequent deserialization."
  },
  {
    "id": 2976,
    "type": "Summary",
    "comment": "Retrieve the absolute path of the current version",
    "code": "    public String getCurrentDirPath() {\n        return storeDir.getAbsolutePath() + File.separator + \"version-\"\n               + Long.toString(getCurrentVersionId());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2977,
    "type": "Summary",
    "comment": "Builds a ConfigurationModel instance based on annotation  Configure found in the annotated object instance",
    "code": "\tprivate ConfigurationDTO buildConfigurationModel()\n\t\t\tthrows AnnotationRequired {\n\n\t\tif (!finder.isAnnotationPresent(Configure.class)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tConfigurationDTO configuration = new ConfigurationDTO();\n\t\tconfiguration.setConfigurationClass(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"using\").getName());\n\t\tconfiguration.setKeywords(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"keywords\").getName());\n\t\tconfiguration.setFailureStrategy(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"failureStrategy\").getName());\n\t\tconfiguration.setPendingStepStrategy(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"pendingStepStrategy\").getName());\n\t\tconfiguration.setParanamer(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"paranamer\").getName());\n\t\tconfiguration.setStoryControls(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"storyControls\").getName());\n\t\tconfiguration.setStepCollector(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"stepCollector\").getName());\n\t\tconfiguration.setStepdocReporter(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"stepdocReporter\").getName());\n\t\tconfiguration.setStepFinder(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"stepFinder\").getName());\n\t\tconfiguration.setStepMonitor(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"stepMonitor\").getName());\n\t\tconfiguration.setStepPatternParser(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"stepPatternParser\").getName());\n\t\tconfiguration.setStoryLoader(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"storyLoader\").getName());\n\t\tconfiguration.setStoryParser(finder.getAnnotatedValue(Configure.class,\n\t\t\t\tClass.class, \"storyParser\").getName());\n\t\tconfiguration.setStoryPathResolver(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"storyPathResolver\").getName());\n\t\tconfiguration\n\t\t\t\t.setStoryReporterBuilder(finder.getAnnotatedValue(\n\t\t\t\t\t\tConfigure.class, Class.class, \"storyReporterBuilder\")\n\t\t\t\t\t\t.getName());\n\t\tconfiguration.setViewGenerator(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"viewGenerator\").getName());\n\t\tconfiguration.setParameterConverters(parameterConverters());\n\t\tconfiguration.setParameterControls(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"parameterControls\").getName());\n\t\tconfiguration.setPathCalculator(finder.getAnnotatedValue(\n\t\t\t\tConfigure.class, Class.class, \"pathCalculator\").getName());\n\t\treturn configuration;\n\t}\n\n",
    "label": 1,
    "rec": "Builds a ConfigurationDTO instance based on annotation  Configure found in the annotated object instance"
  },
  {
    "id": 2978,
    "type": "Summary",
    "comment": "Creates a SecurityContext instance for the user represented by the given method argument.",
    "code": "    protected SecurityContext createSecurityContext(AuthenticationToken token, Account account) {\n        assertPrincipals(account);\n\n        //get any existing session that may exist - we don't want to lose it:\n        SecurityContext securityContext = ThreadContext.getSecurityContext();\n        Session session = null;\n        if (securityContext != null) {\n            session = securityContext.getSession(false);\n        }\n\n        InetAddress authcSourceIP = null;\n        if (token instanceof InetAuthenticationToken) {\n            authcSourceIP = ((InetAuthenticationToken) token).getInetAddress();\n        }\n        if (authcSourceIP == null) {\n            //try the thread local:\n            authcSourceIP = ThreadContext.getInetAddress();\n        }\n\n        return createSecurityContext(account.getPrincipal(), session, true, authcSourceIP);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2979,
    "type": "Summary",
    "comment": "Method that returns an instance of  ExplorerSettings from its.",
    "code": "    public static FileManagerSettings fromId(String id) {\n        FileManagerSettings[] values = values();\n        int cc = values.length;\n        for (int i = 0; i < cc; i++) {\n            if (values[i].mId == id) {\n                return values[i];\n            }\n        }\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Method that returns an instance of  FileManagerSettings from its."
  },
  {
    "id": 2980,
    "type": "Summary",
    "comment": "From a file this will read the ZuulFilter source code, compile it, and add it to the list of current filters a true response means that it was successful.",
    "code": "    public boolean putFilter(File file) throws Exception\n    {\n        try {\n            String sName = file.getAbsolutePath();\n            if (filterClassLastModified.get(sName) != null && (file.lastModified() != filterClassLastModified.get(sName))) {\n                LOG.debug(\"reloading filter \" + sName);\n                filterRegistry.remove(sName);\n            }\n            ZuulFilter filter = filterRegistry.get(sName);\n            if (filter == null) {\n                Class clazz = compiler.compile(file);\n                if (!Modifier.isAbstract(clazz.getModifiers())) {\n                    filter = FILTER_FACTORY.newInstance(clazz);\n                    putFilter(sName, filter, file.lastModified());\n                    return true;\n                }\n            }\n        }\n        catch (Exception e) {\n            LOG.error(\"Error loading filter! Continuing. file=\" + String.valueOf(file), e);\n            return false;\n        }\n\n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2981,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_RELATIVE_VOLUME_ADJUSTMENT2;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 2982,
    "type": "Summary",
    "comment": "Gets type (e.g.",
    "code": "    public String getType() {\n        return valType;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2983,
    "type": "Summary",
    "comment": "Trigger a job for an application, if allowed",
    "code": "    private Application triggerAllowParallel(JobType jobType, Application application, boolean first, String cause, Lock lock) {\n        if (jobType == null) { // previous was last job\n            return application;\n        }\n\n        // Note: We could make a more fine-grained and more correct determination about whether to block \n        //       by instead basing the decision on what is currently deployed in the zone. However,\n        //       this leads to some additional corner cases, and the possibility of blocking an application\n        //       fix to a version upgrade, so not doing it now\n        if (jobType.isProduction() && application.deployingBlocked(clock.instant())) {\n            return application;\n        }\n        \n        if (application.deploymentJobs().isRunning(jobType, jobTimeoutLimit())) {\n            return application;\n        }\n\n        // TODO: Remove when we can determine why this occurs\n        if (jobType != JobType.component && ! application.deploying().isPresent()) {\n            log.warning(String.format(\"Want to trigger %s for %s with reason %s, but this application is not \" +\n                                              \"currently deploying a change\",\n                                      jobType, application, cause));\n            return application;\n        }\n\n        if  ( ! deploysTo(application, jobType)) {\n            return application;\n        }\n\n        // Note that this allows a new change to catch up and prevent an older one from continuing\n        if ( ! application.deploymentJobs().isDeployableTo(jobType.environment(), application.deploying())) {\n            log.warning(String.format(\"Want to trigger %s for %s with reason %s, but change is untested\", jobType,\n                                      application, cause));\n            return application;\n        }\n\n        // Ignore applications that are not associated with a project\n        if ( ! application.deploymentJobs().projectId().isPresent()) {\n            return application;\n        }\n\n        log.info(String.format(\"Triggering %s for %s, %s: %s\", jobType, application,\n                               application.deploying().map(d -> \"deploying \" + d).orElse(\"restarted deployment\"),\n                               cause));\n        buildSystem.addJob(application.id(), jobType, first);\n\n        return application.withJobTriggering(jobType, application.deploying(), clock.instant(), controller);\n    }\n\n",
    "label": 1,
    "rec": "Trigger a job for an application"
  },
  {
    "id": 2984,
    "type": "Summary",
    "comment": "Try to parse the given str snippet in an object of the type associated to this AttributeType.",
    "code": "    public Object parse(String str) {\n        switch (this) {\n            case BYTE:\n                return new Byte(removeDecimalDigitsFromString(str));\n            case SHORT:\n                return new Short(removeDecimalDigitsFromString(str));\n            case INT:\n                return new Integer(removeDecimalDigitsFromString(str));\n            case LONG:\n                return new Long(removeDecimalDigitsFromString(str));\n            case FLOAT:\n                return new Float(str);\n            case DOUBLE:\n                return new Double(str);\n            case BOOLEAN:\n                return new Boolean(str);\n            case CHAR:\n                return new Character(str.charAt(0));\n            case BIGINTEGER:\n                return new BigInteger(removeDecimalDigitsFromString(str));\n            case BIGDECIMAL:\n                return new BigDecimal(str);\n            case DYNAMIC_BYTE:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_SHORT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_INT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_LONG:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_FLOAT:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_DOUBLE:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BOOLEAN:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_CHAR:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_STRING:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BIGINTEGER:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case DYNAMIC_BIGDECIMAL:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case TIME_INTERVAL:\n                throw new UnsupportedOperationException(\"Not supported.\");\n            case LIST_BYTE:\n                return new ByteList(removeDecimalDigitsFromString(str));\n            case LIST_SHORT:\n                return new ShortList(removeDecimalDigitsFromString(str));\n            case LIST_INTEGER:\n                return new IntegerList(removeDecimalDigitsFromString(str));\n            case LIST_LONG:\n                return new LongList(removeDecimalDigitsFromString(str));\n            case LIST_FLOAT:\n                return new FloatList(str);\n            case LIST_DOUBLE:\n                return new DoubleList(str);\n            case LIST_BOOLEAN:\n                return new BooleanList(str);\n            case LIST_CHARACTER:\n                return new CharacterList(str);\n            case LIST_STRING:\n                return new StringList(str);\n            case LIST_BIGINTEGER:\n                return new BigIntegerList(removeDecimalDigitsFromString(str));\n            case LIST_BIGDECIMAL:\n                return new BigDecimalList(str);\n        }\n        return str;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2985,
    "type": "Summary",
    "comment": "Returns the list of initial ServiceReference objects that will be tracked by this ServiceTracker object.",
    "code": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString className, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(className, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(className, filterString);\n\t\t}\n\t}\n\n",
    "label": 1,
    "rec": "Returns the list of initial ServiceReferences that will be tracked by this ServiceTracker."
  },
  {
    "id": 2986,
    "type": "Summary",
    "comment": "Initiates a login attempt with the provided credentials in the http header.",
    "code": "    protected boolean executeLogin(ServletRequest request, ServletResponse response) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to authenticate Subject based on Http BASIC Authentication request...\");\n        }\n\n        HttpServletRequest httpRequest = toHttp(request);\n        String authorizationHeader = httpRequest.getHeader(AUTHORIZATION_HEADER);\n\n        if (authorizationHeader != null && authorizationHeader.length() > 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Executing login with headers [\" + authorizationHeader + \"]\");\n            }\n\n            String[] authTokens = authorizationHeader.split(\" \");\n\n            if (authTokens[0].trim().equalsIgnoreCase(HttpServletRequest.BASIC_AUTH)) {\n                String encodedCredentials = authTokens[1];\n\n                String decodedCredentials = Base64.decodeToString(encodedCredentials);\n\n                String[] credentials = decodedCredentials.split(\":\");\n\n                if (credentials != null && credentials.length > 1) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Processing login request [\" + credentials[0] + \"]\");\n                    }\n                    Subject subject = getSubject(request, response);\n                    UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(credentials[0], credentials[1]);\n                    try {\n                        subject.login(usernamePasswordToken);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Successfully logged in user [\" + credentials[0] + \"]\");\n                        }\n                        return true;\n                    } catch (AuthenticationException ae) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Unable to log in subject [\" + credentials[0] + \"]\", ae);\n                        }\n                    }\n                }\n            }\n        }\n\n        //always default to sending the challenge.  If we've made it to this point in the code, that\n        //means the authentication attempt either never occured, or wasn't successful:\n        return sendChallenge(request, response);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2987,
    "type": "Summary",
    "comment": "Returns the entity type for relation.",
    "code": "\tprivate String getType(String propertyName, String explicitTargetEntity, ElementKind expectedElementKind) {\n\t\tfor ( Element elem : element.getEnclosedElements() ) {\n\t\t\tif ( !expectedElementKind.equals( elem.getKind() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeMirror mirror;\n\t\t\tString name = elem.getSimpleName().toString();\n\t\t\tif ( ElementKind.METHOD.equals( elem.getKind() ) ) {\n\t\t\t\tname = StringUtil.getPropertyName( name );\n\t\t\t\tmirror = ( ( ExecutableElement ) elem ).getReturnType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmirror = elem.asType();\n\t\t\t}\n\n\t\t\tif ( name == null || !name.equals( propertyName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( explicitTargetEntity != null ) {\n\t\t\t\t// TODO should there be a check of the target entity class and if it is loadable?\n\t\t\t\treturn explicitTargetEntity;\n\t\t\t}\n\n\t\t\tswitch ( mirror.getKind() ) {\n\t\t\t\tcase INT: {\n\t\t\t\t\treturn \"java.lang.Integer\";\n\t\t\t\t}\n\t\t\t\tcase LONG: {\n\t\t\t\t\treturn \"java.lang.Long\";\n\t\t\t\t}\n\t\t\t\tcase BOOLEAN: {\n\t\t\t\t\treturn \"java.lang.Boolean\";\n\t\t\t\t}\n\t\t\t\tcase BYTE: {\n\t\t\t\t\treturn \"java.lang.Byte\";\n\t\t\t\t}\n\t\t\t\tcase SHORT: {\n\t\t\t\t\treturn \"java.lang.Short\";\n\t\t\t\t}\n\t\t\t\tcase CHAR: {\n\t\t\t\t\treturn \"java.lang.Char\";\n\t\t\t\t}\n\t\t\t\tcase FLOAT: {\n\t\t\t\t\treturn \"java.lang.Float\";\n\t\t\t\t}\n\t\t\t\tcase DOUBLE: {\n\t\t\t\t\treturn \"java.lang.Double\";\n\t\t\t\t}\n\t\t\t\tcase DECLARED: {\n\t\t\t\t\treturn mirror.toString();\n\t\t\t\t}\n\t\t\t\tcase TYPEVAR: {\n\t\t\t\t\treturn mirror.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcontext.logMessage(\n\t\t\t\tDiagnostic.Kind.WARNING,\n\t\t\t\t\"Unable to determine type for property \" + propertyName + \" of class \" + getQualifiedName()\n\t\t\t\t\t\t+ \" using assess type \" + accessTypeInfo.getDefaultAccessType()\n\t\t);\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the entity type for a property."
  },
  {
    "id": 2988,
    "type": "Summary",
    "comment": "Test if the specified key exists.",
    "code": "    public Boolean exists(final byte[] key) {\n        checkIsInMulti();\n        client.exists(key);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2989,
    "type": "Summary",
    "comment": "Check whether a given field or local variable is known to be null, either because it is definitely null, or because is has been tested against null.",
    "code": "public boolean canOnlyBeNull(LocalVariableBinding local) {\n\treturn isDefinitelyNull(local) || isProtectedNull(local);\n}\n\n",
    "label": 1,
    "rec": "Check whether a given local variable is known to be null, either because it is definitely null, or because is has been tested against null."
  },
  {
    "id": 2990,
    "type": "Summary",
    "comment": "Predict the class of an instance.",
    "code": "    public int predict(int[] x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob;\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    logprob = Math.log(priori[i]);\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += x[j] * logcondprob[i][j];\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    logprob = Math.log(priori[i]);\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob += logcondprob[i][j];\n                        } else {\n                            logprob += Math.log(1.0 - Math.exp(logcondprob[i][j]));\n                        }\n                    }\n                    break;\n\n                case CNB:\n                case WCNB:\n                case TWCNB:\n                    logprob = 0.0;\n                    for (int j = 0; j < p; j++) {\n                        if (x[j] > 0) {\n                            logprob -= x[j] * logcondprob[i][j];\n                        }\n                    }\n                    break;\n\n                default:\n                    // we should never reach here\n                    throw new IllegalStateException(\"Unknown model: \" + model);\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        MathEx.softmax(posteriori);\n        return MathEx.whichMax(posteriori);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2991,
    "type": "Summary",
    "comment": "Creates a copy of the given  IOReadableWritable object by an in-memory serialization and subsequent deserialization.",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T createCopy(final T original) {\n\n\t\tfinal Kryo kryo = new Kryo();\n\t\tfinal byte[] buf = new byte[8192];\n\t\tfinal Output output = new Output(buf);\n\t\tkryo.writeObject(output, original);\n\t\toutput.flush();\n\t\tfinal Input input = new Input(buf);\n\t\treturn (T) kryo.readObject(input, original.getClass());\n\t}\n\n",
    "label": 1,
    "rec": "Creates a copy of the given object by an in-memory serialization and subsequent deserialization."
  },
  {
    "id": 2992,
    "type": "Summary",
    "comment": "Starts new grid with given name.",
    "code": "    protected Ignite startGrid(String gridName) throws Exception {\n        return startGrid(gridName, (GridSpringResourceContext)null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2993,
    "type": "Summary",
    "comment": "In the absence of a proper Cluster.clone() operation, this hack safely clones a Cluster object via serde to/from XML.",
    "code": "    public static Cluster cloneCluster(Cluster cluster) {\n        // Could add a better .clone() implementation that clones the derived\n        // data structures. The constructor invoked by this clone implementation\n        // can be slow for large numbers of partitions. Probably faster to copy\n        // all the maps and stuff.\n        return new Cluster(cluster.getName(),\n                           new ArrayList<Node>(cluster.getNodes()),\n                           new ArrayList<Zone>(cluster.getZones()));\n        /*-\n         * Historic \"clone\" code being kept in case this, for some reason, was the \"right\" way to be doing this.\n        ClusterMapper mapper = new ClusterMapper();\n        return mapper.readCluster(new StringReader(mapper.writeCluster(cluster)));\n         */\n    }\n",
    "label": 1,
    "rec": "Clones the cluster by constructing a new one with same name, partition layout, and nodes."
  },
  {
    "id": 2994,
    "type": "Summary",
    "comment": "Returns the current zoom value, something between 0 and 1.",
    "code": "    public float getZoom() {\n        return mCameraController.getZoomValue();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2995,
    "type": "Summary",
    "comment": "Generate a random name.",
    "code": "  public static String randMatrixName() {\n    return randString(Constants.RANDOM, 5);\n  }\n\n",
    "label": 1,
    "rec": "Generate a random matrix name."
  },
  {
    "id": 2996,
    "type": "Summary",
    "comment": "Update the top-level information of this realm.",
    "code": "    public Response updateRealm(final RealmRepresentation rep) {\n        auth.requireManage();\n\n        logger.debug(\"updating realm: \" + realm.getName());\n        try {\n            RepresentationToModel.updateRealm(rep, realm);\n            if (rep.isRealmCacheEnabled() != null && session.realms() instanceof CacheRealmProvider) {\n                CacheRealmProvider cacheRealmProvider = (CacheRealmProvider)session.realms();\n                cacheRealmProvider.setEnabled(rep.isRealmCacheEnabled());\n            }\n            if (rep.isUserCacheEnabled() != null && session.userStorage() instanceof CacheUserProvider) {\n                CacheUserProvider cache = (CacheUserProvider)session.userStorage();\n                cache.setEnabled(rep.isUserCacheEnabled());\n            }\n\n            // Refresh periodic sync tasks for configured federationProviders\n            List<UserFederationProviderModel> federationProviders = realm.getUserFederationProviders();\n            UsersSyncManager usersSyncManager = new UsersSyncManager();\n            for (final UserFederationProviderModel fedProvider : federationProviders) {\n                usersSyncManager.refreshPeriodicSyncForProvider(session.getKeycloakSessionFactory(), session.getProvider(TimerProvider.class), fedProvider, realm.getId());\n            }\n\n            return Response.noContent().build();\n        } catch (PatternSyntaxException e) {\n            return Flows.errors().exists(\"Specified regex pattern(s) is invalid.\");\n        } catch (ModelDuplicateException e) {\n            return Flows.errors().exists(\"Realm \" + rep.getRealm() + \" already exists.\");\n        }  catch (Exception e) {\n            return Flows.errors().exists(\"Failed to update \" + rep.getRealm() + \" Realm.\");\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2997,
    "type": "Summary",
    "comment": "ZooKeeperChildrenCache implementing automatic re-loading on update use this method by passing in a different",
    "code": "    public Set<String> getChildren(final String path) throws KeeperException, InterruptedException {\n        try {\n            return getChildrenAsync(path, this).join();\n        } catch (CompletionException e) {\n            if (e.getCause() instanceof KeeperException) {\n                throw (KeeperException)e.getCause();\n            } else {\n                throw e;\n            }\n        }\n    }\n",
    "label": 1,
    "rec": "Simple ZooKeeperChildrenCache use this method to invalidate cache entry on watch event w/o automatic re-loading"
  },
  {
    "id": 2998,
    "type": "Summary",
    "comment": "Deduces version information purely from QR Code dimensions.",
    "code": "  public static Version getProvisionalVersionForDimension(int dimension) throws FormatException {\n    if (dimension % 4 != 1) {\n      throw FormatException.getFormatInstance();\n    }\n    try {\n      return getVersionForNumber((dimension - 17) / 4);\n    } catch (IllegalArgumentException ignored) {\n      throw FormatException.getFormatInstance();\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 2999,
    "type": "Summary",
    "comment": "Attempts to persist a float to the  android.content.SharedPreferences.",
    "code": "    protected boolean persistFloat(float value) {\n        if (!shouldPersist()) {\n            return false;\n        }\n\n        if (value == getPersistedFloat(Float.NaN)) {\n            // It's already there, so the same as persisting\n            return true;\n        }\n\n        PreferenceDataStore dataStore = getPreferenceDataStore();\n        if (dataStore != null) {\n            dataStore.putFloat(mKey, value);\n        } else {\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putFloat(mKey, value);\n            tryCommit(editor);\n        }\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist a  Float if this Preference is persistent."
  },
  {
    "id": 3000,
    "type": "Summary",
    "comment": "Find unique elements of vector.",
    "code": "    public static int[] unique(int[] x) {\n        return Arrays.stream(x).distinct().toArray();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3001,
    "type": "Summary",
    "comment": "Deserializes a H2MetricValueDomain from a byte array",
    "code": "\tpublic static H2TimeSeries deserialize(byte[] arr) throws IOException, ClassNotFoundException {\n\t\tByteArrayInputStream bais = new ByteArrayInputStream(arr);\n\t\tObjectInputStream ois = new ObjectInputStream(bais);\n\t\treturn (H2TimeSeries) ois.readObject();\n\t}\n\n",
    "label": 1,
    "rec": "Deserializes a H2TimeSeries from a byte array"
  },
  {
    "id": 3002,
    "type": "Summary",
    "comment": "Creates a long indexer to access efficiently the data of a pointer.",
    "code": "    public static LongIndexer create(final LongPointer pointer, long[] sizes, long[] strides, boolean direct) {\n        if (direct) {\n            return Raw.getInstance() != null ? new LongRawIndexer(pointer, sizes, strides)\n                                             : new LongBufferIndexer(pointer.asBuffer(), sizes, strides);\n        } else {\n            final long position = pointer.position();\n            long[] array = new long[(int)Math.min(pointer.limit() - position, Integer.MAX_VALUE)];\n            pointer.get(array);\n            return new LongArrayIndexer(array, sizes, strides) {\n                @Override public void release() {\n                    pointer.position(position).put(array);\n                    super.release();\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3003,
    "type": "Summary",
    "comment": "Prints the summary state of this AllocationPointerOperations",
    "code": "\tpublic static final String print(final long address[]) {\n\t\tif(address==null || address.length==0) throw new IllegalArgumentException(\"Address array was null or zero length\");\n\t\tfinal byte dim = getDimension(address[0]);\n\t\tStringBuilder b = new StringBuilder(String.format(\"AllocationPointer >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[0]), getCapacity(address[0]), getEndOffset(address[0])));\n\t\tif(dim>1) {\n\t\t\tb.append(String.format(\"\\n\\tAllocation Sizes >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[1]), getCapacity(address[1]), getEndOffset(address[1])));\n\t\t\tif(dim>2) b.append(String.format(\"\\n\\tAllocation Alignment Overheads >> [size: %s, capacity: %s, byteSize: %s]\", getSize(address[2]), getCapacity(address[2]), getEndOffset(address[2])));\n\t\t}\n\t\treturn b.toString();\n\t}\n\n",
    "label": 1,
    "rec": "Prints the summary state of an AllocationPointer"
  },
  {
    "id": 3004,
    "type": "Summary",
    "comment": "Get updates for this tagData",
    "code": "    public TodorooCursor<Update> getUpdates(TagData tagData) {\n        return updateDao.query(Query.select(Update.PROPERTIES).where(\n                Update.TAGS.like(\"%\" + tagData.getValue(Task.REMOTE_ID) + \",%\")).\n                orderBy(Order.desc(Update.CREATION_DATE)));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3005,
    "type": "Summary",
    "comment": "Checks for builtin functions and does Action 'f'.",
    "code": "\tprotected Expression buildForBuiltInFunction(ParserRuleContext ctx, String functionName, ArrayList<ParameterExpression> paramExpressions) {\n\t\t// In global namespace, so it can be a builtin function\n\t\t// Double verification: verify passed function name is a (non-parameterized) built-in function.\n\t\ttry {\n\t\t\tif (functions.contains(functionName)) {\n\t\t\t\t// It is a user function definition (which takes precedence if name same as built-in)\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tExpression lsf = handleLanguageSpecificFunction(ctx, functionName, paramExpressions);\n\t\t\tif (lsf != null) {\n\t\t\t\tsetFileLineColumn(lsf, ctx);\n\t\t\t\treturn lsf;\n\t\t\t}\n\n\t\t\tBuiltinFunctionExpression bife = BuiltinFunctionExpression.getBuiltinFunctionExpression(ctx, functionName, paramExpressions, currentFile);\n\t\t\tif (bife != null) {\n\t\t\t\t// It is a builtin function\n\t\t\t\treturn bife;\n\t\t\t}\n\n\t\t\tParameterizedBuiltinFunctionExpression pbife = ParameterizedBuiltinFunctionExpression\n\t\t\t\t\t.getParamBuiltinFunctionExpression(ctx, functionName, paramExpressions, currentFile);\n\t\t\tif (pbife != null){\n\t\t\t\t// It is a parameterized builtin function\n\t\t\t\treturn pbife;\n\t\t\t}\n\n\t\t\t// built-in read, rand ...\n\t\t\tDataExpression dbife = DataExpression.getDataExpression(ctx, functionName, paramExpressions, currentFile, errorListener);\n\t\t\tif (dbife != null){\n\t\t\t\treturn dbife;\n\t\t\t}\n\t\t} \n\t\tcatch(Exception e) {\n\t\t\tnotifyErrorListeners(\"unable to process builtin function expression \" + functionName  + \":\" + e.getMessage(), ctx.start);\n\t\t}\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Creates a builtin function expression."
  },
  {
    "id": 3006,
    "type": "Summary",
    "comment": "Returns the message processor for the specified message class",
    "code": "\tpublic static ZWaveCommandProcessor getMessageDispatcher(SerialMessage.SerialMessageClass serialMessage) {\n\t\tif(messageMap == null) {\n\t\t\tmessageMap = new HashMap<SerialMessage.SerialMessageClass, Class<? extends ZWaveCommandProcessor>>();\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AddNodeToNetwork, AddNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationCommandHandler, ApplicationCommandMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationUpdate, ApplicationUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignReturnRoute, AssignReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignSucReturnRoute, AssignSucReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.DeleteReturnRoute, DeleteReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.EnableSuc, EnableSucMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetRoutingInfo, GetRoutingInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetVersion, GetVersionMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetSucNodeId, GetSucNodeIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetControllerCapabilities, GetControllerCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IdentifyNode, IdentifyNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.MemoryGetId, MemoryGetIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveFailedNodeID, RemoveFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IsFailedNodeID, IsFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveNodeFromNetwork, RemoveNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeInfo, RequestNodeInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeNeighborUpdate, RequestNodeNeighborUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SendData, SendDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialApiGetCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetInitData, SerialApiGetInitDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiSetTimeouts, SerialApiSetTimeoutsMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiSoftReset, SerialApiSoftResetMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SetSucNodeID, SetSucNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SetDefault, ControllerSetDefaultMessageClass.class);\n\t\t}\n\n\t\tConstructor<? extends ZWaveCommandProcessor> constructor;\n\t\ttry {\n\t\t\tif(messageMap.get(serialMessage) == null) {\n\t\t\t\tlogger.warn(\"SerialMessage class {} is not implemented!\", serialMessage.getLabel());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconstructor = messageMap.get(serialMessage).getConstructor();\n\t\t\treturn constructor.newInstance();\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Command processor error\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3007,
    "type": "Summary",
    "comment": "Creates an  FileDataSourceContract contract for the specified resource file in the temporary folder for arbitrary key/value pairs coming from the given input contract.",
    "code": "\tprivate <K extends Key, V extends Value> DataSourceContract<K, V> createInput(\n\t\t\tClass<? extends InputFormat<K, V>> inputFormat, String resource) {\n\t\tfinal DataSourceContract<K, V> read = new DataSourceContract<K, V>(inputFormat, getResourcePath(resource),\n\t\t\t\"Input\");\n\t\treturn read;\n\t}\n\n",
    "label": 1,
    "rec": "Creates an  DataSourceContract contract for the specified resource file in the temporary folder for arbitrary key/value pairs coming from the given input contract."
  },
  {
    "id": 3008,
    "type": "Summary",
    "comment": "Blocks until at least 1 byte is read.",
    "code": "    public int read(byte[] buf, int off, int len, long timeout) throws IgniteCheckedException,\n        GridIpcSharedMemoryOperationTimedoutException{\n        assert buf != null;\n        assert len > 0;\n        assert buf.length >= off + len;\n\n        assert isReader;\n\n        lock.readLock().lock();\n\n        try {\n            if (closed.get())\n                throw new IgniteCheckedException(\"Shared memory segment has been closed: \" + this);\n\n            return (int) IpcSharedMemoryUtils.readSharedMemory(shmemPtr, buf, off, len, timeout);\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3009,
    "type": "Summary",
    "comment": "Get RowsSupportFragment if it's bound to BrowseSupportFragment or null if either BrowseSupportFragment has not been created yet or a different fragment is bound to it.",
    "code": "    public RowsSupportFragment getRowsSupportFragment() {\n        return mRowsSupportFragment;\n    }\n\n",
    "label": 1,
    "rec": "Get currently bound RowsSupportFragment or null if BrowseSupportFragment has not been created yet."
  },
  {
    "id": 3010,
    "type": "Summary",
    "comment": "Creates setup task based on job information.",
    "code": "    @Nullable private Collection<GridHadoopTaskInfo> setupTask(GridHadoopJobId jobId) {\n        if (activeJobs.containsKey(jobId))\n            return null;\n        else {\n            initState(jobId);\n\n            return Collections.singleton(new GridHadoopTaskInfo(SETUP, jobId, 0, 0, null));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3011,
    "type": "Summary",
    "comment": "Determines if the virtual is an object parse virtual.",
    "code": "    public static boolean isObject(String type) {\n        char c = type.charAt(0);\n\n        return c == 'L' || c == '[';\n    }\n\n",
    "label": 1,
    "rec": "Determines if the type can be represented by an  Object."
  },
  {
    "id": 3012,
    "type": "Summary",
    "comment": "Performs the authentication attempt by interacting with the single configured realm, which is significantly simpler than performing multi-realm logic.",
    "code": "    protected Account doSingleRealmAuthentication( Realm realm, AuthenticationToken token ) {\n        if ( !realm.supports( token.getClass() ) ) {\n            String msg = \"Single configured realm [\" + realm + \"] does not support authentication tokens of type [\" +\n                token.getClass().getName() + \"].  Please ensure that the appropriate Realm implementation is \" +\n                \"configured correctly or that the realm accepts AuthenticationTokens of this type.\";\n            throw new UnsupportedTokenException( msg );\n        }\n        Account account = realm.getAccount( token );\n        if ( account == null ) {\n            String msg = \"Single configured realm [\" + realm + \"] was unable to find account data for the \" +\n                \"submitted AuthenticationToken [\" + token + \"].\";\n            throw new UnknownAccountException( msg );\n        }\n        return account;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3013,
    "type": "Summary",
    "comment": "Get the  ContentDeliveryUnitConfigMap list for the supplied selector string.",
    "code": "    public List<ContentHandlerConfigMap> getMappings(String selector) {\n        return targetMapTable.get(selector.toLowerCase());\n    }\n\n",
    "label": 1,
    "rec": "Get the  ContentHandlerConfigMap list for the supplied selector string."
  },
  {
    "id": 3014,
    "type": "Summary",
    "comment": "Get representation of the application.",
    "code": "    public ApplicationRepresentation getApplication() {\n        auth.requireView();\n\n        return ModelToRepresentation.toRepresentation(application);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3015,
    "type": "Summary",
    "comment": "Gets an iterator over all allowed numbers, if restrictions apply.",
    "code": "    @SuppressWarnings(\"unchecked\")\n    public Iterator<Integer> iterator() {\n        if (ranges == null) {\n            return Collections.emptyIterator(); // no values\n        }\n\n        IteratorChain chain = new IteratorChain();\n        for (IntRange range : ranges) {\n            chain.addIterator(range.iterator());\n        }\n        return chain;\n    }\n\n",
    "label": 1,
    "rec": "Gets an iterator over all values."
  },
  {
    "id": 3016,
    "type": "Summary",
    "comment": "Returns the bit value at offset in the string value stored at key",
    "code": "    public Boolean getbit(byte[] key, long offset) {\n        client.getbit(key, offset);\n        return client.getIntegerReply() == 1;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3017,
    "type": "Summary",
    "comment": "Indicates whether cloud sync is in use.",
    "code": "    public boolean isActive() {\n        // The sync needs to be enabled.\n        if (!getPreferences().isSyncEnabled()) return false;\n\n        // network is online.\n        NetworkUtilities networkUtilities = new NetworkUtilities(getContext());\n        if (!networkUtilities.isOnline()) return false;\n\n        // wifi preferences\n        if (getPreferences().shouldSyncOnlyOnWifi()) {\n            if (!networkUtilities.isOnWiFi()) return false;\n        }\n\n        // check if a provider is selected? Default is Dropbox, so no need.\n\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Indicates whether synchronization can be performed, meaning all of the criteria must be true: sync enabled, respect wi-fi sync setting, provider is selected, network is online."
  },
  {
    "id": 3018,
    "type": "Summary",
    "comment": "Return the difference between the Set stored at key1 and all the Sets key2, ..., keyN  Example:  key1 = [x, a, b, c] key2 = [c] key3 = [a, d]",
    "code": "    public Set<String> sdiff(final String... keys) {\n        runChecks();\n        client.sdiff(keys);\n        final List<String> members = client.getMultiBulkReply();\n        return new HashSet<String>(members);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3019,
    "type": "Summary",
    "comment": "Creates an empty Optional using reflection to stay backwards-compatible with older",
    "code": "    public static Object emptyOptional() {\n        // no need for double-checked locking\n        if (emptyOptional != null) {\n            return emptyOptional;\n        }\n\n        return emptyOptional = invokeNullaryFactoryMethod(\"java.util.Optional\", \"empty\");\n    }\n",
    "label": 1,
    "rec": "Creates an empty Optional using reflection to stay backwards-compatible with older JDKs."
  },
  {
    "id": 3020,
    "type": "Summary",
    "comment": "Returns the dataHolder for the given world.",
    "code": "    public OverloadedWorldHolder getWorldData(String worldName) {\n    \tString worldNameLowered = worldName.toLowerCase();\n    \t\n    \t// Find this worlds data\n    \tif (worldsData.containsKey(worldNameLowered)) {\n    \t\t\n    \t\tString usersMirror = mirrorsUser.get(worldNameLowered);\n        \tString groupsMirror = mirrorsGroup.get(worldNameLowered);\n    \t\t\n    \t\tif (usersMirror != null) {\n    \t\t\t\n    \t\t\t// If both are mirrored\n    \t\t\tif (groupsMirror != null) {\n    \t\t\t\t\n    \t\t\t\t// if the data sources are the same, return the parent\n    \t\t\t\tif (usersMirror == groupsMirror)\n    \t\t\t\t\treturn getUpdatedWorldData(usersMirror.toLowerCase());\n    \t\t\t\t\n    \t\t\t\t// Both data sources are mirrors, but they are from different parents\n        \t\t\t// so we return the actual data object.\n        \t\t\treturn getUpdatedWorldData(worldNameLowered);\n    \t\t\t}\n    \t\t\t\n    \t\t\t// Groups isn't a mirror  so return this this worlds data source\n    \t\t\treturn getUpdatedWorldData(worldNameLowered);\t\n    \t\t}\n    \t\t\n    \t\t// users isn't mirrored so we need to return this worlds data source\n    \t\treturn getUpdatedWorldData(worldNameLowered);\n    \t}\n    \t\n    \t// Oddly no data source was found for this world so return the default.\n        GroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning default world...\");\n        return getDefaultWorld();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3021,
    "type": "Summary",
    "comment": "Determines the  ElkGraphElement ElkGraphElements that are (transitively) connected to  kedge across hierarchy boundaries via common ports.",
    "code": "    public static Iterator<KGraphElement> getConnectedElements(final KEdge kedge,\n            final boolean addPorts) {\n\n        final SelectionIterator sourceSideIt = new DefaultSelectionIterator(kedge, addPorts, false);\n        final SelectionIterator targetSideIt = new DefaultSelectionIterator(kedge, addPorts, true);\n\n        return getConnectedElements(kedge, sourceSideIt, targetSideIt);\n    }\n\n",
    "label": 1,
    "rec": "Determines the  KGraphElement KGraphElements that are (transitively) connected to  kedge across hierarchy boundaries via common ports."
  },
  {
    "id": 3022,
    "type": "Summary",
    "comment": "Creates a client session object for SAML IdP-initiated SSO session.",
    "code": "    public AuthenticationSessionModel getOrCreateLoginSessionForIdpInitiatedSso(KeycloakSession session, RealmModel realm, ClientModel client, String relayState) {\n        String[] bindingProperties = getUrlAndBindingForIdpInitiatedSso(client);\n        if (bindingProperties == null) {\n            return null;\n        }\n        String redirect = bindingProperties[0];\n        String bindingType = bindingProperties[1];\n\n        AuthenticationSessionModel authSession = createAuthenticationSession(client, null);\n\n        authSession.setProtocol(SamlProtocol.LOGIN_PROTOCOL);\n        authSession.setAction(AuthenticationSessionModel.Action.AUTHENTICATE.name());\n        authSession.setClientNote(SamlProtocol.SAML_BINDING, bindingType);\n        authSession.setClientNote(SamlProtocol.SAML_IDP_INITIATED_LOGIN, \"true\");\n        authSession.setRedirectUri(redirect);\n\n        if (relayState == null) {\n            relayState = client.getAttribute(SamlProtocol.SAML_IDP_INITIATED_SSO_RELAY_STATE);\n        }\n        if (relayState != null && !relayState.trim().equals(\"\")) {\n            authSession.setClientNote(GeneralConstants.RELAY_STATE, relayState);\n        }\n\n        return authSession;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3023,
    "type": "Summary",
    "comment": "Retrieves Account information from underlying data store.",
    "code": "    protected Account getAccount(Object principal) {\n\n        if ( principal == null ) {\n            return null;\n        }\n\n        Account account = null;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Retrieving Account for principal [\" + principal + \"]\");\n        }\n\n        boolean cacheEnabled = isAccountCacheEnabled();\n        Cache accountCache = null;\n        if (cacheEnabled) {\n            accountCache = getAccountCache();\n            if (accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Attempting to retrieve the Account from cache.\");\n                }\n                account = (Account) accountCache.get(principal);\n                if (log.isTraceEnabled()) {\n                    if (account == null) {\n                        log.trace(\"No Account found in cache for principal [\" + principal + \"]\");\n                    } else {\n                        log.trace(\"Account found in cache for principal [\" + principal + \"]\");\n                    }\n                }\n            }\n        }\n\n\n        if (account == null) {\n            // Call template method if tbe Account was not found in a cache\n            account = doGetAccount(principal);\n            // If the account is not null and the cache has been created, then cache the account.\n            if (account != null && accountCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching Account [\" + principal + \"].\");\n                }\n                accountCache.put(principal, account);\n            }\n        }\n\n        return account;\n    }\n",
    "label": 1,
    "rec": "Retrieves Account information for the given account principal."
  },
  {
    "id": 3024,
    "type": "Summary",
    "comment": "Gets the damage done to the vehicle",
    "code": "    public double getDamage() {\n        return damage;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3025,
    "type": "Summary",
    "comment": "Returns an Iterator for all IQProvider instances.",
    "code": "    public Collection<Object> getIQProviders() {\n        return Collections.unmodifiableCollection(iqProviders.values());\n    }\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable collection of all IQProvider instances."
  },
  {
    "id": 3026,
    "type": "Summary",
    "comment": "Returns a new  SizeSelector that keeps only sizes whose height is at least equal to the given height.",
    "code": "    public static SizeSelector minHeight(final int height) {\n        return withFilter(new Filter() {\n            @Override\n            public boolean accepts(@NonNull Size size) {\n                return size.getHeight() >= height;\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3027,
    "type": "Summary",
    "comment": "If a RowPanelExpander component is a child of this table, return it.",
    "code": "    public PanelExpansion getPanelExpansion() {\n        for (UIComponent kid : getChildren())\n            if (kid instanceof PanelExpansion) return (PanelExpansion) kid;\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "If a PanelExpansion component is a child of this table, return it."
  },
  {
    "id": 3028,
    "type": "Summary",
    "comment": "Executes the request and returns PluginResult.",
    "code": "\tpublic PluginResult execute(String action, JSONArray args, String callbackId) {\n\t\ttry {\n\t\t\tif (action.equals(\"startActivity\")) {\n\t\t\t\tif(args.length() != 1) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Parse the arguments\n\t\t\t\tJSONObject obj = args.getJSONObject(0);\n\t\t\t\tString type = obj.has(\"type\") ? obj.getString(\"type\") : null;\n\t\t\t\tUri uri = obj.has(\"url\") ? Uri.parse(obj.getString(\"url\")) : null;\n\t\t\t\tJSONObject extras = obj.has(\"extras\") ? obj.getJSONObject(\"extras\") : null;\n\t\t\t\tMap<String, String> extrasMap = new HashMap<String, String>();\n\t\t\t\t\n\t\t\t\t// Populate the extras if any exist\n\t\t\t\tif (extras != null) {\n\t\t\t\t\tJSONArray extraNames = extras.names();\n\t\t\t\t\tfor (int i = 0; i < extraNames.length(); i++) {\n\t\t\t\t\t\tString key = extraNames.getString(i);\n\t\t\t\t\t\tString value = extras.getString(key);\n\t\t\t\t\t\textrasMap.put(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstartActivity(obj.getString(\"action\"), uri, type, extrasMap);\n\t\t\t\treturn new PluginResult(PluginResult.Status.OK);\n\t\t\t\t\n\t\t\t} else if (action.equals(\"hasExtra\")) {\n\t\t\t\tif (args.length() != 1) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t\t\t}\n\t\t\t\tIntent i = this.ctx.getIntent();\n\t\t\t\tString extraName = args.getString(0);\n\t\t\t\treturn new PluginResult(PluginResult.Status.OK, i.hasExtra(extraName));\n\t\t\t\t\n\t\t\t} else if (action.equals(\"getExtra\")) {\n\t\t\t\tif (args.length() != 1) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t\t\t}\n\t\t\t\tIntent i = this.ctx.getIntent();\n\t\t\t\tString extraName = args.getString(0);\n\t\t\t\tif (i.hasExtra(extraName)) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.OK, i.getStringExtra(extraName));\n\t\t\t\t} else {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.ERROR);\n\t\t\t\t}\n\t\t\t} else if (action.equals(\"getUri\")) {\n\t\t\t\tif (args.length() != 0) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t\t\t}\n\n\t\t\t\tIntent i = this.ctx.getIntent();\n\t\t\t\tString uri = i.getDataString();\n\t\t\t\treturn new PluginResult(PluginResult.Status.OK, uri);\n\t\t\t} else if (action.equals(\"onNewIntent\")) {\n\t\t\t\tif (args.length() != 0) {\n\t\t\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.onNewIntentCallback = callbackId;\n\t\t\t\tPluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n\t\t\t\tresult.setKeepCallback(true);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn new PluginResult(PluginResult.Status.INVALID_ACTION);\n\t\t} catch (JSONException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn new PluginResult(PluginResult.Status.JSON_EXCEPTION);\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3029,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_RELEASE_TIME;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3030,
    "type": "Summary",
    "comment": "Returns the balance of a user",
    "code": "\tpublic static double getMoney(String name) throws UserDoesNotExistException\n\t{\n\t\tUser user = getUserByName(name);\n\t\tif (user == null) {\n\t\t\tthrow new UserDoesNotExistException(name);\n\t\t}\n\t\treturn user.getMoney();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3031,
    "type": "Summary",
    "comment": "Creates an AuthenticationEvent in the event of a successful authentication attempt, based on the given authentication token and AuthenticationInfo that was created as a result of the successful attempt.",
    "code": "    protected AuthenticationEvent createSuccessEvent( AuthenticationToken token, Account account ) {\n        AuthenticationEventFactory factory = getAuthenticationEventFactory();\n        return factory.createSuccessEvent( token, account );\n    }\n",
    "label": 1,
    "rec": "Creates an AuthenticationEvent in the event of a successful authentication attempt, based on the given authentication token and Account that was created as a result of the successful attempt."
  },
  {
    "id": 3032,
    "type": "Summary",
    "comment": "Creates appropriate empty projection exception.",
    "code": "    public static GridEmptyProjectionException emptyTopologyException() {\n        return new GridEmptyProjectionException(\"Topology projection is empty. Note that predicate based \" +\n            \"projection can be empty from call to call.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3033,
    "type": "Summary",
    "comment": "Attempt to parse a  Repo from the given  Uri",
    "code": "    public static Repository getRepository(Uri uri) {\n        List<String> segments = uri.getPathSegments();\n        if (segments == null)\n            return null;\n        if (segments.size() < 2)\n            return null;\n\n        String repoOwner = segments.get(0);\n        if (!RepositoryUtils.isValidOwner(repoOwner))\n            return null;\n\n        String repoName = segments.get(1);\n        if (!RepositoryUtils.isValidRepo(repoName))\n            return null;\n\n        return InfoUtils.createRepoFromData(repoOwner, repoName);\n    }\n",
    "label": 1,
    "rec": "Attempt to parse a  Repository from the given  Uri"
  },
  {
    "id": 3034,
    "type": "Summary",
    "comment": "Prefer to execute request using POST",
    "code": "    private CompletableFuture<String> executeCommand(String app, String ip, int port, String api, Map<String, String> params, boolean useHttpPost) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        if (StringUtil.isBlank(ip) || StringUtil.isBlank(api)) {\n            future.completeExceptionally(new IllegalArgumentException(\"Bad URL or command name\"));\n            return future;\n        }\n        StringBuilder urlBuilder = new StringBuilder();\n        urlBuilder.append(\"http://\");\n        urlBuilder.append(ip).append(':').append(port).append('/').append(api);\n        if (params == null) {\n            params = Collections.emptyMap();\n        }\n        if (!useHttpPost || !isSupportPost(app, ip, port)) {\n            // Using GET in older versions, append parameters after url\n            if (!params.isEmpty()) {\n                if (urlBuilder.indexOf(\"?\") == -1) {\n                    urlBuilder.append('?');\n                } else {\n                    urlBuilder.append('&');\n                }\n                urlBuilder.append(queryString(params));\n            }\n            return executeCommand(new HttpGet(urlBuilder.toString()));\n        } else {\n            // Using POST\n            return executeCommand(\n                    postRequest(urlBuilder.toString(), params, isSupportEnhancedContentType(app, ip, port)));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3035,
    "type": "Summary",
    "comment": "Returns the keys from the given object or the indexes from an array",
    "code": "    public Collection<String> getPropertyKeys(Object obj) {\n        if (isArray(obj)) {\n          throw new UnsupportedOperationException();\n        } else {\n            return ((Map) obj).keySet();\n        }\n    }\n",
    "label": 1,
    "rec": "Returns the keys from the given object"
  },
  {
    "id": 3036,
    "type": "Summary",
    "comment": "Returns a previously serialized identity byte array or  null if the byte array could not be acquired.",
    "code": "    protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {\n\n        if (!WebUtils.isHttp(subjectContext)) {\n            if (log.isDebugEnabled()) {\n                String msg = \"SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a \" +\n                        \"servlet request and response in order to retrieve the rememberMe cookie. Returning \" +\n                        \"immediately and ignoring rememberMe operation.\";\n                log.debug(msg);\n            }\n            return null;\n        }\n\n        WebSubjectContext wsc = (WebSubjectContext) subjectContext;\n        if (isIdentityRemoved(wsc)) {\n            return null;\n        }\n\n        HttpServletRequest request = WebUtils.getHttpRequest(wsc);\n        HttpServletResponse response = WebUtils.getHttpResponse(wsc);\n\n        String base64 = getCookie().readValue(request, response);\n        // Browsers do not always remove cookies immediately (SHIRO-183)\n        // ignore cookies that are scheduled for removal\n        if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;\n\n        if (base64 != null) {\n            base64 = ensurePadding(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\");\n            }\n            byte[] decoded = Base64.decode(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\");\n            }\n            return decoded;\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3037,
    "type": "Summary",
    "comment": "Update the project preferences from the preference store.",
    "code": "\tpublic ProjectPreferences loadProjectPreferences(IProject project, Map<String, Validator> baseValidators) \n\t\tthrows BackingStoreException {\n\t\t\n\t\tIEclipsePreferences pref = getPreferences();\n\n\t\tif (pref == null)return null;\n\t\tint version = pref.getInt(PrefConstants.frameworkVersion, 0);\n\t\tif (version == 0){\n\t\t\t// This means that we have a project that is before WTP 3.0\n\t\t\treturn migrateFromBeforeWTP30(project, baseValidators);\n\t\t}\n\t\t\n\t\tif (version != ValPrefManagerGlobal.frameworkVersion)ValPrefManagerGlobal.migrate(version, pref);\n\n\t\tif (!pref.nodeExists(PrefConstants.vals)){\n\t\t\treturn new ProjectPreferences(project, pref.getBoolean(PrefConstants.override, ProjectPreferences.DefaultOverride),\n\t\t\t\tpref.getBoolean(PrefConstants.suspend, ProjectPreferences.DefaultSuspend), new Validator[0]);\n\t\t}\n\t\t\n\t\tPreferences vp = pref.node(PrefConstants.vals);\n\t\tList<Validator> list = new LinkedList<Validator>();\n\t\tfor (String id : vp.childrenNames()){\n\t\t\tValidator base = baseValidators.get(id);\n\t\t\tValidator v = ValPrefManagerGlobal.loadValidator(id, vp, base);\n\t\t\tif (v != null){\n\t\t\t\tV2 v2 = v.asV2Validator();\n\t\t\t\tif (v2 != null)v2.setLevel(Validator.Level.Project);\n\t\t\t\tlist.add(v);\n\t\t\t}\n\t\t}\n\t\tValidator[] vals = new Validator[list.size()];\n\t\tlist.toArray(vals);\n\t\treturn new ProjectPreferences(project, pref.getBoolean(PrefConstants.override, ProjectPreferences.DefaultOverride),\n\t\t\tpref.getBoolean(PrefConstants.suspend, ProjectPreferences.DefaultSuspend), vals);\n\t}\n\n",
    "label": 1,
    "rec": "Answer the project preferences from the preference store."
  },
  {
    "id": 3038,
    "type": "Summary",
    "comment": "Resolve mode for the given path.",
    "code": "    private IgfsMode resolveMode(IgfsPath path) {\n        return modeRslvr.resolveMode(path);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3039,
    "type": "Summary",
    "comment": "Trigger a job for an application, if allowed",
    "code": "    private Application triggerAllowParallel(JobType jobType, Application application, boolean first, String cause, Lock lock) {\n        if (jobType == null) { // previous was last job\n            return application;\n        }\n\n        // Note: We could make a more fine-grained and more correct determination about whether to block \n        //       by instead basing the decision on what is currently deployed in the zone. However,\n        //       this leads to some additional corner cases, and the possibility of blocking an application\n        //       fix to a version upgrade, so not doing it now\n        if (jobType.isProduction() && application.deployingBlocked(clock.instant())) {\n            return application;\n        }\n        \n        if (application.deploymentJobs().isRunning(jobType, jobTimeoutLimit())) {\n            return application;\n        }\n\n        // TODO: Remove when we can determine why this occurs\n        if (jobType != JobType.component && ! application.deploying().isPresent()) {\n            log.warning(String.format(\"Want to trigger %s for %s with reason %s, but this application is not \" +\n                                              \"currently deploying a change\",\n                                      jobType, application, cause));\n            return application;\n        }\n\n        if  ( ! deploysTo(application, jobType)) {\n            return application;\n        }\n\n        // Note that this allows a new change to catch up and prevent an older one from continuing\n        if ( ! application.deploymentJobs().isDeployableTo(jobType.environment(), application.deploying())) {\n            log.warning(String.format(\"Want to trigger %s for %s with reason %s, but change is untested\", jobType,\n                                      application, cause));\n            return application;\n        }\n\n        // Ignore applications that are not associated with a project\n        if ( ! application.deploymentJobs().projectId().isPresent()) {\n            return application;\n        }\n\n        log.info(String.format(\"Triggering %s for %s, %s: %s\", jobType, application,\n                               application.deploying().map(d -> \"deploying \" + d).orElse(\"restarted deployment\"),\n                               cause));\n        buildSystem.addJob(application.id(), jobType, first);\n\n        return application.withJobTriggering(jobType, application.deploying(), clock.instant(), controller);\n    }\n\n",
    "label": 1,
    "rec": "Trigger a job for an application"
  },
  {
    "id": 3040,
    "type": "Summary",
    "comment": "Block until the either initial node creation initiated by  #start() succeeds or the timeout elapses.",
    "code": "    public boolean waitForInitialCreate(long timeout, TimeUnit unit) throws InterruptedException\n    {\n        Preconditions.checkState(state.get() == State.STARTED, \"Not started\");\n\n        CountDownLatch localLatch = initialCreateLatch.get();\n        return (localLatch == null) || localLatch.await(timeout, unit);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3041,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames. FRAME_ID_MUSICIAN_CREDITS;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3042,
    "type": "Summary",
    "comment": "Queries the OSGi service registry for a service that provides a transformation service of a given transformation type (e.g.",
    "code": "\tstatic public TransformationService getTransformationService(BundleContext context, String transformationType) {\n\t\t\n\t\tif (StringUtils.isBlank(transformationType)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (cachedServices.containsKey(transformationType)) {\n\t\t\treturn cachedServices.get(transformationType);\n\t\t}\n\t\t\n\t\tif(context!=null) {\n\t\t\tString filter = \"(openhab.transform=\" + transformationType + \")\";\n\t\t\ttry {\n\t\t\t\tCollection<ServiceReference<TransformationService>> refs = context.getServiceReferences(TransformationService.class, filter);\n\t\t\t\tif(refs!=null && refs.size() > 0) {\n\t\t\t\t\tTransformationService service = (TransformationService) context.getService(refs.iterator().next());\n\t\t\t\t\tcachedServices.put(transformationType, service);\n\t\t\t\t\treturn service;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"Cannot get service reference for transformation service of type \" + transformationType);\n\t\t\t\t}\n\t\t\t} catch (InvalidSyntaxException e) {\n\t\t\t\tlogger.warn(\"Cannot get service reference for transformation service of type \" + transformationType, e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3043,
    "type": "Summary",
    "comment": "Removes the  org.apache.stratos.messaging.domain.instance.context.InstanceContext object mapping to the specified instance id from the specified InstanceContext collection",
    "code": "    private Instance removeInstanceFrom(Iterator<Instance> iterator, String instanceId) {\n        while (iterator.hasNext()) {\n            Instance activeInstance = iterator.next();\n            if (activeInstance == null) {\n                iterator.remove();\n                continue;\n            }\n            if (instanceId.equals(activeInstance.getInstanceId())) {\n                iterator.remove();\n                return activeInstance;\n            }\n        }\n\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Removes the  org.apache.stratos.messaging.domain.instance.Instance object mapping to the specified instance id from the specified InstanceContext collection"
  },
  {
    "id": 3044,
    "type": "Summary",
    "comment": "Get a  ThreadFactory suitable for use in the current environment.",
    "code": "  public static ThreadFactory getThreadFactory(String nameFormat, boolean daemon) {\n    if (IS_RESTRICTED_APPENGINE) {\n      @SuppressWarnings(\"BetaApi\")\n      ThreadFactory factory = MoreExecutors.platformThreadFactory();\n      return factory;\n    } else {\n      return new ThreadFactoryBuilder()\n          .setDaemon(daemon)\n          .setNameFormat(nameFormat)\n          .build();\n    }\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3045,
    "type": "Summary",
    "comment": "This is called from Model.score().",
    "code": "  public Frame score(Frame frame) {\n    if (!get_params().autoencoder) {\n      return super.score(frame);\n    } else {\n      // Reconstruction\n      // Adapt the Frame layout - returns adapted frame and frame containing only\n      // newly created vectors\n      Frame[] adaptFrms = adapt(frame,false,false/*no response*/);\n      // Adapted frame containing all columns - mix of original vectors from fr\n      // and newly created vectors serving as adaptors\n      Frame adaptFrm = adaptFrms[0];\n      // Contains only newly created vectors. The frame eases deletion of these vectors.\n      Frame onlyAdaptFrm = adaptFrms[1];\n\n      final int len = model_info().data_info().fullN();\n      String prefix = \"reconstr_\";\n      assert(model_info().data_info()._responses == 0);\n      String[] coefnames = model_info().data_info().coefNames();\n      assert(len == coefnames.length);\n      for( int c=0; c<len; c++ )\n        adaptFrm.add(prefix+coefnames[c],adaptFrm.anyVec().makeZero());\n      new MRTask2() {\n        @Override public void map( Chunk chks[] ) {\n          double tmp [] = new double[_names.length];\n          float preds[] = new float [len];\n          final Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info);\n          for( int row=0; row<chks[0]._len; row++ ) {\n            float p[] = score_autoencoder(chks, row, tmp, preds, neurons);\n            for( int c=0; c<preds.length; c++ )\n              chks[_names.length+c].set0(row,p[c]);\n          }\n        }\n      }.doAll(adaptFrm);\n\n      // Return just the output columns\n      int x=_names.length, y=adaptFrm.numCols();\n      onlyAdaptFrm.delete();\n      return adaptFrm.extractFrame(x, y);\n    }\n  }\n",
    "label": 1,
    "rec": "This is an overridden version of Model.score()."
  },
  {
    "id": 3046,
    "type": "Summary",
    "comment": "Checks whether property is one added by Visor when node is started via remote SSH session.",
    "code": "    public static boolean isVisorNodeStartProperty(String name) {\n        return IGNITE_SSH_HOST.equals(name) || IGNITE_SSH_USER_NAME.equals(name);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3047,
    "type": "Summary",
    "comment": "Asynchronously call  org.apache.curator.framework.CuratorFramework#createContainers(String) using the given executor",
    "code": "    public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, ZPath path)\n    {\n        return asyncEnsureContainers(client, path, null);\n    }\n",
    "label": 1,
    "rec": "Asynchronously call  org.apache.curator.framework.CuratorFramework#createContainers(String) using the  java.util.concurrent.ForkJoinPool#commonPool()."
  },
  {
    "id": 3048,
    "type": "Summary",
    "comment": "Gets daemon flag.",
    "code": "    public static boolean isDaemon() {\n        return GridGainEx.isDaemon();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3049,
    "type": "Summary",
    "comment": "Returns the name of the language.",
    "code": "  public TargetLanguage language() {\n    return language;\n  }\n\n",
    "label": 1,
    "rec": "Returns the language."
  },
  {
    "id": 3050,
    "type": "Summary",
    "comment": "Returns true if this object contains enough information to retrieve a token",
    "code": "    public boolean isValid() {\n        if (grantType==null) {\n            return false;\n        }\n        switch (grantType) {\n            case CLIENT_CREDENTIALS:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret\n                    )\n                );\n            case PASSWORD:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password\n                    )\n                );\n            case PASSWORD_WITH_PASSCODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        passcode\n                    )\n                );\n            case AUTHORIZATION_CODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri\n                    )\n                );\n            case AUTHORIZATION_CODE_WITH_TOKEN:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri,\n                        authCodeAPIToken\n                    )\n                );\n            default: return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3051,
    "type": "Summary",
    "comment": "Is the process-tree alive? Currently we care only about the status of the root-process.",
    "code": "  public boolean isAlive() {\n    if (pid == -1) {\n      return false;\n    } else {\n      return isAlive(pid.toString());\n    }\n  }\n\n",
    "label": 1,
    "rec": "Is the root-process alive?"
  },
  {
    "id": 3052,
    "type": "Summary",
    "comment": "Creates a new Group with the given name and adds it to this holder",
    "code": "    public Group createGroup(String groupName) {\n    \tif (groupName.startsWith(\"g:\")) {\n        \tGroup newGroup = new Group(groupName);\n        \treturn GroupManager.getGlobalGroups().newGroup(newGroup);\n        }\n    \t\n    \tif (this.groups.containsKey(groupName.toLowerCase())) {\n            return null;\n        }\n        \n    \tGroup newGroup = new Group(this, groupName);\n        this.addGroup(newGroup);\n        haveGroupsChanged = true;\n        return newGroup;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3053,
    "type": "Summary",
    "comment": "Returns the username (at String[] index 0) and password (at String[] index 1) obtained from the  #getAuthzHeader(javax.servlet.ServletRequest) authorizationHeader.",
    "code": "    protected String[] getPrincipalsAndCredentials( String authorizationHeader, ServletRequest request ) {\n        if ( authorizationHeader == null ) {\n            return null;\n        }\n        String[] authTokens = authorizationHeader.split(\" \");\n        if ( authTokens == null || authTokens.length < 2 ) {\n            return null;\n        }\n        return getPrincipalsAndCredentials(authTokens[0], authTokens[1]);\n    }\n",
    "label": 1,
    "rec": "Returns the username obtained from the  #getAuthzHeader(javax.servlet.ServletRequest) authorizationHeader."
  },
  {
    "id": 3054,
    "type": "Summary",
    "comment": "Returns true if this object contains enough information to retrieve a token",
    "code": "    public boolean isValid() {\n        if (grantType==null) {\n            return false;\n        }\n        switch (grantType) {\n            case CLIENT_CREDENTIALS:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret\n                    )\n                );\n            case PASSWORD:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password\n                    )\n                );\n            case PASSWORD_WITH_PASSCODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        passcode\n                    )\n                );\n            case AUTHORIZATION_CODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri,\n                        state\n                    )\n                );\n            case AUTHORIZATION_CODE_WITH_TOKEN:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri,\n                        authCodeAPIToken,\n                        state\n                    )\n                );\n            default: return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3055,
    "type": "Summary",
    "comment": "Returns the default item for the specified debugger.",
    "code": "\tpublic PHPexeItem getDefaultItem() {\n\t\treturn PHPDebugPlugin.getWorkspaceDefaultExe();\n\t}\n\n",
    "label": 1,
    "rec": "Returns the default workspace PHPexeItem."
  },
  {
    "id": 3056,
    "type": "Summary",
    "comment": "Utility - return true if the given Zookeeper result code is retry-able",
    "code": "    public static boolean      shouldRetry(int rc)\n    {\n        return (rc == KeeperException.Code.CONNECTIONLOSS.intValue()) ||\n            (rc == KeeperException.Code.OPERATIONTIMEOUT.intValue()) ||\n            (rc == KeeperException.Code.SESSIONMOVED.intValue()) ||\n            (rc == KeeperException.Code.SESSIONEXPIRED.intValue()) ||\n            (rc == -13); // KeeperException.Code.NEWCONFIGNOQUORUM.intValue()) - using hard coded value for ZK 3.4.x compatibility\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3057,
    "type": "Summary",
    "comment": "This default implementation merely returns new  SimpleSession#SimpleSession(String) SimpleSession(host);",
    "code": "    public Session createSession(SessionContext initData) {\r\n        if (initData != null) {\r\n            String host = initData.getHost();\r\n            if (host != null) {\r\n                return new SimpleSession(host);\r\n            }\r\n        }\r\n        return new SimpleSession();\r\n    }\r\n\n",
    "label": 1,
    "rec": "Creates a new  SimpleSession SimpleSession instance retaining the context's  SessionContext#getHost() host if one can be found."
  },
  {
    "id": 3058,
    "type": "Summary",
    "comment": "Convert Hadoop job metadata to job status.",
    "code": "    public static GridHadoopJobStatus status(GridHadoopJobMetadata meta) {\n        GridHadoopJobInfo jobInfo = meta.jobInfo();\n\n        return new GridHadoopJobStatus(\n            meta.jobId(),\n            jobInfo.jobName(),\n            jobInfo.user(),\n            meta.pendingSplits() != null ? meta.pendingSplits().size() : 0,\n            meta.pendingReducers() != null ? meta.pendingReducers().size() : 0,\n            meta.mapReducePlan().mappers(),\n            meta.mapReducePlan().reducers(),\n            meta.phase(),\n            meta.failCause() != null,\n            meta.version()\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3059,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_AUDIO_SEEK_POINT_INDEX;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3060,
    "type": "Summary",
    "comment": "Returns true if the tokenCredentials are equal to the accountCredentials.",
    "code": "    protected boolean equals( Object tokenCredentials, Object accountCredentials ) {\n        if ( (tokenCredentials instanceof byte[] || tokenCredentials instanceof char[] || tokenCredentials instanceof String ) &&\n             (accountCredentials instanceof byte[] || accountCredentials instanceof char[] || tokenCredentials instanceof String ) ) {\n            byte[] tokenBytes = toBytes(tokenCredentials);\n            byte[] accountBytes = toBytes(accountCredentials);\n            return Arrays.equals( tokenBytes, accountBytes );\n        } else {\n            return accountCredentials.equals( tokenCredentials );\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3061,
    "type": "Summary",
    "comment": "Get the  OpcBinaryDataTypeCodec identified by  description from the dictionary identified by  namespaceUri.",
    "code": "    @Nullable\n    default OpcUaBinaryDataTypeCodec<?> getBinaryCodec(String namespaceUri, String description) {\n        DataTypeCodec codec = getCodec(namespaceUri, description);\n\n        if (codec instanceof OpcUaBinaryDataTypeCodec) {\n            return (OpcUaBinaryDataTypeCodec) codec;\n        } else {\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get the  OpcUaBinaryDataTypeCodec identified by  description from the dictionary identified by  namespaceUri."
  },
  {
    "id": 3062,
    "type": "Summary",
    "comment": "Gets state of grid default grid.",
    "code": "    public static IgniteState state() {\n        return IgnitionEx.state();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3063,
    "type": "Summary",
    "comment": "Construct a  PartialRestResponse based on the builder configuration.",
    "code": "    public RestLiResponse build()\n    {\n      if (_record instanceof IdResponse)\n      {\n        final IdResponse<?> idResponse = (IdResponse<?>) _record;\n        final Object key = idResponse.getId();\n        if (key != null)\n        {\n          final ProtocolVersion protocolVersion = ProtocolVersionUtil.extractProtocolVersion(_headers);\n          _headers.put(HeaderUtil.getIdHeaderName(protocolVersion), URIParamUtils.encodeKeyForHeader(key, protocolVersion));\n        }\n      }\n\n      return new RestLiResponse(_status, _record, _headers, _cookies);\n    }\n\n",
    "label": 1,
    "rec": "Construct a  RestLiResponse based on the builder configuration."
  },
  {
    "id": 3064,
    "type": "Summary",
    "comment": "Get a value from the given properties.",
    "code": "\tprivate String getProperty(Map<String, Object> properties, String name) {\n\n\t\tString value = (String) properties.get(name);\n\t\tif (StringUtils.isNotBlank(value)) {\n\t\t\treturn value.trim();\n\t\t} else {\n\t\t\tlogger.warn(\"mqtt-persistence:\" + name, \"Missing or invalid property '\" + name + \"'\");\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3065,
    "type": "Summary",
    "comment": "Get an AssertionWrapper instance which corresponds to a Transformed Token.",
    "code": "    public SamlAssertionWrapper getTransformedToken() {\n        return transformedToken;\n    }\n\n",
    "label": 1,
    "rec": "Get an SamlAssertionWrapper instance which corresponds to a Transformed Token."
  },
  {
    "id": 3066,
    "type": "Summary",
    "comment": "Formats the amount of money like all other Essentials functions.",
    "code": "\tpublic static String format(double amount)\n\t{\n\t\tif (ess == null)\n\t\t{\n\t\t\tthrow new RuntimeException(noCallBeforeLoad);\n\t\t}\n\t\treturn Util.displayCurrency(BigDecimal.valueOf(amount), ess);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3067,
    "type": "Summary",
    "comment": "Get a list of portraits.",
    "code": "\tpublic List<String> getPortraits(){\n\t\treturn this.portraits;\n\t}\n\n",
    "label": 1,
    "rec": "Get a list of portrait image ids."
  },
  {
    "id": 3068,
    "type": "Summary",
    "comment": "Checks that we have appropriate permissions for this session type.",
    "code": "    protected boolean checkPermissions(SessionType sessionType, Audio audio) {\n        checkPermissionsManifestOrThrow(sessionType, audio);\n        // Manifest is OK at this point. Let's check runtime permissions.\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) return true;\n\n        Context c = getContext();\n        boolean needsCamera = true;\n        boolean needsAudio = sessionType == SessionType.VIDEO && audio == Audio.ON;\n\n        needsCamera = needsCamera && c.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED;\n        needsAudio = needsAudio && c.checkSelfPermission(Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED;\n\n        if (needsCamera || needsAudio) {\n            requestPermissions(needsCamera, needsAudio);\n            return false;\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3069,
    "type": "Summary",
    "comment": "Returns the next valid execution time after now",
    "code": "\t\tpublic Long nextExecutionTime() {\n\t\t\tDate nextExec = cex.getNextValidTimeAfter(new Date());\n\t\t\tif(nextExec==null) return null;\n\t\t\treturn nextExec.getTime();\n\t\t}\n\n",
    "label": 1,
    "rec": "Returns the next valid execution time in ms.UTC after now"
  },
  {
    "id": 3070,
    "type": "Summary",
    "comment": "Build a new schema from the currently set values",
    "code": "    public Schema build()\n    {\n        return new Schema(pathRegex, path, documentation, dataValidator, ephemeral, sequential, watched, canBeDeleted);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3071,
    "type": "Summary",
    "comment": "This method is called by an event processor to determine the RemoteSharedObjectDescriptions associated with the given receivers.",
    "code": "\tprotected SharedObjectDescription[] getReplicaDescriptions(ID[] receivers) {\n\t\tSharedObjectDescription[] descriptions = null;\n\t\tif (receivers == null || receivers.length == 1) {\n\t\t\tdescriptions = new SharedObjectDescription[1];\n\t\t\tdescriptions[0] = getReplicaDescription((receivers==null)?null:receivers[0]);\n\t\t} else {\n\t\t\tdescriptions = new SharedObjectDescription[receivers.length];\n\t\t\tfor(int i=0; i < receivers.length; i++) {\n\t\t\t\tdescriptions[i] = getReplicaDescription(receivers[i]);\n\t\t\t}\n\t\t}\n\t\treturn descriptions;\n\t}\n\n",
    "label": 1,
    "rec": "This method is called by an event processor to determine the SharedObjectDescriptions associated with the given receivers."
  },
  {
    "id": 3072,
    "type": "Summary",
    "comment": "Sets the logo on the  ActionBar to the user's avatar.",
    "code": "    public AvatarHelper bind(final ActionBar actionBar, final User user) {\n        if (user == null)\n            return this;\n\n        final String avatarUrl = user.getAvatarUrl();\n        if (TextUtils.isEmpty(avatarUrl))\n            return this;\n\n        final Integer userId = Integer.valueOf(user.getId());\n\n        Bitmap loadedImage = loaded.get(userId);\n        if (loadedImage != null) {\n            BitmapDrawable drawable = new BitmapDrawable(context.getResources(), loadedImage);\n            drawable.setBounds(0, 0, logoWidth, logoWidth);\n            actionBar.setLogo(drawable);\n            return this;\n        }\n\n        new FetchAvatarTask(context) {\n\n            @Override\n            public Bitmap call() throws Exception {\n                synchronized (AvatarHelper.this) {\n                    Bitmap image = getImage(user);\n                    if (image == null) {\n                        fetchAvatar(avatarUrl, userId);\n                        image = getImage(user);\n                    }\n                    return image;\n                }\n            }\n\n            @Override\n            protected void onSuccess(Bitmap image) throws Exception {\n                if (image != null)\n                    actionBar.setLogo(new BitmapDrawable(context.getResources(), image));\n            }\n        }.execute();\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3073,
    "type": "Summary",
    "comment": "Sets the scope of this dependency, e.g.",
    "code": "    public Dependency setScope( String scope )\n    {\n        if ( this.scope.equals( scope ) || ( scope == null && this.scope.length() <= 0 ) )\n        {\n            return this;\n        }\n        return new Dependency( artifact, scope, optional, exclusions );\n    }\n\n",
    "label": 1,
    "rec": "Sets the scope of the dependency, e.g."
  },
  {
    "id": 3074,
    "type": "Summary",
    "comment": "Builds a large product image file path that can be used by the image servlet",
    "code": "\tpublic String buildLargeProductImageUtils(MerchantStore store, String sku, String imageName) {\n\t\treturn new StringBuilder().append(getBasePath()).append(Constants.SLASH).append(store.getCode()).append(Constants.SLASH)\n\t\t\t\t.append(sku).append(Constants.SLASH).append(Constants.SMALL_IMAGE).append(Constants.SLASH).append(imageName).toString();\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3075,
    "type": "Summary",
    "comment": "Returns a set of partitions that were deleted in the target set getDeletedInTarget(cluster, null) - everything was deleted, returns cluster.",
    "code": "    public static <T> Set<T> getDeletedInTarget(final Set<T> current, final Set<T> target) {\n        if(current == null || target == null) {\n            return new HashSet<T>();\n        }\n        return getDiff(current, target);\n    }\n\n",
    "label": 1,
    "rec": "Returns a set of objects that were deleted in the target set getDeletedInTarget(current, null) - everything was deleted, returns current."
  },
  {
    "id": 3076,
    "type": "Summary",
    "comment": "Gets owner of a IgfsEx path.",
    "code": "    private static String getOwner(final IgfsEx i, final IgfsPath p) {\n        return IgfsUserContext.doAs(USER, new IgniteOutClosure<String>() {\n            @Override public String apply() {\n                IgfsFile f = i.info(p);\n\n                assert f != null;\n\n                return f.property(IgfsUtils.PROP_USER_NAME);\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3077,
    "type": "Summary",
    "comment": "Create an instance of the  Authentication object by using the plugin class name.",
    "code": "    public static Authentication create(String authPluginClassName, Map<String, String> authParams)\n            throws UnsupportedAuthenticationException {\n        try {\n            return DefaultImplementation.createAuthentication(authPluginClassName, authParams);\n        } catch (Throwable t) {\n            throw new UnsupportedAuthenticationException(t);\n        }\n    }\n",
    "label": 1,
    "rec": "Create an instance of the Authentication-Plugin."
  },
  {
    "id": 3078,
    "type": "Summary",
    "comment": "Add issue to intent being built up",
    "code": "        public Builder issue(Issue issue) {\n            return repo(createFromUrl(issue.getHtmlUrl())).add(EXTRA_ISSUE, issue).add(EXTRA_ISSUE_NUMBER,\n                    issue.getNumber());\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3079,
    "type": "Summary",
    "comment": "Constructs an AmbientTalk ATClosure from a Java method.",
    "code": "\tpublic static final ATMethod downMethod(ATObject natObject, String jSelector, ATSymbol origName) throws InterpreterException {\n\t\treturn new NativeMethod(JavaInterfaceAdaptor.getMethod(natObject.getClass(), natObject, jSelector), origName);\n\t}\n\n",
    "label": 1,
    "rec": "Constructs an AmbientTalk ATMethod from a Java method."
  },
  {
    "id": 3080,
    "type": "Summary",
    "comment": "The level of priority to use for applying filters.",
    "code": "    public int getFilterPriorityToApply() {\n        return filterPriority;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3081,
    "type": "Summary",
    "comment": "Returns the first element that containes an Id with value uri and namespace.",
    "code": "    public static Element findElementById(Node startNode, String value,\n            String namespace) {\n        Element foundElement = null;\n\n        /*\n         * Replace the formely recursive implementation with a depth-first-loop\n         * lookup\n         */\n        if (startNode == null) {\n            return null;\n        }\n        Node startParent = startNode.getParentNode();\n        Node processedNode = null;\n\n        while (startNode != null) {\n            // start node processing at this point\n            if (startNode.getNodeType() == Node.ELEMENT_NODE) {\n                Element se = (Element) startNode;\n                if (se.hasAttributeNS(namespace, \"Id\")\n                        && value.equals(se.getAttributeNS(namespace, \"Id\"))) {\n                    if (foundElement == null) {\n                        foundElement = se; // Continue searching to find\n                        // duplicates\n                    } else {\n                        log\n                                .warn(\"Multiple elements with the same 'Id' attribute value!\");\n                        return null;\n                    }\n                }\n            }\n\n            processedNode = startNode;\n            startNode = startNode.getFirstChild();\n\n            // no child, this node is done.\n            if (startNode == null) {\n                // close node processing, get sibling\n                startNode = processedNode.getNextSibling();\n            }\n            // no more siblings, get parent, all children\n            // of parent are processed.\n            while (startNode == null) {\n                processedNode = processedNode.getParentNode();\n                if (processedNode == startParent) {\n                    return foundElement;\n                }\n                // close parent node processing (processed node now)\n                startNode = processedNode.getNextSibling();\n            }\n        }\n        return foundElement;\n    }\n\n",
    "label": 1,
    "rec": "Returns the single element that containes an Id with value uri and namespace."
  },
  {
    "id": 3082,
    "type": "Summary",
    "comment": "Any int or non-null Integer.",
    "code": "    public static int anyInt() {\n        reportMatcher(new InstanceOf(Integer.class));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3083,
    "type": "Summary",
    "comment": "Get playback position of current track in milliseconds.",
    "code": "\tpublic int position(){\n\t\tif(this.player != null){\n\t\t\treturn this.player.position();\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n",
    "label": 1,
    "rec": "Get playback position of current track."
  },
  {
    "id": 3084,
    "type": "Summary",
    "comment": "get a specific value at (row, col) of a Symmetric (upper) matrix",
    "code": "\tpublic double get(int row, int col) {\n\t\treturn row < col ? super.get(row, col) : super.get(col, row);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3085,
    "type": "Summary",
    "comment": "Attempts to persist a String to the  android.content.SharedPreferences.",
    "code": "    protected boolean persistString(String value) {\n        if (!shouldPersist()) {\n            return false;\n        }\n\n        // Shouldn't store null\n        if (TextUtils.equals(value, getPersistedString(null))) {\n            // It's already there, so the same as persisting\n            return true;\n        }\n\n        PreferenceDataStore dataStore = getPreferenceDataStore();\n        if (dataStore != null) {\n            dataStore.putString(mKey, value);\n        } else {\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putString(mKey, value);\n            tryCommit(editor);\n        }\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist a  String if this Preference is persistent."
  },
  {
    "id": 3086,
    "type": "Summary",
    "comment": "Create portable marshaller.",
    "code": "    private static GridPortableMarshaller marshaller() {\n        try {\n            PortableContext ctx = new PortableContext(BinaryNoopMetadataHandler.instance(), new IgniteConfiguration());\n\n            PortableMarshaller marsh = new PortableMarshaller();\n\n            marsh.setContext(new MarshallerContextImpl(null));\n\n            ctx.configure(marsh);\n\n            return new GridPortableMarshaller(ctx);\n        }\n        catch (IgniteCheckedException e) {\n            throw U.convertException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3087,
    "type": "Summary",
    "comment": "Gets the  EdmPrimitiveTypeKind from a full-qualified type name.",
    "code": "  public static EdmPrimitiveTypeKind valueOfFQN(final FullQualifiedName fqn) {\n    return valueOfFQN(fqn.toString());\n  }\n\n",
    "label": 1,
    "rec": "Gets EdmPrimitiveTypeKind from a full-qualified type name, for the given OData protocol version."
  },
  {
    "id": 3088,
    "type": "Summary",
    "comment": "performs back-door proxy get to  MetadataStore#getDonorNode()",
    "code": "    private List<Versioned<byte[]>> proxyGet(ByteArray key) throws VoldemortException {\n\n        if(!storeRepository.hasNodeStore(getName(), metadata.getRebalancingStealInfo().getDonorId())) {\n            throw new VoldemortException(\"Node Store not present in storeRepository for (store,nodeId) pair (\"\n                                         + getName()\n                                         + \",\"\n                                         + metadata.getRebalancingStealInfo().getDonorId() + \").\");\n        }\n\n        return storeRepository.getNodeStore(getName(),\n                                            metadata.getRebalancingStealInfo().getDonorId())\n                              .get(key);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3089,
    "type": "Summary",
    "comment": "Get currently bound RowsFragment or null if BrowseFragment has not been created yet.",
    "code": "    public RowsFragment getRowsFragment() {\n        if (mMainFragment instanceof RowsFragment) {\n            return (RowsFragment) mMainFragment;\n        }\n\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Get RowsFragment if it's bound to BrowseFragment or null if either BrowseFragment has not been created yet or a different fragment is bound to it."
  },
  {
    "id": 3090,
    "type": "Summary",
    "comment": "Update account information.",
    "code": "    public Response processAccountUpdate(final MultivaluedMap<String, String> formData) {\n        if (auth == null) {\n            return login(null);\n        }\n\n        require(AccountRoles.MANAGE_ACCOUNT);\n\n        String action = formData.getFirst(\"submitAction\");\n        if (action != null && action.equals(\"Cancel\")) {\n            setReferrerOnPage();\n            return account.createResponse(AccountPages.ACCOUNT);\n        }\n\n        csrfCheck(formData);\n\n        UserModel user = auth.getUser();\n\n        List<FormMessage> errors = Validation.validateUpdateProfileForm(formData);\n        if (errors != null && !errors.isEmpty()) {\n            setReferrerOnPage();\n            return account.setErrors(errors).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);\n        }\n\n        try {\n            user.setFirstName(formData.getFirst(\"firstName\"));\n            user.setLastName(formData.getFirst(\"lastName\"));\n\n            String email = formData.getFirst(\"email\");\n            String oldEmail = user.getEmail();\n            boolean emailChanged = oldEmail != null ? !oldEmail.equals(email) : email != null;\n\n            user.setEmail(formData.getFirst(\"email\"));\n\n            AttributeFormDataProcessor.process(formData, realm, user);\n\n            event.event(EventType.UPDATE_PROFILE).client(auth.getClient()).user(auth.getUser()).success();\n\n            if (emailChanged) {\n                user.setEmailVerified(false);\n                event.clone().event(EventType.UPDATE_EMAIL).detail(Details.PREVIOUS_EMAIL, oldEmail).detail(Details.UPDATED_EMAIL, email).success();\n            }\n            setReferrerOnPage();\n            return account.setSuccess(Messages.ACCOUNT_UPDATED).createResponse(AccountPages.ACCOUNT);\n        } catch (ModelReadOnlyException roe) {\n            setReferrerOnPage();\n            return account.setError(Messages.READ_ONLY_USER).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3091,
    "type": "Summary",
    "comment": "Create Definition factory from specified configuration object.",
    "code": "    public static DefinitionsFactory createDefinitionsFactory(\n        DefinitionsFactoryConfig factoryConfig)\n        throws DefinitionsFactoryException {\n        return tilesUtilImpl.createDefinitionsFactory(factoryConfig);\n    }\n\n",
    "label": 1,
    "rec": "Create Definition impl from specified configuration object."
  },
  {
    "id": 3092,
    "type": "Summary",
    "comment": "Gets hadoop job status for given job ID.",
    "code": "    @Nullable public GridHadoopJobStatus status(GridHadoopJobId jobId) throws GridException {\n        if (!busyLock.tryReadLock())\n            return null; // Grid is stopping.\n\n        try {\n            GridHadoopJobMetadata meta = (GridHadoopJobMetadata)jobMetaCache().get(jobId);\n\n            return meta != null ? status(meta) : null;\n        }\n        finally {\n            busyLock.readUnlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3093,
    "type": "Summary",
    "comment": "Get RowsSupportFragment if it's bound to BrowseSupportFragment or null if either BrowseSupportFragment has not been created yet or a different fragment is bound to it.",
    "code": "    public RowsSupportFragment getRowsSupportFragment() {\n        return (RowsSupportFragment)mMainFragment;\n    }\n\n",
    "label": 1,
    "rec": "Get currently bound RowsSupportFragment or null if BrowseSupportFragment has not been created yet."
  },
  {
    "id": 3094,
    "type": "Summary",
    "comment": "Add the specified member to the set value stored at key.",
    "code": "    public Long sadd(final byte[] key, final byte[] member) {\n        checkIsInMulti();\n        client.sadd(key, member);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3095,
    "type": "Summary",
    "comment": "Returns the GroupSettings list - Lazy",
    "code": "\tpublic List<Group> getGroupSettingsList(boolean forceUpdate) throws IOException {\r\n\t\treturn getSettings(forceUpdate).getGroupSettingsList();\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Returns the Group list - Lazy"
  },
  {
    "id": 3096,
    "type": "Summary",
    "comment": " function defines the Memory comparator.",
    "code": "  private static FactorComparator<Executor> getMemoryComparator(int weight){\n    return FactorComparator.create(MEMORY_COMPARATOR_NAME, weight, new Comparator<Executor>(){\n\n      @Override\n      public int compare(Executor o1, Executor o2) {\n       ExecutorInfo stat1 = o1.getExecutorInfo();\n       ExecutorInfo stat2 = o2.getExecutorInfo();\n\n       int result = 0;\n       if (statisticsObjectCheck(stat1,stat2,MEMORY_COMPARATOR_NAME,result)){\n         return result;\n       }\n\n       if (stat1.getRemainingMemory() != stat2.getRemainingMemory()){\n         return stat1.getRemainingMemory() > stat2.getRemainingMemory() ? 1:-1;\n       }\n\n       return Double.compare(stat1.getRemainingMemoryPercent(), stat2.getRemainingMemoryPercent());\n      }});\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3097,
    "type": "Summary",
    "comment": "Check whether queue has temporarily or permanently exceeded its budget.",
    "code": "    public boolean isOverBudget() {\n        // check whether session budget exceeded\n        // or totalExpenditure exceeds totalBudget\n        return (sessionBudget > 0 && (totalExpenditure - expenditureAtLastActivation) > sessionBudget)\n            || (this.totalBudget >= 0 && this.totalExpenditure >= this.totalBudget);\n    }\n\n",
    "label": 1,
    "rec": "Check whether queue has temporarily (session) or permanently (total) exceeded its budgets."
  },
  {
    "id": 3098,
    "type": "Summary",
    "comment": "Returns the currently accessible SecurityContext available to the calling code.",
    "code": "    public static SecurityContext getSecurityContext() {\n        //todo Refactor to use thread local prior to 1.0\n        throw new UnsupportedOperationException( \"Should be changed to use thread local before 1.0 release\" );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3099,
    "type": "Summary",
    "comment": "Validate a classname.",
    "code": "    @Deprecated\n    protected boolean validate(String name) {\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Unused."
  },
  {
    "id": 3100,
    "type": "Summary",
    "comment": "Allows automatic approval for a white list of clients in the implicit grant case.",
    "code": "\tpublic boolean isApproved(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n\t\tif (useTokenServices && super.isApproved(authorizationRequest, userAuthentication)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!userAuthentication.isAuthenticated()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (authorizationRequest.isApproved()) {\n\t\t\treturn true;\n\t\t}\n\t\tString clientId = authorizationRequest.getClientId();\n\t\tboolean approved = false;\n\t\tif (clientDetailsService != null) {\n\t\t\tClientDetails client = clientDetailsService.loadClientByClientId(clientId);\n\t\t\tCollection<String> requestedScopes = authorizationRequest.getScope();\n\t\t\tif (isAutoApprove(client, requestedScopes)) {\n\t\t\t\tapproved = true;\n\t\t\t}\n\t\t}\n\t\treturn approved;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3101,
    "type": "Summary",
    "comment": "Use the mappings and properties specified in the given application resource.",
    "code": "\tprotected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n\t\ttry {\n\t\t\tList errors = new ArrayList();\n\t\t\tDocument document = xmlHelper.createSAXReader( resourceName, errors, entityResolver )\n\t\t\t\t\t.read( new InputSource( stream ) );\n\t\t\tif ( errors.size() != 0 ) {\n\t\t\t\tthrow new MappingException( \"invalid configuration\", (Throwable) errors.get( 0 ) );\n\t\t\t}\n\t\t\tdoConfigure( document );\n\t\t}\n\t\tcatch (DocumentException e) {\n\t\t\tthrow new HibernateException( \"Could not parse configuration: \" + resourceName, e );\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe );\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n",
    "label": 1,
    "rec": "Configure this configuration's state from the contents of the given input stream."
  },
  {
    "id": 3102,
    "type": "Summary",
    "comment": "Acquires the  Subject Subject that owns the  Session Session with the specified  sessionId.",
    "code": "    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        Map<String, Object> context = new HashMap<String, Object>(1);\n        context.put(SubjectFactory.SESSION_ID, sessionId);\n        return createSubject(context);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3103,
    "type": "Summary",
    "comment": "Get application directory on external storage.",
    "code": "    public String getDatabaseStorageDirectory() {\n        //get external storage\n        File externalStorage;\n        externalStorage = Environment.getExternalStorageDirectory();\n\n        if (externalStorage == null || !externalStorage.exists() || !externalStorage.isDirectory() || !externalStorage.canWrite()) {\n            return getContext().getFilesDir().getAbsolutePath();\n        }\n\n        File defaultFolder = new File(externalStorage + File.separator + getContext().getPackageName());\n        if (!defaultFolder.exists()) {\n            defaultFolder = new File(externalStorage + \"/MoneyManagerEx\");\n            if (!defaultFolder.exists()) {\n                //make a directory\n                if (!defaultFolder.mkdirs()) {\n                    return getContext().getFilesDir().getAbsolutePath();\n                }\n            }\n        }\n//        return defaultFolder;\n\n        String databasePath;\n\n        if (defaultFolder.getAbsoluteFile().exists()) {\n            databasePath = defaultFolder.toString();\n        } else {\n            String internalFolder;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) {\n                internalFolder = getContext().getApplicationInfo().dataDir;\n            } else {\n                internalFolder = \"/data/data/\" + getContext().getApplicationContext().getPackageName();\n            }\n            // add databases\n            internalFolder += \"/databases\"; // \"/data.mmb\";\n            databasePath = internalFolder;\n        }\n\n        return databasePath;\n    }\n\n",
    "label": 1,
    "rec": "Gets the directory on external storage where the database is (to be) stored."
  },
  {
    "id": 3104,
    "type": "Summary",
    "comment": "Decodes a QR Code represented as a  BitMatrix.",
    "code": "  public DecoderResult decode(BitMatrix bits) throws ReaderException {\n\n    // Construct a parser and read version, error-correction level\n    BitMatrixParser parser = new BitMatrixParser(bits);\n    Version version = parser.readVersion();\n    ErrorCorrectionLevel ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n\n    // Read codewords\n    byte[] codewords = parser.readCodewords();\n    // Separate into data blocks\n    DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n\n    // Count total number of data bytes\n    int totalBytes = 0;\n    for (int i = 0; i < dataBlocks.length; i++) {\n      totalBytes += dataBlocks[i].getNumDataCodewords();\n    }\n    byte[] resultBytes = new byte[totalBytes];\n    int resultOffset = 0;\n\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (int j = 0; j < dataBlocks.length; j++) {\n      DataBlock dataBlock = dataBlocks[j];\n      byte[] codewordBytes = dataBlock.getCodewords();\n      int numDataCodewords = dataBlock.getNumDataCodewords();\n      correctErrors(codewordBytes, numDataCodewords);\n      for (int i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    }\n\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3105,
    "type": "Summary",
    "comment": "This implementation:  Ensures the  #setSecurityManager(org.apache.shiro.mgt.SecurityManager) securityManager property has been set Creates a  FilterChainManager instance that reflects the configured  #setFilters(java.util.Map) filters and  #setFilterChainDefinitionMap(java.util.Map) filter chain definitions Wraps the FilterChainManager with a suitable  org.apache.shiro.web.filter.mgt.FilterChainResolver FilterChainResolver since the Shiro Filter implementations do not know of  FilterChainManagers Sets both the  SecurityManager and  FilterChainResolver instances on a new Shiro Filter instance and returns that filter instance. ",
    "code": "    protected AbstractShiroFilter createInstance() throws Exception {\n\n        log.debug(\"Creating Shiro Filter instance.\");\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n        //Expose the constructed FilterChainManager by first wrapping it in a\n        // FilterChainResolver implementation. The ShiroFilter implementations\n        // do not know about FilterChainManagers - only resolvers:\n        PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();\n        chainResolver.setFilterChainManager(manager);\n\n        //Now create a ShiroFilter and apply the acquired SecurityManager and built\n        //FilterChainResolver.  It doesn't matter that the ShiroFilter instance is an INI filter\n        //here - we're just using it because it is a concrete ShiroFilter instance that accepts\n        //injection of the SecurityManager and FilterChainResolver:\n        IniShiroFilter shiroFilter = new IniShiroFilter();\n        shiroFilter.setSecurityManager(securityManager);\n        shiroFilter.setFilterChainResolver(chainResolver);\n\n        return shiroFilter;\n    }\n",
    "label": 1,
    "rec": "This implementation:  Ensures the required  #setSecurityManager(org.apache.shiro.mgt.SecurityManager) securityManager property has been set  #createFilterChainManager() Creates a  FilterChainManager instance that reflects the configured  #setFilters(java.util.Map) filters and  #setFilterChainDefinitionMap(java.util.Map) filter chain definitions Wraps the FilterChainManager with a suitable  org.apache.shiro.web.filter.mgt.FilterChainResolver FilterChainResolver since the Shiro Filter implementations do not know of  FilterChainManagers Sets both the  SecurityManager and  FilterChainResolver instances on a new Shiro Filter instance and returns that filter instance. "
  },
  {
    "id": 3106,
    "type": "Summary",
    "comment": "Used for attributes representation.",
    "code": "    public static String getXMLDateStringFromDouble(double d) {\n        if (d == Double.NEGATIVE_INFINITY) {\n            return \"-Infinity\";\n        } else if (d == Double.POSITIVE_INFINITY) {\n            return \"Infinity\";\n        }\n        GregorianCalendar gc = new GregorianCalendar();\n        gc.setTimeInMillis((long) d);\n        String s = dateFactory.newXMLGregorianCalendar(gc).toXMLFormat().substring(0, 23);\n        s = s.endsWith(\"T00:00:00.000\") ? s.substring(0, 10) : s;\n        return s;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3107,
    "type": "Summary",
    "comment": "Default implementation that returns true if the specified authzHeader starts with the same (case-insensitive) characters specified by the  #getAuthzScheme() authzHeaderScheme, false otherwise.",
    "code": "    protected boolean isLoginAttempt(String authzHeader) {\n        String authzScheme = getAuthzScheme().toLowerCase();\n        return authzHeader.toLowerCase().startsWith(authzScheme);\n    }\n",
    "label": 1,
    "rec": "Default implementation that returns true if the specified authzHeader starts with the same (case-insensitive) characters specified by the  #getAuthzScheme() authzScheme, false otherwise."
  },
  {
    "id": 3108,
    "type": "Summary",
    "comment": "Bind view to image at URL",
    "code": "    public AvatarLoader bind(final ImageView view, final User user) {\n        if (user == null)\n            return setImage(loadingAvatar, view);\n\n        final String avatarUrl = user.getAvatarUrl();\n        if (TextUtils.isEmpty(avatarUrl))\n            return setImage(loadingAvatar, view);\n\n        final Integer userId = Integer.valueOf(user.getId());\n\n        BitmapDrawable loadedImage = loaded.get(userId);\n        if (loadedImage != null)\n            return setImage(loadedImage, view);\n\n        setImage(loadingAvatar, view, userId);\n\n        new FetchAvatarTask(context) {\n\n            @Override\n            public BitmapDrawable call() throws Exception {\n                if (!userId.equals(view.getTag(id.iv_avatar)))\n                    return null;\n\n                final BitmapDrawable image = getImage(user);\n                if (image != null)\n                    return image;\n                else\n                    return fetchAvatar(avatarUrl, userId);\n            }\n\n            @Override\n            protected void onSuccess(final BitmapDrawable image) throws Exception {\n                if (image == null)\n                    return;\n                loaded.put(userId, image);\n                if (userId.equals(view.getTag(id.iv_avatar)))\n                    setImage(image, view);\n            }\n\n        }.execute();\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3109,
    "type": "Summary",
    "comment": "Creates a  DocumentCollectionEntity instance",
    "code": "    static DocumentEntity of(String name) throws NullPointerException {\n        return new DefaultDocumentEntity(name);\n    }\n\n",
    "label": 1,
    "rec": "Creates a  DocumentEntity instance"
  },
  {
    "id": 3110,
    "type": "Summary",
    "comment": "Currently, this method does nothing, there is an alternate method to create tasks",
    "code": "    public TodorooCursor<Task> getLocallyCreated(Property<?>[] properties) {\n        return taskDao.query(Query.select(properties).where(Criterion.and(TaskCriteria.isActive(),\n                Task.REMOTE_ID.isNull())));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3111,
    "type": "Summary",
    "comment": "get all get method in psi class",
    "code": "    public static Map<String, String> getAllGetterMethods(PsiClass psiClass, String currentMethodName) {\r\n        Map<String, String> methodNames = new HashMap<String, String>();\r\n        PsiMethod[] psiMethods = null;\r\n        String prefix = \"\";\r\n        //flat field\r\n        if (!currentMethodName.contains(\".\")) {\r\n            psiMethods = psiClass.getAllMethods();\r\n        } else {\r\n            prefix = currentMethodName.substring(0, currentMethodName.lastIndexOf('.'));\r\n            String getterMethod = \"get\" + StringUtil.capitalize(prefix);\r\n            PsiClass psiFieldClass = findGetterMethodReturnType(psiClass, getterMethod);\r\n            if (psiFieldClass != null) {\r\n                psiMethods = psiFieldClass.getAllMethods();\r\n                prefix = prefix + \".\";\r\n            }\r\n        }\r\n        if (psiMethods != null && psiMethods.length > 0) {\r\n            for (PsiMethod psiMethod : psiMethods) {\r\n                String methodName = psiMethod.getName();\r\n                if (methodName.startsWith(\"get\") && psiMethod.getParameterList().getParametersCount() == 0) {\r\n                    String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(\"get\", \"\"));\r\n                    String type = psiMethod.getReturnType().getPresentableText();\r\n                    methodNames.put(name, type);\r\n                }\r\n                if (methodName.startsWith(\"is\") && psiMethod.getParameterList().getParametersCount() == 0) {\r\n                    String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(\"is\", \"\"));\r\n                    String type = psiMethod.getReturnType().getPresentableText();\r\n                    methodNames.put(name, type);\r\n                }\r\n            }\r\n        }\r\n        methodNames.remove(\"class\");    //getClass is controled by JVM\r\n        return methodNames;\r\n    }\r\n\n",
    "label": 1,
    "rec": "get all get method in psi class with return type"
  },
  {
    "id": 3112,
    "type": "Summary",
    "comment": "Creates metrics provider just for testing purposes.",
    "code": "    protected DiscoveryMetricsProvider createMetricsProvider() {\n        return new DiscoveryMetricsProvider() {\n            /** {@inheritDoc} */\n            @Override public ClusterMetrics metrics() { return new DiscoveryMetricsAdapter(); }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3113,
    "type": "Summary",
    "comment": "Creates the directory named by the trailing filename of this file, including the complete directory path required to create this directory.",
    "code": "    public boolean mkdirs() {\n        return mkdirs(false);\n    }\n\n",
    "label": 1,
    "rec": "Creates the directory named by this file, creating missing parent directories if necessary."
  },
  {
    "id": 3114,
    "type": "Summary",
    "comment": "Retrieve instance of  HystrixEventNotifier to use based on order of precedence as defined in  HystrixPlugins class header.",
    "code": "    public HystrixEventNotifier getEventNotifier() {\n        if (notifier != null) {\n            // we have a global override so use it\n            return notifier;\n        } else {\n            // we don't have an injected default nor an override so construct a default\n            return HystrixEventNotifierDefault.getInstance();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3115,
    "type": "Summary",
    "comment": "Returns the height of each row.",
    "code": "    public int getItemHeight()\n    {\n        checkWidget();\n        return itemHeight;\n    }\n\n",
    "label": 1,
    "rec": "Returns the default height of the items in this Grid."
  },
  {
    "id": 3116,
    "type": "Summary",
    "comment": "Add the specified member to the set value stored at key.",
    "code": "    public Long sadd(final String key, final String member) {\n        runChecks();\n        client.sadd(key, member);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3117,
    "type": "Summary",
    "comment": "Returns whether the given model elements are either all library folders or all source folders.",
    "code": "\tprivate boolean allOfSameKind(IFolder[] folders) {\n\t\tint libraryFolderCount = 0;\n\n\t\t// count the library folders in the array\n\t\tfor (IResource folder : folders) {\n\t\t\tif (LibraryFolderManager.getInstance().isInLibraryFolder(folder)) {\n\t\t\t\tlibraryFolderCount++;\n\t\t\t}\n\t\t}\n\n\t\t// If the number of library folders is 0, then all folders are source\n\t\t// folders. If the number of library folders equals the number of given\n\t\t// folders, then all folders are library folders. In any other case,\n\t\t// there is a mixture of library folders and source folders.\n\t\treturn libraryFolderCount == 0 || libraryFolderCount == folders.length;\n\t}\n\n",
    "label": 1,
    "rec": "Returns whether the given folders are either all library folders or all source folders."
  },
  {
    "id": 3118,
    "type": "Summary",
    "comment": "Retrieve (or create) an interned HystrixCommandKey instance for a given name.",
    "code": "        public static HystrixCommandKey asKey(String name) {\n            HystrixCommandKey k = intern.get(name);\n            if (k == null) {\n                k = new HystrixCommandKeyDefault(name);\n                intern.putIfAbsent(name, k);\n            }\n            return k;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3119,
    "type": "Summary",
    "comment": "This method parses a string ala \"00:00\" (hours and minutes) or \"0:00:00\" (days, hours and minutes).",
    "code": "    protected static int parseDuration( String str )\n    {\n        int minutes = 0;\n        if (str == null)\n            return 0;\n\n        try\n        {\n            // for now ignore this special duration notation\n            // because P1M != PT1M but there are wrong edits in OSM! e.g. http://www.openstreetmap.org/way/24791405\n            // http://wiki.openstreetmap.org/wiki/Key:duration\n            if (str.startsWith(\"P\"))\n                return minutes;\n\n            int index = str.indexOf(\":\");\n            if (index > 0)\n            {\n                String hourStr = str.substring(0, index);\n                String minStr = str.substring(index + 1);\n                index = minStr.indexOf(\":\");\n                if (index > 0)\n                {\n                    // string contains seconds too: we ignore them\n                    minStr = minStr.substring(0, index);\n                }\n\n                minutes += Integer.parseInt(hourStr) * 60;\n                minutes += Integer.parseInt(minStr);\n                return minutes;\n            } else\n            {\n                return Integer.parseInt(str);\n            }\n        } catch (Exception ex)\n        {\n            logger.warn(\"Cannot parse \" + str + \" using 0 minutes\");\n        }\n        return minutes;\n    }\n",
    "label": 1,
    "rec": "This method parses a string ala 'hh:mm', format for hours and minutes 'mm', 'hh:mm' or 'hh:mm:ss'"
  },
  {
    "id": 3120,
    "type": "Summary",
    "comment": "Obtains the value generated via the series of next value calls",
    "code": "    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        int count = 0;\n        if(ctx.configuration().jsonProvider().isArray(model)){\n\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            for (Object obj : objects) {\n                if (obj instanceof Number) {\n                    Number value = (Number) obj;\n                    count++;\n                    next(value);\n                }\n            }\n        }\n        if (parameters != null) {\n            for (Parameter param : parameters) {\n                if (param.getCachedValue() instanceof Number) {\n                    Number value = (Number)param.getCachedValue();\n                    count++;\n                    next(value);\n                }\n            }\n        }\n        if (count != 0) {\n            return getValue();\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using empty array\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3121,
    "type": "Summary",
    "comment": "Creates a copy of the given object by an in-memory serialization and subsequent deserialization.",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static IOReadableWritable createCopy(IOReadableWritable original) {\n\n\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tfinal DataOutputStream dos = new DataOutputStream(baos);\n\n\t\ttry {\n\t\t\toriginal.write(dos);\n\t\t} catch (IOException ioe) {\n\t\t\tfail(ioe.getMessage());\n\t\t}\n\n\t\tfinal String className = original.getClass().getName();\n\t\tif (className == null) {\n\t\t\tfail(\"Class name is null\");\n\t\t}\n\n\t\tClass<? extends IOReadableWritable> clazz = null;\n\n\t\ttry {\n\t\t\tclazz = (Class<? extends IOReadableWritable>) Class.forName(className);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (clazz == null) {\n\t\t\tfail(\"Cannot find class with name \" + className);\n\t\t}\n\n\t\tIOReadableWritable copy = null;\n\t\ttry {\n\t\t\tcopy = clazz.newInstance();\n\t\t} catch (InstantiationException e) {\n\t\t\tfail(e.getMessage());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (copy == null) {\n\t\t\tfail(\"Copy of object of type \" + className + \" is null\");\n\t\t}\n\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\t\tfinal DataInputStream dis = new DataInputStream(bais);\n\n\t\ttry {\n\t\t\tcopy.read(dis);\n\t\t} catch (IOException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\treturn copy;\n\t}\n\n",
    "label": 1,
    "rec": "Creates a copy of the given  IOReadableWritable object by an in-memory serialization and subsequent deserialization."
  },
  {
    "id": 3122,
    "type": "Summary",
    "comment": "Authenticates remote client.",
    "code": "    private SecurityContext authenticate(GridRestRequest req) throws IgniteCheckedException {\n        UUID clientId = req.clientId();\n        SecurityContext secCtx = sesMap.get(new SubjectKey(REMOTE_CLIENT, clientId));\n\n        if (secCtx != null)\n            return secCtx;\n\n        // Authenticate client if invalid session.\n        AuthenticationContext authCtx = new AuthenticationContext();\n\n        authCtx.subjectType(REMOTE_CLIENT);\n        authCtx.subjectId(req.clientId());\n\n        GridSecurityCredentials cred;\n\n        if (req.credentials() instanceof GridSecurityCredentials)\n            cred = (GridSecurityCredentials)req.credentials();\n        else if (req.credentials() instanceof String) {\n            String credStr = (String)req.credentials();\n\n            int idx = credStr.indexOf(':');\n\n            cred = idx >= 0 && idx < credStr.length() ?\n                new GridSecurityCredentials(credStr.substring(0, idx), credStr.substring(idx + 1)) :\n                new GridSecurityCredentials(credStr, null);\n        }\n        else {\n            cred = new GridSecurityCredentials();\n\n            cred.setUserObject(req.credentials());\n        }\n\n        authCtx.address(req.address());\n\n        authCtx.credentials(cred);\n\n        SecurityContext subjCtx = ctx.security().authenticate(authCtx);\n\n        if (subjCtx == null) {\n            if (req.credentials() == null)\n                throw new IgniteCheckedException(\"Failed to authenticate remote client (secure session SPI not set?): \" + req);\n            else\n                throw new IgniteCheckedException(\"Failed to authenticate remote client (invalid credentials?): \" + req);\n        }\n\n        return subjCtx;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3123,
    "type": "Summary",
    "comment": "Read the byte stream and process up to chunksize bytes,",
    "code": "  @Override\n  public final boolean dealWithBytes(InputStream inputStream)\n    throws IOException, ManifoldCFException\n  {\n    while (true)\n    {\n      int amt = inputStream.read(byteBuffer);\n      if (amt == -1)\n        return false;\n      for (int i = 0; i < amt; i++)\n      {\n        if (dealWithByte(byteBuffer[i]))\n          return true;\n      }\n    }\n  }\n\n",
    "label": 1,
    "rec": "Read a byte stream and process bytes."
  },
  {
    "id": 3124,
    "type": "Summary",
    "comment": "Bind  Object#toString() to given  WebView",
    "code": "    public static WebView showSource(WebView view, String name, final Object provider) {\n        view.setWebViewClient(new WebViewClient() {\n\n            public boolean shouldOverrideUrlLoading(WebView view, String url) {\n                view.loadUrl(url);\n                return true;\n            }\n\n        });\n        int suffix = name.lastIndexOf('.');\n        final String brush;\n        if (suffix != -1 && suffix + 2 < name.length())\n            brush = \"brush: \" + name.substring(suffix + 1) + \";\";\n        else\n            brush = \"\";\n        view.getSettings().setJavaScriptEnabled(true);\n        view.getSettings().setBuiltInZoomControls(true);\n        view.addJavascriptInterface(new Object() {\n            public String toString() {\n                return \"<script type=\\\"syntaxhighlighter\\\" class=\\\"toolbar:false;\" + brush + \"\\\"><![CDATA[\\n\"\n                        + provider.toString() + \"\\n]]></script>\";\n            }\n\n        }, \"SourceProvider\");\n        view.loadUrl(\"file:///android_asset/source-editor.html\");\n        return view;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3125,
    "type": "Summary",
    "comment": "This method should be overridden by subclasses to change configuration parameters.",
    "code": "    protected IgniteConfiguration getConfiguration(GridTestResources rsrcs) throws Exception {\n        return getConfiguration(getTestGridName(), rsrcs);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3126,
    "type": "Summary",
    "comment": "Uses the principal found in the Account parameter (not the authentication token) to construct a  org.jsecurity.authc.event.SuccessfulAuthenticationEvent",
    "code": "    public AuthenticationEvent createSuccessEvent(AuthenticationToken token, AuthenticationInfo info) {\n        return new SuccessfulAuthenticationEvent(token, info);\n    }\n",
    "label": 1,
    "rec": "Uses the principal found in the AuthenticationInfo parameter (not the authentication token) to construct a  org.jsecurity.authc.event.SuccessfulAuthenticationEvent"
  },
  {
    "id": 3127,
    "type": "Summary",
    "comment": "Returns a factory closure that creates new  AtomicBoolean instance initialized to  false.",
    "code": "    public static GridCallable<AtomicBoolean> newAtomicBoolean() {\n        return ATOMIC_BOOL_FACTORY;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3128,
    "type": "Summary",
    "comment": "Returns a list of values whose time intervals overlap with a [ low,  high] time interval.",
    "code": "\tpublic List<T> getValues(Interval<T> interval) {\n\t\tList<T> result = new ArrayList<T>();\n\t\tfor (Interval<T> i : intervalTree.search(interval))\n\t\t\tresult.add(i.getValue());\n\t\treturn result;\n\t}\n",
    "label": 1,
    "rec": "Returns a list of values whose time intervals overlap with a given time interval."
  },
  {
    "id": 3129,
    "type": "Summary",
    "comment": "Cache configuration.",
    "code": "    protected CacheConfiguration cacheConfiguration(String gridName) throws Exception {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n        cfg.setCacheMode(PARTITIONED);\n        cfg.setStartSize(700000);\n        cfg.setWriteSynchronizationMode(FULL_ASYNC);\n        cfg.setEvictionPolicy(null);\n        cfg.setBackups(1);\n        cfg.setDistributionMode(PARTITIONED_ONLY);\n        cfg.setPreloadPartitionedDelay(-1);\n        cfg.setBackups(1);\n\n        GridCacheQueryConfiguration qcfg = new GridCacheQueryConfiguration();\n\n        qcfg.setIndexPrimitiveKey(true);\n\n        cfg.setQueryConfiguration(qcfg);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3130,
    "type": "Summary",
    "comment": "Fetch the result of a given action from a given result vector ",
    "code": "    public static List fetchAllActionResults(\n        List resultList,\n        int action, \n        List actionResultList\n    ) {\n        for (int i = 0; i < resultList.size(); i++) {\n            //\n            // Check the result of every action whether it matches the given action\n            //\n            WSSecurityEngineResult result = \n                (WSSecurityEngineResult) resultList.get(i);\n            int resultAction = \n                ((java.lang.Integer)result.get(WSSecurityEngineResult.TAG_ACTION)).intValue();\n            if (resultAction == action) {\n                actionResultList.add(result);\n            }\n        }\n        return actionResultList;\n    }\n\n",
    "label": 1,
    "rec": "Fetch the result of a given action from a given result list."
  },
  {
    "id": 3131,
    "type": "Summary",
    "comment": "Returns an object that implements all of the interfaces implemented by the specified objects.",
    "code": "    public static Object create(Object[] delegates, ClassLoader loader) {\n        Info info = getInfo(delegates);\n        return createHelper(null, info.interfaces, delegates, info.routing, loader);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3132,
    "type": "Summary",
    "comment": "ReadNote",
    "code": "    @Processor\n    @InvalidateConnectionOn(exception = NotAuthenticatedException.class)\n    public Note readNote(String objectId) {\n        return (Note) read(ServiceSourceCollection.Notes, objectId);\n    }\n\n",
    "label": 1,
    "rec": "Fetches the note identified by the object id in the collection."
  },
  {
    "id": 3133,
    "type": "Summary",
    "comment": "Return the sorted set cardinality (number of elements).",
    "code": "    public Long zcard(final String key) {\n        runChecks();\n        client.zcard(key);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3134,
    "type": "Summary",
    "comment": "This method decides if a property chunk is needed in order to store selected values of tag.",
    "code": "    private boolean isExtendedContentDescriptionMandatory(Tag tag)\n    {\n        /*\n         * last changes store all values in extended content description. Even those which are normally\n         * stored in the content description chunk.\n         * The content description chunk is still provided for legacy applications. \n         */\n        return !tag.isEmpty();\n    }\n\n",
    "label": 1,
    "rec": "This method decides if an extended property chunk is needed in order to store selected values of tag."
  },
  {
    "id": 3135,
    "type": "Summary",
    "comment": "Stratified sampling",
    "code": "  public static Frame sampleFrameStratified(final Frame fr, Vec label, final float[] sampling_ratios, final long seed, final boolean debug) {\n    return sampleFrameStratified(fr, label, sampling_ratios, seed, debug, 0);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3136,
    "type": "Summary",
    "comment": "truststore and truststore-password must be set if ssl-not-required and disable-trust-manager are both false.",
    "code": "    public static boolean validateTruststoreSetIfRequired(ModelNode attributes) {\n        if (isSet(attributes, DISABLE_TRUST_MANAGER)) {\n            return true;\n        }\n\n        if (isSet(attributes, SSL_REQUIRED) && attributes.get(SSL_REQUIRED.getName()).asString().equals(\"none\")) {\n            return true;\n        }\n\n        return isSet(attributes, TRUSTSTORE) && isSet(attributes, TRUSTSTORE_PASSWORD);\n    }\n",
    "label": 1,
    "rec": "truststore and truststore-password must be set if ssl-required is not none and disable-trust-manager is false."
  },
  {
    "id": 3137,
    "type": "Summary",
    "comment": "Method returns callable for execution all update operations in async and sync mode.",
    "code": "    private Callable<Long> internalUpdate(final long l, final boolean updated) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteTx tx = CU.txStartInternal(ctx, seqView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicSequenceValue seq = seqView.get(key);\n\n                    checkRemoved();\n\n                    assert seq != null;\n\n                    long curLocVal;\n\n                    long newUpBound;\n\n                    lock.lock();\n\n                    try {\n                        curLocVal = locVal;\n\n                        // If local range was already reserved in another thread.\n                        if (locVal + l <= upBound) {\n                            long retVal = locVal;\n\n                            locVal += l;\n\n                            return updated ? locVal : retVal;\n                        }\n\n                        long curGlobalVal = seq.get();\n\n                        long newLocVal;\n\n                        /* We should use offset because we already reserved left side of range.*/\n                        long off = batchSize > 1 ? batchSize - 1 : 1;\n\n                        // Calculate new values for local counter, global counter and upper bound.\n                        if (curLocVal + l >= curGlobalVal) {\n                            newLocVal = curLocVal + l;\n\n                            newUpBound = newLocVal + off;\n                        }\n                        else {\n                            newLocVal = curGlobalVal;\n\n                            newUpBound = newLocVal + off;\n                        }\n\n                        locVal = newLocVal;\n                        upBound = newUpBound;\n\n                        if (updated)\n                            curLocVal = newLocVal;\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n\n                    // Global counter must be more than reserved upper bound.\n                    seq.set(newUpBound + 1);\n\n                    seqView.put(key, seq);\n\n                    tx.commit();\n\n                    return curLocVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to get and add: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3138,
    "type": "Summary",
    "comment": "Get the  WritableComparable comparator used to compare keys.",
    "code": "  public RawComparator getOutputKeyComparator() {\n    Class theClass = getClass(\"mapred.output.key.comparator.class\", null,\n    \t\tRawComparator.class);\n    if (theClass != null)\n      return (RawComparator)ReflectionUtils.newInstance(theClass, this);\n    return WritableComparator.get(getMapOutputKeyClass());\n  }\n\n",
    "label": 1,
    "rec": "Get the  RawComparator comparator used to compare keys."
  },
  {
    "id": 3139,
    "type": "Summary",
    "comment": "Gets a list of all grids started so far.",
    "code": "    public static List<Grid> allGrids() {\n        return GridGainEx.allGrids();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3140,
    "type": "Summary",
    "comment": "Returns a handle to file identified by the given URI.",
    "code": "  public IFile file(URI uri) {\n    IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n    IPath path = pathOf(uri);\n    return (path != null) ? root.getFile(path) : null;\n  }\n\n",
    "label": 1,
    "rec": "Returns a handle to a workspace file identified by the given URI."
  },
  {
    "id": 3141,
    "type": "Summary",
    "comment": "Commits local part of colocated transaction.",
    "code": "    public IgniteFuture<GridCacheTx> commitAsyncLocal() {\n        if (log.isDebugEnabled())\n            log.debug(\"Committing colocated tx locally: \" + this);\n\n        // In optimistic mode prepare was called explicitly.\n        if (pessimistic())\n            prepareAsync();\n\n        IgniteFuture<GridCacheTxEx<K, V>> prep = prepFut.get();\n\n        // Do not create finish future if there are no remote nodes.\n        if (F.isEmpty(dhtMap) && F.isEmpty(nearMap)) {\n            if (prep != null)\n                return (IgniteFuture<GridCacheTx>)(IgniteFuture)prep;\n\n            return new GridFinishedFuture<GridCacheTx>(cctx.kernalContext(), this);\n        }\n\n        final GridDhtTxFinishFuture<K, V> fut = new GridDhtTxFinishFuture<>(cctx, this, /*commit*/true);\n\n        cctx.mvcc().addFuture(fut);\n\n        if (prep == null || prep.isDone()) {\n            assert prep != null || optimistic();\n\n            try {\n                if (prep != null)\n                    prep.get(); // Check for errors of a parent future.\n\n                fut.finish();\n            }\n            catch (GridCacheTxOptimisticException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                fut.onError(e);\n            }\n            catch (IgniteCheckedException e) {\n                U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                fut.onError(e);\n            }\n        }\n        else\n            prep.listenAsync(new CI1<IgniteFuture<GridCacheTxEx<K, V>>>() {\n                @Override public void apply(IgniteFuture<GridCacheTxEx<K, V>> f) {\n                    try {\n                        f.get(); // Check for errors of a parent future.\n\n                        fut.finish();\n                    }\n                    catch (GridCacheTxOptimisticException e) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Failed optimistically to prepare transaction [tx=\" + this + \", e=\" + e + ']');\n\n                        fut.onError(e);\n                    }\n                    catch (IgniteCheckedException e) {\n                        U.error(log, \"Failed to prepare transaction: \" + this, e);\n\n                        fut.onError(e);\n                    }\n                }\n            });\n\n        return fut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3142,
    "type": "Summary",
    "comment": "Method to read a key present in the HTTP request URI",
    "code": "    private List<ByteArray> readKey(String requestURI) {\n        List<ByteArray> keyList = null;\n        String[] parts = requestURI.split(\"/\");\n        if(parts.length > 2) {\n            String base64KeyList = parts[2];\n            keyList = new ArrayList<ByteArray>();\n\n            if(!base64KeyList.contains(\",\")) {\n                String rawKey = base64KeyList.trim();\n                keyList.add(new ByteArray(Base64.decodeBase64(rawKey.getBytes())));\n            } else {\n                String[] base64KeyArray = base64KeyList.split(\",\");\n                for(String base64Key: base64KeyArray) {\n                    String rawKey = base64Key.trim();\n                    keyList.add(new ByteArray(Base64.decodeBase64(rawKey.getBytes())));\n                }\n            }\n        }\n        return keyList;\n    }\n\n",
    "label": 1,
    "rec": "Method to read a key (or keys) present in the HTTP request URI."
  },
  {
    "id": 3143,
    "type": "Summary",
    "comment": "Send HTTP request and wait response from the server.",
    "code": "\tprotected String sendQuery(String query) throws IhcExecption {\n\t\ttry {\n\t\t\treturn sendQ(query);\n\t\t} catch (NoHttpResponseException e) {\n\t\t\ttry {\n\t\t\t\tlogger.debug(\"No response received, resend query\");\n\t\t\t\treturn sendQ(query);\n\t\t\t} catch (IOException ee) {\n\t\t\t\tthrow new IhcExecption(ee);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new IhcExecption(e);\n\t\t} \n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3144,
    "type": "Summary",
    "comment": "Builds an  org.jsecurity.realm.support.ldap.LdapDirectoryInfo object by querying the active directory LDAP context for the specified username. This method can be overridden by subclasses to query the LDAP server in a more complex way.",
    "code": "    protected LdapSecurityInfo queryForLdapDirectoryInfo(String username, LdapContext ctx) throws NamingException {\n\n        LdapSecurityInfo info = new LdapSecurityInfo();\n\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        String searchFilter = \"(&(objectClass=*)(userPrincipalName=\" + username + \"))\";\n\n        // Perform context search\n        NamingEnumeration answer = ctx.search(searchBase, searchFilter, searchCtls);\n\n        while (answer.hasMoreElements()) {\n            SearchResult sr = (SearchResult) answer.next();\n\n            log.debug(\"Retrieving group names for user [\" + sr.getName() + \"]\");\n\n            Attributes attrs = sr.getAttributes();\n\n            if (attrs != null) {\n                NamingEnumeration ae = attrs.getAll();\n                while( ae.hasMore() ) {\n                    Attribute attr = (Attribute) ae.next();\n                    processAttribute(info, attr);\n                }\n            }\n        }\n\n        return info;\n    }\n",
    "label": 1,
    "rec": "Builds an  LdapSecurityInfo object by querying the active directory LDAP context for the specified username. This method can be overridden by subclasses to query the LDAP server in a more complex way."
  },
  {
    "id": 3145,
    "type": "Summary",
    "comment": "Finds the manufacturer in the database.",
    "code": "\tpublic boolean FindManufacturer(int manufacturerId) {\n\t\tif(database == null)\n\t\t\treturn false;\n\t\t\n\t\tselManufacturer = null;\n\t\tselProduct = null;\n\t\tproductFile = null;\n\t\t\n\t\tfor(ZWaveDbManufacturer manufacturer : database.Manufacturer) {\n\t\t\tif(manufacturer.Id == manufacturerId) {\n\t\t\t\tselManufacturer = manufacturer;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3146,
    "type": "Summary",
    "comment": "Queries for all of the results this statement returns from a DB cursor in the form of the  ModelClass",
    "code": "    @Override\n    public List<TModel> queryList() {\n        checkSelect(\"query\");\n        return super.queryList();\n    }\n\n",
    "label": 1,
    "rec": "Queries for all of the results this statement returns from a DB cursor in the form of the  TModel"
  },
  {
    "id": 3147,
    "type": "Summary",
    "comment": "Heuristically checks if exception was caused by invalid HDFS version and returns appropriate exception.",
    "code": "    private IgfsException handleSecondaryFsError(IOException e, String detailMsg) {\n        return cast(detailMsg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3148,
    "type": "Summary",
    "comment": "This method is useful when you do not have a root node in your content.",
    "code": "    public static Node buildNode(String content) {\n        return buildNode(null, content);\n    }\n\n",
    "label": 1,
    "rec": "Construct a node structure for the given content."
  },
  {
    "id": 3149,
    "type": "Summary",
    "comment": "Can the given event be rendered by this view holder?",
    "code": "    public static boolean isValid(final GithubEvent event) {\n        if (event == null)\n            return false;\n\n        if (event.payload == null)\n            return false;\n\n        Gson gson = new Gson();\n        final String json = gson.toJson(event.payload);\n\n        final String type = event.type.toString();\n        if (TextUtils.isEmpty(type))\n            return false;\n\n        return TYPE_COMMIT_COMMENT.equals(type) //\n                || (TYPE_CREATE.equals(type) //\n                && (gson.fromJson(json, CreatedEventPayload.class)).ref_type != null) //\n                || TYPE_DELETE.equals(type) //\n                || TYPE_DOWNLOAD.equals(type) //\n                || TYPE_FOLLOW.equals(type) //\n                || TYPE_FORK.equals(type) //\n                || TYPE_FORK_APPLY.equals(type) //\n                || (TYPE_GIST.equals(type)\n                && (gson.fromJson(json, GistEventPayload.class)).gist != null)\n                || TYPE_GOLLUM.equals(type) //\n                || (TYPE_ISSUE_COMMENT.equals(type) //\n                && (gson.fromJson(json, IssueCommentEventPayload.class)).issue != null) //\n                || (TYPE_ISSUES.equals(type) //\n                && (gson.fromJson(json, IssueEventPayload.class)).issue != null) //\n                || TYPE_MEMBER.equals(type) //\n                || TYPE_PUBLIC.equals(type) //\n                || TYPE_PULL_REQUEST.equals(type) //\n                || TYPE_PULL_REQUEST_REVIEW_COMMENT.equals(type) //\n                || TYPE_PUSH.equals(type) //\n                || TYPE_TEAM_ADD.equals(type) //\n                || TYPE_WATCH.equals(type);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3150,
    "type": "Summary",
    "comment": "Get the output stream where the events will be serialized to.",
    "code": "    public OutputStream getOutputStream() throws StreamException {\n        if (outputStream != null) {\n            closeStartTag();\n            flushBuffer();\n            return outputStream;\n        } else {\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get the output stream events are serialized to."
  },
  {
    "id": 3151,
    "type": "Summary",
    "comment": "Factory method to provide  ThreadPoolExecutor instances as desired.",
    "code": "    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixProperty<Integer> corePoolSize, HystrixProperty<Integer> maximumPoolSize, HystrixProperty<Integer> keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n        ThreadFactory threadFactory = null;\n        if (!PlatformSpecific.isAppEngine()) {\n            threadFactory = new ThreadFactory() {\n                protected final AtomicInteger threadNumber = new AtomicInteger(0);\n\n                @Override\n                public Thread newThread(Runnable r) {\n                    Thread thread = new Thread(r, \"hystrix-\" + threadPoolKey.name() + \"-\" + threadNumber.incrementAndGet());\n                    thread.setDaemon(true);\n                    return thread;\n                }\n\n            };\n        } else {\n            threadFactory = PlatformSpecific.getAppEngineThreadFactory();\n        }\n\n        return new ThreadPoolExecutor(corePoolSize.get(), maximumPoolSize.get(), keepAliveTime.get(), unit, workQueue, threadFactory);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3152,
    "type": "Summary",
    "comment": "Parses the given JSON input using the default  Configuration and returns a  ReadContext for path evaluation",
    "code": "    public static DocumentContext parse(Object json) {\n        return new JsonReader().parse(json);\n    }\n",
    "label": 1,
    "rec": "Parses the given JSON input using the default  Configuration and returns a  DocumentContext for path evaluation"
  },
  {
    "id": 3153,
    "type": "Summary",
    "comment": "Given a spend request containing an incomplete transaction, makes it valid by adding inputs and outputs according to the instructions in the request.",
    "code": "    public boolean completeTx(SendRequest req) {\n        lock.lock();\n        try {\n            Preconditions.checkArgument(!req.completed, \"Given SendRequest has already been completed.\");\n            // Calculate the amount of value we need to import.\n            BigInteger value = BigInteger.ZERO;\n            for (TransactionOutput output : req.tx.getOutputs()) {\n                value = value.add(output.getValue());\n            }\n            BigInteger totalOutput = value;\n\n            log.info(\"Completing send tx with {} outputs totalling {} (not including fees)\",\n                    req.tx.getOutputs().size(), bitcoinValueToFriendlyString(value));\n\n            // If any inputs have already been added, we don't need to get their value from wallet\n            BigInteger totalInput = BigInteger.ZERO;\n            for (TransactionInput input : req.tx.getInputs())\n                if (input.getConnectedOutput() != null)\n                    totalInput = totalInput.add(input.getConnectedOutput().getValue());\n                else\n                    log.warn(\"SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.\");\n            value = value.subtract(totalInput);\n\n            List<TransactionInput> originalInputs = new ArrayList<TransactionInput>(req.tx.getInputs());\n\n            // We need to know if we need to add an additional fee because one of our values are smaller than 0.01 BTC\n            boolean needAtLeastReferenceFee = false;\n            if (req.ensureMinRequiredFee) {\n                for (TransactionOutput output : req.tx.getOutputs())\n                    if (output.getValue().compareTo(Utils.CENT) < 0) {\n                        needAtLeastReferenceFee = true;\n                        break;\n                    }\n            }\n\n            // Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us\n            // with the actual outputs that'll be used to gather the required amount of value. In this way, users\n            // can customize coin selection policies.\n            //\n            // Note that this code is poorly optimized: the spend candidates only alter when transactions in the wallet\n            // change - it could be pre-calculated and held in RAM, and this is probably an optimization worth doing.\n            // Note that output.isMine(this) needs to test the keychain which is currently an array, so it's\n            // O(candidate outputs ^ keychain.size())! There's lots of low hanging fruit here.\n            LinkedList<TransactionOutput> candidates = calculateSpendCandidates(true);\n            Address changeAddress = req.changeAddress;\n            int minSize = 0;\n            // There are 3 possibilities for what adding change might do:\n            // 1) No effect\n            // 2) Causes increase in fee (change < 0.01 COINS)\n            // 3) Causes the transaction to have a dust output or change < fee increase (ie change will be thrown away)\n            // If we get either of the last 2, we keep note of what the inputs looked like at the time and move try to\n            // add inputs as we go up the list (keeping track of minimum inputs for each category).  At the end, we pick\n            // the best input set as the one which generates the lowest total fee.\n            BigInteger additionalValueForNextCategory = null;\n            CoinSelection selection3 = null;\n            CoinSelection selection2 = null; TransactionOutput selection2Change = null;\n            CoinSelection selection1 = null; TransactionOutput selection1Change = null;\n            while (true) {\n                req.tx.clearInputs();\n                for (TransactionInput input : originalInputs)\n                    req.tx.addInput(input);\n\n                BigInteger fees = req.fee.add(BigInteger.valueOf(minSize/1000).multiply(req.feePerKb));\n                if (needAtLeastReferenceFee && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)\n                    fees = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;\n\n                BigInteger valueNeeded = value.add(fees);\n                if (additionalValueForNextCategory != null)\n                    valueNeeded = valueNeeded.add(additionalValueForNextCategory);\n                BigInteger additionalValueSelected = additionalValueForNextCategory;\n\n                // Of the coins we could spend, pick some that we actually will spend.\n                CoinSelection selection = coinSelector.select(valueNeeded, candidates);\n                // Can we afford this?\n                if (selection.valueGathered.compareTo(valueNeeded) < 0)\n                    break;\n                checkState(selection.gathered.size() > 0 || originalInputs.size() > 0);\n\n                // We keep track of an upper bound on transaction size to calculate fees that need added\n                // Note that the difference between the upper bound and lower bound is usually small enough that it\n                // will be very rare that we pay a fee we do not need to\n                int size = 0;\n\n                // We can't be sure a selection is valid until we check fee per kb at the end, so we just store them here temporarily\n                boolean eitherCategory2Or3 = false;\n                boolean isCategory3 = false;\n\n                BigInteger change = selection.valueGathered.subtract(valueNeeded);\n                if (additionalValueSelected != null)\n                    change = change.add(additionalValueSelected);\n\n                TransactionOutput changeOutput = null;\n                // If change is < 0.01 BTC, we will need to have at least minfee to be accepted by the network\n                if (req.ensureMinRequiredFee && !change.equals(BigInteger.ZERO) &&\n                        change.compareTo(Utils.CENT) < 0 && fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0) {\n                    // This solution may fit into category 2, but it may also be category 3, we'll check that later\n                    eitherCategory2Or3 = true;\n                    additionalValueForNextCategory = Utils.CENT;\n                    // If the change is smaller than the fee we want to add, this will be negative\n                    change = change.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(fees));\n                }\n\n                if (change.compareTo(BigInteger.ZERO) > 0) {\n                    // The value of the inputs is greater than what we want to send. Just like in real life then,\n                    // we need to take back some coins ... this is called \"change\". Add another output that sends the change\n                    // back to us. The address comes either from the request or getChangeAddress() as a default..\n                    if (changeAddress == null)\n                        changeAddress = getChangeAddress();\n                    changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);\n                    // If the change output would result in this transaction being rejected as dust, just drop the change and make it a fee\n                    if (req.ensureMinRequiredFee && Transaction.MIN_NONDUST_OUTPUT.compareTo(change) >= 0) {\n                        // This solution definitely fits in category 3\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(\n                                                         Transaction.MIN_NONDUST_OUTPUT.add(BigInteger.ONE));\n                    } else {\n                        size += changeOutput.bitcoinSerialize().length + VarInt.sizeOf(req.tx.getOutputs().size()) - VarInt.sizeOf(req.tx.getOutputs().size() - 1);\n                        // This solution is either category 1 or 2\n                        if (!eitherCategory2Or3) // must be category 1\n                            additionalValueForNextCategory = null;\n                    }\n                } else {\n                    if (eitherCategory2Or3) {\n                        // This solution definitely fits in category 3 (we threw away change because it was smaller than MIN_TX_FEE)\n                        isCategory3 = true;\n                        additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);\n                    }\n                }\n\n                for (TransactionOutput output : selection.gathered) {\n                    req.tx.addInput(output);\n                    // If the scriptBytes don't default to none, our size calculations will be thrown off\n                    checkState(req.tx.getInput(req.tx.getInputs().size()-1).getScriptBytes().length == 0);\n                    try {\n                        if (output.getScriptPubKey().isSentToAddress()) {\n                            // Send-to-address spends usually take maximum pubkey.length (as it may be compressed or not) + 75 bytes\n                            size += this.findKeyFromPubHash(output.getScriptPubKey().getPubKeyHash()).getPubKey().length + 75;\n                        } else if (output.getScriptPubKey().isSentToRawPubKey())\n                            size += 74; // Send-to-pubkey spends usually take maximum 74 bytes to spend\n                        else\n                            throw new RuntimeException(\"Unknown output type returned in coin selection\");\n                    } catch (ScriptException e) {\n                        // If this happens it means an output script in a wallet tx could not be understood. That should never\n                        // happen, if it does it means the wallet has got into an inconsistent state.\n                        throw new RuntimeException(e);\n                    }\n                }\n\n                // Estimate transaction size and loop again if we need more fee per kb\n                size += req.tx.bitcoinSerialize().length;\n                if (size/1000 > minSize/1000 && req.feePerKb.compareTo(BigInteger.ZERO) > 0) {\n                    minSize = size;\n                    // We need more fees anyway, just try again with the same additional value\n                    additionalValueForNextCategory = additionalValueSelected;\n                    continue;\n                }\n\n                if (isCategory3) {\n                    if (selection3 == null)\n                        selection3 = selection;\n                } else if (eitherCategory2Or3) {\n                    // If we are in selection2, we will require at least CENT additional. If we do that, there is no way\n                    // we can end up back here because CENT additional will always get us to 1\n                    checkState(selection2 == null);\n                    checkState(additionalValueForNextCategory.equals(Utils.CENT));\n                    selection2 = selection;\n                    selection2Change = checkNotNull(changeOutput); // If we get no change in category 2, we are actually in category 3\n                } else {\n                    // Once we get a category 1 (change kept), we should break out of the loop because we can't do better\n                    checkState(selection1 == null);\n                    checkState(additionalValueForNextCategory == null);\n                    selection1 = selection;\n                    selection1Change = changeOutput;\n                }\n\n                if (additionalValueForNextCategory != null) {\n                    if (additionalValueSelected != null)\n                        checkState(additionalValueForNextCategory.compareTo(additionalValueSelected) > 0);\n                    continue;\n                }\n                break;\n            }\n\n            req.tx.clearInputs();\n            for (TransactionInput input : originalInputs)\n                req.tx.addInput(input);\n\n            if (selection3 == null && selection2 == null && selection1 == null) {\n                log.warn(\"Insufficient value in wallet for send\");\n                // TODO: Should throw an exception here.\n                return false;\n            }\n\n            BigInteger lowestFee = null;\n            CoinSelection bestCoinSelection = null;\n            TransactionOutput bestChangeOutput = null;\n            if (selection1 != null) {\n                if (selection1Change != null)\n                    lowestFee = selection1.valueGathered.subtract(selection1Change.getValue());\n                else\n                    lowestFee = selection1.valueGathered;\n                bestCoinSelection = selection1;\n                bestChangeOutput = selection1Change;\n            }\n\n            if (selection2 != null) {\n                BigInteger fee = selection2.valueGathered.subtract(checkNotNull(selection2Change).getValue());\n                if (lowestFee == null || fee.compareTo(lowestFee) < 0) {\n                    lowestFee = fee;\n                    bestCoinSelection = selection2;\n                    bestChangeOutput = selection2Change;\n                }\n            }\n\n            if (selection3 != null) {\n                if (lowestFee == null || selection3.valueGathered.compareTo(lowestFee) < 0) {\n                    bestCoinSelection = selection3;\n                    bestChangeOutput = null;\n                }\n            }\n\n            for (TransactionOutput output : bestCoinSelection.gathered)\n                req.tx.addInput(output);\n\n            totalInput = totalInput.add(bestCoinSelection.valueGathered);\n\n            req.tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);\n\n            if (bestChangeOutput != null) {\n                req.tx.addOutput(bestChangeOutput);\n                totalOutput = totalOutput.add(bestChangeOutput.getValue());\n                log.info(\"  with {} coins change\", bitcoinValueToFriendlyString(bestChangeOutput.getValue()));\n            }\n\n            // Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.\n            try {\n                req.tx.signInputs(Transaction.SigHash.ALL, this, req.aesKey);\n            } catch (ScriptException e) {\n                // If this happens it means an output script in a wallet tx could not be understood. That should never\n                // happen, if it does it means the wallet has got into an inconsistent state.\n                throw new RuntimeException(e);\n            }\n\n            // Check size.\n            int size = req.tx.bitcoinSerialize().length;\n            if (size > Transaction.MAX_STANDARD_TX_SIZE) {\n                // TODO: Throw an exception here.\n                log.error(\"Transaction could not be created without exceeding max size: {} vs {}\", size,\n                          Transaction.MAX_STANDARD_TX_SIZE);\n                return false;\n            }\n\n            // Label the transaction as being self created. We can use this later to spend its change output even before\n            // the transaction is confirmed.\n            req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);\n\n            req.completed = true;\n            req.fee = totalInput.subtract(totalOutput);\n            log.info(\"  completed {} with {} inputs\", req.tx.getHashAsString(), req.tx.getInputs().size());\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3154,
    "type": "Summary",
    "comment": "Returns the left side operand.",
    "code": "        public Predicate<? super E> getLeftPredicate() {\r\n            return left;\r\n        }\r\n\n",
    "label": 1,
    "rec": "Returns the left side Predicate."
  },
  {
    "id": 3155,
    "type": "Summary",
    "comment": "Invoke the handler, wrapping any exception to a  ListenerExecutionFailedException with a dedicated error message.",
    "code": "\tprivate Object invokeHandler(ConsumerRecord<K, V> record, Acknowledgment acknowledgment, Message<?> message) {\n\t\tif (this.deDuplicationStrategy != null && this.deDuplicationStrategy.isDuplicate(record)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\treturn this.handlerMethod.invoke(message, record, acknowledgment);\n\t\t}\n\t\tcatch (org.springframework.messaging.converter.MessageConversionException ex) {\n\t\t\tthrow new ListenerExecutionFailedException(createMessagingErrorMessage(\"Listener method could not \" +\n\t\t\t\t\t\"be invoked with the incoming message\", message.getPayload()),\n\t\t\t\t\tnew MessageConversionException(\"Cannot handle message\", ex));\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\tthrow new ListenerExecutionFailedException(createMessagingErrorMessage(\"Listener method could not \" +\n\t\t\t\t\t\"be invoked with the incoming message\", message.getPayload()), ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Listener method '\" +\n\t\t\t\t\tthis.handlerMethod.getMethodAsString(message.getPayload()) + \"' threw exception\", ex);\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3156,
    "type": "Summary",
    "comment": "Check whether a given local variable is known to be non null, either because it is definitely non null, or because is has been tested against non null.",
    "code": "public boolean cannotBeNull(VariableBinding binding) {\n\treturn isDefinitelyNonNull(binding) || isProtectedNonNull(binding);\n}\n\n",
    "label": 1,
    "rec": "Check whether a given field or local variable is known to be non null, either because it is definitely non null, or because is has been tested against non null."
  },
  {
    "id": 3157,
    "type": "Summary",
    "comment": "Pops resource requests off the queue until queue is empty or an unexpired resource request is found.",
    "code": "    private AsyncResourceRequest<V> getNextUnexpiredResourceRequest(Queue<AsyncResourceRequest<V>> requestQueue) {\n        AsyncResourceRequest<V> resourceRequest = requestQueue.poll();\n        while(resourceRequest != null) {\n            if(resourceRequest.getDeadlineNs() < System.nanoTime()) {\n                resourceRequest.handleTimeout();\n                resourceRequest = requestQueue.poll();\n            } else {\n                break;\n            }\n        }\n        return resourceRequest;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3158,
    "type": "Summary",
    "comment": "Checks if a zip file contains a specified entry name.",
    "code": "    public static boolean hasEntry(File file, String searchedEntryName)\n            throws IOException {\n        List<String> elements = getEntryNames(file);\n        return elements.contains(searchedEntryName);\n    }\n\n",
    "label": 1,
    "rec": "Checks if a zip file contains a specified searchedEntryName"
  },
  {
    "id": 3159,
    "type": "Summary",
    "comment": "Executes given closure either locally or on specified node.",
    "code": "    private IgniteFuture<GridRestResponse> execute(UUID destId, String cacheName, Callable<GridRestResponse> c) {\n        boolean locExec = destId == null || destId.equals(ctx.localNodeId()) || replicatedCacheAvailable(cacheName);\n\n        if (locExec)\n            return ctx.closure().callLocalSafe(c, false);\n        else {\n            if (ctx.discovery().node(destId) == null)\n                return new GridFinishedFutureEx<>(new IgniteCheckedException(\"Destination node ID has left the grid (retry \" +\n                    \"the query): \" + destId));\n\n            try {\n                IgniteCompute comp = ctx.grid().compute(ctx.grid().forNodeId(destId)).withNoFailover().enableAsync();\n\n                comp.call(c);\n\n                return comp.future();\n            }\n            catch (IgniteCheckedException e) {\n                // Should not be thrown since uses asynchronous execution.\n                return new GridFinishedFutureEx<>(e);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3160,
    "type": "Summary",
    "comment": "Get a SharedObjectDescription for a replica to be created on a given receiver.",
    "code": "\tprotected RemoteSharedObjectDescription getReplicaDescription(ID receiver) {\n\t\treturn new RemoteSharedObjectDescription(getID(), getClass().getName(),\n\t    \t\tgetConfig().getProperties());\n\t}\n\n",
    "label": 1,
    "rec": "Get a RemoteSharedObjectDescription for a replica to be created on a given receiver."
  },
  {
    "id": 3161,
    "type": "Summary",
    "comment": "Creates a JSONAsserter",
    "code": "    public static JsonAsserter with(Reader reader) throws IOException {\n        return new JsonAsserterImpl(jsonProvider.parse(convertReaderToString(reader)));\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3162,
    "type": "Summary",
    "comment": "Creates a new  TModel and Loads the cursor into a the object.",
    "code": "    public ModelClass loadFromCursor(Cursor cursor) {\n        ModelClass model = newInstance();\n        loadFromCursor(cursor, model);\n        return model;\n    }\n\n",
    "label": 1,
    "rec": "Creates a new  ModelClass and Loads the cursor into a the object."
  },
  {
    "id": 3163,
    "type": "Summary",
    "comment": "byte argument that does not match the given argument matcher.",
    "code": "    public static byte not(byte first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3164,
    "type": "Summary",
    "comment": "Parses a query-string into a map.",
    "code": "    public static Multimap<String, String> parse(final String input) {\n        checkNotNull(input);\n        Multimap<String, String> result = LinkedHashMultimap.create();\n        String[] fields = input.split(FIELD_SEPARATOR);\n        for (String field : fields) {\n            String key, value;\n            int i = field.indexOf(VALUE_SEPARATOR);\n            if (i == -1) {\n                key = field;\n                value = null;\n            }\n            else {\n                key = field.substring(0, i);\n                value = field.substring(i + 1, field.length());\n            }\n            result.put(key, value);\n        }\n        return result;\n    }\n\n",
    "label": 1,
    "rec": "Parses a query-string into a multimap."
  },
  {
    "id": 3165,
    "type": "Summary",
    "comment": "Starts grid with given configuration.",
    "code": "    public static Ignite start(GridConfiguration cfg) throws GridException {\n        return GridGainEx.start(cfg);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3166,
    "type": "Summary",
    "comment": "build user-user or item-item correlation matrix from training data",
    "code": "\tprotected UpperSymmMat buildCorrs(boolean isUser) {\n\t\tLogs.debug(\"Build {} similarity matrix ...\", isUser ? \"user\" : \"item\");\n\n\t\tint numCount = isUser ? numUsers : numItems;\n\t\tUpperSymmMat corrs = new UpperSymmMat(numCount);\n\n\t\tfor (int i = 0; i < numCount; i++) {\n\t\t\tSparseVector iv = isUser ? trainMatrix.row(i) : trainMatrix.col(i);\n\t\t\tList<Integer> items = Lists.toList(iv.getIndex());\n\t\t\tif (items.size() == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = i + 1; j < numCount; j++) {\n\t\t\t\tSparseVector jv = isUser ? trainMatrix.row(j) : trainMatrix.col(j);\n\n\t\t\t\tdouble sim = compCorr(iv, jv, items);\n\n\t\t\t\tif (sim != 0.0)\n\t\t\t\t\tcorrs.set(i, j, sim);\n\t\t\t}\n\t\t}\n\n\t\treturn corrs;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3167,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_COPYRIGHTINFO;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3168,
    "type": "Summary",
    "comment": "Returns the matrix inverse or pseudo inverse.",
    "code": "    public static DenseMatrix inverse(double[][] A) {\n        if (A.length == A[0].length) {\n            LUDecomposition lu = new LUDecomposition(A);\n            return lu.inverse();\n        } else {\n            QRDecomposition qr = new QRDecomposition(A);\n            return qr.inverse();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3169,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_URL_FILE_WEB;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3170,
    "type": "Summary",
    "comment": "Returns the  #getUsername() username as a Principal.",
    "code": "    public Principal getPrincipal() {\n        final String username = getUsername();\n        return new Principal() {\n            public int hashCode() {\n                return username.hashCode();\n            }\n\n            public boolean equals( Object obj ) {\n                if ( obj instanceof Principal ) {\n                    String otherName = ((Principal)obj).getName();\n                    return getName().equals( otherName );\n                } else {\n                    return false;\n                }\n            }\n\n            public String toString() {\n                return username;\n            }\n\n            public String getName() {\n                return username;\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3171,
    "type": "Summary",
    "comment": "get all set method for psiClass",
    "code": "    public static Map<String, String> getAllSetterMethods(PsiClass psiClass, String currentMethodName) {\r\n        Map<String, String> methodNames = new HashMap<String, String>();\r\n        PsiMethod[] psiMethods = null;\r\n        String prefix = \"\";\r\n        //flat field\r\n        if (!currentMethodName.contains(\".\")) {\r\n            psiMethods = psiClass.getAllMethods();\r\n        } else {\r\n            prefix = currentMethodName.substring(0, currentMethodName.lastIndexOf('.'));\r\n            String getterMethod = \"get\" + StringUtil.capitalize(prefix);\r\n            PsiClass psiFieldClass = findGetterMethodReturnType(psiClass, getterMethod);\r\n            if (psiFieldClass != null) {\r\n                psiMethods = psiFieldClass.getAllMethods();\r\n                prefix = prefix + \".\";\r\n            }\r\n        }\r\n        if (psiMethods != null && psiMethods.length > 0) {\r\n            for (PsiMethod psiMethod : psiMethods) {\r\n                String methodName = psiMethod.getName();\r\n                if (methodName.startsWith(\"set\") && psiMethod.getParameterList().getParametersCount() == 1) {\r\n                    String name = prefix + StringUtil.decapitalize(methodName.replaceFirst(\"set\", \"\"));\r\n                    String type = psiMethod.getParameterList().getParameters()[0].getType().getPresentableText();\r\n                    methodNames.put(name, type);\r\n                }\r\n            }\r\n        }\r\n        return methodNames;\r\n    }\r\n\n",
    "label": 1,
    "rec": "get all set method for psiClass with type added"
  },
  {
    "id": 3172,
    "type": "Summary",
    "comment": "Initiates a login attempt with the provided credentials in the http header.",
    "code": "    protected boolean executeLogin(ServletRequest request, ServletResponse response) {\n        boolean isLoggedIn = false;\n\n        HttpServletRequest httpRequest = toHttp(request);\n        String authorizationHeader = httpRequest.getHeader(AUTHORIZATION_HEADER);\n\n        if (authorizationHeader != null && authorizationHeader.length() > 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Executing login with headers [\" + authorizationHeader + \"]\");\n            }\n\n            String[] authTokens = authorizationHeader.split(\" \");\n\n            if (authTokens[0].trim().equalsIgnoreCase(HttpServletRequest.BASIC_AUTH)) {\n                String encodedCredentials = authTokens[1];\n\n                byte[] decodedCredentialByteArray = Base64.decodeBase64(encodedCredentials);\n                String decodedCredentials = new String(decodedCredentialByteArray);\n\n                String[] credentials = decodedCredentials.split(\":\");\n\n                if (credentials != null && credentials.length > 1) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Processing login request [\" + credentials[0] + \"]\");\n                    }\n                    Subject subject = getSubject(request, response);\n                    UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(credentials[0], credentials[1]);\n                    try {\n                        subject.login(usernamePasswordToken);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Successfully logged in user [\" + credentials[0] + \"]\");\n                        }\n                        isLoggedIn = true;\n                    } catch (AuthenticationException ae) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Unable to log in subject [\" + credentials[0] + \"]\", ae);\n                        }\n\n                        return sendChallenge(request, response);\n                    }\n                }\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Returning [\" + isLoggedIn + \"] from executeLogin()\");\n        }\n\n        return isLoggedIn;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3173,
    "type": "Summary",
    "comment": "Returns an  Iterable over the elements in this list in proper sequence.",
    "code": "\tpublic List<MessageObserver> getMessageObservers() {\n\t\tif (messageObservers == null) {\n\t\t\treturn Collections.emptyList();\n\t\t} else {\n\t\t\treturn Collections.unmodifiableList(messageObservers);\n\t\t}\n\t}\n\n",
    "label": 1,
    "rec": "Returns the observers registered for this message."
  },
  {
    "id": 3174,
    "type": "Summary",
    "comment": "Returns the number inputted by the user",
    "code": "    public BigDecimal getEnteredNumber() {\n        String value = \"0\";\n        for (int i = mInputPointer; i >= 0; i--) {\n            if (mInput[i] == -1) {\n                break;\n            } else if (mInput[i] == CLICKED_DECIMAL) {\n                value += \".\";\n            } else {\n                value += mInput[i];\n            }\n        }\n        if (mSign == SIGN_NEGATIVE) {\n            value = \"-\" + value;\n        }\n\n        return new BigDecimal(value);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3175,
    "type": "Summary",
    "comment": "Create the time delta string for an edge given the min and max ITimes within it, rounding to the specified number of significant digits.",
    "code": "    protected String getITimeString(ITime timeMin, ITime timeMax,\n            ITime timeMedian, int sigDigits) {\n        // Make time string\n        if (timeMin != null && timeMax != null) {\n\n            // Round min and max to a few significant digits for readability\n            BigDecimal timeMinDec = new BigDecimal(timeMin.toString())\n                    .round(new MathContext(sigDigits));\n            BigDecimal timeMaxDec = new BigDecimal(timeMax.toString())\n                    .round(new MathContext(sigDigits));\n\n            // Remove trailing zeros and periods from min and max\n            String timeMinStr = removeTrailingZeros(timeMinDec.toString());\n            String timeMaxStr = removeTrailingZeros(timeMaxDec.toString());\n\n            // Round and format median if provided\n            String timeMedStr = \"\";\n            if (timeMedian != null) {\n                BigDecimal timeMedDec = new BigDecimal(timeMedian.toString())\n                        .round(new MathContext(sigDigits));\n\n                timeMedStr = removeTrailingZeros(timeMedDec.toString()) + \",\";\n            }\n\n            // String is range (possibly including median) if min != max time or\n            // else just the single time if they are equal\n            if (!timeMinStr.equals(timeMaxStr)) {\n                return \"[\" + timeMinStr + \",\" + timeMedStr + timeMaxStr + \"]\";\n            }\n            {\n                return timeMinStr;\n            }\n        }\n        {\n            return \"\";\n        }\n    }\n\n",
    "label": 1,
    "rec": "Create the time delta string for an edge given the min, max, and (optionally) median ITimes within it, rounding to the specified number of significant digits."
  },
  {
    "id": 3176,
    "type": "Summary",
    "comment": "Enables integrating hamcrest matchers that match primitive long arguments.",
    "code": "    public static long longThat(Matcher<Long> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3177,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_AUDIO_ENCRYPTION;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3178,
    "type": "Summary",
    "comment": "Returns true if the request was made with a Basic authentication authorization header.",
    "code": "    protected boolean isBasicAuthRequest(HttpServletRequest request) {\n        String authValue = request.getHeader(AUTHORIZATION_HEADER);\n        return authValue != null && authValue.toLowerCase().startsWith(SCHEME_BASIC);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3179,
    "type": "Summary",
    "comment": "As NGINX cannot actually send the CA Chain in http header,",
    "code": "\tpublic X509Certificate[] buildChain(X509Certificate end_user_auth_cert) {\n\t\t\n\t\tX509Certificate[] user_cert_chain = null;\n\t\t\n        try {\n        \t\n        \t// No truststore : no way!\n            if (truststore == null) {\n                log.warn(\"Keycloak Truststore is null, but it is required !\");\n                log.warn(\"  see https://www.keycloak.org/docs/latest/server_installation/index.html#_truststore\");\n                return null;\n            }\n\n            // Create the selector that specifies the starting certificate\n            X509CertSelector selector = new X509CertSelector();\n            selector.setCertificate(end_user_auth_cert);\n\n            // Create the trust anchors (set of root CA certificates)\n            Set<TrustAnchor> trustAnchors = new HashSet<TrustAnchor>();\n            for (X509Certificate trustedRootCert : trustedRootCerts) {\n                trustAnchors.add(new TrustAnchor(trustedRootCert, null));\n            }\n            // Configure the PKIX certificate builder algorithm parameters\n            PKIXBuilderParameters pkixParams = new PKIXBuilderParameters( trustAnchors, selector);\n            \n            // Disable CRL checks, as it's possibly done after depending on Keycloak settings\n            pkixParams.setRevocationEnabled(false);\n            pkixParams.setExplicitPolicyRequired(false);\n            pkixParams.setAnyPolicyInhibited(false);\n            pkixParams.setPolicyQualifiersRejected(false);\n            pkixParams.setMaxPathLength(certificateChainLength);\n            \n            // Adding the list of intermediate certificates + end user certificate\n            intermediateCerts.add(end_user_auth_cert);\n            CollectionCertStoreParameters intermediateCA_userCert = new CollectionCertStoreParameters(intermediateCerts);\n            CertStore intermediateCertStore = CertStore.getInstance(\"Collection\", intermediateCA_userCert, \"BC\");\n            pkixParams.addCertStore(intermediateCertStore);\n\n            // Build and verify the certification chain (revocation status excluded)\n            CertPathBuilder certPathBuilder = CertPathBuilder.getInstance(\"PKIX\",\"BC\");\n            CertPath certPath = certPathBuilder.build(pkixParams).getCertPath();\n            log.debug(\"Certification path building OK, and contains \" + certPath.getCertificates().size() + \" X509 Certificates\");\n            \n            user_cert_chain = convertCertPathtoX509CertArray( certPath );\n            \n        } catch (NoSuchAlgorithmException e) {\n        \tlog.error(e.getLocalizedMessage(),e);\n        } catch (CertPathBuilderException e) {\n            if ( log.isEnabled(Level.TRACE) )\n            \tlog.debug(e.getLocalizedMessage(),e);\n            else\n            \tlog.warn(e.getLocalizedMessage());\n        } catch (InvalidAlgorithmParameterException e) {\n        \tlog.error(e.getLocalizedMessage(),e);\n        } catch (NoSuchProviderException e) {\n        \tlog.error(e.getLocalizedMessage(),e);\n\t\t} finally {\n\t        //Remove end user certificate\n\t        intermediateCerts.remove(end_user_auth_cert);\n\t\t}\n        \n        return user_cert_chain;\n\t}\n",
    "label": 1,
    "rec": "As NGINX cannot actually send the CA Chain in http header(s), we are rebuilding here the end user certificate chain with Keycloak truststore."
  },
  {
    "id": 3180,
    "type": "Summary",
    "comment": "Creates a mock using the Generics Metadata.",
    "code": "    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n        return mockitoCore().mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3181,
    "type": "Summary",
    "comment": "Returns whether this view is in the ative page of the active perspective.",
    "code": "\tprotected boolean isActive() {\r\n\t\treturn fIsActive && getViewer() != null;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Returns whether this view is in the active page of the active perspective and has been fully created."
  },
  {
    "id": 3182,
    "type": "Summary",
    "comment": "Send request for login form and then login using user param.",
    "code": "    public SAMLDocumentHolder idpInitiatedLogin(UserRepresentation user, Binding expectedResponseBinding, boolean consentRequired, boolean consent) {\n        return getSamlResponse(expectedResponseBinding, (client, context, strategy) -> {\n            HttpGet get = new HttpGet(samlEndpoint);\n            CloseableHttpResponse response = client.execute(get);\n            assertThat(response, statusCodeIsHC(Response.Status.OK));\n\n            String loginPageText = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n            response.close();\n\n            assertThat(loginPageText, containsString(\"login\"));\n\n            HttpUriRequest loginRequest = handleLoginPage(user, loginPageText);\n\n            if (consentRequired) {\n                // Client requires consent\n                response = client.execute(loginRequest, context);\n                String consentPageText = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n                loginRequest = handleConsentPage(consentPageText, consent);\n            }\n\n            strategy.setRedirectable(false);\n            return client.execute(loginRequest, context);\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3183,
    "type": "Summary",
    "comment": "Returns a predicate that will accept any String that contains the specified",
    "code": "    public static Predicate<String> contains(CharSequence contains) {\r\n        return new ContainsPredicate(contains);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Creates a Predicate that will accept any String that contains the specified"
  },
  {
    "id": 3184,
    "type": "Summary",
    "comment": "Delete file's data from data cache.",
    "code": "    public IgniteInternalFuture<Object> delete(IgfsFileInfo fileInfo) {\n        //assert validTxState(any); // Allow this method call for any transaction state.\n\n        if (!fileInfo.isFile()) {\n            if (log.isDebugEnabled())\n                log.debug(\"Cannot delete content of not-data file: \" + fileInfo);\n\n            return new GridFinishedFuture<>();\n        }\n        else\n            return delWorker.deleteAsync(fileInfo);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3185,
    "type": "Summary",
    "comment": "Determines the edges that are (transitively) connected to the given edges across hierarchy boundaries via common ports.",
    "code": "    public static Iterator<KEdge> getConnectedEdges(final Iterable<KEdge> kedges) {\n        return Iterators.concat(\n                Iterators.transform(kedges.iterator(), new Function<KEdge, Iterator<KEdge>>() {\n\n            public Iterator<KEdge> apply(final KEdge kedge) {\n                return getConnectedEdges(kedge);\n            }\n        }));\n    }\n\n",
    "label": 1,
    "rec": "Determines the  KEdge KEdges that are (transitively) connected to the given  kedges across hierarchy boundaries via common ports."
  },
  {
    "id": 3186,
    "type": "Summary",
    "comment": "Subtract some miliseconds from the time value",
    "code": "    public static XMLGregorianCalendar subtract(XMLGregorianCalendar value, long millis) {\n        return add(value, - millis);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3187,
    "type": "Summary",
    "comment": "Retrieve a list of currently configured DNS servers IP addresses.",
    "code": "    public static synchronized String[] findDNS() {\n        String[] resArray = null;\n        for (DNSServerLookupMechanism mechanism : LOOKUP_MECHANISMS) {\n            resArray = mechanism.getDnsServerAddresses();\n            if (resArray == null) {\n                continue;\n            }\n\n            List<String> res = new ArrayList<>(Arrays.asList(resArray));\n\n            Iterator<String> it = res.iterator();\n            while (it.hasNext()) {\n                String potentialDnsServer = it.next();\n\n                if (blacklistedDnsServers.contains(potentialDnsServer)) {\n                    LOGGER.fine(\"The DNS server lookup mechanism '\" + mechanism.getName()\n                    + \"' returned a blacklisted result: '\" + potentialDnsServer + \"'\");\n                    it.remove();\n                }\n            }\n\n            if (!res.isEmpty()) {\n                break;\n            }\n        }\n\n        return resArray;\n    }\n\n",
    "label": 1,
    "rec": "Retrieve a list of currently configured DNS servers."
  },
  {
    "id": 3188,
    "type": "Summary",
    "comment": "Returns an iterator of nonzero entries.",
    "code": "    public Iterator<Entry> iterator() {\n        return new Iterator<Entry>() {\n            int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < size();\n            }\n\n            @Override\n            public Entry next() {\n                Entry e = new Entry(index.get(i), value.get(i));\n                i += 1;\n                return e;\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3189,
    "type": "Summary",
    "comment": "Returns an observable that emits the current attached view during  #onTakeView(Object) and null during  #onDropView().",
    "code": "    public Observable<View> view() {\n        return views;\n    }\n\n",
    "label": 1,
    "rec": "Returns an  rx.Observable that emits the current attached view or null."
  },
  {
    "id": 3190,
    "type": "Summary",
    "comment": "Extracts the version id from the directory",
    "code": "    public static long getVersionId(File versionDir) {\n        return getVersionId(versionDir.getName());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3191,
    "type": "Summary",
    "comment": "See  IgniteInternalCache#keepBinary().",
    "code": "    public CacheOperationContext keepBinary() {\n        return new CacheOperationContext(\n            skipStore,\n            subjId,\n            true,\n            expiryPlc,\n            noRetries,\n            dataCenterId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3192,
    "type": "Summary",
    "comment": "Builds an  org.jsecurity.authc.Account object by querying the active directory LDAP context for the specified username.",
    "code": "    protected AuthorizingAccount queryForLdapAccount( Object principal, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        String username = null;\n\n        if ( !(principal instanceof String ) ) {\n            String msg = \"This implementation expects the principal argument to be a String.\";\n            throw new IllegalArgumentException( msg );\n        }\n\n        username = (String)principal;\n\n        // Perform context search\n        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();\n\n        List<String> roleNames;\n\n        try {\n\n            roleNames = getRoleNamesForUser(username, ldapContext);\n\n        } finally {\n\n            LdapUtils.closeContext( ldapContext );\n        }\n\n        return new SimpleAuthorizingAccount( roleNames, null );\n    }\n",
    "label": 1,
    "rec": "Builds an  org.jsecurity.authz.AuthorizingAccount object by querying the active directory LDAP context for the groups that a user is a member of."
  },
  {
    "id": 3193,
    "type": "Summary",
    "comment": "Any String or null.",
    "code": "    public static String anyString() {\n        return reportMatcher(new InstanceOf(String.class)).returnString();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3194,
    "type": "Summary",
    "comment": "Toggles the flash mode between  CameraKit.Constants#FLASH_OFF,  CameraKit.Constants#FLASH_ON,  CameraKit.Constants#FLASH_AUTO and  CameraKit.Constants#FOCUS_FIXED, in this order.",
    "code": "    public int toggleFlash() {\n        int flash = mCameraController.getFlash();\n        switch (flash) {\n            case FLASH_OFF:\n                setFlash(FLASH_ON);\n                break;\n\n            case FLASH_ON:\n                setFlash(FLASH_AUTO);\n                break;\n\n            case FLASH_AUTO:\n            case FLASH_TORCH:\n                setFlash(FLASH_OFF);\n                break;\n        }\n\n        return mCameraController.getFlash();\n    }\n",
    "label": 1,
    "rec": "Toggles the flash mode between  CameraConstants#FLASH_OFF,  CameraConstants#FLASH_ON,  CameraConstants#FLASH_AUTO and  CameraConstants#FOCUS_FIXED, in this order."
  },
  {
    "id": 3195,
    "type": "Summary",
    "comment": "Logout from the admin console",
    "code": "    public Response logout() {\n        URI redirect = AdminRoot.adminConsoleUrl(session.getContext().getUri()).build(realm.getName());\n\n        return Response.status(302).location(\n                OIDCLoginProtocolService.logoutUrl(session.getContext().getUri()).queryParam(\"redirect_uri\", redirect.toString()).build(realm.getName())\n        ).build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3196,
    "type": "Summary",
    "comment": "Method that returns the associated icon.",
    "code": "    public static final int getIcon(Context context, FileSystemObject fso) {\n        //Ensure that mime types are loaded\n        if (sMimeTypes == null) {\n            loadMimeTypes(context);\n        }\n\n        //Check if the argument is a folder\n        if (fso instanceof Directory || FileHelper.isSymlinkRefDirectory(fso)) {\n            return R.drawable.ic_fso_folder;\n        }\n\n        //Get the extension and delivery\n        String ext = FileHelper.getExtension(fso);\n        if (ext != null) {\n            MimeTypeInfo mimeTypeInfo = sMimeTypes.get(ext);\n            if (mimeTypeInfo != null) {\n                //Search the identifier in the cache\n                int drawableId = 0;\n                if (sCachedIndentifiers.containsKey(ext)) {\n                    drawableId = sCachedIndentifiers.get(ext).intValue();\n                } else {\n                    drawableId = ResourcesHelper.getIdentifier(\n                          context.getResources(), \"drawable\", //$NON-NLS-1$\n                          mimeTypeInfo.mDrawable);\n                    sCachedIndentifiers.put(ext, Integer.valueOf(drawableId));\n                }\n                return drawableId;\n            }\n        }\n\n        // Check if the fso is executable\n        if (fso.getPermissions().getUser().isExecute()) {\n            return R.drawable.ic_fso_type_executable;\n        }\n        return R.drawable.ic_fso_default;\n    }\n\n",
    "label": 1,
    "rec": "Method that returns the associated mime/type icon resource identifier of the  FileSystemObject."
  },
  {
    "id": 3197,
    "type": "Summary",
    "comment": "Convenience wrapper around getConfidence().getConfidenceType()",
    "code": "    public boolean isPending() {\n        return getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3198,
    "type": "Summary",
    "comment": "Creates the necessary adapters for the KGraph rooted at the given node.",
    "code": "    public static ElkGraphAdapter adapt(final ElkNode graph) {\n        return new ElkGraphAdapter(graph);\n    }\n\n",
    "label": 1,
    "rec": "Creates the necessary adapters for the ElkGraph rooted at the given node."
  },
  {
    "id": 3199,
    "type": "Summary",
    "comment": "Create GGFS file with the given path.",
    "code": "    private GridGgfsFile file(String path) {\n        return new GridGgfsFileImpl(new IgniteFsPath(path), new GridGgfsFileInfo(), 64 * 1024 * 1024);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3200,
    "type": "Summary",
    "comment": "Changes the shared value only if its value has not changed since the version specified by newValue.",
    "code": "    public boolean trySetValue(byte[] newValue) throws Exception\n    {\n        Preconditions.checkState(state.get() == State.STARTED, \"not started\");\n\n        try\n        {\n            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);\n            stat.setVersion(stat.getVersion() + 1);\n            value = Arrays.copyOf(newValue, newValue.length);\n            return true;\n        }\n        catch ( KeeperException.BadVersionException ignore )\n        {\n            // ignore\n        }\n\n        readValue();\n        return false;\n    }\n",
    "label": 1,
    "rec": "Changes the shared value only if its value has not changed since this client last read it."
  },
  {
    "id": 3201,
    "type": "Summary",
    "comment": "Parse line from log.",
    "code": "        private VisorGgfsProfilerParsedLine parseLine(String s) {\n            String[] ss = s.split(DELIM_FIELD);\n\n            long streamId = parseLong(ss, LOG_COL_STREAM_ID, -1);\n\n            if (streamId >= 0) {\n                int entryType = parseInt(ss, LOG_COL_ENTRY_TYPE, -1);\n\n                // Parse only needed types.\n                if (LOG_TYPES.contains(entryType))\n                    return new VisorGgfsProfilerParsedLine(\n                        parseLong(ss, LOG_COL_TIMESTAMP, 0),\n                        entryType,\n                        parseString(ss, LOG_COL_PATH, \"\"),\n                        GridGgfsMode.valueOf(parseString(ss, LOG_COL_GGFS_MODE, \"\")),\n                        streamId,\n                        parseLong(ss, LOG_COL_DATA_LEN, 0),\n                        parseBoolean(ss, LOG_COL_APPEND, false),\n                        parseBoolean(ss, LOG_COL_OVERWRITE, false),\n                        parseLong(ss, LOG_COL_POS, 0),\n                        parseInt(ss, LOG_COL_READ_LEN, 0),\n                        parseLong(ss, LOG_COL_USER_TIME, 0),\n                        parseLong(ss, LOG_COL_SYSTEM_TIME, 0),\n                        parseLong(ss, LOG_COL_TOTAL_BYTES, 0)\n                    );\n            }\n\n            return null;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3202,
    "type": "Summary",
    "comment": "Return ahe  org.apache.tez.runtime.api.TezInputContext for this specific instance of the LogicalInput",
    "code": "  public final InputContext getContext() {\n    return inputContext;\n  }\n\n",
    "label": 1,
    "rec": "Return ahe  org.apache.tez.runtime.api.InputContext for this specific instance of the LogicalInput"
  },
  {
    "id": 3203,
    "type": "Summary",
    "comment": "Launches and waits for the native compiler to produce a native shared library.",
    "code": "    int compile(String sourceFilename, String outputFilename, ClassProperties properties)\n            throws IOException, InterruptedException {\n        ArrayList<String> command = new ArrayList<String>();\n\n        includeJavaPaths(properties, header);\n\n        String platform  = Loader.getPlatform();\n        String compilerPath = properties.getProperty(\"platform.compiler\");\n        command.add(compilerPath);\n\n        {\n            String p = properties.getProperty(\"platform.sysroot.prefix\", \"\");\n            for (String s : properties.get(\"platform.sysroot\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.includepath.prefix\", \"\");\n            for (String s : properties.get(\"platform.includepath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        command.add(sourceFilename);\n\n        Collection<String> allOptions = properties.get(\"platform.compiler.*\");\n        if (allOptions.isEmpty()) {\n            allOptions.add(\"default\");\n        }\n        for (String s : allOptions) {\n            if (s == null || s.length() == 0) {\n                continue;\n            }\n            String p = \"platform.compiler.\" + s;\n            String options = properties.getProperty(p);\n            if (options != null && options.length() > 0) {\n                command.addAll(Arrays.asList(options.split(\" \")));\n            } else if (!\"default\".equals(s)) {\n                logger.warn(\"Could not get the property named \\\"\" + p + \"\\\"\");\n            }\n        }\n\n        command.addAll(compilerOptions);\n\n        String output = properties.getProperty(\"platform.compiler.output\");\n        if (output != null && output.length() > 0) {\n            command.addAll(Arrays.asList(output.split(\" \")));\n        }\n\n        if (output == null || output.length() == 0 || output.endsWith(\" \")) {\n            command.add(outputFilename);\n        } else {\n            command.add(command.remove(command.size() - 1) + outputFilename);\n        }\n\n        {\n            String p  = properties.getProperty(\"platform.linkpath.prefix\", \"\");\n            String p2 = properties.getProperty(\"platform.linkpath.prefix2\");\n            for (String s : properties.get(\"platform.linkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                    if (p2 != null) {\n                        if (p2.endsWith(\" \")) {\n                            command.add(p2.trim()); command.add(s);\n                        } else {\n                            command.add(p2 + s);\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.link.prefix\", \"\");\n            String x = properties.getProperty(\"platform.link.suffix\", \"\");\n            int i = command.size(); // to inverse order and satisfy typical compilers\n            for (String s : properties.get(\"platform.link\")) {\n                String[] libnameversion = s.split(\"@\");\n                if (libnameversion.length == 3 && libnameversion[1].length() == 0) {\n                    // Only use the version number when the user gave us a double @\n                    s = libnameversion[0] + libnameversion[2];\n                } else {\n                    s = libnameversion[0];\n                }\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s); command.add(i + 2, x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(i, p.trim()); command.add(i + 1, s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(i, p + s); command.add(i + 1, x.trim());\n                } else {\n                    command.add(i, p + s + x);\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.frameworkpath.prefix\", \"\");\n            for (String s : properties.get(\"platform.frameworkpath\")) {\n                if (new File(s).isDirectory()) {\n                    if (p.endsWith(\" \")) {\n                        command.add(p.trim()); command.add(s);\n                    } else {\n                        command.add(p + s);\n                    }\n                }\n            }\n        }\n\n        {\n            String p = properties.getProperty(\"platform.framework.prefix\", \"\");\n            String x = properties.getProperty(\"platform.framework.suffix\", \"\");\n            for (String s : properties.get(\"platform.framework\")) {\n                if (p.endsWith(\" \") && x.startsWith(\" \")) {\n                    command.add(p.trim()); command.add(s); command.add(x.trim());\n                } else if (p.endsWith(\" \")) {\n                    command.add(p.trim()); command.add(s + x);\n                } else if (x.startsWith(\" \")) {\n                    command.add(p + s); command.add(x.trim());\n                } else {\n                    command.add(p + s + x);\n                }\n            }\n        }\n\n        String text = \"\";\n        boolean windows = platform.startsWith(\"windows\");\n        for (String s : command) {\n            boolean hasSpaces = s.indexOf(\" \") > 0;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += s;\n            if (hasSpaces) {\n                text += windows ? \"\\\"\" : \"'\";\n            }\n            text += \" \";\n        }\n        logger.info(text);\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (environmentVariables != null) {\n            pb.environment().putAll(environmentVariables);\n        }\n        return pb.inheritIO().start().waitFor();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3204,
    "type": "Summary",
    "comment": "Get the  Symbol value for the class of the given object, if the annotation is present",
    "code": "    public static String getSymbolValue(Object o) {\n        if (o instanceof Describable) {\n            return getSymbolValue(((Describable) o).getDescriptor().getClass());\n        } else {\n            return getSymbolValue(o.getClass());\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get the  Symbol value for the class of the given object, generally a  Descriptor, if the annotation is present."
  },
  {
    "id": 3205,
    "type": "Summary",
    "comment": "Encloses the incoming string inside double quotes, if it isn't already quoted.",
    "code": "  private static String convertToQuotedString(String s) {\n    if (s == null || s.isEmpty()) {\n      return null;\n    }\n    // If already quoted, return as-is\n    if (s.charAt(0) == '\"' && s.charAt(s.length() - 1) == '\"') {\n      return s;\n    }\n    return '\\\"' + s + '\\\"';\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3206,
    "type": "Summary",
    "comment": "Encrypts the fragment, if a cipher suite is available that supports encryption.",
    "code": "\tprivate byte[] encryptFragment(byte[] plaintextFragment) throws GeneralSecurityException {\r\n\t\t\r\n\t\tif (session == null) {\r\n\t\t\treturn plaintextFragment;\r\n\t\t}\r\n\r\n\t\tbyte[] encryptedFragment = plaintextFragment;\r\n\r\n\t\tCipherSuite cipherSuite = session.getWriteState().getCipherSuite();\r\n\t\tLOGGER.log(Level.FINER, \"Encrypting record fragment using current write state\\n{0}\", session.getWriteState());\r\n\t\t\r\n\t\tswitch (cipherSuite.getCipherType()) {\r\n\t\tcase NULL:\r\n\t\t\t// do nothing\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase AEAD:\r\n\t\t\tencryptedFragment = encryptAEAD(plaintextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase BLOCK:\r\n\t\t\tencryptedFragment = encryptBlockCipher(plaintextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase STREAM:\r\n\t\t\t// Currently, Scandium does not support any stream ciphers\r\n\t\t\t// RC4 is explicitly ruled out from being used in DTLS\r\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.2\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn encryptedFragment;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Encrypts a TLSPlaintext.fragment according to the current DTLS connection state."
  },
  {
    "id": 3207,
    "type": "Summary",
    "comment": "Requests  AffinityFunction and  AffinityKeyMapper from remote node.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, AffinityTopologyVersion topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        AffinityFunction f = (AffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        AffinityKeyMapper m = (AffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        CacheConfiguration ccfg = ctx.cache().cacheConfiguration(cacheName);\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(ccfg));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3208,
    "type": "Summary",
    "comment": "Get the  ContentDeliveryUnitCreator for a resource based on the supplied resource type.",
    "code": "    public ContentHandlerFactory getContentDeliveryUnitCreator(String type) throws UnsupportedContentHandlerTypeException {\n        if(type == null) {\n            throw new IllegalArgumentException(\"null 'resourceExtension' arg in method call.\");\n        }\n        \n        for(int i = 0; i < configLists.size(); i++) {\n            SmooksResourceConfigurationList list = configLists.get(i);\n            \n            for(int ii = 0; ii < list.size(); ii++) {\n                SmooksResourceConfiguration config = list.get(ii);\n                String selector = config.getSelector();\n                \n                if(\"cdu-creator\".equals(selector) && type.equalsIgnoreCase(config.getStringParameter(ContentHandlerFactory.PARAM_RESTYPE))) {\n                    return (ContentHandlerFactory) getObject(config);\n                }\n            }\n        }\n        \n        throw new UnsupportedContentHandlerTypeException(type);\n    }\n\n",
    "label": 1,
    "rec": "Get the  org.milyn.delivery.ContentHandlerFactory for a resource based on the supplied resource type."
  },
  {
    "id": 3209,
    "type": "Summary",
    "comment": "Puts an UTF8 string into this byte vector.",
    "code": "    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException();\n        }\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                length = len;\n                return encodeUTF8(s, i, 65535);\n            }\n        }\n        length = len;\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3210,
    "type": "Summary",
    "comment": "Return the next int handle to be used to indicate cyclic references being saved to the stream.",
    "code": "    private Integer nextHandle() {\n        return Integer.valueOf(this.currentHandle++);\n    }\n\n",
    "label": 1,
    "rec": "Return the next Integer handle to be used to indicate cyclic references being saved to the stream."
  },
  {
    "id": 3211,
    "type": "Summary",
    "comment": "Used to create the admin path in events.",
    "code": "    public String getPath() {\n        switch(this) {\n            case USER: return \"users\";\n            case GROUP: return \"groups\";\n            case CLIENT: return \"clients\";\n            case IDP: return \"identity-provider-settings\";\n            case REALM_ROLE: return \"realms\";\n            case CLIENT_ROLE: return \"clients\";\n            default: return \"\";\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3212,
    "type": "Summary",
    "comment": "Creates a  DocumentCollectionEntity instance",
    "code": "    static DocumentEntity of(String name, List<Document> documents) throws NullPointerException {\n        DefaultDocumentEntity entity = new DefaultDocumentEntity(name);\n        entity.addAll(documents);\n        return entity;\n    }\n\n",
    "label": 1,
    "rec": "Creates a  DocumentEntity instance"
  },
  {
    "id": 3213,
    "type": "Summary",
    "comment": "Returns the current preview graph.",
    "code": "    public Graph getGraph() {\n        if (model != null) {\n            if (model.isUpdateFlag()) {\n                buildGraph();\n            }\n            return previewGraph;\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3214,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_COMPOSER ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3215,
    "type": "Summary",
    "comment": "Calculate rate of metric per second.",
    "code": "    private static int perSecond(float meanTime) {\n        return (meanTime > 0) ? (int)(MICROSECONDS_IN_SECOND / meanTime) : 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3216,
    "type": "Summary",
    "comment": "This method is called by an event processor to determine the SharedObjectDescriptions associated with the given receivers.",
    "code": "\tprotected RemoteSharedObjectDescription[] getReplicaDescriptions(ID[] receivers) {\n\t\tRemoteSharedObjectDescription [] descriptions = null;\n\t\tif (receivers == null || receivers.length == 1) {\n\t\t\tdescriptions = new RemoteSharedObjectDescription[1];\n\t\t\tdescriptions[0] = getReplicaDescription((receivers==null)?null:receivers[0]);\n\t\t} else {\n\t\t\tdescriptions = new RemoteSharedObjectDescription[receivers.length];\n\t\t\tfor(int i=0; i < receivers.length; i++) {\n\t\t\t\tdescriptions[i] = getReplicaDescription(receivers[i]);\n\t\t\t}\n\t\t}\n\t\treturn descriptions;\n\t}\n\n",
    "label": 1,
    "rec": "This method is called by an event processor to determine the RemoteSharedObjectDescriptions associated with the given receivers."
  },
  {
    "id": 3217,
    "type": "Summary",
    "comment": "Extracts a page ID from the given page link.",
    "code": "    public static long pageId(long link) {\n        return link & ~(OFFSET_MASK << (FILE_ID_SIZE + PAGE_IDX_SIZE));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3218,
    "type": "Summary",
    "comment": "Returns the tag contained in this AudioFile, the Tag contains any useful meta-data, like artist, album, title, etc. If the file does not contain any tag, a new empty tag is returned",
    "code": "    public Tag getTag()\n    {\n        return tag;\n    }\n\n",
    "label": 1,
    "rec": "Returns the tag contained in this AudioFile, the Tag contains any useful meta-data, like artist, album, title, etc."
  },
  {
    "id": 3219,
    "type": "Summary",
    "comment": "URL called after login page.",
    "code": "    public Response processLogin(@QueryParam(\"code\") String code,\n                                 final MultivaluedMap<String, String> formData) {\n        event.event(EventType.LOGIN);\n        if (!checkSsl()) {\n            event.error(Errors.SSL_REQUIRED);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, \"HTTPS required\");\n        }\n\n        if (!realm.isEnabled()) {\n            event.error(Errors.REALM_DISABLED);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, \"Realm not enabled.\");\n        }\n        ClientSessionCode clientCode = ClientSessionCode.parse(code, session, realm);\n        if (clientCode == null) {\n            event.error(Errors.INVALID_CODE);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, \"Unknown code, please login again through your application.\");\n        }\n        ClientSessionModel clientSession = clientCode.getClientSession();\n        if (!clientCode.isValid(ClientSessionModel.Action.AUTHENTICATE)) {\n            clientCode.setAction(ClientSessionModel.Action.AUTHENTICATE);\n            event.client(clientSession.getClient()).error(Errors.INVALID_USER_CREDENTIALS);\n            return Flows.forms(this.session, realm, clientSession.getClient(), uriInfo).setError(Messages.INVALID_USER)\n                    .setAccessCode(clientCode.getCode())\n                    .createLogin();\n        }\n\n        String username = formData.getFirst(AuthenticationManager.FORM_USERNAME);\n\n        String rememberMe = formData.getFirst(\"rememberMe\");\n        boolean remember = rememberMe != null && rememberMe.equalsIgnoreCase(\"on\");\n\n        event.client(clientSession.getClient().getClientId())\n                .detail(Details.REDIRECT_URI, clientSession.getRedirectUri())\n                .detail(Details.RESPONSE_TYPE, \"code\")\n                .detail(Details.AUTH_METHOD, \"form\")\n                .detail(Details.USERNAME, username);\n\n        if (remember) {\n            event.detail(Details.REMEMBER_ME, \"true\");\n        }\n\n        OAuthFlows oauth = Flows.oauth(session, realm, request, uriInfo, clientConnection, authManager, tokenManager);\n\n        ClientModel client = clientSession.getClient();\n        if (client == null) {\n            event.error(Errors.CLIENT_NOT_FOUND);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, \"Unknown login requester.\");\n        }\n        if (!client.isEnabled()) {\n            event.error(Errors.CLIENT_NOT_FOUND);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, \"Login requester not enabled.\");\n        }\n\n        if (formData.containsKey(\"cancel\")) {\n            event.error(Errors.REJECTED_BY_USER);\n            return oauth.redirectError(client, \"access_denied\", clientSession.getNote(OpenIdConnectProtocol.STATE_PARAM), clientSession.getRedirectUri());\n        }\n\n        AuthenticationStatus status = authManager.authenticateForm(session, clientConnection, realm, formData);\n\n        if (remember) {\n            authManager.createRememberMeCookie(realm, username, uriInfo, clientConnection);\n        } else {\n            authManager.expireRememberMeCookie(realm, uriInfo, clientConnection);\n        }\n\n        UserModel user = KeycloakModelUtils.findUserByNameOrEmail(session, realm, username);\n        if (user != null) {\n            event.user(user);\n        }\n\n        switch (status) {\n            case SUCCESS:\n            case ACTIONS_REQUIRED:\n                UserSessionModel userSession = session.sessions().createUserSession(realm, user, username, clientConnection.getRemoteAddr(), \"form\", remember);\n                TokenManager.attachClientSession(userSession, clientSession);\n\t\t        event.session(userSession);\n\n                return oauth.processAccessCode(clientSession, userSession, event);\n            case ACCOUNT_TEMPORARILY_DISABLED:\n                event.error(Errors.USER_TEMPORARILY_DISABLED);\n                return Flows.forms(this.session, realm, client, uriInfo)\n                        .setError(Messages.ACCOUNT_TEMPORARILY_DISABLED)\n                        .setFormData(formData)\n                        .setAccessCode(clientCode.getCode())\n                        .createLogin();\n            case ACCOUNT_DISABLED:\n                event.error(Errors.USER_DISABLED);\n                return Flows.forms(this.session, realm, client, uriInfo)\n                        .setError(Messages.ACCOUNT_DISABLED)\n                        .setAccessCode(clientCode.getCode())\n                        .setFormData(formData).createLogin();\n            case MISSING_TOTP:\n                formData.remove(CredentialRepresentation.PASSWORD);\n\n                String passwordToken = new JWSBuilder().jsonContent(new PasswordToken(realm.getName(), user.getId())).rsa256(realm.getPrivateKey());\n                formData.add(CredentialRepresentation.PASSWORD_TOKEN, passwordToken);\n\n                return Flows.forms(this.session, realm, client, uriInfo)\n                        .setFormData(formData)\n                        .setAccessCode(clientCode.getCode())\n                        .createLoginTotp();\n            case INVALID_USER:\n                event.error(Errors.USER_NOT_FOUND);\n                return Flows.forms(this.session, realm, client, uriInfo).setError(Messages.INVALID_USER)\n                        .setFormData(formData)\n                        .setAccessCode(clientCode.getCode())\n                        .createLogin();\n            default:\n                event.error(Errors.INVALID_USER_CREDENTIALS);\n                return Flows.forms(this.session, realm, client, uriInfo).setError(Messages.INVALID_USER)\n                        .setFormData(formData)\n                        .setAccessCode(clientCode.getCode())\n                        .createLogin();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3220,
    "type": "Summary",
    "comment": "This method is used to retrieve the start and end position of a name.",
    "code": "\tprotected int retrieveEndOfElementTypeNamePosition(int start, int end) {\n\t\tthis.scanner.resetTo(start, end);\n\t\ttry {\n\t\t\tint token;\n\t\t\twhile ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {\n\t\t\t\tswitch(token) {\n\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier:\n\t\t\t\t\tcase TerminalTokens.TokenNamebyte:\n\t\t\t\t\tcase TerminalTokens.TokenNamechar:\n\t\t\t\t\tcase TerminalTokens.TokenNamedouble:\n\t\t\t\t\tcase TerminalTokens.TokenNamefloat:\n\t\t\t\t\tcase TerminalTokens.TokenNameint:\n\t\t\t\t\tcase TerminalTokens.TokenNamelong:\n\t\t\t\t\tcase TerminalTokens.TokenNameshort:\n\t\t\t\t\tcase TerminalTokens.TokenNameboolean:\n\t\t\t\t\t\treturn this.scanner.currentPosition - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(InvalidInputException e) {\n\t\t\t// ignore\n\t\t}\n\t\treturn -1;\n\t}\n\n",
    "label": 1,
    "rec": "This method is used to retrieve the position just before the left bracket."
  },
  {
    "id": 3221,
    "type": "Summary",
    "comment": "Get primary file system path.",
    "code": "    IgniteFsPath path() {\n        return path;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3222,
    "type": "Summary",
    "comment": "Locks the passed address.",
    "code": "\t@Override\r\n\tpublic long lock(long address) {\r\n\t\tlong id = Thread.currentThread().getId();\r\n\t\tif(UnsafeAdapter.getLong(address)!=id) {\r\n\t\t\twhile(!UnsafeAdapter.compareAndSwapLong(null, address, UNLOCKED, id)) {\r\n\t\t\t\tThread.yield();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn UnsafeAdapter.getLong(address + UnsafeAdapter.LONG_SIZE);\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Locks the passed address reference."
  },
  {
    "id": 3223,
    "type": "Summary",
    "comment": "Gets the current flash mode.",
    "code": "    public int getFlash() {\n        return mCameraController.getFlash();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3224,
    "type": "Summary",
    "comment": "Get file name for commit file",
    "code": "    public static String getName(final String path) {\n        if (TextUtils.isEmpty(path))\n            return path;\n\n        int lastSlash = path.lastIndexOf('/');\n        if (lastSlash != -1 && lastSlash + 1 < path.length())\n            return path.substring(lastSlash + 1);\n        else\n            return path;\n    }\n",
    "label": 1,
    "rec": "Get file name for path"
  },
  {
    "id": 3225,
    "type": "Summary",
    "comment": "Rolling count of number of threads executed during rolling statistical window.",
    "code": "    public long getRollingCountThreadsExecuted() {\n        return rollingCounterStream.getLatestCount(HystrixEventType.ThreadPool.EXECUTED);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3226,
    "type": "Summary",
    "comment": "Converts the given calendar to a SQL Date.",
    "code": "    static final Timestamp calendarToSqlDate(Calendar c) {\n        return c == null ? null : new Timestamp(c.getTimeInMillis());\n    }\n\n",
    "label": 1,
    "rec": "Converts the given calendar to a SQL Timestamp."
  },
  {
    "id": 3227,
    "type": "Summary",
    "comment": "Starts asynchronous fetch for given region.",
    "code": "        private FetchBufferPart fetch(long pos, int size) {\n            long remaining = limit - pos;\n\n            size = (int)Math.min(size, remaining);\n\n            return size <= 0 ? null :\n                new FetchBufferPart(delegate.hadoop().readData(delegate, pos, size, null, 0, 0), pos, size);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3228,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_MOOD;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3229,
    "type": "Summary",
    "comment": "Changes the shared count only if its value has not changed since the version specified by newCount.",
    "code": "    public boolean  trySetCount(VersionedValue<Integer> previous, int newCount) throws Exception\n    {\n        VersionedValue<byte[]> previousCopy = new VersionedValue<byte[]>(previous.getVersion(), toBytes(previous.getValue()));\n        return sharedValue.trySetValue(previousCopy, toBytes(newCount));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3230,
    "type": "Summary",
    "comment": "Changes the shared count only if its value has not changed since this client last read it.",
    "code": "    public boolean  trySetCount(VersionedValue<Integer> newCount) throws Exception\n    {\n        VersionedValue<byte[]> copy = new VersionedValue<byte[]>(newCount.getVersion(), toBytes(newCount.getValue()));\n        return sharedValue.trySetValue(copy);\n    }\n",
    "label": 1,
    "rec": "Changes the shared count only if its value has not changed since the version specified by newCount."
  },
  {
    "id": 3231,
    "type": "Summary",
    "comment": "Returns the dataHolder for the given world.",
    "code": "    public OverloadedWorldHolder getWorldData(String worldName) {\n    \tString worldNameLowered = worldName.toLowerCase();\n    \t\n    \tif (worldsData.containsKey(worldNameLowered))\n    \t\t\treturn worldsData.get(worldNameLowered);\n\n        GroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning default world...\");\n        return getDefaultWorld();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3232,
    "type": "Summary",
    "comment": "Returns the \"tree-nodes\" cache size.",
    "code": "    @Deprecated\n    public int getTreeNodesCacheSize() {\n        return 0;\n    }\n\n",
    "label": 1,
    "rec": "As of 1.1.0, is deprecated and has no effect."
  },
  {
    "id": 3233,
    "type": "Summary",
    "comment": "Assigns nodes to one partition.",
    "code": "    public Collection<ClusterNode> nodes(int part, Collection<ClusterNode> nodes, int backups) {\n        if (nodes == null)\n            return Collections.emptyList();\n\n        int nodesSize = nodes.size();\n\n        if (nodesSize == 0)\n            return Collections.emptyList();\n\n        if (nodesSize == 1) // Minor optimization.\n            return nodes;\n\n        initialize();\n\n        final Map<NodeInfo, ClusterNode> lookup = new GridLeanMap<>(nodesSize);\n\n        // Store nodes in map for fast lookup.\n        for (ClusterNode n : nodes)\n            // Add nodes into hash circle, if absent.\n            lookup.put(resolveNodeInfo(n), n);\n\n        Collection<NodeInfo> selected;\n\n        if (backupFilter != null) {\n            final GridPredicate<NodeInfo> p = new P1<NodeInfo>() {\n                @Override public boolean apply(NodeInfo id) {\n                    return lookup.containsKey(id);\n                }\n            };\n\n            final NodeInfo primaryId = nodeHash.node(part, p);\n\n            GridPredicate<NodeInfo> backupPrimaryIdFilter = new GridPredicate<NodeInfo>() {\n                @Override public boolean apply(NodeInfo node) {\n                    return backupIdFilter.apply(primaryId, node);\n                }\n            };\n\n            Collection<NodeInfo> backupIds = nodeHash.nodes(part, backups, p, backupPrimaryIdFilter);\n\n            if (F.isEmpty(backupIds) && primaryId != null) {\n                ClusterNode n = lookup.get(primaryId);\n\n                assert n != null;\n\n                return Collections.singletonList(n);\n            }\n\n            selected = primaryId != null ? F.concat(false, primaryId, backupIds) : backupIds;\n        }\n        else {\n            if (!exclNeighbors) {\n                selected = nodeHash.nodes(part, backups == Integer.MAX_VALUE ? backups : backups + 1, new P1<NodeInfo>() {\n                    @Override public boolean apply(NodeInfo id) {\n                        return lookup.containsKey(id);\n                    }\n                });\n\n                if (selected.size() == 1) {\n                    NodeInfo id = F.first(selected);\n\n                    assert id != null : \"Node ID cannot be null in affinity node ID collection: \" + selected;\n\n                    ClusterNode n = lookup.get(id);\n\n                    assert n != null;\n\n                    return Collections.singletonList(n);\n                }\n            }\n            else {\n                int primaryAndBackups = backups + 1;\n\n                selected = new ArrayList<>(primaryAndBackups);\n\n                final Collection<NodeInfo> selected0 = selected;\n\n                List<NodeInfo> ids = nodeHash.nodes(part, primaryAndBackups, new P1<NodeInfo>() {\n                    @Override public boolean apply(NodeInfo id) {\n                        ClusterNode n = lookup.get(id);\n\n                        if (n == null)\n                            return false;\n\n                        Collection<UUID> neighbors = neighbors(n);\n\n                        for (NodeInfo id0 : selected0) {\n                            ClusterNode n0 = lookup.get(id0);\n\n                            if (n0 == null)\n                                return false;\n\n                            Collection<UUID> neighbors0 = neighbors(n0);\n\n                            if (F.containsAny(neighbors0, neighbors))\n                                return false;\n                        }\n\n                        selected0.add(id);\n\n                        return true;\n                    }\n                });\n\n                if (AFFINITY_CONSISTENCY_CHECK)\n                    assert F.eqOrdered(ids, selected);\n            }\n        }\n\n        Collection<ClusterNode> ret = new ArrayList<>(selected.size());\n\n        for (NodeInfo id : selected) {\n            ClusterNode n = lookup.get(id);\n\n            assert n != null;\n\n            ret.add(n);\n        }\n\n        return ret;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3234,
    "type": "Summary",
    "comment": "Attach this context to the thread and return a  AutoCloseable that can be used with try-with-resource statements to properly  #detach and  #cancel the context on completion.",
    "code": "    public Closeable attachAsCloseable() {\n      final Context previous = attach();\n      return new Closeable() {\n        @Override\n        public void close() throws IOException {\n          detachAndCancel(previous, null);\n        }\n      };\n    }\n",
    "label": 1,
    "rec": "Attach this context to the thread and return a  AutoCloseable that can be used with try-with-resource statements to properly attach the previously bound context when  AutoCloseable#close() is called."
  },
  {
    "id": 3235,
    "type": "Summary",
    "comment": "Resolve data affinity from string definition.",
    "code": "    private static GridClientDataAffinity resolveAffinity(String affinity) throws GridClientException {\n        if (isEmpty(affinity))\n            return null;\n\n        if (\"partitioned\".equals(affinity))\n            return new GridClientPartitionAffinity();\n\n        return newInstance(GridClientDataAffinity.class, affinity);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3236,
    "type": "Summary",
    "comment": "Walks through the pointcuts A invokes all its advices.",
    "code": "    public Object proceed() throws Throwable {\r\n        return m_controller.proceed(this);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Walks through the pointcuts and invokes all its advices."
  },
  {
    "id": 3237,
    "type": "Summary",
    "comment": "Executes the command, returning its success",
    "code": "    public boolean execute(CommandSender sender, String commandLabel, String[] args) {\n        boolean success = false;\n\n        if (!owningPlugin.isEnabled()) {\n            return false;\n        }\n\n        try {\n            success = executor.onCommand(sender, this, commandLabel, args);\n        } catch (Throwable ex) {\n            throw new CommandException(\"Unhandled exception executing command '\" + commandLabel + \"' in plugin \" + owningPlugin.getDescription().getFullName(), ex);\n        }\n\n        if (!success && usageMessage.length() > 0) {\n            sender.sendMessage(usageMessage.replace(\"<command>\", commandLabel));\n        }\n        \n        return success;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3238,
    "type": "Summary",
    "comment": "Get the  HystrixCommandMetrics instance for a given  HystrixCommandKey.",
    "code": "    public static HystrixCommandMetrics getInstance(HystrixCommandKey key) {\n        return metrics.get(key.name());\n    }\n",
    "label": 1,
    "rec": "Get the  HystrixCommandMetrics instance for a given  HystrixCommandKey or null if one does not exist."
  },
  {
    "id": 3239,
    "type": "Summary",
    "comment": "Fully import realm from representation, save it to model and return model of newly created realm",
    "code": "    public static boolean importRealm(KeycloakSession session, RealmRepresentation rep, Strategy strategy) {\n        String realmName = rep.getRealm();\n        RealmProvider model = session.realms();\n        RealmModel realm = model.getRealmByName(realmName);\n\n        if (realm != null) {\n            if (strategy == Strategy.IGNORE_EXISTING) {\n                logger.infof(\"Realm '%s' already exists. Import skipped\", realmName);\n                return false;\n            } else {\n                logger.infof(\"Realm '%s' already exists. Removing it before import\", realmName);\n                if (Config.getAdminRealm().equals(realm.getId())) {\n                    // Delete all masterAdmin apps due to foreign key constraints\n                    for (RealmModel currRealm : model.getRealms()) {\n                        currRealm.setMasterAdminClient(null);\n                    }\n                }\n                // TODO: For migration between versions, it should be possible to delete just realm but keep it's users\n                model.removeRealm(realm.getId());\n            }\n        }\n\n        RealmImporter realmManager = session.getContext().getRealmManager();\n        realmManager.importRealm(rep);\n\n        if (System.getProperty(ExportImportConfig.ACTION) != null) {\n            logger.infof(\"Realm '%s' imported\", realmName);\n        }\n        \n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3240,
    "type": "Summary",
    "comment": "Returns an iterator to a (possible empty) list of file input splits which is expected to be consumed by this instance of the  AbstractFileInputTask.",
    "code": "\tpublic FileInputSplit[] getFileInputSplits() {\n\n\t\tfinal InputSplit[] inputSplits = getEnvironment().getInputSplits();\n\n\t\tfinal FileInputSplit[] fileInputSplits = new FileInputSplit[inputSplits.length];\n\n\t\tfor (int i = 0; i < fileInputSplits.length; i++) {\n\t\t\tfileInputSplits[i] = (FileInputSplit) inputSplits[i];\n\t\t}\n\n\t\treturn fileInputSplits;\n\t}\n\n",
    "label": 1,
    "rec": "Returns an array of @FileInputSplits which have been assigned to this task."
  },
  {
    "id": 3241,
    "type": "Summary",
    "comment": "Processes the raw TCP data read from the MAX protocol, returning the corresponding Message.",
    "code": "\tprivate Message processRawMessage(String raw) {\n\n\t\tif (raw.startsWith(\"H:\")) {\n\t\t\treturn new H_Message(raw);\n\t\t} else if (raw.startsWith(\"M:\")) {\n\t\t\treturn new M_Message(raw);\n\t\t} else if (raw.startsWith(\"C:\")) {\n\t\t\treturn new C_Message(raw);\n\t\t} else if (raw.startsWith(\"L:\")) {\n\t\t\treturn new L_Message(raw);\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3242,
    "type": "Summary",
    "comment": "Returns an Iterator for the unfiled roster entries.",
    "code": "    public Collection<RosterEntry> getUnfiledEntries() {\n        return Collections.unmodifiableList(unfiledEntries);\n    }\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable collection for the unfiled roster entries."
  },
  {
    "id": 3243,
    "type": "Summary",
    "comment": "Saves the given item.",
    "code": "    public boolean saveExisting(TYPE item) {\n        ContentValues values = item.getSetValues();\n        if(values == null || values.size() == 0) // nothing changed\n            return true;\n        boolean recordOutstanding = (outstandingTable != null);\n        final AtomicBoolean result = new AtomicBoolean(false);\n\n        if (recordOutstanding) { // begin transaction\n            database.getDatabase().beginTransactionWithListener(new SQLiteTransactionListener() {\n                @Override\n                public void onRollback() {\n                    result.set(false);\n                }\n                @Override\n                public void onCommit() {/**/}\n                @Override\n                public void onBegin() {/**/}\n            });\n        }\n        try {\n            result.set(database.update(table.name, values,\n                    AbstractModel.ID_PROPERTY.eq(item.getId()).toString(), null) > 0);\n            if(result.get()) {\n                if (recordOutstanding)\n                    createOutstandingEntries(item.getId(), values); // Create entries for setValues in outstanding table\n                onModelUpdated(item);\n                item.markSaved();\n            }\n        } finally {\n            if (recordOutstanding) // commit transaction\n                database.getDatabase().endTransaction();\n        }\n        return result.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3244,
    "type": "Summary",
    "comment": "Method that will set specified field, replacing old value, if any.",
    "code": "    public ArrayNode set(int index, JsonNode value)\n    {\n        if (value == null) { // let's not store 'raw' nulls but nodes\n            value = nullNode();\n        }\n        if (index < 0 || index >= _children.size()) {\n            throw new IndexOutOfBoundsException(\"Illegal index \"+ index +\", array size \"+size());\n        }\n        _children.set(index, value);\n        return this;\n    }\n\n",
    "label": 1,
    "rec": "Method that will set specified element, replacing old value."
  },
  {
    "id": 3245,
    "type": "Summary",
    "comment": "Indicates if [ low,  high] interval overlaps with any interval of this instance.",
    "code": "    public boolean isInRange(double low, double high) {\n        if (low > high) {\n            throw new IllegalArgumentException(\n                    \"The left endpoint of the interval must be less than \"\n                    + \"the right endpoint.\");\n        }\n\n        return intervalTree.overlapsWith(new Interval(low, high));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3246,
    "type": "Summary",
    "comment": "To evaluate an asynchronous message send, an asynchronous invoke is performed on the receiver object.",
    "code": "    public ATObject prim_sendTo(ATMessage self, ATObject receiver, ATObject sender) throws InterpreterException {\n        return sender.meta_send(receiver, self.asAsyncMessage());\n    }\n\n",
    "label": 1,
    "rec": "To evaluate an asynchronous message send, the asynchronous message object is asked to be sent by the sender object."
  },
  {
    "id": 3247,
    "type": "Summary",
    "comment": "If the key already exists and is a string, this command appends the provided value at the end of the string.",
    "code": "    public Long append(final String key, final String value) {\n        runChecks();\n        client.append(key, value);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3248,
    "type": "Summary",
    "comment": "Read a property.",
    "code": "  public static final String getProperty(String s)\n  {\n    String rval = System.getProperty(s);\n    if (rval == null)\n      rval = localProperties.getProperty(s);\n    return rval;\n  }\n\n",
    "label": 1,
    "rec": "Read a property, either from the system properties, or from the local property file image."
  },
  {
    "id": 3249,
    "type": "Summary",
    "comment": "Gets a copy of an existing, non-expired  ExpiringSession by ID.",
    "code": "\tpublic ExpiringSession getSession(String sessionId) {\n\t\tExpiringSession storedSession = getTemplate().get(sessionId);\n\n\t\tif (storedSession != null) {\n\t\t\tstoredSession = storedSession.isExpired()\n\t\t\t\t? delete(storedSession)\n\t\t\t\t: touch(GemFireSession.from(storedSession));\n\t\t}\n\n\t\treturn storedSession;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3250,
    "type": "Summary",
    "comment": "Starts the build process and returns a  Collection of  File produced.",
    "code": "    public File[] build() throws IOException, InterruptedException {\n        if (classScanner.getClasses().isEmpty()) {\n            return null;\n        }\n\n        LinkedList<File> outputFiles = new LinkedList<File>();\n        Map<String, LinkedList<Class>> map = new LinkedHashMap<String, LinkedList<Class>>();\n        for (Class c : classScanner.getClasses()) {\n            if (Loader.getEnclosingClass(c) != c) {\n                continue;\n            }\n            Loader.ClassProperties p = Loader.loadProperties(c, properties, false);\n            String libraryName = outputName != null ? outputName : p.getProperty(\"loader.library\", \"\");\n            if (libraryName.length() == 0) {\n                continue;\n            }\n            LinkedList<Class> classList = map.get(libraryName);\n            if (classList == null) {\n                map.put(libraryName, classList = new LinkedList<Class>());\n            }\n            classList.add(c);\n        }\n        for (String libraryName : map.keySet()) {\n            LinkedList<Class> classList = map.get(libraryName);\n            Class[] classArray = classList.toArray(new Class[classList.size()]);\n            File f = generateAndCompile(classArray, libraryName);\n            if (f != null) {\n                outputFiles.add(f);\n                if (copylibs) {\n                    // Do not copy library files from inherit properties ...\n                    Loader.ClassProperties p = Loader.loadProperties(classArray, properties, false);\n                    LinkedList<String> preloads = new LinkedList<String>();\n                    preloads.addAll(p.get(\"loader.preload\"));\n                    preloads.addAll(p.get(\"compiler.link\"));\n                    // ... but we should use all the inherited paths!\n                    p = Loader.loadProperties(classArray, properties, true);\n\n                    File directory = f.getParentFile();\n                    for (String s : preloads) {\n                        URL[] urls = Loader.findLibrary(null, p, s);\n                        File fi;\n                        try {\n                            fi = new File(urls[0].toURI());\n                        } catch (Exception e) {\n                            continue;\n                        }\n                        File fo = new File(directory, fi.getName());\n                        if (fi.exists() && !outputFiles.contains(fo)) {\n                            System.out.println(\"Copying library file: \" + fi);\n                            FileInputStream fis = new FileInputStream(fi);\n                            FileOutputStream fos = new FileOutputStream(fo);\n                            byte[] buffer = new byte[1024];\n                            int length;\n                            while ((length = fis.read(buffer)) != -1) {\n                                fos.write(buffer, 0, length);\n                            }\n                            fos.close();\n                            fis.close();\n                            outputFiles.add(fo);\n                        }\n                    }\n                }\n            }\n        }\n\n        File[] files = outputFiles.toArray(new File[outputFiles.size()]);\n        if (jarPrefix != null && files.length > 0) {\n            File jarFile = new File(jarPrefix + \"-\" + properties.get(\"platform.name\") + \".jar\");\n            File d = jarFile.getParentFile();\n            if (d != null && !d.exists()) {\n                d.mkdir();\n            }\n            createJar(jarFile, outputDirectory == null ? classScanner.getClassLoader().getPaths() : null, files);\n        }\n        return files;\n    }\n\n",
    "label": 1,
    "rec": "Starts the build process and returns an array of  File produced."
  },
  {
    "id": 3251,
    "type": "Summary",
    "comment": "Check if dragged view is next to the left bound.",
    "code": "    boolean isNextToLeftBound() {\n        return transformer.isNextToLeftBound();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3252,
    "type": "Summary",
    "comment": "Returns the annotations infos.",
    "code": "    public AnnotationElement.Annotation[] getAnnotations() {\r\n        return getAnnotationReader().getAnnotationElements();\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns the annotations."
  },
  {
    "id": 3253,
    "type": "Summary",
    "comment": "Initializes logger.",
    "code": "    private static GridLogger initLogger(String log) throws GridException {\n\n        Logger impl = Logger.getRootLogger();\n\n        impl.removeAllAppenders();\n\n        String fileName =  U.getGridGainHome() + \"/work/log/\" + log;\n\n        // Configure output that should go to System.out\n        RollingFileAppender fileApp;\n\n        String fmt = \"[%d{ABSOLUTE}][%-5p][%t][%c{1}] %m%n\";\n\n        try {\n            fileApp = new RollingFileAppender(new PatternLayout(fmt), fileName);\n\n            fileApp.setMaxBackupIndex(0);\n\n            fileApp.rollOver();\n        }\n        catch (IOException e) {\n            throw new GridException(\"Unable to initialize file appender.\", e);\n        }\n\n        LevelRangeFilter lvlFilter = new LevelRangeFilter();\n\n        lvlFilter.setLevelMin(Level.DEBUG);\n\n        fileApp.addFilter(lvlFilter);\n\n        impl.addAppender(fileApp);\n\n        // Configure output that should go to System.out\n        ConsoleAppender conApp = new ConsoleAppender(new PatternLayout(fmt), ConsoleAppender.SYSTEM_OUT);\n\n        lvlFilter = new LevelRangeFilter();\n\n        lvlFilter.setLevelMin(Level.INFO);\n        lvlFilter.setLevelMax(Level.INFO);\n\n        conApp.addFilter(lvlFilter);\n\n        impl.addAppender(conApp);\n\n        // Configure output that should go to System.err\n        conApp = new ConsoleAppender(new PatternLayout(fmt), ConsoleAppender.SYSTEM_ERR);\n\n        conApp.setThreshold(Level.WARN);\n\n        impl.addAppender(conApp);\n\n        impl.setLevel(Level.INFO);\n\n        Logger.getLogger(\"org.gridgain\").setLevel(Level.DEBUG);\n\n        // TODO 8242.\n        return new GridJavaLogger();//return new GridLog4jLogger(false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3254,
    "type": "Summary",
    "comment": "Returns the primary key columns making up the new primary key.",
    "code": "    public String[] getPrimaryKeyColumns()\r\n    {\r\n        return _primaryKeyColumns;\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns the primary key column names making up the new primary key."
  },
  {
    "id": 3255,
    "type": "Summary",
    "comment": "Return the cache listenable",
    "code": "    public Listenable<PathChildrenCacheListener> getListenable()\n    {\n        return listeners;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3256,
    "type": "Summary",
    "comment": "Check if native-zlib code is loaded and initialized correctly.",
    "code": "  public static boolean isNativeZlibLoaded(Configuration conf) {\n    return nativeZlibLoaded && conf.getBoolean(\"hadoop.native.lib\", true); \n  }\n\n",
    "label": 1,
    "rec": "Check if native-zlib code is loaded & initialized correctly and can be loaded for this job."
  },
  {
    "id": 3257,
    "type": "Summary",
    "comment": "Performs and authorization_code grant, but uses a token to assert the user's identity.",
    "code": "    protected UaaContext authenticateAuthCodeWithToken(final TokenRequest tokenRequest) {\n        List<OAuth2AccessTokenSupport> providers = Collections.singletonList(\n            new AuthorizationCodeAccessTokenProvider() {\n                @Override\n                protected ResponseExtractor<OAuth2AccessToken> getResponseExtractor() {\n                    getRestTemplate(); // force initialization\n                    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n                    return new HttpMessageConverterExtractor<OAuth2AccessToken>(CompositeToken.class, Arrays.asList(converter));\n                }\n            }\n        );\n        enhanceRequestParameters(tokenRequest, providers.get(0));\n        AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails();\n        details.setPreEstablishedRedirectUri(tokenRequest.getRedirectUri().toString());\n        configureResourceDetails(tokenRequest, details);\n        setClientCredentials(tokenRequest, details);\n        setRequestScopes(tokenRequest, details);\n        details.setUserAuthorizationUri(tokenRequest.getAuthorizationEndpoint().toString());\n        DefaultOAuth2ClientContext oAuth2ClientContext = new DefaultOAuth2ClientContext();\n        oAuth2ClientContext.getAccessTokenRequest().setStateKey(tokenRequest.getState());\n        oAuth2ClientContext.setPreservedState(tokenRequest.getState(), details.getPreEstablishedRedirectUri());\n        oAuth2ClientContext.getAccessTokenRequest().setCurrentUri(details.getPreEstablishedRedirectUri());\n        Map<String, List<String>> headers = (Map<String, List<String>>) oAuth2ClientContext.getAccessTokenRequest().getHeaders();\n        headers.put(\"Authorization\", Arrays.asList(\"bearer \" + tokenRequest.getAuthCodeAPIToken()));\n        OAuth2RestTemplate template = new OAuth2RestTemplate(details, oAuth2ClientContext);\n        skipSslValidation(tokenRequest, template, providers);\n        OAuth2AccessToken token = template.getAccessToken();\n        return new UaaContextImpl(tokenRequest, template, (CompositeToken) token);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3258,
    "type": "Summary",
    "comment": "Gets the JobInfo object by reading the Configuration and deserializing the string.",
    "code": "  private static InputJobInfo getJobInfo(JobContext jobContext) throws Exception {\n    String jobString = jobContext.getConfiguration().get(HCatConstants.HCAT_KEY_JOB_INFO);\n    if( jobString == null ) {\n      throw new Exception(\"job information not found in JobContext. HCatInputFormat.setInput() not called?\");\n    }\n\n    return (InputJobInfo) HCatUtil.deserialize(jobString);\n  }\n\n",
    "label": 1,
    "rec": "Gets the InputJobInfo object by reading the Configuration and deserializing the string."
  },
  {
    "id": 3259,
    "type": "Summary",
    "comment": "Get selected reference from results bundle",
    "code": "    public static GitReference getSelected(Bundle arguments) {\n        return (GitReference) arguments.getParcelable(ARG_SELECTED);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3260,
    "type": "Summary",
    "comment": "Finds the  Grid, which has a local node with given ID.",
    "code": "    @Nullable private Ignite findGridForNodeId(final UUID nodeId) {\n        return F.find(G.allGrids(), null, new P1<Ignite>() {\n            @Override public boolean apply(Ignite e) {\n                return nodeId.equals(e.cluster().localNode().id());\n            }\n        });\n    }\n",
    "label": 1,
    "rec": "Finds the  org.gridgain.grid.Ignite, which has a local node with given ID."
  },
  {
    "id": 3261,
    "type": "Summary",
    "comment": "Add a user account from the properties provided.",
    "code": "\tpublic ScimUser addUser(UaaUser user) {\n\t\tScimUser scimUser = getScimUser(user);\n\t\tList<ScimUser> users = scimUserProvisioning.retrieveUsers(\"userName eq '\" + user.getUsername() + \"'\");\n\t\tif (users.isEmpty()) {\n\t\t\tlogger.info(\"Registering new user account: \" + user);\n\t\t\t// TODO: send a message or raise an event that can be used to inform the user of his new password\n\t\t\tscimUser = scimUserProvisioning.createUser(scimUser, user.getPassword());\n\t\t} else {\n\t\t\tif (!override) {\n\t\t\t\tlogger.debug(\"Not registering existing user: \" + user);\n\t\t\t\t// We don't update existing accounts - use the ScimUserProvisioning for that\n\t\t\t} else {\n\t\t\t\tString id = users.iterator().next().getId();\n\t\t\t\tscimUserProvisioning.updateUser(id, scimUser);\n\t\t\t\tscimUserProvisioning.changePassword(id, null, user.getPassword());\n\t\t\t}\n\t\t}\n\t\tif (scimGroupProvisioning != null && membershipManager != null) {\n\t\t\tSet<Group> groups = scimUser.getGroups();\n\t\t\tfor (Group g : groups) {\n\t\t\t\taddToGroup(scimUser, g.display);\n\t\t\t}\n\t\t}\n\t\treturn scimUser;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3262,
    "type": "Summary",
    "comment": "Get a specific entry",
    "code": "\tpublic Word get(int index)\n\t{\n\t\treturn words.get(index);\n\t}\n\n",
    "label": 1,
    "rec": "Get a specific word"
  },
  {
    "id": 3263,
    "type": "Summary",
    "comment": "Indicates that GridGain has been sufficiently tested on the current OS.",
    "code": "    public static boolean isSufficientlyTestedOs() {\n        return\n            win7 ||\n                win8 ||\n                win81 ||\n                winXp ||\n                winVista ||\n                mac ||\n                linux ||\n                solaris;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3264,
    "type": "Summary",
    "comment": "Return all the values in a hash.",
    "code": "    public List<String> hvals(final String key) {\n        runChecks();\n        client.hvals(key);\n        final List<String> lresult = client.getMultiBulkReply();\n        return lresult;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3265,
    "type": "Summary",
    "comment": "Returns a set of Nodes sorted according to their depths.",
    "code": "    private static List<NodeDepth> initialiseAndOrderNodes(\n            final Document doc) {\n\n        NodeIterator ni = ((DocumentTraversal) doc).createNodeIterator(\n                doc.getDocumentElement(), NodeFilter.SHOW_ALL, null, false);\n\n        List<NodeDepth> depthSorted = new ArrayList<NodeDepth>();\n             \n        Node n;\n        while ((n = ni.nextNode()) != null) {\n            depthSorted.add(new NodeDepth(n));\n        }\n        \n        ni.detach();\n        Collections.sort(depthSorted, new NodeDepthComparator());\n        \n        return depthSorted;\n    }\n\n",
    "label": 1,
    "rec": "Returns a list of Nodes sorted according to their depths."
  },
  {
    "id": 3266,
    "type": "Summary",
    "comment": "Returns the self-loop supervisor.",
    "code": "    public SelfLoopSupervisorImpl getSelfLoopSupervisor() {\n        return (SelfLoopSupervisorImpl) parent.getModel().getSelfLoopSupervisor();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3267,
    "type": "Summary",
    "comment": "Returns the ECKey identified in the connected output, for either P2PKH scripts or P2PK scripts.",
    "code": "    public ECKey getConnectedKey(KeyBag keyBag) throws ScriptException {\n        TransactionOutput connectedOutput = getConnectedOutput();\n        checkNotNull(connectedOutput, \"Input is not connected so cannot retrieve key\");\n        Script connectedScript = connectedOutput.getScriptPubKey();\n        if (ScriptPattern.isPayToPubKeyHash(connectedScript)) {\n            byte[] addressBytes = ScriptPattern.extractHashFromPayToPubKeyHash(connectedScript);\n            return keyBag.findKeyFromPubKeyHash(addressBytes, Script.ScriptType.P2PKH);\n        } else if (ScriptPattern.isPayToWitnessPubKeyHash(connectedScript)) {\n            byte[] addressBytes = ScriptPattern.extractHashFromPayToWitnessHash(connectedScript);\n            return keyBag.findKeyFromPubKeyHash(addressBytes, Script.ScriptType.P2WPKH);\n        } else if (ScriptPattern.isPayToPubKey(connectedScript)) {\n            byte[] pubkeyBytes = ScriptPattern.extractKeyFromPayToPubKey(connectedScript);\n            return keyBag.findKeyFromPubKey(pubkeyBytes);\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Could not understand form of connected output script: \" + connectedScript);\n        }\n    }\n",
    "label": 1,
    "rec": "Returns the ECKey identified in the connected output, for either P2PKH, P2WPKH or P2PK scripts."
  },
  {
    "id": 3268,
    "type": "Summary",
    "comment": "Checks if this is a directory-related event.",
    "code": "    public boolean isDirectory() {\n        int t = type();\n\n        return t == EVT_IGFS_DIR_CREATED || t == EVT_IGFS_DIR_RENAMED || t == EVT_IGFS_DIR_DELETED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3269,
    "type": "Summary",
    "comment": "Hash the provided  token's credentials using the salt stored with the account if the  info instance is an  instanceof  SaltedAuthenticationInfo SaltedAuthenticationInfo (see the class-level JavaDoc for why this is the preferred approach).",
    "code": "    protected Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations) {\n        String hashAlgorithmName = assertHashAlgorithmName();\n        return new SimpleHash(hashAlgorithmName, credentials, salt, hashIterations);\n    }\n",
    "label": 1,
    "rec": "Hashes the provided credentials a total of  hashIterations times, using the given salt."
  },
  {
    "id": 3270,
    "type": "Summary",
    "comment": "Returns the dataHolder for the given world.",
    "code": "    public OverloadedWorldHolder getWorldData(String worldName) {\n    \tString worldNameLowered = worldName.toLowerCase();\n    \t\n    \tif (worldsData.containsKey(worldNameLowered))\n    \t\t\treturn worldsData.get(worldNameLowered);\n\n        GroupManager.logger.finest(\"Requested world \" + worldName + \" not found or badly mirrored. Returning default world...\");\n        return getDefaultWorld();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3271,
    "type": "Summary",
    "comment": "Returns an array of URLs from the given comma-separated list of URLs.",
    "code": "\tprivate static URI[] getURLs(String spec) {\n\t\tString[] urlSpecs = getArrayFromString(spec, \",\"); //$NON-NLS-1$\n\t\tArrayList result = new ArrayList(urlSpecs.length);\n\t\tfor (int i = 0; i < urlSpecs.length; i++) {\n\t\t\ttry {\n\t\t\t\tresult.add(new URI(urlSpecs[i]));\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tLogHelper.log(new Status(IStatus.ERROR, InstallerActivator.PI_INSTALLER, \"Invalid URL in install description: \" + urlSpecs[i], e)); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty())\n\t\t\treturn null;\n\t\treturn (URI[]) result.toArray(new URI[result.size()]);\n\t}\n\n",
    "label": 1,
    "rec": "Returns an array of URIs from the given comma-separated list of URLs."
  },
  {
    "id": 3272,
    "type": "Summary",
    "comment": "Return a new instance with the currently set values",
    "code": "    public ServiceInstance<T> build()\n    {\n        return new ServiceInstance<T>(name, id, address, port, sslPort, payload, registrationTimeUTC);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3273,
    "type": "Summary",
    "comment": "Returns a string representation of this interval in one of the formats:    [low, high, value]   (low, high, value]   [low, high, value)   (low, high, value)  Times are always shown as doubles",
    "code": "\tpublic String toString() {\n\t\treturn (lopen ? \"(\" : \"[\") + low + \", \" + high + \", \" + value + (ropen ? \")\" : \"]\");\n\t}\n",
    "label": 1,
    "rec": "Returns a string representation of this interval in one of the formats:    [low, high, value]   (low, high, value]   [low, high, value)   (low, high, value) "
  },
  {
    "id": 3274,
    "type": "Summary",
    "comment": "Create GGFS file with the given path.",
    "code": "    private IgniteFsFile file(String path) {\n        return new IgniteFsFileImpl(new IgniteFsPath(path), new GridGgfsFileInfo(), 64 * 1024 * 1024);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3275,
    "type": "Summary",
    "comment": "Tries to reassemble the handshake message with the available fragments.",
    "code": "\tprivate final HandshakeMessage reassembleFragments(\r\n\t\t\tint messageSeq,\r\n\t\t\tSortedSet<FragmentedHandshakeMessage> fragments,\r\n\t\t\tint totalLength,\r\n\t\t\tHandshakeType type,\r\n\t\t\tDTLSSession session) throws HandshakeException {\r\n\r\n\t\tHandshakeMessage message = null;\r\n\r\n\t\tbyte[] reassembly = new byte[] {};\r\n\t\tint offset = 0;\r\n\t\tfor (FragmentedHandshakeMessage fragmentedHandshakeMessage : fragments) {\r\n\t\t\t\r\n\t\t\tint fragmentOffset = fragmentedHandshakeMessage.getFragmentOffset();\r\n\t\t\tint fragmentLength = fragmentedHandshakeMessage.getFragmentLength();\r\n\t\t\t\r\n\t\t\tif (fragmentOffset == offset) { // eliminate duplicates\r\n\t\t\t\t// case: no overlap\r\n\t\t\t\treassembly = ByteArrayUtils.concatenate(reassembly, fragmentedHandshakeMessage.fragmentToByteArray());\r\n\t\t\t\toffset = reassembly.length;\r\n\t\t\t} else if (fragmentOffset < offset && (fragmentOffset + fragmentLength) > offset) {\r\n\t\t\t\t// case: overlap fragment\r\n\t\t\t\t\r\n\t\t\t\t// determine the offset where the fragment adds new information for the reassembly\r\n\t\t\t\tint newOffset = offset - fragmentOffset;\r\n\t\t\t\tint newLength = fragmentLength - newOffset;\r\n\t\t\t\tbyte[] newBytes = new byte[newLength];\r\n\t\t\t\t// take only the new bytes and add them\r\n\t\t\t\tSystem.arraycopy(fragmentedHandshakeMessage.fragmentToByteArray(), newOffset, newBytes, 0, newLength);\t\r\n\t\t\t\treassembly = ByteArrayUtils.concatenate(reassembly, newBytes);\r\n\t\t\t\t\r\n\t\t\t\toffset = reassembly.length;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (reassembly.length == totalLength) {\r\n\t\t\t// the reassembled fragment has the expected length\r\n\t\t\tFragmentedHandshakeMessage wholeMessage =\r\n\t\t\t\t\tnew FragmentedHandshakeMessage(type, totalLength, messageSeq, 0, reassembly, getPeerAddress());\r\n\t\t\treassembly = wholeMessage.toByteArray();\r\n\t\t\t\r\n\t\t\tKeyExchangeAlgorithm keyExchangeAlgorithm = KeyExchangeAlgorithm.NULL;\r\n\t\t\tboolean receiveRawPublicKey = false;\r\n\t\t\tif (session != null) {\r\n\t\t\t\tkeyExchangeAlgorithm = session.getKeyExchange();\r\n\t\t\t\treceiveRawPublicKey = session.receiveRawPublicKey();\r\n\t\t\t}\r\n\t\t\tmessage = HandshakeMessage.fromByteArray(reassembly, keyExchangeAlgorithm, receiveRawPublicKey, getPeerAddress());\r\n\t\t}\r\n\t\t\r\n\t\treturn message;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Reassembles handshake message fragments into the original message."
  },
  {
    "id": 3276,
    "type": "Summary",
    "comment": "Returns the message processor for the specified message class",
    "code": "\tpublic static ZWaveCommandProcessor getMessageDispatcher(SerialMessage.SerialMessageClass serialMessage) {\n\t\tif(messageMap == null) {\n\t\t\tmessageMap = new HashMap<SerialMessage.SerialMessageClass, Class<? extends ZWaveCommandProcessor>>();\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AddNodeToNetwork, AddNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationCommandHandler, ApplicationCommandMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.ApplicationUpdate, ApplicationUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignReturnRoute, AssignReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.AssignSucReturnRoute, AssignSucReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.DeleteReturnRoute, DeleteReturnRouteMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.EnableSuc, EnableSucMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetRoutingInfo, GetRoutingInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetVersion, GetVersionMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetSucNodeId, GetSucNodeIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.GetControllerCapabilities, GetControllerCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IdentifyNode, IdentifyNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.MemoryGetId, MemoryGetIdMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveFailedNodeID, RemoveFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.IsFailedNodeID, IsFailedNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RemoveNodeFromNetwork, RemoveNodeMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeInfo, RequestNodeInfoMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.RequestNodeNeighborUpdate, RequestNodeNeighborUpdateMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SendData, SendDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialApiGetCapabilitiesMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SerialApiGetInitData, SerialApiGetInitDataMessageClass.class);\n\t\t\tmessageMap.put(SerialMessage.SerialMessageClass.SetSucNodeID, SetSucNodeMessageClass.class);\n\t\t}\n\n\t\tConstructor<? extends ZWaveCommandProcessor> constructor;\n\t\ttry {\n\t\t\tconstructor = messageMap.get(serialMessage).getConstructor();\n\t\t\treturn constructor.newInstance();\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t} catch (InstantiationException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t} catch (SecurityException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"Command processor error: {}\", e);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3277,
    "type": "Summary",
    "comment": "This method returns a Filter that performs xor on two other filters.",
    "code": "    public static <E> Predicates.XorPredicate<E> xor(Predicate<E> left, Predicate<E> right) {\r\n        return new Predicates.XorPredicate<E>(left, right);\r\n    }\r\n\n",
    "label": 1,
    "rec": "This method returns a Predicate that performs xor on two other predicates."
  },
  {
    "id": 3278,
    "type": "Summary",
    "comment": "Calculates the PathDetails for this Path.",
    "code": "    public String toString() {\n        return \"found: \" + found + \", weight: \" + weight + \", time: \" + time + \", distance: \" + distance + \", edges: \" + edgeIds.size();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3279,
    "type": "Summary",
    "comment": "Asynchronously renders the given resource value (which should refer to a drawable) and returns it as an image.",
    "code": "  @Nullable\n  public BufferedImage renderDrawable(ResourceValue drawableResourceValue) {\n    if (drawableResourceValue == null) {\n      return null;\n    }\n\n    HardwareConfig hardwareConfig = myHardwareConfigHelper.getConfig();\n\n    Module module = myRenderService.getModule();\n    final DrawableParams params =\n      new DrawableParams(drawableResourceValue, module, hardwareConfig, getResourceResolver(), myLayoutlibCallback,\n                         myMinSdkVersion.getApiLevel(), myTargetSdkVersion.getApiLevel(), myLogger);\n    params.setForceNoDecor();\n    params.setAssetRepository(myAssetRepository);\n\n    try {\n      Result result = RenderService.runRenderAction(new Callable<Result>() {\n        @Override\n        public Result call() throws Exception {\n          return myLayoutLib.renderDrawable(params);\n        }\n      });\n\n      if (result != null && result.isSuccess()) {\n        Object data = result.getData();\n        if (data instanceof BufferedImage) {\n          return (BufferedImage)data;\n        }\n      }\n    }\n    catch (final Exception e) {\n      // ignore\n    }\n\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Renders the given resource value (which should refer to a drawable) and returns it as an image"
  },
  {
    "id": 3280,
    "type": "Summary",
    "comment": "Build a new schema from the currently set values",
    "code": "    public Schema build()\n    {\n        return new Schema(name, pathRegex, path, documentation, schemaValidator, ephemeral, sequential, watched, canBeDeleted, metadata);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3281,
    "type": "Summary",
    "comment": "Returns the  AbstractTaskContainer category the new task belongs to",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tprotected AbstractTaskListElement getCategory() {\n\t\tint index = categoryChooser.getSelectionIndex();\n\t\tif (addToCategory.getSelection() && index != -1) {\n\t\t\tif (index == 0) {\n\t\t\t\treturn TasksUiPlugin.getTaskListManager().getTaskList().getUncategorizedCategory();\n\t\t\t}\n\t\t\treturn ((List<AbstractTaskListElement>) categoryChooser.getData()).get(index - 1);\n\t\t}\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the  AbstractTaskListElement category the new task belongs to"
  },
  {
    "id": 3282,
    "type": "Summary",
    "comment": "Creates an OSM turn relation out of an unspecified OSM relation ",
    "code": "    OSMTurnRelation createTurnRelation(ReaderRelation relation) {\n        String tagRestriction = \"\";\n        String vehicleTypeRestricted = \"\";\n        List<String> vehicleTypesExcept = new ArrayList<>();\n        if (relation.hasTag(\"restriction\")) {\n            tagRestriction = relation.getTag(\"restriction\");\n        } else if (relation.hasTagStartsWith(\"restriction:\")) {\n            vehicleTypeRestricted = relation.getKeyStartsWith(\"restriction:\");\n            tagRestriction = relation.getTag(vehicleTypeRestricted);\n            vehicleTypeRestricted = vehicleTypeRestricted.replace(\"restriction:\", \"\").trim();\n        }\n        if (relation.hasTag(\"except\")) {\n            String tagExcept = relation.getTag(\"except\");\n            if (!Helper.isEmpty(tagExcept)) {\n                List<String> vehicleTypes = new ArrayList<>(Arrays.asList(tagExcept.split(\";\")));\n                for (String vehicleType : vehicleTypes)\n                    vehicleTypesExcept.add(vehicleType.trim());\n            }\n        }\n        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(tagRestriction);\n        if (type != OSMTurnRelation.Type.UNSUPPORTED) {\n            long fromWayID = -1;\n            long viaNodeID = -1;\n            long toWayID = -1;\n\n            for (ReaderRelation.Member member : relation.getMembers()) {\n                if (ReaderElement.WAY == member.getType()) {\n                    if (\"from\".equals(member.getRole())) {\n                        fromWayID = member.getRef();\n                    } else if (\"to\".equals(member.getRole())) {\n                        toWayID = member.getRef();\n                    }\n                } else if (ReaderElement.NODE == member.getType() && \"via\".equals(member.getRole())) {\n                    viaNodeID = member.getRef();\n                }\n            }\n            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0) {\n                OSMTurnRelation osmTurnRelation = new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);\n                osmTurnRelation.setVehicleTypeRestricted(vehicleTypeRestricted);\n                osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);\n                return osmTurnRelation;\n            }\n        }\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3283,
    "type": "Summary",
    "comment": "Determines the  KEdge KEdges that are (transitively) connected to  kedge across hierarchy boundaries via common ports.",
    "code": "    public static Iterator<ElkEdge> getConnectedEdges(final ElkEdge edge) {\n        // Default behavior should be to not select the ports\n        return Iterators.filter(getConnectedElements(edge, false), ElkEdge.class);\n    }\n\n",
    "label": 1,
    "rec": "Determines the edges that are (transitively) connected to the given edge across hierarchy boundaries via common ports."
  },
  {
    "id": 3284,
    "type": "Summary",
    "comment": "Get issue from event",
    "code": "    public Issue getIssue(GithubEvent event) {\n        if (event == null)\n            return null;\n        if (event.payload == null)\n            return null;\n\n        Gson gson = new Gson();\n        String json = gson.toJson(event.payload);\n\n        switch (event.type) {\n            case IssuesEvent:\n                return gson.fromJson(json, IssueEventPayload.class).issue;\n            case IssueCommentEvent:\n                return gson.fromJson(json, IssueCommentEventPayload.class).issue;\n            case PullRequestEvent:\n                return gson.fromJson(json, PullRequestEventPayload.class).pull_request;\n            default:\n                return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3285,
    "type": "Summary",
    "comment": "Use doThrow() when you want to stub the void method to throw exception of specified class.",
    "code": "    public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n        return MOCKITO_CORE.stubber().doThrow(toBeThrown);\n    }\n",
    "label": 1,
    "rec": "Use doThrow() when you want to stub the void method with an exception."
  },
  {
    "id": 3286,
    "type": "Summary",
    "comment": "Resolves task name by task name hash.",
    "code": "    public String resolveTaskName(int taskNameHash) {\n        if (taskNameHash == 0)\n            return null;\n\n        assert ctx.security().enabled();\n\n        return tasksMetaCache.peek(new GridTaskNameHashKey(taskNameHash));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3287,
    "type": "Summary",
    "comment": "Gets the face that this block is attached on",
    "code": "    public BlockFace getAttachedFace() {\n        byte data = getData();\n\n        switch (data) {\n        case 0x1:\n            return BlockFace.WEST;\n\n        case 0x2:\n            return BlockFace.EAST;\n\n        case 0x3:\n            return BlockFace.NORTH;\n\n        case 0x4:\n            return BlockFace.SOUTH;\n\n        case 0x5:\n            return BlockFace.DOWN;\n        }\n\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3288,
    "type": "Summary",
    "comment": "Creates a new Filter based on given criteria",
    "code": "    public static Filter filter(Collection<Predicate> predicates) {\n        return new AndFilter(predicates);\n    }\n",
    "label": 1,
    "rec": "Create a new Filter based on given list of criteria."
  },
  {
    "id": 3289,
    "type": "Summary",
    "comment": "Resolve file info for the given path and the given mode.",
    "code": "    private IgfsFileInfo resolveFileInfo(IgfsPath path, IgfsMode mode) throws IgniteCheckedException {\n        assert path != null;\n        assert mode != null;\n\n        IgfsFileInfo info = null;\n\n        switch (mode) {\n            case PRIMARY:\n                info = meta.info(meta.fileId(path));\n\n                break;\n\n            case DUAL_SYNC:\n            case DUAL_ASYNC:\n                info = meta.info(meta.fileId(path));\n\n                if (info == null) {\n                    IgfsFile status = secondaryFs.info(path);\n\n                    if (status != null)\n                        info = status.isDirectory() ? new IgfsFileInfo(true, status.properties()) :\n                            new IgfsFileInfo(status.blockSize(), status.length(), null, null, false,\n                            status.properties());\n                }\n\n                break;\n\n            default:\n                assert false : \"Unknown mode: \" + mode;\n        }\n\n        return info;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3290,
    "type": "Summary",
    "comment": "Return true if the supplied object is a  GateEditPart; otherwise false.",
    "code": "\tprotected boolean isGateEditPart( Object object ) {\n\t\treturn object instanceof BorderItemEditPart && ((BorderItemEditPart)object).getMainFigure() instanceof BorderItemFigure;\n\t}\n\n",
    "label": 1,
    "rec": "Return true if the supplied object is a  BorderItemEditPart; otherwise false."
  },
  {
    "id": 3291,
    "type": "Summary",
    "comment": "Get the value at the specified index within the message.",
    "code": "    public int getValue(int idx) {\n        return (buffer.getShort(idx * 2 + 2));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3292,
    "type": "Summary",
    "comment": "Returns the right side operand.",
    "code": "        public Predicate<? super E> getRightPredicate() {\r\n            return right;\r\n        }\r\n\n",
    "label": 1,
    "rec": "Returns the right side Predicate."
  },
  {
    "id": 3293,
    "type": "Summary",
    "comment": "After a horizontal scan finds a potential finder pattern, this method \"cross-checks\" by scanning down vertically through the center of the possible finder pattern to see if the same proportion is detected.",
    "code": "  private float crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal) {\n    MonochromeBitmapSource image = this.image;\n\n    int maxI = image.getHeight();\n    int[] stateCount = new int[5];\n\n    // Start counting up from center\n    int i = startI;\n    while (i >= 0 && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i--;\n    }\n    if (i < 0) {\n      return Float.NaN;\n    }\n    while (i >= 0 && !image.isBlack(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return Float.NaN;\n    }\n    while (i >= 0 && image.isBlack(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return Float.NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.isBlack(centerJ, i)) {\n      stateCount[2]++;\n      i++;\n    }\n    if (i == maxI) {\n      return Float.NaN;\n    }\n    while (i < maxI && !image.isBlack(centerJ, i) && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      i++;\n    }\n    if (i == maxI || stateCount[3] >= maxCount) {\n      return Float.NaN;\n    }\n    while (i < maxI && image.isBlack(centerJ, i) && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      i++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return Float.NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is more than 20% different than\n    // the original, assume it's a false positive\n    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n      return Float.NaN;\n    }\n\n    return foundPatternCross(stateCount) ? centerFromEnd(stateCount, i) : Float.NaN;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3294,
    "type": "Summary",
    "comment": "Gets serializer.",
    "code": "    public PortableSerializer getSerializer() {\n        return serializer;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3295,
    "type": "Summary",
    "comment": "Adds a file with the given  idx to the batch.",
    "code": "    public String addFile(String index, InputStream is, String name, String mime) throws IOException {\n        String mimeType = mime;\n        if (mimeType == null) {\n            mimeType = \"application/octet-stream\";\n        }\n        Blob blob = Blobs.createBlob(is, mime);\n        blob.setFilename(name);\n\n        String fileEntryKey = key + \"_\" + index;\n        BatchManager bm = Framework.getService(BatchManager.class);\n        bm.getTransientStore().putBlobs(fileEntryKey, Collections.singletonList(blob));\n        bm.getTransientStore().putParameter(fileEntryKey, CHUNKED_PARAM_NAME, String.valueOf(false));\n        bm.getTransientStore().putParameter(key, index, fileEntryKey);\n\n        return fileEntryKey;\n    }\n\n",
    "label": 1,
    "rec": "Adds a file with the given  index to the batch."
  },
  {
    "id": 3296,
    "type": "Summary",
    "comment": "Cache configuration.",
    "code": "    protected CacheConfiguration cacheConfiguration(String gridName) throws Exception {\n        CacheConfiguration cfg = defaultCacheConfiguration();\n        cfg.setCacheMode(PARTITIONED);\n        cfg.setStartSize(700000);\n        cfg.setWriteSynchronizationMode(FULL_ASYNC);\n        cfg.setEvictionPolicy(null);\n        cfg.setBackups(1);\n        cfg.setDistributionMode(PARTITIONED_ONLY);\n        cfg.setPreloadPartitionedDelay(-1);\n        cfg.setBackups(1);\n\n        GridCacheQueryConfiguration qcfg = new GridCacheQueryConfiguration();\n\n        qcfg.setIndexPrimitiveKey(true);\n\n        cfg.setQueryConfiguration(qcfg);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3297,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_POSITION_SYNC;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3298,
    "type": "Summary",
    "comment": "Returns all rules for which the trigger condition is true for the given type, item and command.",
    "code": "\tpublic Iterable<Rule> getRules(TriggerTypes triggerType, Item item, Command command) {\n\t\treturn internalGetRules(triggerType, item, null, command);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3299,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_FILE_OWNER;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3300,
    "type": "Summary",
    "comment": "Extends the tree by calculating the next key that hangs off the given parent path.",
    "code": "    public DeterministicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation) {\n        DeterministicKey parent = get(parentPath, relative, createParent);\n        int nAttempts = 0;\n        while (nAttempts++ < MAX_CHILD_DERIVATION_ATTEMPTS) {\n            try {\n                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getChildNumberPath(), privateDerivation);\n                return deriveChild(parent, createChildNumber);\n            } catch (HDDerivationException ignore) { }\n        }\n        throw new HDDerivationException(\"Maximum number of child derivation attempts reached, this is probably an indication of a bug.\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3301,
    "type": "Summary",
    "comment": "Prepares near transaction.",
    "code": "            @Override public GridNearTxPrepareResponse apply(IgniteInternalFuture<GridNearTxPrepareResponse> f) {\n                try {\n                    return f.get();\n                }\n                catch (Exception e) {\n                    locTx.setRollbackOnly(); // Just in case.\n\n                    if (!X.hasCause(e, IgniteTxOptimisticCheckedException.class) &&\n                        !X.hasCause(e, IgniteFutureCancelledException.class))\n                        U.error(log, \"Failed to prepare DHT transaction: \" + locTx, e);\n\n                    return new GridNearTxPrepareResponse(\n                        req.version(),\n                        req.futureId(),\n                        req.miniId(),\n                        req.version(),\n                        req.version(),\n                        null,\n                        e,\n                        null,\n                        req.deployInfo() != null);\n                }\n            }\n",
    "label": 1,
    "rec": "Prepares local colocated tx."
  },
  {
    "id": 3302,
    "type": "Summary",
    "comment": "Return all the members (elements) of the set value stored at key.",
    "code": "    public Set<String> smembers(final String key) {\n        runChecks();\n        client.smembers(key);\n        final List<String> members = client.getMultiBulkReply();\n        return new HashSet<String>(members);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3303,
    "type": "Summary",
    "comment": "Get length of current track.",
    "code": "\tpublic int length(){\n\t\tif(this.oggPlayer != null){\n\t\t\treturn this.oggPlayer.length();\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n",
    "label": 1,
    "rec": "Get length of current track in milliseconds."
  },
  {
    "id": 3304,
    "type": "Summary",
    "comment": "Gets topology version or -1 in case of topology version is not required for this message.",
    "code": "    public AffinityTopologyVersion topologyVersion() {\n        return AffinityTopologyVersion.NONE;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3305,
    "type": "Summary",
    "comment": "short argument that matches both given argument matchers.",
    "code": "    public static short and(short first, short second) {\n        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3306,
    "type": "Summary",
    "comment": "Get RowsFragment if it's bound to BrowseFragment or null if either BrowseFragment has not been created yet or a different fragment is bound to it.",
    "code": "    public RowsFragment getRowsFragment() {\n        return (RowsFragment)mMainFragment;\n    }\n\n",
    "label": 1,
    "rec": "Get currently bound RowsFragment or null if BrowseFragment has not been created yet."
  },
  {
    "id": 3307,
    "type": "Summary",
    "comment": "Returns current authentication session if it exists, otherwise returns  null.",
    "code": "    public AuthenticationSessionModel getCurrentAuthenticationSession(RealmModel realm, ClientModel client, String tabId) {\n        List<String> authSessionIds = getAuthSessionCookieIds(realm);\n\n        return authSessionIds.stream().map(id -> {\n            SimpleEntry<String, String> entry = decodeAuthSessionId(id);\n            String sessionId = entry.getKey();\n\n            AuthenticationSessionModel authSession = getAuthenticationSessionByIdAndClient(realm, sessionId, client, tabId);\n\n            if (authSession != null) {\n                reencodeAuthSessionCookie(sessionId, entry.getValue(), realm);\n                return authSession;\n            }\n\n            return null;\n        }).filter(authSession -> Objects.nonNull(authSession)).findFirst().orElse(null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3308,
    "type": "Summary",
    "comment": "Asynchronously renders the given resource value (which should refer to a drawable) and returns it as an image.",
    "code": "  @Nullable\n  public BufferedImage renderDrawable(ResourceValue drawableResourceValue) {\n    if (drawableResourceValue == null) {\n      return null;\n    }\n\n    HardwareConfig hardwareConfig = myHardwareConfigHelper.getConfig();\n\n    Module module = myRenderService.getModule();\n    final DrawableParams params =\n      new DrawableParams(drawableResourceValue, module, hardwareConfig, getResourceResolver(), myLayoutlibCallback,\n                         myMinSdkVersion.getApiLevel(), myTargetSdkVersion.getApiLevel(), myLogger);\n    params.setForceNoDecor();\n    params.setAssetRepository(myAssetRepository);\n\n    try {\n      Result result = RenderService.runRenderAction(new Callable<Result>() {\n        @Override\n        public Result call() throws Exception {\n          return myLayoutLib.renderDrawable(params);\n        }\n      });\n\n      if (result != null && result.isSuccess()) {\n        Object data = result.getData();\n        if (data instanceof BufferedImage) {\n          return (BufferedImage)data;\n        }\n      }\n    }\n    catch (final Exception e) {\n      // ignore\n    }\n\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Renders the given resource value (which should refer to a drawable) and returns it as an image"
  },
  {
    "id": 3309,
    "type": "Summary",
    "comment": "Escapes name to be valid SQL identifier.",
    "code": "    private static String escapeName(String name, boolean escapeAll) {\n        SB sb = null;\n\n        for (int i = 0; i < name.length(); i++) {\n            char ch = name.charAt(i);\n\n            if (!Character.isLetter(ch) && !Character.isDigit(ch) && ch != '_' &&\n                !(ch == '\"' && (i == 0 || i == name.length() - 1)) && ch != '-') {\n                // Class name can also contain '$' or '.' - these should be escaped.\n                assert ch == '$' || ch == '.';\n\n                if (sb == null)\n                    sb = new SB();\n\n                sb.a(name.substring(sb.length(), i));\n\n                // Replace illegal chars with '_'.\n                sb.a('_');\n            }\n        }\n\n        String res = sb == null ? name : sb.a(name.substring(sb.length(), name.length())).toString();\n\n        return escapeAll ? (\"\\\"\" + res + \"\\\"\") : res;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3310,
    "type": "Summary",
    "comment": "This default implementation merely returns new  SimpleSession#SimpleSession(java.net.InetAddress) SimpleSession( InetAddress originatingHost);",
    "code": "    public Session createSession(String host) {\n        return new SimpleSession(host);\n    }\n",
    "label": 1,
    "rec": "This default implementation merely returns new  SimpleSession#SimpleSession(String) SimpleSession(host);"
  },
  {
    "id": 3311,
    "type": "Summary",
    "comment": "Cast IO exception to GGFS exception.",
    "code": "    public static GridGgfsException cast(String msg, IOException e) {\n        if (e instanceof FileNotFoundException)\n            return new GridGgfsFileNotFoundException(e);\n        else if (e instanceof ParentNotDirectoryException)\n            return new GridGgfsParentNotDirectoryException(msg, e);\n        else if (e instanceof PathIsNotEmptyDirectoryException)\n            return new GridGgfsDirectoryNotEmptyException(e);\n        else if (e instanceof PathExistsException)\n            return new IgniteFsPathAlreadyExistsException(msg, e);\n        else\n            return new GridGgfsException(msg, e);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3312,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_SIGNATURE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3313,
    "type": "Summary",
    "comment": "Converts value as per appropriate DataType of the field.",
    "code": "    public static Object value(String strValue, Field field) {\n        checkNotNull(field);\n        // if field is not primitive type\n        Type fieldType = field.getGenericType();\n        if (fieldType instanceof ParameterizedType) {\n            Class<?> clazz = (Class<?>) ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[0];\n            // convert to list\n            if (field.getType().equals(List.class)) {\n                return stringToList(strValue, clazz);\n            } // convert to set\n            else if (field.getType().equals(Set.class)) {\n                return stringToSet(strValue, clazz);\n            } else if (field.getType().equals(Map.class)) {\n                Class<?> valueClass = (Class<?>) ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[1];\n                return stringToMap(strValue, clazz, valueClass);\n            } else if (field.getType().equals(Optional.class)) {\n                Type typeClazz = ((ParameterizedType) fieldType).getActualTypeArguments()[0];\n                if (typeClazz instanceof ParameterizedType) {\n                    throw new IllegalArgumentException(format(\"unsupported non-primitive Optional<%s> for %s\",\n                            typeClazz.getClass(), field.getName()));\n                }\n                return Optional.ofNullable(convert(strValue, (Class) typeClazz));\n            } else {\n                throw new IllegalArgumentException(\n                        format(\"unsupported field-type %s for %s\", field.getType(), field.getName()));\n            }\n        } else {\n            return convert(strValue, field.getType());\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3314,
    "type": "Summary",
    "comment": "Returns all context button menu entries, which are executable.",
    "code": "\tprivate List<SapphireActionHandler> getExecutableMenuEntries() {\n\t\t// has ContextButtonMenuEntries -> create popup\n\t\tList<SapphireActionHandler> activeHandlers = getSapphireAction().getActiveHandlers();\n\t\tList<SapphireActionHandler> menuEntries = new ArrayList<SapphireActionHandler>();\n\t\tfor (SapphireActionHandler handler : activeHandlers) {\n\t\t\tif (handler.isEnabled()) {\n\t\t\t\tmenuEntries.add(handler);\n\t\t\t}\n\t\t}\n\t\treturn menuEntries;\n\t}\n\n",
    "label": 1,
    "rec": "Returns all action handlers, which are executable."
  },
  {
    "id": 3315,
    "type": "Summary",
    "comment": "Attempt to kill the process, waiting up to the given time for it to die",
    "code": "  public boolean softKill(final long time, final TimeUnit unit)\n      throws InterruptedException {\n    checkStarted();\n    if (this.processId != 0 && isStarted()) {\n      try {\n        if (this.isExecuteAsUser) {\n          final String cmd =\n              String.format(\"%s %s %s %d\", this.executeAsUserBinary,\n                  this.effectiveUser, KILL_COMMAND, this.processId);\n          Runtime.getRuntime().exec(cmd);\n        } else {\n          final String cmd = String.format(\"%s %d\", KILL_COMMAND, this.processId);\n          Runtime.getRuntime().exec(cmd);\n        }\n        return this.completeLatch.await(time, unit);\n      } catch (final IOException e) {\n        this.logger.error(\"Kill attempt failed.\", e);\n      }\n      return false;\n    }\n    return false;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3316,
    "type": "Summary",
    "comment": "Searches through all stored sessions and returns that session which matches the session identifier or null if no such session available.",
    "code": "\tprivate DTLSSession getSessionByIdentifier(byte[] sessionId) {\r\n\t\tif (sessionId == null || sessionId.length == 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tfor (DTLSSession session:dtlsSessions.values()) {\r\n\t\t\tSessionId sessionIdentifier = session.getSessionIdentifier();\r\n\t\t\tif (sessionIdentifier != null) {\r\n\t\t\t\tif (Arrays.equals(sessionId, sessionIdentifier.getSessionId())) {\r\n\t\t\t\t\treturn session;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Finds a cached session by its identifier."
  },
  {
    "id": 3317,
    "type": "Summary",
    "comment": "Return the members of a set resulting from the union of all the sets hold at the specified keys.",
    "code": "  public Set<String> sunion(final String... keys) {\n    checkIsInMulti();\n    client.sunion(keys);\n    final List<String> members = client.getMultiBulkReply();\n    if (members == null) {\n      return null;\n    }\n    return new HashSet<String>(members);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3318,
    "type": "Summary",
    "comment": "Indicates if this instance is included in a [ low,  high] time interval.",
    "code": "\tpublic boolean isInRange(double low, double high) {\n\t\tif (low > high)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The left endpoint of the interval must be less than \" +\n\t\t\t\t\t\t\"the right endpoint.\");\n\n\t\treturn intervalTree.overlapsWith(new Interval<T>(low, high));\n\t}\n",
    "label": 1,
    "rec": "Indicates if [ low,  high] interval overlaps with any interval of this instance."
  },
  {
    "id": 3319,
    "type": "Summary",
    "comment": "Compiles a JsonPath",
    "code": "    public static JsonPath compile(String jsonPath, Filter... filters) {\n        notEmpty(jsonPath, \"json can not be null or empty\");\n\n        return new JsonPath(jsonPath, filters);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3320,
    "type": "Summary",
    "comment": "Check if Valuable contains a ENTITY or COLLECTION_ENTITY ValueType",
    "code": "  public boolean isEntity() {\n    return getValueType() == ValueType.ENTITY || getValueType() == ValueType.COLLECTION_ENTITY;\n  }\n\n",
    "label": 1,
    "rec": "Checks whether this parameter value is of the value type ENTITY or COLLECTION_ENTITY."
  },
  {
    "id": 3321,
    "type": "Summary",
    "comment": "Build a  DistributedQueue from the current builder values",
    "code": "    public DistributedQueue<T>      buildQueue()\n    {\n        return new DistributedQueue<T>\n        (\n            client,\n            consumer,\n            serializer,\n            queuePath,\n            factory,\n            executor,\n            Integer.MAX_VALUE,\n            false,\n            lockPath\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3322,
    "type": "Summary",
    "comment": "Creates a copy of the given object by an in-memory serialization and subsequent deserialization.",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends IOReadableWritable> T createCopy(final T original) throws IOException {\n\n\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tfinal DataOutputStream dos = new DataOutputStream(baos);\n\n\t\toriginal.write(dos);\n\n\t\tfinal String className = original.getClass().getName();\n\t\tif (className == null) {\n\t\t\tfail(\"Class name is null\");\n\t\t}\n\n\t\tClass<T> clazz = null;\n\n\t\ttry {\n\t\t\tclazz = (Class<T>) Class.forName(className);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (clazz == null) {\n\t\t\tfail(\"Cannot find class with name \" + className);\n\t\t}\n\n\t\tT copy = null;\n\t\ttry {\n\t\t\tcopy = clazz.newInstance();\n\t\t} catch (InstantiationException e) {\n\t\t\tfail(e.getMessage());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (copy == null) {\n\t\t\tfail(\"Copy of object of type \" + className + \" is null\");\n\t\t}\n\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\t\tfinal DataInputStream dis = new DataInputStream(bais);\n\n\t\tcopy.read(dis);\n\n\t\treturn copy;\n\t}\n\n",
    "label": 1,
    "rec": "Creates a copy of the given  IOReadableWritable object by an in-memory serialization and subsequent deserialization."
  },
  {
    "id": 3323,
    "type": "Summary",
    "comment": "New metadata object for linking a task to the specified tag.",
    "code": "    public static Metadata newTagMetadata(Task task, String tagName, BigInteger tagUuid) {\n        return newTagMetadata(task.getId(), task.getValue(Task.UUID), tagName, tagUuid);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3324,
    "type": "Summary",
    "comment": "Initialize a  ProxyHost from this  WebProxySettings for the provided hostToProxy.",
    "code": "    public ProxyHostEx toProxyHost(final String hostToProxy) {\r\n        final ProxyHostEx proxyHost;\r\n        if (this.hostName != null) {\r\n            final boolean shouldProxy = shouldProxy(hostToProxy, noProxyHostPatterns);\r\n            if (shouldProxy) {\r\n                proxyHost = new ProxyHostEx(hostName, port, proxyUser, proxySecret);\r\n            } else {\r\n                proxyHost = null;\r\n            }\r\n        }\r\n        else {\r\n            proxyHost = null;\r\n        }\r\n        return proxyHost;\r\n    }\r\n\n",
    "label": 1,
    "rec": "Initialize a  ProxyHostEx from this  WebProxySettings for the provided hostToProxy."
  },
  {
    "id": 3325,
    "type": "Summary",
    "comment": "the list of  PlainSelects in this UNION",
    "code": "\tpublic List<PlainSelect> getPlainSelects() {\n\t\treturn plainSelects;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3326,
    "type": "Summary",
    "comment": "Get a RemoteSharedObjectDescription for a replica to be created on a given receiver.",
    "code": "\tprotected ReplicaSharedObjectDescription getReplicaDescription(ID receiver) {\n\t\treturn new ReplicaSharedObjectDescription(getID(), getClass().getName(),\n\t    \t\tgetConfig().getProperties());\n\t}\n\n",
    "label": 1,
    "rec": "Get a ReplicaSharedObjectDescription for a replica to be created on a given receiver."
  },
  {
    "id": 3327,
    "type": "Summary",
    "comment": "Returns a data holder for the given file",
    "code": "    public static WorldDataHolder load(String worldName, File groupsFile, File usersFile) throws FileNotFoundException, IOException {\n        WorldDataHolder ph = new WorldDataHolder(worldName);\n        ph.groupsFile = groupsFile;\n        ph.usersFile = usersFile;\n\n\n        //READ GROUPS FILE\n        Yaml yamlGroups = new Yaml(new SafeConstructor());\n        Map<String, Object> groupsRootDataNode;\n        if (!groupsFile.exists()) {\n            throw new IllegalArgumentException(\"The file which should contain permissions does not exist!\\n\" + groupsFile.getPath());\n        }\n        FileInputStream groupsInputStream = new FileInputStream(groupsFile);\n        try {\n            groupsRootDataNode = (Map<String, Object>) yamlGroups.load(new UnicodeReader(groupsInputStream));\n            if (groupsRootDataNode == null) {\n                throw new NullPointerException();\n            }\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"The following file couldn't pass on Parser.\\n\" + groupsFile.getPath(), ex);\n        } finally {\n            groupsInputStream.close();\n        }\n\n        //PROCESS GROUPS FILE\n        Map<String, List<String>> inheritance = new HashMap<String, List<String>>();\n        try {\n            Map<String, Object> allGroupsNode = (Map<String, Object>) groupsRootDataNode.get(\"groups\");\n            for (String groupKey : allGroupsNode.keySet()) {\n                Map<String, Object> thisGroupNode = (Map<String, Object>) allGroupsNode.get(groupKey);\n                Group thisGrp = ph.createGroup(groupKey);\n                if (thisGrp == null) {\n                    throw new IllegalArgumentException(\"I think this user was declared more than once: \" + groupKey);\n                }\n                if (thisGroupNode.get(\"default\") == null) {\n                    thisGroupNode.put(\"default\", false);\n                }\n                if ((Boolean.parseBoolean(thisGroupNode.get(\"default\").toString()))) {\n                    if (ph.getDefaultGroup() != null) {\n                        GroupManager.logger.warning(\"The group \" + thisGrp.getName() + \" is declaring be default where\" + ph.getDefaultGroup().getName() + \" already was.\");\n                        GroupManager.logger.warning(\"Overriding first request.\");\n                    }\n                    ph.setDefaultGroup(thisGrp);\n                }\n\n                //PERMISSIONS NODE\n                if (thisGroupNode.get(\"permissions\") == null) {\n                    thisGroupNode.put(\"permissions\", new ArrayList<String>());\n                }\n                if (thisGroupNode.get(\"permissions\") instanceof List) {\n                    for (Object o : ((List) thisGroupNode.get(\"permissions\"))) {\n                        thisGrp.addPermission(o.toString());\n                    }\n                } else if (thisGroupNode.get(\"permissions\") instanceof String) {\n                    thisGrp.addPermission((String) thisGroupNode.get(\"permissions\"));\n                } else {\n                    throw new IllegalArgumentException(\"Unknown type of permissions node(Should be String or List<String>): \" + thisGroupNode.get(\"permissions\").getClass().getName());\n                }\n\n                //INFO NODE\n                Map<String, Object> infoNode = (Map<String, Object>) thisGroupNode.get(\"info\");\n                if (infoNode != null) {\n                    thisGrp.setVariables(infoNode);\n                }\n\n                //END INFO NODE\n\n                Object inheritNode = thisGroupNode.get(\"inheritance\");\n                if (inheritNode == null) {\n                    thisGroupNode.put(\"inheritance\", new ArrayList<String>());\n                } else if (inheritNode instanceof List) {\n                    List<String> groupsInh = (List<String>) inheritNode;\n                    for (String grp : groupsInh) {\n                        if (inheritance.get(groupKey) == null) {\n                            List<String> thisInherits = new ArrayList<String>();\n                            inheritance.put(groupKey, thisInherits);\n                        }\n                        inheritance.get(groupKey).add(grp);\n\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            throw new IllegalArgumentException(\"Your Permissions config file is invalid. See console for details.\");\n        }\n        if (ph.defaultGroup == null) {\n            throw new IllegalArgumentException(\"There was no Default Group declared.\");\n        }\n        for (String groupKey : inheritance.keySet()) {\n            List<String> inheritedList = inheritance.get(groupKey);\n            Group thisGroup = ph.getGroup(groupKey);\n            for (String inheritedKey : inheritedList) {\n                Group inheritedGroup = ph.getGroup(inheritedKey);\n                if (thisGroup != null && inheritedGroup != null) {\n                    thisGroup.addInherits(inheritedGroup);\n                }\n            }\n        }\n\n\n        //READ USERS FILE\n        Yaml yamlUsers = new Yaml(new SafeConstructor());\n        Map<String, Object> usersRootDataNode;\n        if (!groupsFile.exists()) {\n            throw new IllegalArgumentException(\"The file which should contain permissions does not exist!\\n\" + usersFile.getPath());\n        }\n        FileInputStream usersInputStream = new FileInputStream(usersFile);\n        try {\n            usersRootDataNode = (Map<String, Object>) yamlUsers.load(new UnicodeReader(usersInputStream));\n            if (usersRootDataNode == null) {\n                throw new NullPointerException();\n            }\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"The following file couldn't pass on Parser.\\n\" + usersFile.getPath(), ex);\n        } finally {\n            usersInputStream.close();\n        }\n\n        // PROCESS USERS FILE\n        Map<String, Object> allUsersNode = (Map<String, Object>) usersRootDataNode.get(\"users\");\n        \n        // Stop loading if the file is empty\n        if (allUsersNode == null)\n        \treturn ph;\n\n        for (String usersKey : allUsersNode.keySet()) {\n            Map<String, Object> thisUserNode = (Map<String, Object>) allUsersNode.get(usersKey);\n            User thisUser = ph.createUser(usersKey);\n            if (thisUser == null) {\n                throw new IllegalArgumentException(\"I think this user was declared more than once: \" + usersKey);\n            }\n            if (thisUserNode.get(\"permissions\") == null) {\n                thisUserNode.put(\"permissions\", new ArrayList<String>());\n            }\n            if (thisUserNode.get(\"permissions\") instanceof List) {\n                for (Object o : ((List) thisUserNode.get(\"permissions\"))) {\n                    thisUser.addPermission(o.toString());\n                }\n            } else if (thisUserNode.get(\"permissions\") instanceof String) {\n                thisUser.addPermission(thisUserNode.get(\"permissions\").toString());\n            }\n\n            //SUBGROUPS LOADING\n            if (thisUserNode.get(\"subgroups\") == null) {\n                thisUserNode.put(\"subgroups\", new ArrayList<String>());\n            }\n            if (thisUserNode.get(\"subgroups\") instanceof List) {\n                for (Object o : ((List) thisUserNode.get(\"subgroups\"))) {\n                    Group subGrp = ph.getGroup(o.toString());\n                    if (subGrp != null) {\n                        thisUser.addSubGroup(subGrp);\n                    } else {\n                        GroupManager.logger.warning(\"Subgroup \" + o.toString() + \" not found for user \" + thisUser.getName() + \". Ignoring entry.\");\n                    }\n                }\n            } else if (thisUserNode.get(\"subgroups\") instanceof String) {\n                Group subGrp = ph.getGroup(thisUserNode.get(\"subgroups\").toString());\n                if (subGrp != null) {\n                    thisUser.addSubGroup(subGrp);\n                } else {\n                    GroupManager.logger.warning(\"Subgroup \" + thisUserNode.get(\"subgroups\").toString() + \" not found for user \" + thisUser.getName() + \". Ignoring entry.\");\n                }\n            }\n\n\n            //USER INFO NODE - BETA\n\n            //INFO NODE\n            Map<String, Object> infoNode = (Map<String, Object>) thisUserNode.get(\"info\");\n            if (infoNode != null) {\n                thisUser.setVariables(infoNode);\n            }\n            //END INFO NODE - BETA\n\n            if (thisUserNode.get(\"group\") != null) {\n                Group hisGroup = ph.getGroup(thisUserNode.get(\"group\").toString());\n                if (hisGroup == null) {\n                \tGroupManager.logger.warning(\"There is no group \" + thisUserNode.get(\"group\").toString() + \", as stated for player \" + thisUser.getName() + \": Set to '\" + ph.getDefaultGroup().getName() + \"'.\");\n                \thisGroup = ph.defaultGroup;\n                    //throw new IllegalArgumentException(\"There is no group \" + thisUserNode.get(\"group\").toString() + \", as stated for player \" + thisUser.getName());\n                }\n                thisUser.setGroup(hisGroup);\n            } else {\n                thisUser.setGroup(ph.defaultGroup);\n            }\n        }\n        return ph;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3328,
    "type": "Summary",
    "comment": "Returns true if  #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed, otherwise returns the result of  #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied.",
    "code": "    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        //mapped value is ignored - not needed for most (if not all) authc Filters.\n        return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);\n    }\n",
    "label": 1,
    "rec": "Returns true if  #isAccessAllowed(ServletRequest,ServletResponse,Object) isAccessAllowed(Request,Response,Object), otherwise returns the result of  #onAccessDenied(ServletRequest,ServletResponse,Object) onAccessDenied(Request,Response,Object)."
  },
  {
    "id": 3329,
    "type": "Summary",
    "comment": "Get number of pending video messages",
    "code": "\tprivate long pendingVideoMessages() {\n\t\tif (msgOut != null) {\n\t\t\tOOBControlMessage pendingRequest = new OOBControlMessage();\n\t\t\tpendingRequest.setTarget(\"ConnectionConsumer\");\n\t\t\tpendingRequest.setServiceName(\"pendingVideoCount\");\n\t\t\tmsgOut.sendOOBControlMessage(this, pendingRequest);\n\t\t\tif (pendingRequest.getResult() != null) {\n\t\t\t\treturn (Long) pendingRequest.getResult();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3330,
    "type": "Summary",
    "comment": "Gets execution pool for policy.",
    "code": "    private Executor pool(GridIoPolicy plc) {\n        switch (plc) {\n            case P2P_POOL:\n                return p2pPool;\n            case SYSTEM_POOL:\n                return sysPool;\n            case PUBLIC_POOL:\n                return pubPool;\n            case MANAGEMENT_POOL:\n                return mgmtPool;\n            case AFFINITY_POOL:\n                return affPool;\n\n            case UTILITY_CACHE_POOL:\n                assert utilityCachePool != null : \"Utility cache pool is not configured.\";\n\n                return utilityCachePool;\n\n            case MARSH_CACHE_POOL:\n                assert marshCachePool != null : \"Marshaller cache pool is not configured.\";\n\n                return marshCachePool;\n\n            default: {\n                assert false : \"Invalid communication policy: \" + plc;\n\n                // Never reached.\n                return null;\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3331,
    "type": "Summary",
    "comment": "Create schema.",
    "code": "    private BinarySchema createSchema() {\n        assert fieldIdLen == BinaryUtils.FIELD_ID_LEN;\n\n        BinarySchema.Builder builder = BinarySchema.Builder.newBuilder();\n\n        int searchPos = footerStart;\n        int searchEnd = searchPos + footerLen;\n\n        while (searchPos < searchEnd) {\n            int fieldId = in.readIntPositioned(searchPos);\n\n            builder.addField(fieldId);\n\n            searchPos += BinaryUtils.FIELD_ID_LEN + fieldOffsetLen;\n        }\n\n        return builder.build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3332,
    "type": "Summary",
    "comment": "Template-pattern method to be implemented by subclasses to retrieve the AuthorizationIfno for the given principals.",
    "code": "    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n",
    "label": 1,
    "rec": "Retrieves the AuthorizationInfo for the given principals from the underlying data store."
  },
  {
    "id": 3333,
    "type": "Summary",
    "comment": "Factory method for SPI queries.",
    "code": "    public static SpiQuery spi() {\n        return new SpiQuery();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3334,
    "type": "Summary",
    "comment": "Cluster a new instance.",
    "code": "    public int predict(T x) {\n        List<Neighbor<T,T>> neighbors = new ArrayList<>();\n        nns.range(x, radius, neighbors);\n        \n        if (neighbors.size() < minPts) {\n            return OUTLIER;\n        }\n        \n        int[] count = new int[k + 1];\n        for (Neighbor<T,T> neighbor : neighbors) {\n            int yi = y[neighbor.index];\n            if (yi == OUTLIER) yi = k;\n            count[yi]++;\n        }\n        \n        int y = MathEx.whichMax(count);\n        return y == k ? OUTLIER : y;\n    }\n",
    "label": 1,
    "rec": "Classifies a new observation."
  },
  {
    "id": 3335,
    "type": "Summary",
    "comment": "Invokes the dispatcher to handler the request envelope and construct the handler input",
    "code": "    public ResponseEnvelope invoke(RequestEnvelope requestEnvelope, Object context) {\n        if (skillId != null && !requestEnvelope.getContext().getSystem().getApplication().getApplicationId().equals(skillId)) {\n            throw new AskSdkException(\"Skill ID verification failed.\");\n        }\n\n        ServiceClientFactory factory = apiClient != null ? ServiceClientFactory.builder()\n                .withDefaultApiConfiguration(getApiConfiguration(requestEnvelope))\n                .build() : null;\n\n        HandlerInput handlerInput = HandlerInput.builder()\n                .withRequestEnvelope(requestEnvelope)\n                .withPersistenceAdapter(persistenceAdapter)\n                .withContext(context)\n                .withServiceClientFactory(factory)\n                .build();\n\n        Optional<Response> response = requestDispatcher.dispatch(handlerInput);\n        return ResponseEnvelope.builder()\n                .withResponse(response != null ? response.orElse(null) : null)\n                .withSessionAttributes\n                        (requestEnvelope.getSession() != null ? handlerInput.getAttributesManager().getSessionAttributes() : null)\n                .withVersion(SdkConstants.FORMAT_VERSION)\n                .withUserAgent(UserAgentUtils.getUserAgent(customUserAgent))\n                .build();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3336,
    "type": "Summary",
    "comment": "Attempts to persist a String to the  android.content.SharedPreferences.",
    "code": "    protected boolean persistString(String value) {\n        if (!shouldPersist()) {\n            return false;\n        }\n\n        // Shouldn't store null\n        if (value == getPersistedString(null)) {\n            // It's already there, so the same as persisting\n            return true;\n        }\n\n        PreferenceDataStore dataStore = getPreferenceDataStore();\n        if (dataStore != null) {\n            dataStore.putString(mKey, value);\n        } else {\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putString(mKey, value);\n            tryCommit(editor);\n        }\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist a  String if this Preference is persistent."
  },
  {
    "id": 3337,
    "type": "Summary",
    "comment": "Gets 4 bytes from byte list as an integer.",
    "code": "    public int getInt(int i) {\n        assert i + 4 <= size;\n\n        return IgniteByteUtils.bytesToInt(data, i);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3338,
    "type": "Summary",
    "comment": "Verification will be triggered after given amount of millis, allowing testing of async code.",
    "code": "    public static VerificationAfterDelay after(Duration delay) {\n        return new After(delay, VerificationModeFactory.times(1));\n    }\n",
    "label": 1,
    "rec": "Verification will be triggered after given amount of time, allowing testing of async code."
  },
  {
    "id": 3339,
    "type": "Summary",
    "comment": "Returns a List of IntrospectedTable elements that matches the specified table configuration.",
    "code": "    public List<IntrospectedTable> introspectTables(TableConfiguration tc)\n            throws SQLException {\n\n        // get the raw columns from the DB\n        Map<ActualTableName, List<IntrospectedColumn>> columns = getColumns(tc);\n\n        if (columns.isEmpty()) {\n            warnings.add(getString(\"Warning.19\", tc.getCatalog(), //$NON-NLS-1$\n                    tc.getSchema(), tc.getTableName()));\n            return Collections.emptyList();\n        }\n\n        removeIgnoredColumns(tc, columns);\n        calculateExtraColumnInformation(tc, columns);\n        applyColumnOverrides(tc, columns);\n        calculateIdentityColumns(tc, columns);\n\n        List<IntrospectedTable> introspectedTables = calculateIntrospectedTables(\n                tc, columns);\n\n        // now introspectedTables has all the columns from all the\n        // tables in the configuration. Do some validation...\n\n        Iterator<IntrospectedTable> iter = introspectedTables.iterator();\n        while (iter.hasNext()) {\n            IntrospectedTable introspectedTable = iter.next();\n\n            if (!introspectedTable.hasAnyColumns()) {\n                // add warning that the table has no columns, remove from the\n                // list\n                String warning = getString(\n                                \"Warning.1\", introspectedTable.getFullyQualifiedTable().toString()); //$NON-NLS-1$\n                warnings.add(warning);\n                iter.remove();\n            } else if (!introspectedTable.hasPrimaryKeyColumns()\n                    && !introspectedTable.hasBaseColumns()) {\n                // add warning that the table has only BLOB columns, remove from\n                // the list\n                String warning = getString(\n                                \"Warning.18\", introspectedTable.getFullyQualifiedTable().toString()); //$NON-NLS-1$\n                warnings.add(warning);\n                iter.remove();\n            } else {\n                // now make sure that all columns called out in the\n                // configuration\n                // actually exist\n                reportIntrospectionWarnings(introspectedTable, tc,\n                        introspectedTable.getFullyQualifiedTable());\n            }\n        }\n\n        return introspectedTables;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3340,
    "type": "Summary",
    "comment": "This is an overridden version of Model.score().",
    "code": "  public Frame score(Frame frame) {\n    if (!get_params().autoencoder) {\n      return super.score(frame);\n    } else {\n      // Reconstruction\n      Frame fr = new Frame(frame);\n      final int len = model_info().data_info().fullN();\n      String prefix = \"reconstr_\";\n      assert(model_info().data_info()._responses == 0);\n      String[] coefnames = model_info().data_info().coefNames();\n      assert(len == coefnames.length);\n      for( int c=0; c<len; c++ )\n        fr.add(prefix+coefnames[c],fr.anyVec().makeZero());\n      new MRTask2() {\n        @Override public void map( Chunk chks[] ) {\n          double tmp [] = new double[_names.length];\n          float preds[] = new float [len];\n          final Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info);\n          for( int row=0; row<chks[0]._len; row++ ) {\n            float p[] = score_autoencoder(chks, row, tmp, preds, neurons);\n            for( int c=0; c<preds.length; c++ )\n              chks[_names.length+c].set0(row,p[c]);\n          }\n        }\n      }.doAll(fr);\n\n      // Return just the output columns\n      int x=_names.length, y=fr.numCols();\n      return fr.extractFrame(x, y);\n    }\n  }\n",
    "label": 1,
    "rec": "This is called from Model.score()."
  },
  {
    "id": 3341,
    "type": "Summary",
    "comment": "Creates utility system cache configuration.",
    "code": "        private static CacheConfiguration utilitySystemCache(boolean client) {\n            CacheConfiguration cache = new CacheConfiguration();\n\n            cache.setName(CU.UTILITY_CACHE_NAME);\n            cache.setCacheMode(REPLICATED);\n            cache.setAtomicityMode(TRANSACTIONAL);\n            cache.setSwapEnabled(false);\n            cache.setQueryIndexEnabled(false);\n            cache.setRebalanceMode(SYNC);\n            cache.setWriteSynchronizationMode(FULL_SYNC);\n            cache.setAffinity(new CacheRendezvousAffinityFunction(false, 100));\n\n            if (client)\n                cache.setDistributionMode(CLIENT_ONLY);\n\n            return cache;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3342,
    "type": "Summary",
    "comment": "Create a new Filter based on given list of criteria.",
    "code": "    public static Filter filter(Predicate criteria) {\n        return new SingleFilter(criteria);\n    }\n",
    "label": 1,
    "rec": "Creates a new Filter based on given criteria"
  },
  {
    "id": 3343,
    "type": "Summary",
    "comment": "Get password and generate key and iv.",
    "code": "    private static CipherParameters getAESPasswordKey(final char[] password, final byte[] salt) {\n        final PBEParametersGenerator generator = new OpenSSLPBEParametersGenerator();\n        generator.init(PBEParametersGenerator.PKCS5PasswordToBytes(password), salt, NUMBER_OF_ITERATIONS);\n        return (ParametersWithIV) generator.generateDerivedParameters(KEY_LENGTH, IV_LENGTH);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3344,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_FILE_TYPE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3345,
    "type": "Summary",
    "comment": "Creates the given item.",
    "code": "    public boolean createNew(TYPE item) {\n        long newRow = database.insert(table.name,\n                AbstractModel.ID_PROPERTY.name, item.getMergedValues());\n        boolean result = newRow >= 0;\n        if(result) {\n            item.markSaved();\n            item.setId(newRow);\n        }\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3346,
    "type": "Summary",
    "comment": "Returns the column before which the new column should be added.",
    "code": "    public String getNextColumn()\r\n    {\r\n        return _nextColumnName;\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns the name of the column before which the new column should be added."
  },
  {
    "id": 3347,
    "type": "Summary",
    "comment": "Perform write.",
    "code": "    boolean write(final byte[] data) {\n        return addTask(new GridGgfsFileWorkerTask() {\n            @Override public void execute() throws GridException {\n                out.write(data);\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3348,
    "type": "Summary",
    "comment": "Get the list of remote user agents to compile.",
    "code": "  public static Set<String> getRemoteUserAgents() {\n    if (unitTestShell == null) {\n      return null;\n    }\n    return unitTestShell.runStyle.getUserAgents();\n  }\n\n",
    "label": 1,
    "rec": "Get the set of remote user agents to compile."
  },
  {
    "id": 3349,
    "type": "Summary",
    "comment": "Returns true if this object contains enough information to retrieve a token",
    "code": "    public boolean isValid() {\n        if (grantType==null) {\n            return false;\n        }\n        switch (grantType) {\n            case CLIENT_CREDENTIALS:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret\n                    )\n                );\n            case PASSWORD:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password\n                    )\n                );\n            case PASSWORD_WITH_PASSCODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        passcode\n                    )\n                );\n            case AUTHORIZATION_CODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        username,\n                        password,\n                        redirectUri,\n                        state\n                    )\n                );\n            case AUTHORIZATION_CODE_WITH_TOKEN:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        authorizationEndpoint,\n                        clientId,\n                        clientSecret,\n                        redirectUri,\n                        authCodeAPIToken,\n                        state\n                    )\n                );\n            case FETCH_TOKEN_FROM_CODE:\n                return !hasAnyNullValues(\n                    Arrays.asList(\n                        tokenEndpoint,\n                        clientId,\n                        clientSecret,\n                        redirectUri,\n                        authorizationCode\n                    )\n                );\n            case SAML2_BEARER:\n                return !hasAnyNullValues(\n                        Arrays.asList(\n                            tokenEndpoint,\n                            clientId,\n                            clientSecret,\n                            authCodeAPIToken\n                        )\n                    );\n            default: return false;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3350,
    "type": "Summary",
    "comment": "Returns the  TModel representation of the object.",
    "code": "    public ModelClass getModelObject(int index) {\n        return getJsonModel(index).toModel();\n    }\n\n",
    "label": 1,
    "rec": "Returns the  ModelClass representation of the object."
  },
  {
    "id": 3351,
    "type": "Summary",
    "comment": "Is the given issue a pull request?",
    "code": "    public static boolean isPullRequest(final Issue issue) {\n        return issue != null && issue.pullRequest != null\n                && !TextUtils.isEmpty(issue.pullRequest.html_url);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3352,
    "type": "Summary",
    "comment": "Utility function that constructs AdminClient.",
    "code": "    public static AdminClient getAdminClient(String url) {\n        return new AdminClient(url);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3353,
    "type": "Summary",
    "comment": "Acquires the Sender singleton instance",
    "code": "\tpublic static SenderFactory getInstance() {\n\t\tif(instance==null) {\n\t\t\tsynchronized(lock) {\n\t\t\t\tif(instance==null) {\n\t\t\t\t\tinstance = new SenderFactory();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\n",
    "label": 1,
    "rec": "Acquires the SenderFactory singleton instance"
  },
  {
    "id": 3354,
    "type": "Summary",
    "comment": "Gets span release future.",
    "code": "    public IgniteInternalFuture<Object> releaseFuture() {\n        return releaseFut;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3355,
    "type": "Summary",
    "comment": "Retrieve the bundle that has the given symbolic name and version.",
    "code": "\tpublic List<AbstractBundle> getBundleBySymbolicName(String symbolicName, Version version) {\n\t\tsynchronized (bundles) {\n\t\t\treturn bundles.getBundles(symbolicName, version);\n\t\t}\n\t}\n\n",
    "label": 1,
    "rec": "Retrieve the bundles that has the given symbolic name and version."
  },
  {
    "id": 3356,
    "type": "Summary",
    "comment": "Build a new service discovery with the currently set values.",
    "code": "    public ServiceDiscovery<T> build()\n    {\n        if ( serializer == null )\n        {\n            serializer(new JsonInstanceSerializer<T>(payloadClass));\n        }\n        return new ServiceDiscoveryImpl<T>(client, basePath, serializer, thisInstance, watchInstances);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3357,
    "type": "Summary",
    "comment": "Returns the language.",
    "code": "  public SupportedLanguage language() {\n    return language;\n  }\n\n",
    "label": 1,
    "rec": "Returns the supported language."
  },
  {
    "id": 3358,
    "type": "Summary",
    "comment": "Stops the engine.",
    "code": "    private Task<Void> startBind() {\n        return mOrchestrator.scheduleStateChange(CameraState.ENGINE, CameraState.BIND,\n                true,\n                new Callable<Task<Void>>() {\n            @Override\n            public Task<Void> call() {\n                if (getPreview() != null && getPreview().hasSurface()) {\n                    return onStartBind();\n                } else {\n                    return Tasks.forCanceled();\n                }\n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3359,
    "type": "Summary",
    "comment": "double argument that has an absolute difference to the given value that is less than the given delta details.",
    "code": "    public static double eq(double value, double delta) {\n        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3360,
    "type": "Summary",
    "comment": "Get section, given a raw position in the list.",
    "code": "    private Group getGroup(int position) {\n        int previous = 0;\n        int size;\n        for (Group group : groups) {\n            size = group.getItemCount();\n            if (position - previous < size) return group;\n            previous += group.getItemCount();\n        }\n        throw new IndexOutOfBoundsException(\"Requested position \" + position + \"in group adapter \" +\n                \"but there are only \" + previous + \" items\");\n    }\n",
    "label": 1,
    "rec": "Get group, given a raw position in the list."
  },
  {
    "id": 3361,
    "type": "Summary",
    "comment": "A context may have an associated  Deadline at which it will be automatically cancelled.",
    "code": "  public Deadline getDeadline() {\n    if (cancellableAncestor == null) {\n      return null;\n    }\n    return cancellableAncestor.getDeadline();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3362,
    "type": "Summary",
    "comment": "Sets the type of this proxy.",
    "code": "    public Proxy setType( String type )\n    {\n        return new Proxy( type, host, port, auth );\n    }\n\n",
    "label": 1,
    "rec": "Sets the type of the proxy."
  },
  {
    "id": 3363,
    "type": "Summary",
    "comment": "Creates marshaller system cache configuration.",
    "code": "        private static CacheConfiguration marshallerSystemCache(boolean client) {\n            if (!client) {\n                CacheConfiguration cache = new CacheConfiguration();\n\n                cache.setName(CU.MARSH_CACHE_NAME);\n                cache.setCacheMode(REPLICATED);\n                cache.setAtomicityMode(TRANSACTIONAL);\n                cache.setSwapEnabled(false);\n                cache.setRebalanceMode(SYNC);\n                cache.setWriteSynchronizationMode(FULL_SYNC);\n                cache.setAffinity(new CacheRendezvousAffinityFunction(false, 100));\n                cache.setNodeFilter(CacheConfiguration.ALL_NODES);\n\n                return cache;\n            }\n\n            return null;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3364,
    "type": "Summary",
    "comment": "Returns the value of the 'Server' reference.",
    "code": "\tpublic IBuildServer getServer() {\n\t\tif (eContainerFeatureID() != BuildPackage.BUILD_PLAN__SERVER)\n\t\t\treturn null;\n\t\treturn (IBuildServer) eContainer();\n\t}\n\n",
    "label": 1,
    "rec": "Returns the value of the 'Server' container reference."
  },
  {
    "id": 3365,
    "type": "Summary",
    "comment": "Tells whether the Java version is compatible with Java 9.",
    "code": "  public boolean isJava9Compatible() {\n    return javaSpecVersionNumber.getMajor() >= 9;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3366,
    "type": "Summary",
    "comment": "Returns the value for the key from a valid time-bucket reader.",
    "code": "    private BucketedValue getValueFromTimeBucketReader(Slice key, long timeBucket)\n    {\n      FileAccess.FileReader fileReader = readers.get(timeBucket);\n      if (fileReader != null) {\n        return readValue(fileReader, key, timeBucket);\n      }\n      //file reader is not loaded and is null\n      try {\n        if (loadFileReader(timeBucket)) {\n          return readValue(readers.get(timeBucket), key, timeBucket);\n        }\n        return null;\n      } catch (IOException e) {\n        throw new RuntimeException(\"while loading \" + bucketId + \", \" + timeBucket, e);\n      }\n    }\n\n",
    "label": 1,
    "rec": "Returns the value for the key from a time-bucket reader"
  },
  {
    "id": 3367,
    "type": "Summary",
    "comment": "Get the death message that will appear to everyone on the server.",
    "code": "    public String getDeathMessage() {\n        return deathMessage;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3368,
    "type": "Summary",
    "comment": "Removes NewLine, CarriageReturn and Tab characters from a String.",
    "code": "    public static String removeFormattingCharacters(final String toBeEscaped) {\n        StringBuffer escapedBuffer = new StringBuffer();\n        for (int i = 0; i < toBeEscaped.length(); i++) {\n            if ((toBeEscaped.charAt(i) != '\\n') && (toBeEscaped.charAt(i) != '\\r') && (toBeEscaped.charAt(i) != '\\t')) {\n                escapedBuffer.append(toBeEscaped.charAt(i));\n            }\n        }\n        return escapedBuffer.toString();\n    }\n\n",
    "label": 1,
    "rec": "Removes newline, carriage return and tab characters from a string."
  },
  {
    "id": 3369,
    "type": "Summary",
    "comment": "Helper method to create Message instance from handler",
    "code": "    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {\n        return Message.obtain(handler, responseMessageId, responseMessageData);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3370,
    "type": "Summary",
    "comment": "Creates a copy of the given object by an in-memory serialization and subsequent deserialization.",
    "code": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends IOReadableWritable> T createCopy(final T original) throws IOException {\n\n\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tfinal DataOutputStream dos = new DataOutputStream(baos);\n\n\t\toriginal.write(dos);\n\n\t\tfinal String className = original.getClass().getName();\n\t\tif (className == null) {\n\t\t\tfail(\"Class name is null\");\n\t\t}\n\n\t\tClass<T> clazz = null;\n\n\t\ttry {\n\t\t\tclazz = (Class<T>) Class.forName(className);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (clazz == null) {\n\t\t\tfail(\"Cannot find class with name \" + className);\n\t\t}\n\n\t\tT copy = null;\n\t\ttry {\n\t\t\tcopy = clazz.newInstance();\n\t\t} catch (InstantiationException e) {\n\t\t\tfail(e.getMessage());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\n\t\tif (copy == null) {\n\t\t\tfail(\"Copy of object of type \" + className + \" is null\");\n\t\t}\n\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\t\tfinal DataInputStream dis = new DataInputStream(bais);\n\n\t\tcopy.read(dis);\n\n\t\treturn copy;\n\t}\n\n",
    "label": 1,
    "rec": "Creates a copy of the given  IOReadableWritable object by an in-memory serialization and subsequent deserialization."
  },
  {
    "id": 3371,
    "type": "Summary",
    "comment": "Returns the first checkpoint of the curve.",
    "code": "    public Point getPt2() {\n        return pt2;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3372,
    "type": "Summary",
    "comment": "Determines the brightness of the given bulb.",
    "code": "\tpublic int getBrightness(int deviceNumber) {\n\t\tif (settingsData == null) {\n\t\t\tlogger.error(\"Hue bridge settings not initialized correctly.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn (Integer) settingsData.node(\"lights\")\n\t\t\t\t.node(Integer.toString(deviceNumber)).node(\"state\")\n\t\t\t\t.value(\"bri\");\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3373,
    "type": "Summary",
    "comment": "Retrieve the rough binary length of a string (length + 2 bytes length prefix).",
    "code": "    public static int size(String name) {\n        if (name.isEmpty()) return 1; // TODO\n        return name.length() + 2;\n    }\n\n",
    "label": 1,
    "rec": "Retrieve the rough binary length of a string (1 byte for the root domain or (length + 2) bytes)."
  },
  {
    "id": 3374,
    "type": "Summary",
    "comment": "float argument that matches both given argument matchers.",
    "code": "    public static float and(float first, float second) {\n        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3375,
    "type": "Summary",
    "comment": "Returns a set of URLs based on URLs derived from class loaders expanded with Manifest information.",
    "code": "    public static Collection<URL> forManifest() {\n        return forManifest(forClassLoader());\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs based on URLs derived from class loaders expanded with Manifest information."
  },
  {
    "id": 3376,
    "type": "Summary",
    "comment": "long argument that matches any of the given argument matchers.",
    "code": "    public static long or(long first, long second) {\n        return LastArguments.instance().reportOr().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3377,
    "type": "Summary",
    "comment": "Try to parse the bits as svm light format, return SVMParser instance if the input is in svm light format, null otherwise.",
    "code": "  public static PSetupGuess guessSetup(byte [] bits){\n    InputStream is = new ByteArrayInputStream(bits);\n    SVMLightParser p = new SVMLightParser(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, false));\n    InspectDataOut dout = new InspectDataOut();\n    try{p.streamParse(is, dout);}catch(Exception e){throw new RuntimeException(e);}\n    return new PSetupGuess(new ParserSetup(ParserType.SVMLight, CsvParser.AUTO_SEP, dout._ncols,false,null,false),dout._nlines,dout._invalidLines,dout.data(),dout.errors());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3378,
    "type": "Summary",
    "comment": "Returns a set of URLs based on the  java.class.path system property.",
    "code": "    public static Collection<URL> forJavaClassPath() {\n        Collection<URL> urls = new ArrayList<URL>();\n        String javaClassPath = System.getProperty(\"java.class.path\");\n        if (javaClassPath != null) {\n            for (String path : javaClassPath.split(File.pathSeparator)) {\n                try {\n                    urls.add(new File(path).toURI().toURL());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return distinctUrls(urls);\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs based on the  java.class.path system property."
  },
  {
    "id": 3379,
    "type": "Summary",
    "comment": "Get repositories for given  User ",
    "code": "    public List<Repo> getRepos(final User user, boolean forceReload)\n            throws IOException {\n        OrganizationRepositories resource = allRepos.under(user);\n        return forceReload ? dbCache.requestAndStore(resource) : dbCache\n                .loadOrRequest(resource);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3380,
    "type": "Summary",
    "comment": "Cumulative count of number of threads executed since the start of the application.",
    "code": "    public long getCumulativeCountThreadsExecuted() {\n        if (cumulativeCounter.hasValue()) {\n            return cumulativeCounter.getValue()[0];\n        } else {\n            return 0L;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3381,
    "type": "Summary",
    "comment": "Returns an Iterator for all PacketExtensionProvider instances.",
    "code": "    public Collection<Object> getExtensionProviders() {\n        return Collections.unmodifiableCollection(extensionProviders.values());\n    }\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable collection of all PacketExtensionProvider instances."
  },
  {
    "id": 3382,
    "type": "Summary",
    "comment": "Gets the TreeSpecies with the given data value",
    "code": "    public static TreeSpecies getByData(final byte data) {\n        return BY_DATA.get(data);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3383,
    "type": "Summary",
    "comment": "Parse simple expression.",
    "code": "    private static String parseExpression(String text, int startPos, int len, OdbcEscapeType type, Pattern pattern) {\n        String val = parseExpression(text, startPos, len);\n\n        if (!pattern.matcher(val).matches())\n            throw new IgniteException(\"Invalid \" + type + \" escape sequence: \" + substring(text, startPos, len));\n\n        return val;\n    }\n",
    "label": 1,
    "rec": "Parse expression and validate against ODBC specification with regex pattern."
  },
  {
    "id": 3384,
    "type": "Summary",
    "comment": "Fetch all metadata that are unattached to the task",
    "code": "    public TodorooCursor<Metadata> fetchDangling(Property<?>[] properties) {\n        Query sql = Query.select(properties).from(Metadata.TABLE).join(Join.left(Task.TABLE,\n                Metadata.TASK.eq(Task.ID))).where(Task.TITLE.isNull());\n        Cursor cursor = database.getDatabase().rawQuery(sql.toString(), null);\n        return new TodorooCursor<Metadata>(cursor, properties);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3385,
    "type": "Summary",
    "comment": "Gets the value of howlProperties.",
    "code": "  public Properties getInputStorageDriverProperties() {\n    return hcatProperties;\n  }\n\n",
    "label": 1,
    "rec": "Gets the value of hcatProperties."
  },
  {
    "id": 3386,
    "type": "Summary",
    "comment": "Returns a list of  Resource shared with the  #user",
    "code": "    public Response getSharedWithMe(@QueryParam(\"name\") String name,\n            @QueryParam(\"first\") Integer first,\n            @QueryParam(\"max\") Integer max) {\n        return queryResponse((f, m) -> toPermissions(ticketStore.findGrantedResources(auth.getUser().getId(), name, f, m), false)\n                .stream(), first, max);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3387,
    "type": "Summary",
    "comment": "Rolling count of number of threads rejected during rolling statistical window.",
    "code": "    public long getRollingCountThreadsRejected() {\n        return rollingCounterStream.getLatestCount(HystrixEventType.ThreadPool.REJECTED);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3388,
    "type": "Summary",
    "comment": "Returns the project that contains the resource at the given URI.",
    "code": "  public IProject project(Resource resource) {\n    return file(resource.getURI()).getProject();\n  }\n\n",
    "label": 1,
    "rec": "Returns the project that contains the given resource."
  },
  {
    "id": 3389,
    "type": "Summary",
    "comment": "Returns if this note is sharped.",
    "code": "    public boolean isSharped() {\n        byte note = getToneByte();\n        return Tone.getById(note).isSharped(note);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3390,
    "type": "Summary",
    "comment": "Dumps the detailed state of the referenced AllocationPointerOperations",
    "code": "\tpublic static final String dump(final long address[]) {\n\t\tif(address==null || address.length==0) throw new IllegalArgumentException(\"Address array was null or zero length\");\n\t\tfinal byte dim = getDimension(address[0]);\t\t\n\t\tStringBuilder b = new StringBuilder(print(address));\n//\t\tb.append(\"\\n\\tAddresses: [\");\n//\t\tfinal int size = getSize(address);\n//\t\tif(size>0) {\n//\t\t\tfor(int i = 0; i < size; i++) {\n//\t\t\t\tb.append(getAddress(address, i)).append(\", \");\n//\t\t\t}\t\t\t\n//\t\t\tb.deleteCharAt(b.length()-1);\n//\t\t\tb.deleteCharAt(b.length()-1);\n//\t\t}\n//\t\treturn b.append(\"]\").toString();\n\t\treturn b.toString();\n\t}\n\n",
    "label": 1,
    "rec": "Prints the detailed state of an AllocationPointer"
  },
  {
    "id": 3391,
    "type": "Summary",
    "comment": "byte argument that does not match the given argument matcher.",
    "code": "    public static byte not(byte first) {\n        return mockingProgress.getLastArguments().reportNot().returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3392,
    "type": "Summary",
    "comment": "Returns an array with all the aspects.",
    "code": "    public AspectContainer[] getAspectContainers() {\n        initialize();\n        return m_aspectContainers;\n    }\n\n",
    "label": 1,
    "rec": "Returns an array with all the aspect containers."
  },
  {
    "id": 3393,
    "type": "Summary",
    "comment": "Gets tasks that were created since last sync",
    "code": "    public TodorooCursor<Task> getLocallyCreated(Property<?>[] properties) {\n        return\n            taskDao.query(Query.select(properties).join(METADATA_JOIN).where(\n                    Criterion.or(TASK_ID.eq(0), Metadata.TASK.isNull())));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3394,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ALBUM  ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3395,
    "type": "Summary",
    "comment": "Starts all grids specified within given Spring XML configuration file URL.",
    "code": "    public static Ignite start(URL springCfgUrl) throws IgniteCheckedException {\n        return start(springCfgUrl, null, null, null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3396,
    "type": "Summary",
    "comment": "If a RowExpander component is a child of this table, return it.",
    "code": "    public RowExpansion getRowExpansion() {\n        for (UIComponent kid : getChildren())\n            if (kid instanceof RowExpansion) return (RowExpansion) kid;\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "If a RowExpansion component is a child of this table, return it."
  },
  {
    "id": 3397,
    "type": "Summary",
    "comment": "byte argument that matches any of the given argument matchers.",
    "code": "    public static byte or(byte first, byte second) {\n        MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr();\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3398,
    "type": "Summary",
    "comment": "Method that returns if the filesystem can be mounted.",
    "code": "    public static boolean isMountAllowed(MountPoint mp) {\n        return !RESTRICTED_FS_TYPE.contains(mp.getType());\n    }\n\n",
    "label": 1,
    "rec": "Method that returns if a filesystem is allowed to be mounted/unmounted (rw/ro)."
  },
  {
    "id": 3399,
    "type": "Summary",
    "comment": "Sign the root element",
    "code": "    public static Document sign(Document doc, KeyPair keyPair, String digestMethod, String signatureMethod, String referenceURI, String canonicalizationMethodType)\n            throws GeneralSecurityException, MarshalException, XMLSignatureException {\n        return sign(doc, keyPair, digestMethod, signatureMethod, referenceURI, null, canonicalizationMethodType);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3400,
    "type": "Summary",
    "comment": "Builds an  AuthenticationInfo object by querying the active directory LDAP context for the specified username.",
    "code": "    protected AuthenticationInfo queryForLdapAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException {\n\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ldapContextFactory.getLdapContext( upToken.getUsername(), String.valueOf( upToken.getPassword() ) );\n        } finally {\n            LdapUtils.closeContext( ctx );\n        }\n\n        return new SimpleAuthenticationInfo( upToken.getUsername(), upToken.getPassword() );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3401,
    "type": "Summary",
    "comment": "Returns the project that contains the given resource.",
    "code": "  public IProject project(URI resourceUri) {\n    return file(resourceUri).getProject();\n  }\n\n",
    "label": 1,
    "rec": "Returns the project that contains the resource at the given URI."
  },
  {
    "id": 3402,
    "type": "Summary",
    "comment": "Return the number of items in a hash.",
    "code": "    public Long hlen(final byte[] key) {\n        checkIsInMulti();\n        client.hlen(key);\n        return client.getIntegerReply();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3403,
    "type": "Summary",
    "comment": "Deregister the device associated with the registration token from BaaS.",
    "code": "    private Task<Void> deregisterWithServer() {\n        final Map<String, Object> request = getDeregisterPushDeviceRequest();\n        return getStitchClient().executePipeline(new PipelineStage(\n                Actions.DEREGISTER_PUSH, request))\n                .continueWith(new Continuation<List<Object>, Void>() {\n                    @Override\n                    public Void then(@NonNull Task<List<Object>> task) throws Exception {\n                        if (!task.isSuccessful()) {\n                            throw task.getException();\n                        }\n\n                        removeInfoFromConfigs(_info);\n                        return null;\n                    }\n                });\n    }\n\n",
    "label": 1,
    "rec": "Deregister the device associated with the registration token from Stitch."
  },
  {
    "id": 3404,
    "type": "Summary",
    "comment": "Indicates whether current OS is Windows.",
    "code": "    public static boolean isWindows() {\n        return win7 || win8 || win81 || winXp || win95 || win98 || winNt || win2k ||\n            win2003 || win2008 || winVista || unknownWin;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3405,
    "type": "Summary",
    "comment": "The same as getConfiguration(String gridName) but it sets custom GGFS configuration",
    "code": "    protected IgniteConfiguration getConfiguration(String gridName, GridGgfsConfiguration ggfsCfg) throws Exception {\n        IgniteConfiguration cfg = GridGainEx.loadConfiguration(\"config/hadoop/default-config.xml\").get1();\n\n        assert cfg != null;\n\n        cfg.setGridName(gridName);\n\n        cfg.setIncludeEventTypes(concat(EVTS_GGFS, EVT_TASK_FAILED, EVT_TASK_FINISHED, EVT_JOB_MAPPED));\n\n        cfg.setGgfsConfiguration(ggfsCfg);\n\n        cfg.setCacheConfiguration(getCacheConfiguration(gridName));\n\n        cfg.setHadoopConfiguration(null);\n\n        GridTcpDiscoverySpi discoSpi = new GridTcpDiscoverySpi();\n\n        discoSpi.setIpFinder(new GridTcpDiscoveryVmIpFinder(true));\n\n        cfg.setDiscoverySpi(discoSpi);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3406,
    "type": "Summary",
    "comment": "Prepare Search And transform sql into ES Search Request",
    "code": "\tpublic ActionRequestBuilder explain(String sql) throws SqlParseException {\n\t\tSQLQueryExpr sqlExpr = toSqlExpr(sql);\n\n\t\tSelect select = new SqlParser().parseSelect(sqlExpr);\n\t\tQuery query = QueryFactory.create(client, select);\n\t\treturn query.explain();\n\t}\n\n",
    "label": 1,
    "rec": "Prepare action And transform sql into ES ActionRequest"
  },
  {
    "id": 3407,
    "type": "Summary",
    "comment": "Allows at-least-once verification.",
    "code": "    public static VerificationMode atLeastOnce() {\n        return VerificationModeImpl.atLeastOnce();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3408,
    "type": "Summary",
    "comment": "Returns top n entries sorted by descending value.",
    "code": "\tpublic Int2IntMap.Entry[] getEntriesSortedByValue(int k) {\n\t\tInt2IntMap.Entry[] entries = getEntriesSortedByValue();\n\n\t\tif (entries == null)\n\t\t\treturn null;\n\n\t\tif (entries.length < k)\n\t\t\treturn entries;\n\n\t\treturn Arrays.copyOfRange(entries, 0, k);\n\t}\n\n",
    "label": 1,
    "rec": "Returns top k entries sorted by descending value."
  },
  {
    "id": 3409,
    "type": "Summary",
    "comment": "Creates a read-only view of a Graph, presenting the sub-graph consisting of all the nodes; and those edges accepted by edgeFilter.",
    "code": "    static Graph filteredView(GraphHopperStorage baseGraph, EdgeFilter edgeFilter) {\n        return new Graph() {\n            @Override\n            public Graph getBaseGraph() {\n                return baseGraph;\n            }\n\n            @Override\n            public int getNodes() {\n                return baseGraph.getNodes();\n            }\n\n            @Override\n            public int getEdges() {\n                return baseGraph.getEdges();\n            }\n\n            @Override\n            public NodeAccess getNodeAccess() {\n                return baseGraph.getNodeAccess();\n            }\n\n            @Override\n            public BBox getBounds() {\n                return baseGraph.getBounds();\n            }\n\n            @Override\n            public EdgeIteratorState edge(int a, int b) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public AllEdgesIterator getAllEdges() {\n                final AllEdgesIterator edge = baseGraph.getAllEdges();\n                return new AllEdgesIterator() {\n                    @Override\n                    public int length() {\n                        return edge.length();\n                    }\n\n                    @Override\n                    public boolean next() {\n                        while (edge.next()) {\n                            if (edgeFilter.accept(edge)) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n\n                    @Override\n                    public int getEdge() {\n                        return edge.getEdge();\n                    }\n\n                    @Override\n                    public int getOrigEdgeFirst() {\n                        return getEdge();\n                    }\n\n                    @Override\n                    public int getOrigEdgeLast() {\n                        return getEdge();\n                    }\n\n                    @Override\n                    public int getBaseNode() {\n                        return edge.getBaseNode();\n                    }\n\n                    @Override\n                    public int getAdjNode() {\n                        return edge.getAdjNode();\n                    }\n\n                    @Override\n                    public PointList fetchWayGeometry(int mode) {\n                        return edge.fetchWayGeometry(mode);\n                    }\n\n                    @Override\n                    public EdgeIteratorState setWayGeometry(PointList list) {\n                        edge.setWayGeometry(list);\n                        return this;\n                    }\n\n                    @Override\n                    public double getDistance() {\n                        return edge.getDistance();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setDistance(double dist) {\n                        edge.setDistance(dist);\n                        return this;\n                    }\n\n                    @Override\n                    public long getFlags() {\n                        return edge.getFlags();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setFlags(long flags) {\n                        edge.setFlags(flags);\n                        return this;\n                    }\n\n                    @Override\n                    public int getAdditionalField() {\n                        return edge.getAdditionalField();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setAdditionalField(int value) {\n                        edge.setAdditionalField(value);\n                        return this;\n                    }\n\n                    @Override\n                    public boolean isForward(FlagEncoder encoder) {\n                        return edge.isForward(encoder);\n                    }\n\n                    @Override\n                    public boolean isBackward(FlagEncoder encoder) {\n                        return edge.isBackward(encoder);\n                    }\n\n                    @Override\n                    public boolean getBool(int key, boolean _default) {\n                        return edge.getBool(key, _default);\n                    }\n\n                    @Override\n                    public String getName() {\n                        return edge.getName();\n                    }\n\n                    @Override\n                    public EdgeIteratorState setName(String name) {\n                        edge.setName(name);\n                        return this;\n                    }\n\n                    @Override\n                    public EdgeIteratorState detach(boolean reverse) {\n                        return edge.detach(reverse);\n                    }\n\n                    @Override\n                    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            }\n\n            @Override\n            public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public EdgeExplorer createEdgeExplorer() {\n                return baseGraph.createEdgeExplorer(edgeFilter);\n            }\n\n            @Override\n            public Graph copyTo(Graph g) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public GraphExtension getExtension() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3410,
    "type": "Summary",
    "comment": "Construct list of fully qualified class names whose sources are found under a given source directory.",
    "code": "  public static Map<String, String> scan(String sourceDir)\n  {\n    final String sourceDirWithSeparator = sourceDir.endsWith(File.separator) ? sourceDir : sourceDir + File.separator;\n    final File dir = new File(sourceDirWithSeparator);\n    if (!dir.exists() || !dir.isDirectory())\n    {\n      return Collections.emptyMap();\n    }\n\n    // suppress the warning because of inconsistent FileUtils interface\n    @SuppressWarnings(\"unchecked\")\n    final Collection<File> files = (Collection<File>) FileUtils.listFiles(dir, null, true);\n    final Map<String, String> classFileNames = new HashMap<String, String>();\n    final int prefixLength = sourceDirWithSeparator.length();\n    for (File f : files)\n    {\n      assert(f.exists() && f.isFile());\n\n      final int extensionIndex = f.getName().lastIndexOf('.');\n      final String filePath = f.getPath();\n      if (extensionIndex < 0 || !filePath.startsWith(sourceDirWithSeparator))\n      {\n        continue;\n      }\n\n      final int reverseExtensionIndex = f.getName().length() - extensionIndex;\n      classFileNames.put(filePath.substring(prefixLength, filePath.length() - reverseExtensionIndex).replace(File.separator, \".\"),\n                         filePath);\n    }\n\n    return classFileNames;\n  }\n\n",
    "label": 1,
    "rec": "Construct map from fully qualified class name to filename whose sources are found under a given source directory."
  },
  {
    "id": 3411,
    "type": "Summary",
    "comment": "De-serializes node metrics.",
    "code": "    public static ClusterMetrics deserialize(byte[] data, int off) {\n        int start = off;\n\n        ClusterMetricsSnapshot metrics = new ClusterMetricsSnapshot();\n\n        metrics.setLastUpdateTime(U.currentTimeMillis());\n\n        metrics.setMaximumActiveJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentActiveJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setAverageActiveJobs(U.bytesToFloat(data, off));\n\n        off += 4;\n\n        metrics.setMaximumWaitingJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentWaitingJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setAverageWaitingJobs(U.bytesToFloat(data, off));\n\n        off += 4;\n\n        metrics.setMaximumRejectedJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentRejectedJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setAverageRejectedJobs(U.bytesToFloat(data, off));\n\n        off += 4;\n\n        metrics.setMaximumCancelledJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentCancelledJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setAverageCancelledJobs(U.bytesToFloat(data, off));\n\n        off += 4;\n\n        metrics.setTotalRejectedJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setTotalCancelledJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setTotalExecutedJobs(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setMaximumJobWaitTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setCurrentJobWaitTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setAverageJobWaitTime(U.bytesToDouble(data, off));\n\n        off += 8;\n\n        metrics.setMaximumJobExecuteTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setCurrentJobExecuteTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setAverageJobExecuteTime(U.bytesToDouble(data, off));\n\n        off += 8;\n\n        metrics.setTotalExecutedTasks(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentIdleTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setTotalIdleTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setAvailableProcessors(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setCurrentCpuLoad(U.bytesToDouble(data, off));\n\n        off += 8;\n\n        metrics.setAverageCpuLoad(U.bytesToDouble(data, off));\n\n        off += 8;\n\n        metrics.setCurrentGcCpuLoad(U.bytesToDouble(data, off));\n\n        off += 8;\n\n        metrics.setHeapMemoryInitialized(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setHeapMemoryUsed(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setHeapMemoryCommitted(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setHeapMemoryMaximum(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setNonHeapMemoryInitialized(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setNonHeapMemoryUsed(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setNonHeapMemoryCommitted(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setNonHeapMemoryMaximum(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setStartTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setNodeStartTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setUpTime(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setCurrentThreadCount(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setMaximumThreadCount(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setTotalStartedThreadCount(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setCurrentDaemonThreadCount(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setLastDataVersion(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setSentMessagesCount(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setSentBytesCount(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setReceivedMessagesCount(U.bytesToInt(data, off));\n\n        off += 4;\n\n        metrics.setReceivedBytesCount(U.bytesToLong(data, off));\n\n        off += 8;\n\n        metrics.setOutboundMessagesQueueSize(U.bytesToInt(data, off));\n\n        off += 4;\n\n        assert off - start == METRICS_SIZE : \"Invalid metrics size [expected=\" + METRICS_SIZE + \", actual=\" +\n            (off - start) + ']';\n\n        return metrics;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3412,
    "type": "Summary",
    "comment": "Get console for simple moving average.",
    "code": "  public InputPort<Object> getConsole(String name, String nodeName, DAG dag)\n  {\n    // hack to output to HTTP based on actual environment\n    String serverAddr = System.getenv(\"MALHAR_AJAXSERVER_ADDRESS\");\n    if (serverAddr != null) {\n      HttpOutputOperator<Object> oper = dag.addOperator(name, new HttpOutputOperator<Object>());\n      oper.setResourceURL(URI.create(\"http://\" + serverAddr + \"/channel/\" + nodeName));\n      return oper.input;\n    }\n\n    ConsoleOutputOperator oper = dag.addOperator(name, ConsoleOutputOperator.class);\n    return oper.input;\n  }\n\n",
    "label": 1,
    "rec": "Get console for output."
  },
  {
    "id": 3413,
    "type": "Summary",
    "comment": "Dispatches message",
    "code": "\t\tpublic boolean dispatch(Msg msg, String port) {\n\t\t\tbyte cmd  = 0x00;\n\t\t\tbyte cmd1 = 0x00;\n\t\t\tboolean isConsumed = false;\n\t\t\tint key = -1;\n\t\t\ttry {\n\t\t\t\tcmd  = msg.getByte(\"Cmd\");\n\t\t\t\tcmd1 = msg.getByte(\"command1\");\n\t\t\t} catch (FieldException e) {\n\t\t\t\tlogger.debug(\"no command found, dropping msg {}\", msg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (handleAllLinkMessage(msg, port)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (msg.isAckOfDirect()) {\n\t\t\t\t// in the case of direct ack, the cmd1 code is useless.\n\t\t\t\t// you have to know what message was sent before to\n\t\t\t\t// interpret the reply message\n\t\t\t\tif (m_feature.getQueryStatus() == DeviceFeature.QueryStatus.QUERY_PENDING\n\t\t\t\t\t\t&& cmd == 0x50) {\n\t\t\t\t\t// must be a reply to our message, tweak the cmd1 code!\n\t\t\t\t\tlogger.trace(\"changing key to 0x19 for msg {}\", msg);\n\t\t\t\t\tkey = 0x19; // we have installed a handler under that command number\n\t\t\t\t\tisConsumed = true;\n\t\t\t\t} else {\n\t\t\t\t\tkey = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkey = (cmd1 & 0xFF);\n\t\t\t}\n\t\t\tif (key != -1 || m_feature.isStatusFeature()) {\n\t\t\t\tMessageHandler h = m_feature.getMsgHandlers().get(key);\n\t\t\t\tif (h == null) h = m_feature.getDefaultMsgHandler();\n\t\t\t\tlogger.trace(\"{}:{}->{} DIRECT: {}\", m_feature.getDevice().getAddress(), m_feature.getName(),\n\t\t\t\t\t\th.getClass().getSimpleName(), msg);\n\t\t\t\th.handleMessage(-1, cmd1, msg, m_feature, port);\n\t\t\t}\n\t\t\tif (isConsumed) {\n\t\t\t\tm_feature.setQueryStatus(DeviceFeature.QueryStatus.QUERY_ANSWERED);\n\t\t\t}\n\t\t\treturn isConsumed;\n\t\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3414,
    "type": "Summary",
    "comment": "Returns a Filter that only accepts an element if all the filters accept the element.",
    "code": "    public static <E> Predicates.AllPredicate<E> all(Predicate<E>... predicates) {\r\n        return new Predicates.AllPredicate<E>(predicates);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns a Predicate that only accepts an element if all the predicates accept the element."
  },
  {
    "id": 3415,
    "type": "Summary",
    "comment": "The version is generated by taking last order plus one and random  UUID.",
    "code": "    private GridCacheVersion next(long topVer, boolean addTime, boolean forLoad) {\n        if (topVer == -1)\n            topVer = cctx.kernalContext().discovery().topologyVersion();\n\n        long globalTime = cctx.kernalContext().clockSync().adjustedTime(topVer);\n\n        if (addTime) {\n            if (gridStartTime == 0)\n                gridStartTime = cctx.kernalContext().discovery().gridStartTime();\n\n            topVer += (gridStartTime - TOP_VER_BASE_TIME) / 1000;\n        }\n\n        int locNodeOrder = (int)cctx.localNode().order();\n\n        long ord = forLoad ? loadOrder.incrementAndGet() : order.incrementAndGet();\n\n        GridCacheVersion next = new GridCacheVersion(\n            (int)topVer,\n            globalTime,\n            ord,\n            locNodeOrder,\n            dataCenterId);\n\n        last = next;\n\n        return next;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3416,
    "type": "Summary",
    "comment": "Queries whether a value is the special OclInvalid token.",
    "code": "\tpublic boolean isInvalid(Object value) {\n\t\treturn getEnvironment().getOCLStandardLibrary().getInvalid() == value;\n\t}\n\n",
    "label": 1,
    "rec": "Queries whether a value is the special invalid token."
  },
  {
    "id": 3417,
    "type": "Summary",
    "comment": "Return SQL selector query for getting tasks with a given tag",
    "code": "        public QueryTemplate queryTemplate() {\n            return new QueryTemplate().join(Join.inner(Metadata.TABLE,\n                    Task.ID.eq(Metadata.TASK))).where(Criterion.and(\n                            MetadataCriteria.withKey(KEY), TAG.eq(tag),\n                            TaskCriteria.isActive()));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3418,
    "type": "Summary",
    "comment": "Finds all Customers and returns a  PagedCollection for paging through them starting at the given page.",
    "code": "    public ResourceCollection<Customer> all(int pageNumber) {\n        String queryString = new QueryString().append(\"page\", pageNumber).toString();\n        NodeWrapper response = http.get(\"/customers?\" + queryString);\n        return new ResourceCollection<Customer>(new CustomerPager(this), response, Customer.class);\n    }\n\n",
    "label": 1,
    "rec": "Finds all Customers and returns a  ResourceCollection for paging through them starting at the given page."
  },
  {
    "id": 3419,
    "type": "Summary",
    "comment": "Handle Request/Stream messages.",
    "code": "        public Flux<Payload> requestStream(Payload payload) {\n            String streamName = payload.getDataUtf8();\n            if (DATA_STREAM_NAME.equals(streamName)) {\n                return Flux.from(dataPublisher);\n            }\n            return Flux.error(new IllegalArgumentException(streamName));\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3420,
    "type": "Summary",
    "comment": "Calculates the checksum of checksums of individual files.",
    "code": "    public static byte[] calculateCheckSum(File[] files, CheckSumType checkSumType)\n            throws Exception {\n        CheckSum checkSumGenerator = CheckSum.getInstance(checkSumType);\n        CheckSum fileCheckSumGenerator = CheckSum.getInstance(checkSumType);\n\n        int bufferSize = 64 * 1024;\n        byte[] buffer = new byte[bufferSize];\n\n        Arrays.sort(files, new Comparator<File>() {\n\n            public int compare(File fs1, File fs2) {\n                // directories before files\n                if(fs1.isDirectory())\n                    return fs2.isDirectory() ? 0 : -1;\n                if(fs2.isDirectory())\n                    return fs1.isDirectory() ? 0 : 1;\n\n                String f1 = fs1.getName(), f2 = fs2.getName();\n\n                // All checksum files given priority\n                if(f1.endsWith(\"checkSum.txt\"))\n                    return -1;\n                if(f2.endsWith(\"checkSum.txt\"))\n                    return 1;\n\n                // if both same, lexicographically\n                if((f1.endsWith(\".index\") && f2.endsWith(\".index\"))\n                   || (f1.endsWith(\".data\") && f2.endsWith(\".data\"))) {\n                    return f1.compareToIgnoreCase(f2);\n                }\n\n                if(f1.endsWith(\".index\")) {\n                    return 1;\n                } else {\n                    return -1;\n                }\n            }\n        });\n\n        for(File file: files) {\n            if(file.isFile() && !file.getName().startsWith(\".\")\n               && !file.getName().contains(\"checkSum.txt\")) {\n                DataInputStream is;\n                try {\n                    is = new DataInputStream(new FileInputStream(file));\n                } catch(FileNotFoundException e) {\n                    continue;\n                }\n\n                try {\n                    while(true) {\n                        int read = is.read(buffer);\n                        if(read < 0)\n                            break;\n                        else if(read < bufferSize) {\n                            buffer = ByteUtils.copy(buffer, 0, read);\n                        }\n                        fileCheckSumGenerator.update(buffer);\n                    }\n                    is.close();\n                } catch(IOException e) {\n                    break;\n                }\n                checkSumGenerator.update(fileCheckSumGenerator.getCheckSum());\n            }\n        }\n        return checkSumGenerator.getCheckSum();\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3421,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_PLAY_COUNTER;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3422,
    "type": "Summary",
    "comment": "Gets secondary file system factory.",
    "code": "    public HadoopFileSystemFactory getFileSystemFactory() {\n        return fsFactory;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3423,
    "type": "Summary",
    "comment": "Creates a new and empty  FastSet of size 3 if the method parameter is null.",
    "code": "  public static Collection<Refreshable> buildRefreshed(Collection<Refreshable> currentAlreadyRefreshed) {\n    return currentAlreadyRefreshed == null ? new HashSet<Refreshable>(3) : currentAlreadyRefreshed;\n  }\n\n",
    "label": 1,
    "rec": "Creates a new and empty  Collection if the method parameter is null."
  },
  {
    "id": 3424,
    "type": "Summary",
    "comment": "Creates cache configuration for atomic data structures.",
    "code": "        private static CacheConfiguration atomicsSystemCache(AtomicConfiguration cfg, boolean client) {\n            CacheConfiguration ccfg = new CacheConfiguration();\n\n            ccfg.setName(CU.ATOMICS_CACHE_NAME);\n            ccfg.setAtomicityMode(TRANSACTIONAL);\n            ccfg.setSwapEnabled(false);\n            ccfg.setQueryIndexEnabled(false);\n            ccfg.setRebalanceMode(SYNC);\n            ccfg.setWriteSynchronizationMode(FULL_SYNC);\n            ccfg.setCacheMode(cfg.getCacheMode());\n\n            if (cfg.getCacheMode() == PARTITIONED) {\n                ccfg.setBackups(cfg.getBackups());\n\n                ccfg.setDistributionMode(client ? NEAR_ONLY : NEAR_PARTITIONED);\n            }\n            else\n                ccfg.setDistributionMode(client ? NEAR_ONLY : PARTITIONED_ONLY);\n\n            return ccfg;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3425,
    "type": "Summary",
    "comment": "Solves A x = b by iterative biconjugate gradient method.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol, int maxIter) {\n        if (tol <= 0.0) {\n            throw new IllegalArgumentException(\"Invalid tolerance: \" + tol);\n        }\n\n        if (maxIter <= 0) {\n            throw new IllegalArgumentException(\"Invalid maximum number of iterations: \" + maxIter);\n        }\n\n        if (itol < 1 || itol > 4) {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        double err = 0.0;\n        double ak, akden, bk, bkden = 1.0, bknum, bnrm, dxnrm, xnrm, zm1nrm, znrm = 0.0;\n        int j, n = b.length;\n\n        double[] p = new double[n];\n        double[] pp = new double[n];\n        double[] r = new double[n];\n        double[] rr = new double[n];\n        double[] z = new double[n];\n        double[] zz = new double[n];\n\n        A.ax(x, r);\n        for (j = 0; j < n; j++) {\n            r[j] = b[j] - r[j];\n            rr[j] = r[j];\n        }\n\n        if (itol == 1) {\n            bnrm = snorm(b, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 2) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n        } else if (itol == 3 || itol == 4) {\n            Ap.asolve(b, z);\n            bnrm = snorm(z, itol);\n            Ap.asolve(r, z);\n            znrm = snorm(z, itol);\n        } else {\n            throw new IllegalArgumentException(String.format(\"Illegal itol: %d\", itol));\n        }\n\n        for (int iter = 1; iter <= maxIter; iter++) {\n            Ap.asolve(rr, zz);\n            for (bknum = 0.0, j = 0; j < n; j++) {\n                bknum += z[j] * rr[j];\n            }\n            if (iter == 1) {\n                for (j = 0; j < n; j++) {\n                    p[j] = z[j];\n                    pp[j] = zz[j];\n                }\n            } else {\n                bk = bknum / bkden;\n                for (j = 0; j < n; j++) {\n                    p[j] = bk * p[j] + z[j];\n                    pp[j] = bk * pp[j] + zz[j];\n                }\n            }\n            bkden = bknum;\n            A.ax(p, z);\n            for (akden = 0.0, j = 0; j < n; j++) {\n                akden += z[j] * pp[j];\n            }\n            ak = bknum / akden;\n            A.atx(pp, zz);\n            for (j = 0; j < n; j++) {\n                x[j] += ak * p[j];\n                r[j] -= ak * z[j];\n                rr[j] -= ak * zz[j];\n            }\n            Ap.asolve(r, z);\n            if (itol == 1) {\n                err = snorm(r, itol) / bnrm;\n            } else if (itol == 2) {\n                err = snorm(z, itol) / bnrm;\n            } else if (itol == 3 || itol == 4) {\n                zm1nrm = znrm;\n                znrm = snorm(z, itol);\n                if (Math.abs(zm1nrm - znrm) > Math.EPSILON * znrm) {\n                    dxnrm = Math.abs(ak) * snorm(p, itol);\n                    err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n                xnrm = snorm(x, itol);\n                if (err <= 0.5 * xnrm) {\n                    err /= xnrm;\n                } else {\n                    err = znrm / bnrm;\n                    continue;\n                }\n            }\n\n            if (iter % 10 == 0) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n            }\n\n            if (err <= tol) {\n                logger.info(String.format(\"BCG: the error after %3d iterations: %.5g\", iter, err));\n                break;\n            }\n        }\n\n        return err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3426,
    "type": "Summary",
    "comment": "This method will return current value only if clearIndex(V) will require previous value.",
    "code": "    protected CacheObject saveValueForIndexUnlocked() throws IgniteCheckedException {\n        assert Thread.holdsLock(this);\n\n        if (!cctx.cache().isMongoDataCache() && !cctx.cache().isMongoMetaCache())\n            return null;\n\n        return rawGetOrUnmarshalUnlocked(false);\n    }\n",
    "label": 1,
    "rec": "This method will return current value only if clearIndex(V) will require previous value (this is the case for Mongo caches)."
  },
  {
    "id": 3427,
    "type": "Summary",
    "comment": "Update the TOTP for this account.",
    "code": "    public Response processTotpUpdate(final MultivaluedMap<String, String> formData) {\n        if (auth == null) {\n            return login(\"totp\");\n        }\n\n        auth.require(AccountRoles.MANAGE_ACCOUNT);\n\n        String action = formData.getFirst(\"submitAction\");\n        if (action != null && action.equals(\"Cancel\")) {\n            setReferrerOnPage();\n            return account.createResponse(AccountPages.TOTP);\n        }\n\n        csrfCheck(formData);\n\n        UserModel user = auth.getUser();\n\n        String totp = formData.getFirst(\"totp\");\n        String totpSecret = formData.getFirst(\"totpSecret\");\n\n        if (Validation.isBlank(totp)) {\n            setReferrerOnPage();\n            return account.setError(Response.Status.BAD_REQUEST, Messages.MISSING_TOTP).createResponse(AccountPages.TOTP);\n        } else if (!CredentialValidation.validOTP(realm, totp, totpSecret)) {\n            setReferrerOnPage();\n            return account.setError(Response.Status.BAD_REQUEST, Messages.INVALID_TOTP).createResponse(AccountPages.TOTP);\n        }\n\n        UserCredentialModel credentials = new UserCredentialModel();\n        credentials.setType(realm.getOTPPolicy().getType());\n        credentials.setValue(totpSecret);\n        session.userCredentialManager().updateCredential(realm, user, credentials);\n\n        // to update counter\n        UserCredentialModel cred = new UserCredentialModel();\n        cred.setType(realm.getOTPPolicy().getType());\n        cred.setValue(totp);\n        session.userCredentialManager().isValid(realm, user, cred);\n\n        event.event(EventType.UPDATE_TOTP).client(auth.getClient()).user(auth.getUser()).success();\n\n        setReferrerOnPage();\n        return account.setSuccess(Messages.SUCCESS_TOTP).createResponse(AccountPages.TOTP);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3428,
    "type": "Summary",
    "comment": "As this is a HashedCredentialMatcher, this method overrides the parent by returning a hashed value of the submitted token's credentials.",
    "code": "    protected Object getCredentials(AuthenticationToken token) {\n        Object credentials = token.getCredentials();\n        Object salt = isHashSalted() ? getSalt( token ) : null;\n        return hashProvidedCredentials(credentials, salt, getHashIterations() );\n    }\n",
    "label": 1,
    "rec": "As this is a HashedCredentialMatcher, this method overrides the parent method by returning a hashed value of the submitted token's credentials."
  },
  {
    "id": 3429,
    "type": "Summary",
    "comment": "Update the top-level information of this realm.",
    "code": "    public Response updateRealm(final RealmRepresentation rep) {\n        auth.requireManage();\n\n        logger.debug(\"updating realm: \" + realm.getName());\n        try {\n            RepresentationToModel.updateRealm(rep, realm);\n            if (rep.isRealmCacheEnabled() != null && session.realms() instanceof CacheRealmProvider) {\n                CacheRealmProvider cacheRealmProvider = (CacheRealmProvider)session.realms();\n                cacheRealmProvider.setEnabled(rep.isRealmCacheEnabled());\n            }\n            if (rep.isUserCacheEnabled() != null && session.userStorage() instanceof CacheUserProvider) {\n                CacheUserProvider cache = (CacheUserProvider)session.userStorage();\n                cache.setEnabled(rep.isUserCacheEnabled());\n            }\n\n            // Refresh periodic sync tasks for configured federationProviders\n            List<UserFederationProviderModel> federationProviders = realm.getUserFederationProviders();\n            UsersSyncManager usersSyncManager = new UsersSyncManager();\n            for (final UserFederationProviderModel fedProvider : federationProviders) {\n                usersSyncManager.refreshPeriodicSyncForProvider(session.getKeycloakSessionFactory(), session.getProvider(TimerProvider.class), fedProvider, realm.getId());\n            }\n\n            return Response.noContent().build();\n        } catch (PatternSyntaxException e) {\n            return Flows.errors().exists(\"Specified regex pattern(s) is invalid.\");\n        } catch (ModelDuplicateException e) {\n            return Flows.errors().exists(\"Realm \" + rep.getRealm() + \" already exists.\");\n        }  catch (Exception e) {\n            return Flows.errors().exists(\"Failed to update \" + rep.getRealm() + \" Realm.\");\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3430,
    "type": "Summary",
    "comment": "build redis client form  RedisConnectionConfig with io.lettuce.",
    "code": "    private RedisClient getRedisClient(RedisConnectionConfig connectionConfig) {\n        if (connectionConfig.getRedisSentinels().size() == 0) {\n            RecordLog.info(\"[RedisDataSource] Creating stand-alone mode Redis client\");\n            return getRedisStandaloneClient(connectionConfig);\n        } else {\n            RecordLog.info(\"[RedisDataSource] Creating Redis Sentinel mode Redis client\");\n            return getRedisSentinelClient(connectionConfig);\n        }\n    }\n",
    "label": 1,
    "rec": "Build Redis client fromm  RedisConnectionConfig."
  },
  {
    "id": 3431,
    "type": "Summary",
    "comment": "Checks if user is authorized to produce/consume on a given topic",
    "code": "    protected boolean isAuthorized(DestinationName topic) throws Exception {\n        if (service().isAuthorizationEnabled()) {\n            return service().getAuthorizationService().canLookup(topic, clientAppId(), authData());\n        }\n        return true;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3432,
    "type": "Summary",
    "comment": "Returns the total byte size of the referenced AllocationPointerOperations",
    "code": "\tpublic static final long getEndOffset(final long address) {\n\t\treturn getEndAddress(address) - getAddressOfDim(address);\n\t}\n\n",
    "label": 1,
    "rec": "Returns the total byte size of the referenced AllocationPointer"
  },
  {
    "id": 3433,
    "type": "Summary",
    "comment": "Create system cache used by Hadoop component.",
    "code": "    public static CacheConfiguration hadoopSystemCache() {\n        CacheConfiguration cache = new CacheConfiguration();\n\n        cache.setName(CU.SYS_CACHE_HADOOP_MR);\n        cache.setCacheMode(REPLICATED);\n        cache.setAtomicityMode(TRANSACTIONAL);\n        cache.setWriteSynchronizationMode(FULL_SYNC);\n\n        cache.setEvictionPolicy(null);\n        cache.setSwapEnabled(false);\n        cache.setQueryIndexEnabled(false);\n        cache.setStore(null);\n        cache.setEagerTtl(true);\n        cache.setPreloadMode(SYNC);\n\n        return cache;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3434,
    "type": "Summary",
    "comment": "Returns whether a Java line breakpoint is already registered with the breakpoint manager for a type with the given name at the given line number.",
    "code": "\tpublic static IJavaLineBreakpoint lineBreakpointExists(String typeName, int lineNumber) throws CoreException {\r\n\t\tString modelId= getPluginIdentifier();\r\n\t\tString markerType= JavaLineBreakpoint.getMarkerType();\r\n\t\tIBreakpointManager manager= DebugPlugin.getDefault().getBreakpointManager();\r\n\t\tIBreakpoint[] breakpoints= manager.getBreakpoints(modelId);\r\n\t\tfor (int i = 0; i < breakpoints.length; i++) {\r\n\t\t\tif (!(breakpoints[i] instanceof IJavaLineBreakpoint)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tIJavaLineBreakpoint breakpoint = (IJavaLineBreakpoint) breakpoints[i];\r\n\t\t\tif (breakpoint.getMarker().getType().equals(markerType)) {\r\n\t\t\t\tif (breakpoint.getTypeName().equals(typeName)) {\r\n\t\t\t\t\tif (breakpoint.getLineNumber() == lineNumber) {\r\n\t\t\t\t\t\treturn breakpoint;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\t\r\n\n",
    "label": 1,
    "rec": "Returns a Java line breakpoint that is already registered with the breakpoint manager for a type with the given name at the given line number."
  },
  {
    "id": 3435,
    "type": "Summary",
    "comment": "There should only be one fetch request in flight at any give time.",
    "code": "    Single<Parsed> fetchAndPersist(@Nonnull final Key key) {\n        try {\n            return inFlightRequests.get(key, () -> response(key));\n        } catch (ExecutionException e) {\n            return Single.error(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3436,
    "type": "Summary",
    "comment": "Returns a collection view of the entity copies contained in this EventCache.",
    "code": "\tpublic Collection values() {\n\t\treturn Collections.unmodifiableCollection( entityToCopyMap.values() );\n\t}\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable set view of the entity copies contained in this EventCache."
  },
  {
    "id": 3437,
    "type": "Summary",
    "comment": "Set of supported picture sizes for the currently opened camera.",
    "code": "    public Collection<Size> getSupportedPictureSizes() {\n        return Collections.unmodifiableSet(supportedPictureSizes);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3438,
    "type": "Summary",
    "comment": "Gets the direction that this sign is currently facing",
    "code": "    public BlockFace getFacing() {\n        byte data = getData();\n\n        if (!isWallSign()) {\n            switch (data) {\n            case 0x0:\n                return BlockFace.WEST;\n\n            case 0x1:\n                return BlockFace.WEST_NORTH_WEST;\n\n            case 0x2:\n                return BlockFace.NORTH_WEST;\n\n            case 0x3:\n                return BlockFace.NORTH_NORTH_WEST;\n\n            case 0x4:\n                return BlockFace.NORTH;\n\n            case 0x5:\n                return BlockFace.NORTH_NORTH_EAST;\n\n            case 0x6:\n                return BlockFace.NORTH_EAST;\n\n            case 0x7:\n                return BlockFace.EAST_NORTH_EAST;\n\n            case 0x8:\n                return BlockFace.EAST;\n\n            case 0x9:\n                return BlockFace.EAST_SOUTH_EAST;\n\n            case 0xA:\n                return BlockFace.SOUTH_EAST;\n\n            case 0xB:\n                return BlockFace.SOUTH_SOUTH_EAST;\n\n            case 0xC:\n                return BlockFace.SOUTH;\n\n            case 0xD:\n                return BlockFace.SOUTH_SOUTH_WEST;\n\n            case 0xE:\n                return BlockFace.SOUTH_WEST;\n\n            case 0xF:\n                return BlockFace.WEST_SOUTH_WEST;\n            }\n\n            return null;\n        } else {\n            return getAttachedFace().getOppositeFace();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3439,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_LINKED_INFO;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3440,
    "type": "Summary",
    "comment": "Add a mapper to identity provider",
    "code": "    public Response addMapper(IdentityProviderMapperRepresentation mapper) {\n        auth.requireManage();\n\n        if (identityProviderModel == null) {\n            throw new javax.ws.rs.NotFoundException();\n        }\n\n        IdentityProviderMapperModel model = RepresentationToModel.toModel(mapper);\n        try {\n            model = realm.addIdentityProviderMapper(model);\n        } catch (Exception e) {\n            return ErrorResponse.error(\"Failed to add mapper '\" + model.getName() + \"' to identity provider [\" + identityProviderModel.getProviderId() + \"].\", Response.Status.BAD_REQUEST);\n        }\n\n        adminEvent.operation(OperationType.CREATE).resource(ResourceType.IDENTITY_PROVIDER_MAPPER).resourcePath(uriInfo, model.getId())\n            .representation(mapper).success();\n\n        return Response.created(uriInfo.getAbsolutePathBuilder().path(model.getId()).build()).build();\n\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3441,
    "type": "Summary",
    "comment": "Returns all rules for which the trigger condition is true for the given type, itemName and command.",
    "code": "\tpublic Iterable<Rule> getRules(TriggerTypes triggerType, Item item, Command command) {\n\t\treturn internalGetRules(triggerType, item, command, null);\n\t}\n",
    "label": 1,
    "rec": "Returns all rules for which the trigger condition is true for the given type, item and command."
  },
  {
    "id": 3442,
    "type": "Summary",
    "comment": "Asynchronous sequence update operation.",
    "code": "    private IgniteInternalFuture<Long> internalUpdateAsync(long l, @Nullable Callable<Long> updateCall, boolean updated)\n        throws IgniteCheckedException {\n        checkRemoved();\n\n        A.ensure(l > 0, \" Parameter mustn't be less then 1: \" + l);\n\n        lock.lock();\n\n        try {\n            // If reserved range isn't exhausted.\n            if (locVal + l <= upBound) {\n                long curVal = locVal;\n\n                locVal += l;\n\n                return new GridFinishedFuture<>(updated ? locVal : curVal);\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n\n        if (updateCall == null)\n            updateCall = internalUpdate(l, updated);\n\n        while (true) {\n            if (updateGuard.compareAndSet(false, true)) {\n                try {\n                    // This call must be outside lock.\n                    return ctx.closures().callLocalSafe(updateCall, true);\n                }\n                finally {\n                    lock.lock();\n\n                    try {\n                        updateGuard.set(false);\n\n                        cond.signalAll();\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n                }\n            }\n            else {\n                lock.lock();\n\n                try {\n                    while (locVal >= upBound && updateGuard.get())\n                        U.await(cond, 500, MILLISECONDS);\n\n                    checkRemoved();\n\n                    // If reserved range isn't exhausted.\n                    if (locVal + l <= upBound) {\n                        long curVal = locVal;\n\n                        locVal += l;\n\n                        return new GridFinishedFuture<>(updated ? locVal : curVal);\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3443,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_GENRE ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3444,
    "type": "Summary",
    "comment": "Generates a map of parameters and the values from the given deep link.",
    "code": "  private static String parsePath(DeepLinkUri parsedUri) {\n    return parsedUri.encodedPath();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3445,
    "type": "Summary",
    "comment": "Best effort to find origin for REST request calls from web UI application to REST application.",
    "code": "    public static String getOriginForRestCalls(String browserRequestURL) {\n        return UriUtils.getOrigin(browserRequestURL);\n    }\n",
    "label": 1,
    "rec": "Find origin for REST request calls from web UI application to REST application (assuming the REST application is deployed on same host like current UI application)"
  },
  {
    "id": 3446,
    "type": "Summary",
    "comment": "Configure a  WebSessionManager using a provided  ReactorSessionRepository.",
    "code": "\tpublic WebSessionManager webSessionManager(ReactorSessionRepository<? extends Session> repository) {\n\t\tSpringSessionWebSessionStore<? extends Session> sessionStore = new SpringSessionWebSessionStore<>(repository);\n\t\tDefaultWebSessionManager manager = new DefaultWebSessionManager();\n\t\tmanager.setSessionStore(sessionStore);\n\t\treturn manager;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3447,
    "type": "Summary",
    "comment": "Create intent to browse a repository's issues",
    "code": "    public static Intent createIntent(IssueFilter filter) {\n        return new Builder(\"repo.issues.VIEW\").repo(filter.getRepository()).add(EXTRA_ISSUE_FILTER, filter).toIntent();\n    }\n",
    "label": 1,
    "rec": "Create intent to browse the filtered issues"
  },
  {
    "id": 3448,
    "type": "Summary",
    "comment": "Gets transactions configuration.",
    "code": "    public TransactionConfiguration getTransactionsConfiguration() {\n        return txCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3449,
    "type": "Summary",
    "comment": "Returns a copy of itself",
    "code": "    @Override\n    protected <T extends Dom> T copy(T parent) {\n        return (T) new ConfigBean(this, parent);\n    }\n\n",
    "label": 1,
    "rec": "Returns a copy of itself providing the parent for the new copy."
  },
  {
    "id": 3450,
    "type": "Summary",
    "comment": "Parses the given JSON input using the provided  Configuration and returns a  DocumentContext for path evaluation",
    "code": "    public static DocumentContext parse(URL json, Configuration configuration) throws IOException {\n        return new JsonContext(configuration).parse(json);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3451,
    "type": "Summary",
    "comment": "Calculates type names for writing into generated Java.",
    "code": "    public static String calculateTypeName(CompilationUnit compilationUnit, FullyQualifiedJavaType fqjt) {\n\n        if (fqjt.isArray()) {\n            // if array, then calculate the name of the base (non-array) type\n            // then add the array indicators back in\n            String fqn = fqjt.getFullyQualifiedName();\n            String typeName = calculateTypeName(compilationUnit,\n                    new FullyQualifiedJavaType(fqn.substring(0, fqn.indexOf('['))));\n            String rc = typeName + fqn.substring(fqn.indexOf('['));\n            return rc;\n        }\n        \n        if (!fqjt.getTypeArguments().isEmpty()) {\n            return calculateParameterizedTypeName(compilationUnit, fqjt);\n        }\n        \n        if (compilationUnit == null\n                || typeDoesNotRequireImport(fqjt)\n                || typeIsInSamePackage(compilationUnit, fqjt) \n                || typeIsAlreadyImported(compilationUnit, fqjt)) {\n            return fqjt.getShortName();\n        } else {\n            return fqjt.getFullyQualifiedName();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3452,
    "type": "Summary",
    "comment": "This helper method could potentially be overridden to return a different type of StopWatchParser that is used to parse the log messages send to this appender.",
    "code": "    private StopWatchParser newStopWatchParser() {\n        try {\n            return (StopWatchParser) Class.forName(stopWatchParserClassName).newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not create StopWatchParser: \" + e.getMessage(), e);\n        }\n    }\n\n",
    "label": 1,
    "rec": "Helper method instantiates a new StopWatchParser based on the StopWatchParserClassName option."
  },
  {
    "id": 3453,
    "type": "Summary",
    "comment": "In place element-wise division A = A / B",
    "code": "    public DenseMatrix div(DenseMatrix b) {\n        if (nrows() != b.nrows() || ncols() != b.ncols()) {\n            throw new IllegalArgumentException(\"Matrix is not of same size.\");\n        }\n\n        int m = nrows();\n        int n = ncols();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                div(i, j, b.get(i, j));\n            }\n        }\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3454,
    "type": "Summary",
    "comment": "Excutes the given url with the given httpMethod",
    "code": "\tpublic static String executeUrl(String httpMethod, String url, int timeout) {\n\t\t\n\t\tString proxyHost = System.getProperty(\"http.proxyHost\");\n\t\tString proxyPort = System.getProperty(\"http.proxyPort\");\n\t\tString proxyUser = System.getProperty(\"http.proxyUser\");\n\t\tString proxyPassword = System.getProperty(\"http.proxyPassword\");\n\t\t\n\t\treturn executeUrl(httpMethod, url, timeout, proxyHost, proxyPort, proxyUser, proxyPassword);\n\t}\n",
    "label": 1,
    "rec": "Executes the given url with the given httpMethod."
  },
  {
    "id": 3455,
    "type": "Summary",
    "comment": "double argument less than the given value.",
    "code": "    public static double lt(double value) {\n        reportMatcher(new LessThan<Double>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3456,
    "type": "Summary",
    "comment": "Indicates if [ low,  high] interval overlaps with any interval of this instance.",
    "code": "\tpublic boolean isInRange(double low, double high) {\n\t\tif (low > high)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The left endpoint of the interval must be less than \" +\n\t\t\t\t\t\t\"the right endpoint.\");\n\n\t\treturn getLow() >= low && getHigh() <= high;\n\t}\n",
    "label": 1,
    "rec": "Indicates if this instance is included in a [ low,  high] time interval."
  },
  {
    "id": 3457,
    "type": "Summary",
    "comment": "Allocates a page from the next memory chunk.",
    "code": "    private long allocateFreePage() {\n        while (true) {\n            Chunk chunk = currentChunk;\n\n            long relPtr = chunk.allocateFreePage();\n\n            if (relPtr == INVALID_REL_PTR) {\n                synchronized (this) {\n                    Chunk full = currentChunk;\n\n                    if (chunk == full && !requestNextChunk())\n                        return INVALID_REL_PTR;\n                }\n            }\n            else\n                return relPtr;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3458,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_COMMERCIAL_FRAME;               \n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3459,
    "type": "Summary",
    "comment": "Get gist from event",
    "code": "    public Gist getGist(final GithubEvent event) {\n        if (event == null)\n            return null;\n        if (event.payload == null)\n            return null;\n\n        Gson gson = new Gson();\n        String json = gson.toJson(event.payload);\n\n        EventType type = event.getType();\n        if (EventType.GistEvent.equals(type))\n            return (gson.fromJson(json, GistEventPayload.class)).gist;\n        else\n            return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3460,
    "type": "Summary",
    "comment": "Generates next affinity key for local node based on current topology.",
    "code": "    public IgniteUuid nextAffinityKey(@Nullable IgniteUuid prevAffKey) {\n        // Do not generate affinity key for non-affinity nodes.\n        if (!isAffinityNode(dataCache.configuration()))\n            return null;\n\n        UUID nodeId = ggfsCtx.kernalContext().localNodeId();\n\n        if (prevAffKey != null && dataCache.affinity().mapKeyToNode(prevAffKey).isLocal())\n            return prevAffKey;\n\n        while (true) {\n            IgniteUuid key = new IgniteUuid(nodeId, affKeyGen.getAndIncrement());\n\n            if (dataCache.affinity().mapKeyToNode(key).isLocal())\n                return key;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3461,
    "type": "Summary",
    "comment": "Determine whether a list of string is not blank",
    "code": "    public static boolean isNotBlank(String str) {\n        return null != str && !\"\".equals(str.trim());\n    }\n\n",
    "label": 1,
    "rec": "Determine whether a string is not blank"
  },
  {
    "id": 3462,
    "type": "Summary",
    "comment": "null argument.",
    "code": "    public static Object isNull() {\n        reportMatcher(Null.NULL);\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3463,
    "type": "Summary",
    "comment": "Returns a set view of the entities contained in this EventCache",
    "code": "\tpublic Set keySet() {\n\t\treturn Collections.unmodifiableSet( entityToCopyMap.keySet() );\n\t}\n\n",
    "label": 1,
    "rec": "Returns an unmodifiable set view of the entities contained in this EventCache"
  },
  {
    "id": 3464,
    "type": "Summary",
    "comment": "Gets grid state.",
    "code": "        IgniteState state() {\n            if (starterThread != Thread.currentThread())\n                U.awaitQuiet(startLatch);\n\n            return state;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3465,
    "type": "Summary",
    "comment": "Replaces all occurrences of  org.gridgain.grid. with  o.g.g.,  org.gridgain.visor. with  o.g.v., and  org.gridgain.scalar. with  o.g.s..",
    "code": "    public static String compact(String s) {\n        return s.replace(\"org.gridgain.grid.\", \"o.g.g.\").\n            replace(\"org.gridgain.visor.\", \"o.g.v.\").\n            replace(\"org.gridgain.scalar.\", \"o.g.s.\").\n            replace(\"org.gridgain.\", \"o.g.\");\n    }\n",
    "label": 1,
    "rec": "Replaces all occurrences of  org.gridgain. with  o.g.,  org.gridgain.grid. with  o.g.g.,  org.gridgain.visor. with  o.g.v. and  org.gridgain.scalar. with  o.g.s.."
  },
  {
    "id": 3466,
    "type": "Summary",
    "comment": "Create split.",
    "code": "    protected IgfsFileRange split(long start, long len) {\n        return new IgfsFileRange(FILE, start, len);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3467,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ATTACHED_PICTURE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3468,
    "type": "Summary",
    "comment": "Bind text view to HTML string",
    "code": "    public HttpImageGetter bind(final TextView view, final String html, final Object id) {\n        if (TextUtils.isEmpty(html))\n            return hide(view);\n\n        CharSequence encoded = fullHtmlCache.get(id);\n        if (encoded != null)\n            return show(view, encoded);\n\n        encoded = rawHtmlCache.get(id);\n        if (encoded == null) {\n            encoded = HtmlUtils.encode(html, loading);\n            // Use default encoding if no img tags\n            if (html.indexOf(\"<img\") == -1) {\n                fullHtmlCache.put(id, encoded);\n                return show(view, encoded);\n            } else\n                rawHtmlCache.put(id, encoded);\n        }\n\n        if (TextUtils.isEmpty(encoded))\n            return hide(view);\n\n        show(view, encoded);\n        view.setTag(id);\n        new RoboAsyncTask<CharSequence>(context) {\n\n            @Override\n            public CharSequence call() throws Exception {\n                return HtmlUtils.encode(html, HttpImageGetter.this);\n            }\n\n            @Override\n            protected void onSuccess(final CharSequence html) throws Exception {\n                rawHtmlCache.remove(id);\n                fullHtmlCache.put(id, html);\n\n                if (id.equals(view.getTag()))\n                    show(view, html);\n            }\n        }.execute();\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3469,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_GROUP_ID_REG ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3470,
    "type": "Summary",
    "comment": "Get the direction that this bed's head is facing toward",
    "code": "    public BlockFace getFacing() {\n        byte data = (byte) (getData() & 0x7);\n\n        switch (data) {\n        case 0x0:\n            return BlockFace.SOUTH;\n\n        case 0x1:\n            return BlockFace.WEST;\n\n        case 0x2:\n            return BlockFace.NORTH;\n\n        case 0x3:\n        default:\n            return BlockFace.EAST;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3471,
    "type": "Summary",
    "comment": "ReadOffer",
    "code": "    @Processor\n    @InvalidateConnectionOn(exception = NotAuthenticatedException.class)\n    public Offer readOffer(String objectId) {\n        return (Offer) read(ServiceSourceCollection.Offers, objectId);\n    }\n\n",
    "label": 1,
    "rec": "Fetches the offer identified by the object id in the collection."
  },
  {
    "id": 3472,
    "type": "Summary",
    "comment": "Gets configuration bean.",
    "code": "    public IgniteConfiguration getConfiguration() {\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3473,
    "type": "Summary",
    "comment": "Replaces all occurrences of  org.apache.ignite. with  o.a.i.,  org.apache.ignite.internal. with  o.a.i.i.,  org.apache.ignite.visor. with  o.a.i.v. and  org.apache.ignite.scalar. with  o.a.i.s..",
    "code": "    public static String compact(String s) {\n        return s.replace(\"org.apache.ignite.internal.visor.\", \"o.a.i.i.v.\").\n            replace(\"org.apache.ignite.internal.\", \"o.a.i.i.\").\n            replace(\"org.apache.ignite.scalar.\", \"o.a.i.s.\").\n            replace(\"org.apache.ignite.\", \"o.a.i.\");\n    }\n",
    "label": 1,
    "rec": "Replaces all occurrences of  org.apache.ignite. with  o.a.i.,  org.apache.ignite.internal. with  o.a.i.i.,  org.apache.ignite.internal.visor. with  o.a.i.i.v. and  org.apache.ignite.scalar. with  o.a.i.s.."
  },
  {
    "id": 3474,
    "type": "Summary",
    "comment": "Returns a distinct collection of URLs based on the  WEB-INF/lib folder.",
    "code": "    public static Collection<URL> forWebInfLib(final ServletContext servletContext) {\n        final Collection<URL> urls = new ArrayList<URL>();\n        Set<?> resourcePaths = servletContext.getResourcePaths(\"/WEB-INF/lib\");\n        if (resourcePaths == null) {\n            return urls;\n        }\n        for (Object urlString : resourcePaths) {\n            try {\n                urls.add(servletContext.getResource((String) urlString));\n            } catch (MalformedURLException e) { /*fuck off*/ }\n        }\n        return distinctUrls(urls);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3475,
    "type": "Summary",
    "comment": "Retrieve a list of currently configured DNS servers IP addresses.",
    "code": "    public static synchronized String[] findDNS() {\n        String[] resArray = null;\n        for (DNSServerLookupMechanism mechanism : LOOKUP_MECHANISMS) {\n            resArray = mechanism.getDnsServerAddresses();\n            if (resArray == null) {\n                continue;\n            }\n\n            List<String> res = new ArrayList<>(Arrays.asList(resArray));\n\n            Iterator<String> it = res.iterator();\n            while (it.hasNext()) {\n                String potentialDnsServer = it.next();\n\n                if (blacklistedDnsServers.contains(potentialDnsServer)) {\n                    LOGGER.fine(\"The DNS server lookup mechanism '\" + mechanism.getName()\n                    + \"' returned a blacklisted result: '\" + potentialDnsServer + \"'\");\n                    it.remove();\n                }\n            }\n\n            if (!res.isEmpty()) {\n                resArray = res.toArray(new String[res.size()]);\n                break;\n            }\n        }\n\n        return resArray;\n    }\n\n",
    "label": 1,
    "rec": "Retrieve a list of currently configured DNS servers."
  },
  {
    "id": 3476,
    "type": "Summary",
    "comment": "Gets GGFS configurations.",
    "code": "    public IgniteFsConfiguration[] getGgfsConfiguration() {\n        return ggfsCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3477,
    "type": "Summary",
    "comment": "Creates the GPX Format out of the points.",
    "code": "    public String createGPX()\n    {\n        return createGPX(\"GraphHopper\", 0, \"GMT\");\n    }\n",
    "label": 1,
    "rec": "Creates the standard GPX string out of the points."
  },
  {
    "id": 3478,
    "type": "Summary",
    "comment": "Reconstructs object on unmarshalling.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            IgniteBiTuple<String, Object> t = stash.get();\n\n            String gridNameR = t.get1();\n            Object ctgrR = t.get2();\n\n            IgniteLogger log = IgnitionEx.gridx(gridNameR).log();\n\n            return ctgrR != null ? log.getLogger(ctgrR) : log;\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3479,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_LYRICIST;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3480,
    "type": "Summary",
    "comment": "Extracts a resource, if the size or last modified timestamp differs from what is in cache, and returns the cached  File.",
    "code": "    public static File cacheResource(URL resourceURL, String target) throws IOException {\n        // Find appropriate subdirectory in cache for the resource ...\n        File urlFile = new File(resourceURL.getPath());\n        String name = urlFile.getName();\n        long size, timestamp;\n        File cacheSubdir = getCacheDir().getCanonicalFile();\n        URLConnection urlConnection = resourceURL.openConnection();\n        if (urlConnection instanceof JarURLConnection) {\n            JarFile jarFile = ((JarURLConnection)urlConnection).getJarFile();\n            JarEntry jarEntry = ((JarURLConnection)urlConnection).getJarEntry();\n            File jarFileFile = new File(jarFile.getName());\n            File jarEntryFile = new File(jarEntry.getName());\n            size = jarEntry.getSize();\n            timestamp = jarEntry.getTime();\n            cacheSubdir = new File(cacheSubdir, jarFileFile.getName() + File.separator + jarEntryFile.getParent());\n        } else {\n            size = urlFile.length();\n            timestamp = urlFile.lastModified();\n            cacheSubdir = new File(cacheSubdir, name);\n        }\n        if (resourceURL.getRef() != null) {\n            // ... get the URL fragment to let users rename library files ...\n            name = resourceURL.getRef();\n        }\n        // ... then check if it has not already been extracted, and if not ...\n        File file = new File(cacheSubdir, name);\n        if (target != null && target.length() > 0) {\n            // ... create symbolic link to already extracted library or ...\n            try {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Creating symbolic link to \" + target);\n                }\n                Path path = file.toPath(), targetPath = Paths.get(target);\n                if ((!file.exists() || !Files.isSymbolicLink(path))\n                        && targetPath.isAbsolute() && !targetPath.equals(path)) {\n                    file.delete();\n                    Files.createSymbolicLink(path, targetPath);\n                }\n            } catch (IOException e) {\n                // ... (probably an unsupported operation on Windows, but DLLs never need links) ...\n                return null;\n            }\n        } else if (!file.exists() || file.length() != size || file.lastModified() != timestamp\n                    || !cacheSubdir.equals(file.getCanonicalFile().getParentFile())) {\n            // ... then extract it from our resources ...\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Extracting \" + resourceURL);\n            }\n            file.delete();\n            extractResource(resourceURL, file, null, null);\n            file.setLastModified(timestamp);\n        } else while (System.currentTimeMillis() - file.lastModified() >= 0\n                   && System.currentTimeMillis() - file.lastModified() < 1000) {\n            // ... else wait until the file is at least 1 second old ...\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException ex) {\n                // ... and reset interrupt to be nice.\n                Thread.currentThread().interrupt();\n            }\n        }\n        return file;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3481,
    "type": "Summary",
    "comment": "Returns whether or not this pre-requisite requires an exact match.",
    "code": "public byte getMatch() {\r\n\treturn match;\r\n}\r\n\n",
    "label": 1,
    "rec": "Returns a byte code indicating the type of match this pre-requisite requires."
  },
  {
    "id": 3482,
    "type": "Summary",
    "comment": "Converts an event repo to a new, clean repo.",
    "code": "\tpublic static Repository eventRepoToRepo(Repository repo) {\n\t\tString[] ref = repo.name().split(\"/\");\n\t\treturn InfoUtils.createRepoFromData(ref[0], ref[1]);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3483,
    "type": "Summary",
    "comment": "FOR TESTING ONLY",
    "code": "    public IndexingSpi spi(@Nullable String name) {\n        if (F.isEmpty(name))\n            return getSpis()[0];\n\n        for (IndexingSpi s : getSpis()) {\n            if (name.equals(s.getName()))\n                return s;\n        }\n\n        throw new GridRuntimeException(\"Failed to find SPI for name: \" + name);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3484,
    "type": "Summary",
    "comment": "Get the  OpcXmlDataTypeCodec identified by  description from the dictionary identified by  namespaceUri.",
    "code": "    @Nullable\n    default OpcUaXmlDataTypeCodec<?> getXmlCodec(String namespaceUri, String description) {\n        DataTypeCodec codec = getCodec(namespaceUri, description);\n\n        if (codec instanceof OpcUaXmlDataTypeCodec) {\n            return (OpcUaXmlDataTypeCodec<?>) codec;\n        } else {\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get the  OpcUaXmlDataTypeCodec identified by  description from the dictionary identified by  namespaceUri."
  },
  {
    "id": 3485,
    "type": "Summary",
    "comment": "Compare a user permission like 'myplugin.' against a full plugin permission name, like 'myplugin.dosomething'.",
    "code": "\tpublic boolean comparePermissionString(String userAccessLevel, String fullPermissionName) {\n        int userAccessLevelLength;\n        if (userAccessLevel == null || fullPermissionName == null\n                || (userAccessLevelLength = userAccessLevel.length()) == 0 || fullPermissionName.length() == 0) {\n            return false;\n        }\n\n        int userAccessLevelOffset;\n        if (userAccessLevel.charAt(0) == '+' || userAccessLevel.charAt(0) == '-') {\n            userAccessLevelOffset = 1;\n        } else {\n            userAccessLevelOffset = 0;\n        }\n        if (\"*\".regionMatches(0, userAccessLevel, userAccessLevelOffset, userAccessLevelLength - userAccessLevelOffset)) {\n            return true;\n        }\n        int fullPermissionNameOffset;\n        if (fullPermissionName.charAt(0) == '+' || fullPermissionName.charAt(0) == '-') {\n            fullPermissionNameOffset = 1;\n        } else {\n            fullPermissionNameOffset = 0;\n        }\n\n        if (userAccessLevel.charAt(userAccessLevel.length() - 1) == '*') {\n            userAccessLevelLength--;\n        }\n        return userAccessLevel.regionMatches(true, userAccessLevelOffset, fullPermissionName, fullPermissionNameOffset, userAccessLevelLength - userAccessLevelOffset);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3486,
    "type": "Summary",
    "comment": "Initiates a login attempt with the provided credentials in the http header.",
    "code": "    protected boolean executeLogin(ServletRequest request, ServletResponse response) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to authenticate Subject based on Http BASIC Authentication request...\");\n        }\n\n        String authorizationHeader = getAuthzHeader(request);\n        if (authorizationHeader == null || authorizationHeader.length() == 0 ) {\n            return false;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Attempting to execute login with headers [\" + authorizationHeader + \"]\");\n        }\n\n        String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);\n        if ( prinCred == null || prinCred.length < 2 ) {\n            return false;\n        }\n\n        String username = prinCred[0];\n        String password = prinCred[1];\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Processing login request for username [\" + username + \"]\");\n        }\n\n        AuthenticationToken token = createToken(username, password, request );\n        if ( token != null ) {\n            return executeLogin(token, request, response );\n        }\n\n        //always default to false.  If we've made it to this point in the code, that\n        //means the authentication attempt either never occured, or wasn't successful:\n        return false;\n    }\n",
    "label": 1,
    "rec": "Executes a login attempt with the provided credentials in the http header and returns true if the login attempt is successful and false otherwise."
  },
  {
    "id": 3487,
    "type": "Summary",
    "comment": "Gets address resolver.",
    "code": "    public IgniteAddressResolver getAddressResolver() {\n        return addrRslvr;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3488,
    "type": "Summary",
    "comment": "Execute getFallback() within protection of a semaphore that limits number of concurrent executions.",
    "code": "    private Observable<R> getFallbackOrThrowException(final HystrixEventType eventType, final FailureType failureType, final String message, final Exception originalException) {\n        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();\n\n        if (properties.fallbackEnabled().get()) {\n            /* fallback behavior is permitted so attempt */\n            // record the executionResult\n            // do this before executing fallback so it can be queried from within getFallback (see See https://github.com/Netflix/Hystrix/pull/144)\n            executionResult = executionResult.addEvents(eventType);\n            final AbstractCommand<R> _cmd = this;\n\n            final TryableSemaphore fallbackSemaphore = getFallbackSemaphore();\n\n            Observable<R> fallbackExecutionChain;\n\n            // acquire a permit\n            if (fallbackSemaphore.tryAcquire()) {\n                executionHook.onFallbackStart(this);\n\n                try {\n                    fallbackExecutionChain = getFallbackObservable();\n                } catch (Throwable t) {\n                    // getFallback() is user provided and can throw so we catch it and turn it into Observable.error\n                    fallbackExecutionChain = Observable.error(t);\n                }\n\n                fallbackExecutionChain =  fallbackExecutionChain\n                        .lift(new FallbackHookApplication(_cmd))\n                        .lift(new DeprecatedOnFallbackHookApplication(_cmd))\n                        .doOnTerminate(new Action0() {\n\n                            @Override\n                            public void call() {\n                                fallbackSemaphore.release();\n                            }\n                        });\n            } else {\n                metrics.markFallbackRejection();\n                executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_REJECTION);\n                logger.debug(\"HystrixCommand Fallback Rejection.\"); // debug only since we're throwing the exception and someone higher will do something with it\n                // if we couldn't acquire a permit, we \"fail fast\" by throwing an exception\n                return Observable.error(new HystrixRuntimeException(FailureType.REJECTED_SEMAPHORE_FALLBACK, this.getClass(), getLogMessagePrefix() + \" fallback execution rejected.\", null, null));\n            }\n\n            return fallbackExecutionChain.doOnNext(new Action1<R>() {\n                @Override\n                public void call(R r) {\n                    if (shouldOutputOnNextEvents()) {\n                        executionResult = executionResult.addEmission(HystrixEventType.FALLBACK_EMIT);\n                        metrics.markFallbackEmit();\n                    }\n                }\n            }).doOnCompleted(new Action0() {\n\n                @Override\n                public void call() {\n                    // mark fallback on counter\n                    metrics.markFallbackSuccess();\n                    // record the executionResult\n                    executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_SUCCESS);\n                }\n\n            }).onErrorResumeNext(new Func1<Throwable, Observable<R>>() {\n\n                @Override\n                public Observable<R> call(Throwable t) {\n                    Exception e = originalException;\n                    Exception fe = getExceptionFromThrowable(t);\n\n\n                    if (fe instanceof UnsupportedOperationException) {\n                        logger.debug(\"No fallback for HystrixCommand. \", fe); // debug only since we're throwing the exception and someone higher will do something with it\n                        /* executionHook for all errors */\n                        e = wrapWithOnErrorHook(failureType, e);\n\n                        return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and no fallback available.\", e, fe));\n                    } else {\n                        logger.debug(\"HystrixCommand execution \" + failureType.name() + \" and fallback failed.\", fe);\n                        metrics.markFallbackFailure();\n                        // record the executionResult\n                        executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_FAILURE);\n\n                        /* executionHook for all errors */\n                        e = wrapWithOnErrorHook(failureType, e);\n\n                        return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback failed.\", e, fe));\n                    }\n                }\n\n            }).doOnTerminate(new Action0() {\n\n                @Override\n                public void call() {\n                    // record that we're completed (to handle non-successful events we do it here as well as at the end of executeCommand\n                    isExecutionComplete.set(true);\n                }\n\n            }).doOnEach(new Action1<Notification<? super R>>() {\n\n                @Override\n                public void call(Notification<? super R> n) {\n                    setRequestContextIfNeeded(currentRequestContext);\n                }\n\n            });\n        } else {\n            /* fallback is disabled so throw HystrixRuntimeException */\n            Exception e = originalException;\n\n            logger.debug(\"Fallback disabled for HystrixCommand so will throw HystrixRuntimeException. \", e); // debug only since we're throwing the exception and someone higher will do something with it\n            // record the executionResult\n            executionResult = executionResult.addEvents(eventType);\n\n            /* executionHook for all errors */\n            e = wrapWithOnErrorHook(failureType, e);\n            return Observable.<R> error(new HystrixRuntimeException(failureType, this.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback disabled.\", e, null)).doOnTerminate(new Action0() {\n\n                @Override\n                public void call() {\n                    // record that we're completed (to handle non-successful events we do it here as well as at the end of executeCommand\n                    isExecutionComplete.set(true);\n                }\n\n            }).doOnEach(new Action1<Notification<? super R>>() {\n\n                @Override\n                public void call(Notification<? super R> n) {\n                    setRequestContextIfNeeded(currentRequestContext);\n                }\n\n            });\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3489,
    "type": "Summary",
    "comment": "Starts grid with given configuration.",
    "code": "    private static IgniteNamedInstance start0(GridStartContext startCtx, boolean failIfStarted ) throws IgniteCheckedException {\n        assert startCtx != null;\n\n        String name = startCtx.config().getGridName();\n\n        if (name != null && name.isEmpty())\n            throw new IgniteCheckedException(\"Non default grid instances cannot have empty string name.\");\n\n        IgniteNamedInstance grid = new IgniteNamedInstance(name);\n\n        IgniteNamedInstance old;\n\n        if (name != null)\n            old = grids.putIfAbsent(name, grid);\n        else {\n            synchronized (dfltGridMux) {\n                old = dfltGrid;\n\n                if (old == null)\n                    dfltGrid = grid;\n            }\n        }\n\n        if (old != null)\n            if (failIfStarted) {\n                if (name == null)\n                    throw new IgniteCheckedException(\"Default Ignite instance has already been started.\");\n                else\n                    throw new IgniteCheckedException(\"Ignite instance with this name has already been started: \" + name);\n            }\n            else\n                return old;\n\n        if (startCtx.config().getWarmupClosure() != null)\n            startCtx.config().getWarmupClosure().apply(startCtx.config());\n\n        startCtx.single(grids.size() == 1);\n\n        boolean success = false;\n\n        try {\n            try {\n                grid.start(startCtx);\n            }\n            catch (IgniteInterruptedCheckedException e) {\n                if (grid.starterThreadInterrupted)\n                    Thread.interrupted();\n\n                throw e;\n            }\n\n            notifyStateChange(name, STARTED);\n\n            success = true;\n        }\n        finally {\n            if (!success) {\n                if (name != null)\n                    grids.remove(name, grid);\n                else {\n                    synchronized (dfltGridMux) {\n                        if (dfltGrid == grid)\n                            dfltGrid = null;\n                    }\n                }\n\n                grid = null;\n            }\n        }\n\n        if (grid == null)\n            throw new IgniteCheckedException(\"Failed to start grid with provided configuration.\");\n\n        return grid;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3490,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ORIGINAL_RELEASE_TIME;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3491,
    "type": "Summary",
    "comment": "Refresh gist",
    "code": "    public Gist refreshGist(String id) throws IOException {\n        return ServiceGenerator.createService(context, GistService.class).getGist(id).blockingGet();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3492,
    "type": "Summary",
    "comment": "Returns a managed InputStream for a managed target.",
    "code": "\tpublic InputStream getInputStream(String managedFile) throws IOException {\n\t\treturn getInputStream(managedFile, ReliableFile.OPEN_BEST_AVAILABLE);\n\t}\n\n",
    "label": 1,
    "rec": "Returns a managed InputStream for a managed file."
  },
  {
    "id": 3493,
    "type": "Summary",
    "comment": "Stratified sampling for classifiers",
    "code": "  public static Frame sampleFrameStratified(final Frame fr, Vec label, float[] sampling_ratios, long maxrows, final long seed, final boolean allowOversampling, final boolean verbose) {\n    if (fr == null) return null;\n    assert(label.isEnum());\n    assert(maxrows >= label.domain().length);\n\n    long[] dist = new ClassDist(label).doAll(label).dist();\n    assert(dist.length > 0);\n    Log.info(\"Doing stratified sampling for data set containing \" + fr.numRows() + \" rows from \" + dist.length + \" classes. Oversampling: \" + (allowOversampling ? \"on\" : \"off\"));\n    if (verbose) {\n      for (int i=0; i<dist.length;++i) {\n        Log.info(\"Class \" + label.domain(i) + \": count: \" + dist[i] + \" prior: \" + (float)dist[i]/fr.numRows());\n      }\n    }\n\n    // create sampling_ratios for class balance with max. maxrows rows (fill existing array if not null)\n    if (sampling_ratios == null || (Utils.minValue(sampling_ratios) == 0 && Utils.maxValue(sampling_ratios) == 0)) {\n      // compute sampling ratios to achieve class balance\n      if (sampling_ratios == null) {\n        sampling_ratios = new float[dist.length];\n      }\n      assert(sampling_ratios.length == dist.length);\n      for (int i=0; i<dist.length;++i) {\n        sampling_ratios[i] = ((float)fr.numRows() / label.domain().length) / dist[i]; // prior^-1 / num_classes\n      }\n      final float inv_scale = Utils.minValue(sampling_ratios); //majority class has lowest required oversampling factor to achieve balance\n      if (!Float.isNaN(inv_scale) && !Float.isInfinite(inv_scale))\n        Utils.div(sampling_ratios, inv_scale); //want sampling_ratio 1.0 for majority class (no downsampling)\n    }\n\n    if (!allowOversampling) {\n      for (int i=0; i<sampling_ratios.length; ++i) {\n        sampling_ratios[i] = Math.min(1.0f, sampling_ratios[i]);\n      }\n    }\n\n    // given these sampling ratios, and the original class distribution, this is the expected number of resulting rows\n    float numrows = 0;\n    for (int i=0; i<sampling_ratios.length; ++i) {\n      numrows += sampling_ratios[i] * dist[i];\n    }\n    final long actualnumrows = Math.min(maxrows, Math.round(numrows)); //cap #rows at maxrows\n    assert(actualnumrows >= 0); //can have no matching rows in case of sparse data where we had to fill in a makeZero() vector\n    Log.info(\"Stratified sampling to a total of \" + String.format(\"%,d\", actualnumrows) + \" rows.\");\n\n    if (actualnumrows != numrows) {\n      Utils.mult(sampling_ratios, (float)actualnumrows/numrows); //adjust the sampling_ratios by the global rescaling factor\n      if (verbose)\n        Log.info(\"Downsampling majority class by \" + (float)actualnumrows/numrows\n                + \" to limit number of rows to \" + String.format(\"%,d\", maxrows));\n    }\n    Log.info(\"Majority class (\" + label.domain()[Utils.minIndex(sampling_ratios)].toString()\n            + \") sampling ratio: \" + Utils.minValue(sampling_ratios));\n    Log.info(\"Minority class (\" + label.domain()[Utils.maxIndex(sampling_ratios)].toString()\n            + \") sampling ratio: \" + Utils.maxValue(sampling_ratios));\n\n    return sampleFrameStratified(fr, label, sampling_ratios, seed, verbose);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3494,
    "type": "Summary",
    "comment": "Get definition factory from appropriate servlet context.",
    "code": "    public static DefinitionsFactory getDefinitionsFactory() {\n        return tilesUtilImpl.getDefinitionsFactory();\n    }\n\n",
    "label": 1,
    "rec": "Get definition impl from appropriate servlet context."
  },
  {
    "id": 3495,
    "type": "Summary",
    "comment": "Gets event predicate that returns  true only if event was produced on one of given nodes (specified by ids).",
    "code": "    public static IgnitePredicate<Event> eventNodeId(@Nullable final UUID... nodeIds) {\n        return isEmpty(nodeIds) ? F.<Event>alwaysFalse() : new IgnitePredicate<Event>() {\n            // Don't set peer deploy aware as UUID is loaded by\n            // system class loader.\n\n            @Override public boolean apply(Event e) {\n                assert e != null;\n\n                return F.isAll(e.node().id(), in(nodeIds));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3496,
    "type": "Summary",
    "comment": "Synchronous call to retrieve the last calculated bucket without waiting for any emissions",
    "code": "    public Output getLatest() {\n        if (counterSubject.hasValue()) {\n            return counterSubject.getValue();\n        } else {\n            return getEmptyOutputValue();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3497,
    "type": "Summary",
    "comment": "Called by native libraries to put  offsetof() and  sizeof() values in  #memberOffsets.",
    "code": "    static Class putMemberOffset(String typeName, String member, int offset) throws ClassNotFoundException {\n        try {\n            Class<?> c = Class.forName(typeName.replace('/', '.'), false, Loader.class.getClassLoader());\n            if (member != null) {\n                putMemberOffset(c.asSubclass(Pointer.class), member, offset);\n            }\n            return c;\n        } catch (ClassNotFoundException e) {\n            logger.warn(\"Loader.putMemberOffset(): \" + e);\n            return null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3498,
    "type": "Summary",
    "comment": "Returns a SortedSet of RegisteredListener for the specified event type creating a new queue if needed",
    "code": "    private HandlerList getEventListeners(Class<? extends Event> type) {\n        try {\n            Method method = getRegistrationClass(type).getDeclaredMethod(\"getHandlerList\");\n            method.setAccessible(true);\n            return (HandlerList)method.invoke(null);\n        } catch (Exception e) {\n            throw new IllegalPluginAccessException(e.toString());\n        }\n    }\n\n",
    "label": 1,
    "rec": "Returns the specified event type's HandlerList"
  },
  {
    "id": 3499,
    "type": "Summary",
    "comment": "Creates a  Command out of the given commandAsString incorporating the  TypeParser.",
    "code": "    private Command createCommandFromString(Item item, String commandAsString) throws BindingConfigParseException {\n\n        if (WILDCARD_COMMAND_KEY.equals(commandAsString)) {\n            return WILDCARD_COMMAND_KEY;\n        } else {\n            Command command = TypeParser.parseCommand(item.getAcceptedCommandTypes(), commandAsString);\n\n            if (command == null) {\n                throw new BindingConfigParseException(\"couldn't create Command from '\" + commandAsString + \"' \");\n            }\n\n            return command;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3500,
    "type": "Summary",
    "comment": "Utility method to retrieve the session id from the given subject context Map which will be used to resolve to a  Session or  null if there is no session id in the map.",
    "code": "    protected Serializable getSessionId(SubjectContext subjectContext) {\n        return subjectContext.getSessionId();\n    }\n",
    "label": 1,
    "rec": "Utility method to retrieve the session id from the given subject context which will be used to resolve to a  Session, or  null if there is no session id available."
  },
  {
    "id": 3501,
    "type": "Summary",
    "comment": "Decodes the given H2O key to the S3 bucket and key name.",
    "code": "  public static String[] decodeKey(Key k) {\n    return decodeKeyImpl(k);\n//    assert checkBijection(k, res[0], res[1]);\n//    return res;\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3502,
    "type": "Summary",
    "comment": "Attempts to persist an int to the  android.content.SharedPreferences.",
    "code": "    protected boolean persistInt(int value) {\n        if (!shouldPersist()) {\n            return false;\n        }\n\n        if (value == getPersistedInt(~value)) {\n            // It's already there, so the same as persisting\n            return true;\n        }\n\n        PreferenceDataStore dataStore = getPreferenceDataStore();\n        if (dataStore != null) {\n            dataStore.putInt(mKey, value);\n        } else {\n            SharedPreferences.Editor editor = mPreferenceManager.getEditor();\n            editor.putInt(mKey, value);\n            tryCommit(editor);\n        }\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Attempts to persist an  Integer if this Preference is persistent."
  },
  {
    "id": 3503,
    "type": "Summary",
    "comment": "Returns the current thread-bound  ServletRequest or  null if there is not one bound.",
    "code": "    public static ServletRequest getServletRequest() {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            Subject subject = ThreadContext.getSubject();\n            if (subject instanceof WebSubject) {\n                WebSubject webSubject = (WebSubject) subject;\n                request = webSubject.getServletRequest();\n            }\n        }\n        return request;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3504,
    "type": "Summary",
    "comment": "Returns the VM (static) singleton SecurityManager.",
    "code": "    public static SecurityManager getSecurityManager() throws IllegalStateException {\n        SecurityManager securityManager = ThreadContext.getSecurityManager();\n        if (securityManager == null) {\n            securityManager = SecurityUtils.securityManager;\n        }\n        if (securityManager == null) {\n            String msg = \"No SecurityManager accessible to the calling code, either bound to the \" +\n                    ThreadContext.class.getName() + \" or as a vm static singleton.  This is an invalid application \" +\n                    \"configuration.\";\n            throw new IllegalStateException(msg);\n        }\n        return securityManager;\n    }\n\n",
    "label": 1,
    "rec": "Returns the SecurityManager accessible to the calling code."
  },
  {
    "id": 3505,
    "type": "Summary",
    "comment": "int argument less than the given value.",
    "code": "    public static int lt(int value) {\n        return reportMatcher(new LessThan<Integer>(value)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3506,
    "type": "Summary",
    "comment": "get deadline in producteev format",
    "code": "    private String createDeadline(Task task) {\n        if(!task.hasDueDate())\n            return null;\n        String time = ApiUtilities.unixTimeToProducteev(task.getValue(Task.DUE_DATE));\n        return time.substring(0, time.lastIndexOf(' '));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3507,
    "type": "Summary",
    "comment": "Returns the item from the backing  com.raizlabs.android.dbflow.list.FlowCursorList.",
    "code": "    @Override\n    public TModel get(int row) {\n        return internalCursorList.getItem(row);\n    }\n\n",
    "label": 1,
    "rec": "Returns the item from the backing  FlowCursorList."
  },
  {
    "id": 3508,
    "type": "Summary",
    "comment": "Returns true if any of the columns in the table are JDBC Dates (as opposed to timestamps).",
    "code": "    public boolean hasJDBCDateColumns() {\n        return Stream.of(primaryKeyColumns.stream(), baseColumns.stream())\n                .flatMap(Function.identity())\n                .anyMatch(IntrospectedColumn::isJDBCDateColumn);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3509,
    "type": "Summary",
    "comment": "Returns a list of all configuration objects.",
    "code": "    public Collection<AbstractCacheServiceConfiguration<K, V>> getAllConfigurations() {\r\n        return (Collection) new ArrayList<AbstractCacheServiceConfiguration>(list);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns a collection of all service configuration objects."
  },
  {
    "id": 3510,
    "type": "Summary",
    "comment": "Starts grid with given communication spi set in configuration.",
    "code": "    private Ignite startGridWithSpi(int idx, GridCommunicationSpi commSpi) throws Exception {\n        this.commSpi = commSpi;\n\n        try {\n            return startGrid(idx);\n        }\n        finally {\n            this.commSpi = null;\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3511,
    "type": "Summary",
    "comment": "Creates and returns the call service for the specified call-service descriptor.",
    "code": "    CallServiceWrapper getCallService(CallServiceDescriptor descriptor) {\n        // Create the new call-service wrapper and update {@link #mCallServices}.\n        registerCallService(descriptor);\n\n        return mCallServices.get(descriptor.getServiceComponent());\n    }\n\n",
    "label": 1,
    "rec": "Creates the requested call service or pulls the previously-created entry from memory."
  },
  {
    "id": 3512,
    "type": "Summary",
    "comment": "Gets hadoop configuration.",
    "code": "    public HadoopConfiguration getHadoopConfiguration() {\n        return hadoopCfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3513,
    "type": "Summary",
    "comment": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  LdapDirectoryInfo instance containing the results.",
    "code": "    protected LdapSecurityInfo performAuthentication(String username, char[] password) throws NamingException {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = initializeLdapContext(username, password);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using URL [\" + url + \"] for user [\" + username + \"].\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return queryForLdapDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            LdapUtils.closeContext(ctx);\n        }\n    }\n",
    "label": 1,
    "rec": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  LdapSecurityInfo instance containing the results."
  },
  {
    "id": 3514,
    "type": "Summary",
    "comment": "Factory method to provide  ThreadPoolExecutor instances as desired.",
    "code": "    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixProperty<Integer> corePoolSize, HystrixProperty<Integer> maximumPoolSize, HystrixProperty<Integer> keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n        return new ThreadPoolExecutor(corePoolSize.get(), maximumPoolSize.get(), keepAliveTime.get(), unit, workQueue, new ThreadFactory() {\n\n            protected final AtomicInteger threadNumber = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = new Thread(r, \"hystrix-\" + threadPoolKey.name() + \"-\" + threadNumber.incrementAndGet());\n                thread.setDaemon(true);\n                return thread; \n            }\n        });\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3515,
    "type": "Summary",
    "comment": "performs back-door proxy get to  VoldemortMetadata#getDonorNode()",
    "code": "    protected List<Versioned<byte[]>> proxyGet(ByteArray key) throws VoldemortException {\n        if(metadata.getRebalancingProxyDest() != null) {\n            return adminClient.redirectGet(metadata.getRebalancingProxyDest().getId(),\n                                           getName(),\n                                           key);\n        }\n\n        throw new VoldemortException(\"DonorNode not set for proxyGet() \");\n    }\n",
    "label": 1,
    "rec": "performs back-door proxy get to  MetadataStore#getDonorNode()"
  },
  {
    "id": 3516,
    "type": "Summary",
    "comment": "Asynchronously commits transaction after all previous asynchronous operations are completed.",
    "code": "    public IgniteInternalFuture<IgniteTx> commitTxAsync(final IgniteTxEx tx) {\n        FutureHolder holder = lastFut.get();\n\n        holder.lock();\n\n        try {\n            IgniteInternalFuture fut = holder.future();\n\n            if (fut != null && !fut.isDone()) {\n                IgniteInternalFuture<IgniteTx> f = new GridEmbeddedFuture<>(fut,\n                    new C2<Object, Exception, IgniteInternalFuture<IgniteTx>>() {\n                        @Override public IgniteInternalFuture<IgniteTx> apply(Object o, Exception e) {\n                            return tx.commitAsync();\n                        }\n                    }, ctx.kernalContext());\n\n                saveFuture(holder, f);\n\n                return f;\n            }\n\n            IgniteInternalFuture<IgniteTx> f = tx.commitAsync();\n\n            saveFuture(holder, f);\n\n            ctx.tm().txContextReset();\n\n            return f;\n        }\n        finally {\n            holder.unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3517,
    "type": "Summary",
    "comment": "overrides Class methods and implements all abstract methods.",
    "code": "    public static Factory enhance(Class cls, MethodInterceptor ih) {\n        return (Factory)enhanceHelper(cls.isInterface() ? null : cls,\n                                      cls.isInterface() ? new Class[]{ cls } : null,\n                                      ih, cls.getClassLoader(), null, null );\n    }\n\n",
    "label": 1,
    "rec": "Overrides non-abstract methods and implements all abstract methods."
  },
  {
    "id": 3518,
    "type": "Summary",
    "comment": "Check whether the AES key can decrypt the first encrypted key in the wallet.",
    "code": "    public boolean checkAESKey(KeyParameter aesKey) {\n        lock.lock();\n        try {\n            return keychain.checkAESKey(aesKey);\n        } finally {\n            lock.unlock();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3519,
    "type": "Summary",
    "comment": "Attempt to extract a job key from the given query if it is scoped to a single job.",
    "code": "  public static Optional<Set<IJobKey>> from(Query.Builder query) {\n    if (Query.isJobScoped(query)) {\n      TaskQuery taskQuery = query.get();\n      ImmutableSet.Builder<IJobKey> builder = ImmutableSet.builder();\n\n      if (taskQuery.isSetJobName()) {\n        builder.add(from(\n            taskQuery.getOwner().getRole(),\n            taskQuery.getEnvironment(),\n            taskQuery.getJobName()));\n      }\n\n      if (taskQuery.isSetJobKeys()) {\n        builder.addAll(IJobKey.setFromBuilders(taskQuery.getJobKeys()));\n      }\n      return Optional.of(assertValid(builder.build()));\n    } else {\n      return Optional.absent();\n    }\n  }\n\n",
    "label": 1,
    "rec": "Attempt to extract job keys from the given query if it is job scoped."
  },
  {
    "id": 3520,
    "type": "Summary",
    "comment": "Should return Ignite installation home folder.",
    "code": "    public String getIgniteHome() {\n        return igniteHome;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3521,
    "type": "Summary",
    "comment": "Get selected milestone from results bundle",
    "code": "    public static Milestone getSelected(Bundle arguments) {\n        return (Milestone) arguments.getParcelable(ARG_SELECTED);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3522,
    "type": "Summary",
    "comment": "Get the  voldemort.store.socket.SocketStore to redirect to for the donor, creating one if needed.",
    "code": "    private Node getNodeIfPresent(int proxyNodeId) {\n        try {\n            return metadata.getCluster().getNodeById(proxyNodeId);\n        } catch(Exception e) {\n            throw new VoldemortException(\"Failed to get proxyNode \" + proxyNodeId\n                                         + \" from current cluster \" + metadata.getCluster()\n                                         + \" at node \" + metadata.getNodeId(), e);\n        }\n    }\n",
    "label": 1,
    "rec": "Get the  voldemort.store.socket.SocketStore to redirect to for the proxy node, creating one if needed."
  },
  {
    "id": 3523,
    "type": "Summary",
    "comment": "Gets a SerialMessage with the SENSOR_BINARY_GET command",
    "code": "\tpublic SerialMessage getValueMessage() {\n\t\tif(isGetSupported == false) {\n\t\t\tlogger.debug(\"NODE {}: Node doesn't support get requests\", this.getNode().getNodeId());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlogger.debug(\"NODE {}: Creating new message for application command SENSOR_BINARY_GET\", this.getNode().getNodeId());\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Get);\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \n    \t\t\t\t\t\t\t2, \n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \n\t\t\t\t\t\t\t\t(byte) SENSOR_BINARY_GET };\n    \t\n    \t// Should there be another byte here to specify the sensor type?\n    \t// Looking at the RaZberry doc, it talks about requesting the sensor type\n    \t// and using FF for the first sensor.\n    \t// Maybe this is a V2 feature - need to find some docs on V2!\n    \t\n    \t\n    \tresult.setMessagePayload(newPayload);\n    \treturn result;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3524,
    "type": "Summary",
    "comment": "Toggles the facing value between  CameraKit.Constants#FACING_BACK and  CameraKit.Constants#FACING_FRONT.",
    "code": "    public int toggleFacing() {\n        int facing = mCameraController.getFacing();\n        switch (facing) {\n            case FACING_BACK:\n                setFacing(FACING_FRONT);\n                break;\n\n            case FACING_FRONT:\n                setFacing(FACING_BACK);\n                break;\n        }\n\n        return mCameraController.getFacing();\n    }\n",
    "label": 1,
    "rec": "Toggles the facing value between  CameraConstants#FACING_BACK and  CameraConstants#FACING_FRONT."
  },
  {
    "id": 3525,
    "type": "Summary",
    "comment": "int argument less than the given value.",
    "code": "    public static int lt(int value) {\n        reportMatcher(new LessThan<Integer>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3526,
    "type": "Summary",
    "comment": "Returns the identifiers of the properties of a given entity class.",
    "code": "    public static Set<String> getPropertyNames(Class<? extends EntityBase> entityClass) {\n        return getProperties(entityClass).keySet();\n    }\n\n",
    "label": 1,
    "rec": "Returns the names of the properties of a given entity class."
  },
  {
    "id": 3527,
    "type": "Summary",
    "comment": "Get representation of the client template",
    "code": "    public ClientTemplateRepresentation getClient() {\n        auth.requireView();\n        return ModelToRepresentation.toRepresentation(template);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3528,
    "type": "Summary",
    "comment": "Getter for property 'hiValue'.",
    "code": "\t\tpublic IntegralDataTypeHolder getHiValue() {\r\n\t\t\treturn upperLimit;\r\n\t\t}\r\n\n",
    "label": 1,
    "rec": "Getter for property 'upperLimit'."
  },
  {
    "id": 3529,
    "type": "Summary",
    "comment": "Method returns callable for execution all update operations in async and sync mode.",
    "code": "    private Callable<Long> internalUpdate(final long l, final boolean updated) {\n        return new Callable<Long>() {\n            @Override public Long call() throws Exception {\n                IgniteInternalTx tx = CU.txStartInternal(ctx, seqView, PESSIMISTIC, REPEATABLE_READ);\n\n                try {\n                    GridCacheAtomicSequenceValue seq = seqView.get(key);\n\n                    checkRemoved();\n\n                    assert seq != null;\n\n                    long curLocVal;\n\n                    long newUpBound;\n\n                    lock.lock();\n\n                    try {\n                        curLocVal = locVal;\n\n                        // If local range was already reserved in another thread.\n                        if (locVal + l <= upBound) {\n                            long retVal = locVal;\n\n                            locVal += l;\n\n                            return updated ? locVal : retVal;\n                        }\n\n                        long curGlobalVal = seq.get();\n\n                        long newLocVal;\n\n                        /* We should use offset because we already reserved left side of range.*/\n                        long off = batchSize > 1 ? batchSize - 1 : 1;\n\n                        // Calculate new values for local counter, global counter and upper bound.\n                        if (curLocVal + l >= curGlobalVal) {\n                            newLocVal = curLocVal + l;\n\n                            newUpBound = newLocVal + off;\n                        }\n                        else {\n                            newLocVal = curGlobalVal;\n\n                            newUpBound = newLocVal + off;\n                        }\n\n                        locVal = newLocVal;\n                        upBound = newUpBound;\n\n                        if (updated)\n                            curLocVal = newLocVal;\n                    }\n                    finally {\n                        lock.unlock();\n                    }\n\n                    // Global counter must be more than reserved upper bound.\n                    seq.set(newUpBound + 1);\n\n                    seqView.put(key, seq);\n\n                    tx.commit();\n\n                    return curLocVal;\n                }\n                catch (Error | Exception e) {\n                    U.error(log, \"Failed to get and add: \" + this, e);\n\n                    throw e;\n                } finally {\n                    tx.close();\n                }\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3530,
    "type": "Summary",
    "comment": "Delete directory recursively.",
    "code": "    private boolean deleteRecursive(File f, boolean deleteIfExists) {\n        BasicFileAttributes attrs;\n\n        try {\n            attrs = Files.readAttributes(f.toPath(), BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n        }\n        catch (IOException ignore) {\n            return deleteIfExists && !f.exists();\n        }\n\n        if (!attrs.isDirectory() || attrs.isSymbolicLink())\n            return f.delete() || (deleteIfExists && !f.exists());\n\n        File[] entries = f.listFiles();\n\n        if (entries != null) {\n            for (File entry : entries) {\n                boolean res = deleteRecursive(entry, true);\n\n                if (!res)\n                    return false;\n            }\n        }\n\n        return f.delete() || (deleteIfExists && !f.exists());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3531,
    "type": "Summary",
    "comment": "The LifecycleProvider for the whole application process.",
    "code": "    public static LifecycleOwner get() {\n        return sInstance;\n    }\n\n",
    "label": 1,
    "rec": "The LifecycleOwner for the whole application process."
  },
  {
    "id": 3532,
    "type": "Summary",
    "comment": "Checks if specified field requires recursive inspection to find resource annotations.",
    "code": "    static boolean mayRequireResources(Field f) {\n        assert f != null;\n\n        // Need to inspect anonymous classes, callable and runnable instances.\n        return f.getName().startsWith(\"this$\") || f.getName().startsWith(\"val$\") ||\n            Callable.class.isAssignableFrom(f.getType()) || Runnable.class.isAssignableFrom(f.getType());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3533,
    "type": "Summary",
    "comment": "Calculates the total size of a directory and all of its contents (recursively)",
    "code": "  public static long getDirectorySize(Path path, FileSystem fs) throws IOException {\n    ContentSummary cs = fs.getContentSummary(path);\n    return cs.getLength();\n  }\n\n",
    "label": 1,
    "rec": "Calculates the total size of all the contents of a directory, including the contents of all of its subdirectories."
  },
  {
    "id": 3534,
    "type": "Summary",
    "comment": "Gets collection of node for given node IDs and predicates.",
    "code": "    public Collection<ClusterNode> nodes(@Nullable Collection<UUID> ids, GridPredicate<UUID>... p) {\n        return F.isEmpty(ids) ? Collections.<ClusterNode>emptyList() :\n            F.view(\n                F.viewReadOnly(ids, U.id2Node(ctx), p),\n                F.notNull());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3535,
    "type": "Summary",
    "comment": "It does nothing.",
    "code": "  @NotNull\n  @Override\n  public ExitCode build(CompileContext context,\n                        ModuleChunk chunk,\n                        DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                        OutputConsumer outputConsumer) throws ProjectBuildException {\n    JpsAndroidGradleModuleExtension extension = AndroidGradleJps.getFirstExtension(chunk);\n    if (extension == null) {\n      String format = \"Project '%1$s' does not have the '%2$s' facet. Nothing done.\";\n      LOG.info(String.format(format, getProjectName(context), AndroidGradleFacet.NAME));\n      return ExitCode.NOTHING_DONE;\n    }\n\n    String[] buildTasks = getBuildTasks(context, chunk);\n    if (buildTasks.length == 0) {\n      String format = \"No build tasks found for project '%1$s'. Nothing done.\";\n      LOG.info(String.format(format, getProjectName(context)));\n      return ExitCode.NOTHING_DONE;\n    }\n\n    String msg = \"Gradle build using tasks: \" + Arrays.toString(buildTasks);\n    context.processMessage(new ProgressMessage(msg));\n    LOG.info(msg);\n\n    ensureTempDirExists();\n\n    BuilderExecutionSettings executionSettings;\n    try {\n      executionSettings = new BuilderExecutionSettings();\n    } catch (RuntimeException e) {\n      throw new ProjectBuildException(e);\n    }\n\n    LOG.info(\"Using execution settings: \" + executionSettings);\n\n    String androidHome = null;\n    if (!isAndroidHomeKnown(executionSettings)) {\n      androidHome = getAndroidHomeFromModuleSdk(context, chunk);\n    }\n\n    String format = \"About to build project '%1$s' located at %2$s\";\n    LOG.info(String.format(format, getProjectName(context), executionSettings.getProjectDir().getAbsolutePath()));\n\n    return doBuild(context, buildTasks, executionSettings, androidHome);\n  }\n\n",
    "label": 1,
    "rec": "Builds a project using Gradle."
  },
  {
    "id": 3536,
    "type": "Summary",
    "comment": "Return all the members (elements) of the set value stored at key.",
    "code": "  public Set<byte[]> smembers(final byte[] key) {\n    checkIsInMulti();\n    client.smembers(key);\n    return SetFromList.of(client.getBinaryMultiBulkReply());\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3537,
    "type": "Summary",
    "comment": "Renames this file to the name represented by the  dest file.",
    "code": "    public boolean renameTo(File newPath) {\n        if (path.isEmpty() || newPath.path.isEmpty()) {\n            return false;\n        }\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkWrite(path);\n            security.checkWrite(newPath.path);\n        }\n        return renameToImpl(pathBytes, newPath.pathBytes);\n    }\n\n",
    "label": 1,
    "rec": "Renames this file to  newPath."
  },
  {
    "id": 3538,
    "type": "Summary",
    "comment": "Get organizations ",
    "code": "    public List<User> getOrgs() throws IOException {\n        SQLiteOpenHelper helper = new CacheHelper(context);\n        try {\n            List<User> userAndOrgs = loadUserAndOrgsFromDB(helper);\n\n            return userAndOrgs == null ? requestAndStoreUserAndOrgs(helper) : userAndOrgs;\n        } finally {\n            helper.close();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3539,
    "type": "Summary",
    "comment": "Returns an iterator of nonzero entries.",
    "code": "    public Iterator<Entry> iterator() {\n        return new Iterator<Entry>() {\n            int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < size();\n            }\n\n            @Override\n            public Entry next() {\n                return new Entry(i++);\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3540,
    "type": "Summary",
    "comment": "Returns access token response as a string from a refresh token invocation on the remote OIDC broker",
    "code": "    public String refreshTokenForLogout(KeycloakSession session, UserSessionModel userSession) {\n        String refreshToken = userSession.getNote(FEDERATED_REFRESH_TOKEN);\n        try (VaultStringSecret vaultStringSecret = session.vault().getStringSecret(getConfig().getClientSecret())) {\n            return SimpleHttp.doPost(getConfig().getTokenUrl(), session)\n                    .param(\"refresh_token\", refreshToken)\n                    .param(OAUTH2_PARAMETER_GRANT_TYPE, OAUTH2_GRANT_TYPE_REFRESH_TOKEN)\n                    .param(OAUTH2_PARAMETER_CLIENT_ID, getConfig().getClientId())\n                    .param(OAUTH2_PARAMETER_CLIENT_SECRET, vaultStringSecret.get().orElse(getConfig().getClientSecret())).asString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3541,
    "type": "Summary",
    "comment": "Overrides non-abstract methods and implements all abstract methods.",
    "code": "    public static Factory enhance(Class cls, Callback callback) {\n        return (Factory)enhanceHelper(cls.isInterface() ? null : cls,\n                                      cls.isInterface() ? new Class[]{ cls } : null,\n                                      callback, cls.getClassLoader(), null );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3542,
    "type": "Summary",
    "comment": "Gets the Java options with 'nuxeo.' properties substituted.",
    "code": "    protected List<String> getJavaOptsProperty(Function<String, String> mapper) {\n        return configurationGenerator.getJavaOpts(mapper);\n    }\n\n",
    "label": 1,
    "rec": "Gets the Java options defined in Nuxeo configuration files, e.g."
  },
  {
    "id": 3543,
    "type": "Summary",
    "comment": "Create node with specified node id and replica count.",
    "code": "    private ClusterNode createNode(String nodeId, int replicaCnt) {\n        GridTestNode node = new GridTestNode(UUID.fromString(nodeId));\n\n        node.setAttribute(DFLT_REPLICA_COUNT_ATTR_NAME, replicaCnt);\n\n        return node;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3544,
    "type": "Summary",
    "comment": "Reads  GridUuid from input stream.",
    "code": "    @Nullable public static IgniteUuid readGridUuid(DataInput in) throws IOException {\n        // If UUID is not null.\n        if (!in.readBoolean()) {\n            long most = in.readLong();\n            long least = in.readLong();\n\n            UUID globalId = GridUuidCache.onGridUuidRead(new UUID(most, least));\n\n            long locId = in.readLong();\n\n            return new IgniteUuid(globalId, locId);\n        }\n\n        return null;\n    }\n",
    "label": 1,
    "rec": "Reads  org.gridgain.grid.IgniteUuid from input stream."
  },
  {
    "id": 3545,
    "type": "Summary",
    "comment": "Returns a  Subject instance that reflects the specified identity (principals), backed by the given  Session instance.",
    "code": "    protected Subject createSubject(PrincipalCollection principals, Session session) {\n        Map<String, Object> context = new HashMap<String, Object>(2);\n        if (principals != null && !principals.isEmpty()) {\n            context.put(SubjectFactory.PRINCIPALS, principals);\n        }\n        if (session != null) {\n            context.put(SubjectFactory.SESSION, session);\n        }\n        return createSubject(context);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3546,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ENCODING_TIME;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3547,
    "type": "Summary",
    "comment": "Parse an incoming request message.",
    "code": "  public ReqT parseRequest(InputStream input) {\n    return requestMarshaller.parse(input);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3548,
    "type": "Summary",
    "comment": "Check whether a given local variable is known to be unable to gain a definite non null or definite null status by the use of an enclosing flow info.",
    "code": "public boolean cannotBeDefinitelyNullOrNonNull(VariableBinding binding) {\n\treturn isPotentiallyUnknown(binding) ||\n\t\tisPotentiallyNonNull(binding) && isPotentiallyNull(binding);\n}\n\n",
    "label": 1,
    "rec": "Check whether a given field or local variable is known to be unable to gain a definite non null or definite null status by the use of an enclosing flow info."
  },
  {
    "id": 3549,
    "type": "Summary",
    "comment": "Return a view to publish all keys in JWK format.",
    "code": "\tpublic ModelAndView publishClientJwk() {\n\t\t\n\t\t// map from key id to key\n\t\tMap<String, PublicKey> keys = signingAndValidationService.getAllPublicKeys();\n\n\t\t// TODO: check if keys are empty, return a 404 here or just an empty list?\n\t\t\n\t\treturn new ModelAndView(jwkViewName, \"keys\", keys);\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3550,
    "type": "Summary",
    "comment": "Returns an annotation processor for a set of annotation types.",
    "code": "    public AnnotationProcessor getProcessorFor(Set<AnnotationTypeDeclaration> atds, AnnotationProcessorEnvironment env) {\r\n        return new JdbcControlAnnotationProcessor(env);\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns an JdbcControlAnnotationProcessor"
  },
  {
    "id": 3551,
    "type": "Summary",
    "comment": "Get binary field for the property.",
    "code": "        private BinaryField binaryField(BinaryObject obj) {\n            if (skipFieldLookup)\n                return null;\n\n            BinaryField field0 = field;\n\n            if (field0 == null && !fieldTaken) {\n                BinaryType type = obj instanceof BinaryObjectEx ? ((BinaryObjectEx)obj).rawType() : obj.type();\n\n                if (type != null) {\n                    field0 = type.field(propName);\n\n                    assert field0 != null;\n\n                    field = field0;\n                }\n\n                fieldTaken = true;\n            }\n\n            return field0;\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3552,
    "type": "Summary",
    "comment": "Gets the address of a direct buffer.",
    "code": "\tpublic static long getDirectBufferAddress(Buffer buf) {\n\t\tif (!(buf instanceof DirectBuffer)) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn ((DirectBuffer) buf).getEffectiveAddress().toLong();\n\t}\n\n",
    "label": 1,
    "rec": "Gets the start address of a direct buffer."
  },
  {
    "id": 3553,
    "type": "Summary",
    "comment": "Creates the version object based on the dimension of the original bit matrix from the datamatrix code. See ISO 16022:2006 Table 7 - ECC 200 symbol attributes",
    "code": "  private static Version readVersion(BitMatrix bitMatrix) throws FormatException {\n    int numRows = bitMatrix.getHeight();\n    int numColumns = bitMatrix.getWidth();\n    return Version.getVersionForDimensions(numRows, numColumns);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3554,
    "type": "Summary",
    "comment": "Returns the pointcut.",
    "code": "    public Expression getExpression() {\n        return m_expression;\n    }\n\n",
    "label": 1,
    "rec": "Returns the expression."
  },
  {
    "id": 3555,
    "type": "Summary",
    "comment": "Gets cache with \"skip-store\" flag set.",
    "code": "    public PlatformCache withSkipStore() {\n        if (cache.delegate().skipStore())\n            return this;\n\n        return copy(rawCache.withSkipStore(), keepBinary);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3556,
    "type": "Summary",
    "comment": "Uses reflection to get all  ObservableProperty instances in an Object instance.",
    "code": "  @NotNull\n  public static List<AbstractProperty<?>> getAll(Object object) {\n    ArrayList<AbstractProperty<?>> properties = new ArrayList<AbstractProperty<?>>();\n    for (Field field : object.getClass().getDeclaredFields()) {\n      if (AbstractProperty.class.isAssignableFrom(field.getType())) {\n        try {\n          // We change the access level of this field to avoid getting an IllegalAccessException\n          boolean isFieldPrivate = !field.isAccessible();\n          field.setAccessible(true);\n          properties.add((AbstractProperty)field.get(object));\n          if (isFieldPrivate) {\n            field.setAccessible(false);\n          }\n        }\n        catch (IllegalAccessException ignored) {\n        }\n      }\n    }\n    return properties;\n  }\n\n",
    "label": 1,
    "rec": "Uses reflection to get all  AbstractProperty instances in an Object instance."
  },
  {
    "id": 3557,
    "type": "Summary",
    "comment": "Obtain the code parameter from the url after being redirected back from the auth-server.",
    "code": "    public AccessTokenResponse getBearerToken(HttpServletRequest request) throws IOException, TokenGrantRequest.HttpFailure {\n        String error = request.getParameter(\"error\");\n        if (error != null) throw new IOException(\"OAuth error: \" + error);\n        String redirectUri = request.getRequestURL().append(\"?\").append(request.getQueryString()).toString();\n        String stateCookie = getCookieValue(stateCookieName, request);\n        if (stateCookie == null) throw new IOException(\"state cookie not set\");\n        // we can call get parameter as this should be a redirect\n        String state = request.getParameter(\"state\");\n        String code = request.getParameter(\"code\");\n\n        if (state == null) throw new IOException(\"state parameter was null\");\n        if (!state.equals(stateCookie)) {\n            throw new IOException(\"state parameter invalid\");\n        }\n        if (code == null) throw new IOException(\"code parameter was null\");\n        return resolveBearerToken(redirectUri, code);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3558,
    "type": "Summary",
    "comment": "URL-encode the given input String with the given encoding scheme.",
    "code": "    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n        return URLEncoder.encode(input, encodingScheme);\n    }\n",
    "label": 1,
    "rec": "URL-encode the given input String with the given encoding scheme, using  URLEncoder#encode(String, String) URLEncoder.encode(input, enc)."
  },
  {
    "id": 3559,
    "type": "Summary",
    "comment": "Registers the given  keyManager for the key type  keyManager.getKeyType().",
    "code": "  public static boolean registerKeyManager(final KeyManager<Aead> keyManager)\n      throws GeneralSecurityException {\n    return Registry.registerKeyManager(keyManager.getKeyType(), keyManager);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3560,
    "type": "Summary",
    "comment": "Creates a  SecureRemoteInvocation based on the current session or session",
    "code": "    public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {\n        String sessionId = System.getProperty(SESSION_ID_SYSTEM_PROPERTY_NAME);\n        if( sessionId == null ) {\n            throw new IllegalStateException( \"System property [\" + SESSION_ID_SYSTEM_PROPERTY_NAME + \"] is not set.  \" +\n                    \"This property must be set to the JSecurity session ID for remote calls to function.\" );\n        }\n        RemoteInvocation ri = new RemoteInvocation(methodInvocation);\n        ri.addAttribute( SESSION_ID_KEY, sessionId );\n\n        return ri;\n    }\n",
    "label": 1,
    "rec": "Creates a  RemoteInvocation with the current session ID as an  RemoteInvocation#getAttribute(String) attribute."
  },
  {
    "id": 3561,
    "type": "Summary",
    "comment": "Executes the request and returns PluginResult.",
    "code": "    public PluginResult execute(String action, JSONArray args, String callbackId) {\n        this.callback = callbackId;\n\n        if (action.equals(\"encode\")) {\n            JSONObject obj = args.optJSONObject(0);\n            if (obj != null) {\n                String type = obj.optString(\"type\");\n                String data = obj.optString(\"data\");\n                \n                // If the type is null then force the type to text\n                if (type == null) {\n                    type = TEXT_TYPE;\n                }\n                \n                if (data == null) {\n                    return new PluginResult(PluginResult.Status.ERROR, \"User did not specify data to encode\");                                            \n                }\n                \n                encode(type, data);                    \n            } else {\n                return new PluginResult(PluginResult.Status.ERROR, \"User did not specify data to encode\");                    \n            }\n        }\n        else if (action.equals(\"scan\")) {\n            scan();\n        } else {\n            return new PluginResult(PluginResult.Status.INVALID_ACTION);\n        }\n        PluginResult r = new PluginResult(PluginResult.Status.NO_RESULT);\n        r.setKeepCallback(true);\n        return r;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3562,
    "type": "Summary",
    "comment": "Fetches the Class representing the type of ActionBean that has been bound to the URL supplied.",
    "code": "    public Class<? extends ActionBean> getActionBeanType(String path) {\n        return this.formBeans.get(getUrlBindingFromPath(path));\n    }\n\n",
    "label": 1,
    "rec": "Fetches the Class representing the type of ActionBean that would respond were a request made with the path specified."
  },
  {
    "id": 3563,
    "type": "Summary",
    "comment": "Compute the network output error.",
    "code": "    protected double computeOutputError(double[] target, double weight) {\n        Layer outputLayer = outputLayer();\n\n        int units = outputLayer.getOutputUnits();\n        if (target.length != units) {\n            throw new IllegalArgumentException(String.format(\"Invalid target vector size: %d, expected: %d\", target.length, units));\n        }\n\n        ActivationFunction activation = outputLayer.getActivation();\n        double[] output = outputLayer.getOutput();\n        double[] error = outputLayer.getError();\n        double err = 0.0;\n        for (int i = 0; i < units; i++) {\n            double o = output[i];\n            double t = target[i];\n            double g = t - o;\n\n            switch (obj) {\n                case LEAST_MEAN_SQUARES:\n                    err += 0.5 * g * g;\n                    if (activation == ActivationFunction.LOGISTIC_SIGMOID) {\n                        g *= o * (1.0 - o);\n                    }\n                    break;\n\n                case CROSS_ENTROPY:\n                    switch (activation) {\n                        case SOFTMAX:\n                            err -= t * log(o);\n                            break;\n\n                        case LOGISTIC_SIGMOID:\n                            // We have only one output neuron in this case.\n                            err = -t * log(o) - (1.0 - t) * log(1.0 - o);\n                            g *= o * (1.0 - o);\n                            break;\n\n                        default:\n                            throw new IllegalArgumentException(String.format(\"Unsupported activation function %s for objective function %s\", outputLayer.getActivation(), obj));\n                    }\n            }\n\n            error[i] = weight * g;\n        }\n\n        return weight * err;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3564,
    "type": "Summary",
    "comment": "Sets the port number for this proxy.",
    "code": "    public Proxy setPort( int port )\n    {\n        return new Proxy( type, host, port, auth );\n    }\n\n",
    "label": 1,
    "rec": "Sets the port number for the proxy."
  },
  {
    "id": 3565,
    "type": "Summary",
    "comment": "Helper function to encapsulate the logic to invoke between old and new load manager",
    "code": "    private Optional<String> getLeastLoadedFromLoadManager(ServiceUnitId serviceUnit) throws Exception {\n        Optional<ResourceUnit> leastLoadedBroker = loadManager.get().getLeastLoaded(serviceUnit);\n        if (!leastLoadedBroker.isPresent()) {\n            LOG.warn(\"No broker is available for {}\", serviceUnit);\n            return Optional.empty();\n        }\n\n        String lookupAddress = leastLoadedBroker.get().getResourceId();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"{} : redirecting to the least loaded broker, lookup address={}\", pulsar.getWebServiceAddress(),\n                    lookupAddress);\n        }\n        return Optional.of(lookupAddress);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3566,
    "type": "Summary",
    "comment": "Inspects a given  Throwable as well as its nested causes, in order to look for a specific exception class.",
    "code": "    public static boolean recursiveClassEquals(Throwable throwableToInspect, Class... throwableClassesToLookFor) {\n        for (Class clazz: throwableClassesToLookFor) {\n            Class classToInspect = throwableToInspect.getClass();\n            while (classToInspect != null) {\n                if (classToInspect.equals(clazz)) {\n                    return true;\n                }\n                classToInspect = classToInspect.getSuperclass();\n            }\n        }\n        Throwable cause = throwableToInspect.getCause();\n        return cause != null && recursiveClassEquals(cause, throwableClassesToLookFor);\n    }\n\n",
    "label": 1,
    "rec": "Inspects a given  Throwable as well as its nested causes, in order to look for a specific set of exception classes."
  },
  {
    "id": 3567,
    "type": "Summary",
    "comment": "performs back-door proxy get to  MetadataStore#getDonorNode()",
    "code": "    private List<Versioned<byte[]>> proxyGet(ByteArray key) throws VoldemortException {\n\n        if(!storeRepository.hasNodeStore(getName(), metadata.getRebalancingSlaveNodeId())) {\n            throw new VoldemortException(\"Node Store not present in storeRepository for (store,nodeId) pair (\"\n                                         + getName()\n                                         + \",\"\n                                         + metadata.getRebalancingSlaveNodeId()\n                                         + \").\");\n        }\n\n        return storeRepository.getNodeStore(getName(), metadata.getRebalancingSlaveNodeId())\n                              .get(key);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3568,
    "type": "Summary",
    "comment": "Returns the presence info for a particular user, or null if the user is unavailable (offline) or if no presence information is available, such as when you are not subscribed to the user's presence updates.",
    "code": "    public Presence getPresence(String user) {\n        String key = getPresenceMapKey(StringUtils.parseBareAddress(user));\n        Map<String, Presence> userPresences = presenceMap.get(key);\n        if (userPresences == null) {\n            Presence presence = new Presence(Presence.Type.unavailable);\n            presence.setFrom(user);\n            return presence;\n        }\n        else {\n            // Find the resource with the highest priority\n            // Might be changed to use the resource with the highest availability instead.\n            Presence presence = null;\n\n            for (String resource : userPresences.keySet()) {\n                Presence p = userPresences.get(resource);\n                if (!p.isAvailable()) {\n                    continue;\n                }\n                // Chose presence with highest priority first.\n                if (presence == null || p.getPriority() > presence.getPriority()) {\n                    presence = p;\n                }\n                // If equal priority, choose \"most available\" by the mode value.\n                else if (p.getPriority() == presence.getPriority()) {\n                    Presence.Mode pMode = p.getMode();\n                    // Default to presence mode of available.\n                    if (pMode == null) {\n                        pMode = Presence.Mode.available;\n                    }\n                    Presence.Mode presenceMode = presence.getMode();\n                    // Default to presence mode of available.\n                    if (presenceMode == null) {\n                        presenceMode = Presence.Mode.available;\n                    }\n                    if (pMode.compareTo(presenceMode) < 0) {\n                        presence = p;\n                    }\n                }\n            }\n            if (presence == null) {\n                presence = new Presence(Presence.Type.unavailable);\n                presence.setFrom(user);\n                return presence;\n            }\n            else {\n                return presence;\n            }\n        }\n    }\n\n",
    "label": 1,
    "rec": "Returns the presence info for a particular user."
  },
  {
    "id": 3569,
    "type": "Summary",
    "comment": "All registered instances of  HystrixThreadPoolMetrics",
    "code": "    public static Collection<HystrixThreadPoolMetrics> getInstances() {\n        List<HystrixThreadPoolMetrics> threadPoolMetrics = new ArrayList<HystrixThreadPoolMetrics>();\n        for (HystrixThreadPoolMetrics tpm: metrics.values()) {\n            if (hasExecutedCommandsOnThread(tpm)) {\n                threadPoolMetrics.add(tpm);\n            }\n        }\n\n        return Collections.unmodifiableCollection(threadPoolMetrics);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3570,
    "type": "Summary",
    "comment": "Filters these properties by what can be preserved through a user function's constant fields set.",
    "code": "\tpublic boolean filterByNodesConstantSet(OptimizerNode node, int input) {\n\t\t\n\t\t// check, whether the local order is preserved\n\t\tif (ordering != null) {\n\t\t\tArrayList<Integer> involvedIndexes = ordering.getInvolvedIndexes();\n\t\t\tfor (int i = 0; i < involvedIndexes.size(); i++) {\n\t\t\t\tif (node.isFieldKept(input, involvedIndexes.get(i)) == false) {\n\t\t\t\t\tordering = ordering.createNewOrderingUpToIndex(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// check, whether the local key grouping is preserved\n\t\tif (this.groupedFields != null) {\n\t\t\tfor (Integer index : this.groupedFields) {\n\t\t\t\tif (node.isFieldKept(input, index) == false) {\n\t\t\t\t\tthis.groupedFields = null;\n\t\t\t\t\tthis.grouped = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\telse {\n\t\t\tthis.grouped = false;\n\t\t}\n\t\t\n\t\treturn !isTrivial();\n\t}\n\n",
    "label": 1,
    "rec": "Filters these properties by what can be preserved through the given output contract."
  },
  {
    "id": 3571,
    "type": "Summary",
    "comment": "Returns all the keys matching the glob-style pattern as space separated strings.",
    "code": "    public Set<byte[]> keys(final byte[] pattern) {\n\tcheckIsInMulti();\n\tclient.keys(pattern);\n\treturn new HashSet<byte[]>(client.getBinaryMultiBulkReply());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3572,
    "type": "Summary",
    "comment": "Gets a grid instance for given local node ID.",
    "code": "    public static Grid grid(UUID locNodeId) throws GridIllegalStateException {\n        return GridGainEx.grid(locNodeId);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3573,
    "type": "Summary",
    "comment": "When using this method, make sure to pass Query.selectionArgs to the .query or other action methods.",
    "code": "    public Select where(String selection, String... args) {\n        this.selection = selection;\n        this.selectionArgs = args;\n        return this;\n    }\n\n",
    "label": 1,
    "rec": "When using this method, make sure to pass Select.selectionArgs to the .query or other action methods."
  },
  {
    "id": 3574,
    "type": "Summary",
    "comment": "The default topic for send methods where a topic is not providing.",
    "code": "\tpublic String getDefaultTopic() {\n\t\treturn this.defaultTopic;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3575,
    "type": "Summary",
    "comment": "Get account used for authentication",
    "code": "    public static Account getAccount(final Context context) {\n        final Account[] accounts = AccountManager.get(context)\n                .getAccountsByType(GITHUB_ACCOUNT_TYPE);\n        return accounts.length > 0 ? accounts[0] : null;\n    }\n",
    "label": 1,
    "rec": "Get configured account"
  },
  {
    "id": 3576,
    "type": "Summary",
    "comment": "Creates  UUID predicate evaluating on the given node ID.",
    "code": "    public static IgnitePredicate<UUID> idForNodeId(final UUID nodeId) {\n        A.notNull(nodeId, \"nodeId\");\n\n        return new P1<UUID>() {\n            @Override public boolean apply(UUID id) {\n                return id.equals(nodeId);\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3577,
    "type": "Summary",
    "comment": "Retrieval method for the BandwidthTimerManager singleton.",
    "code": "  @Nonnull\n  public static DeviceBandwidthSampler getInstance() {\n    return DeviceBandwidthSamplerHolder.instance;\n  }\n\n",
    "label": 1,
    "rec": "Retrieval method for the DeviceBandwidthSampler singleton."
  },
  {
    "id": 3578,
    "type": "Summary",
    "comment": "Reconstructs object on unmarshalling.",
    "code": "    protected Object readResolve() throws ObjectStreamException {\n        try {\n            IgniteBiTuple<String, String> t = stash.get();\n\n            return IgnitionEx.gridx(t.get1()).cachex(t.get2());\n        }\n        catch (IllegalStateException e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3579,
    "type": "Summary",
    "comment": "Returns the listenable",
    "code": "    public Listenable<SharedValueListener> getListenable()\n    {\n        return listeners;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3580,
    "type": "Summary",
    "comment": "Creates a  CouchbaseBucketManagerFactory from  CouchbaseEnvironment",
    "code": "    public CouchbaseBucketManagerFactory getManagerFactory(CouchbaseEnvironment environment) throws NullPointerException {\n        Objects.requireNonNull(environment, \"environment is required\");\n        CouchbaseCluster couchbaseCluster = CouchbaseCluster.create(environment, nodes);\n        return new DefaultCouchbaseBucketManagerFactory(couchbaseCluster, user, password);\n    }\n\n",
    "label": 1,
    "rec": "Creates a  DefaultCouchbaseBucketManagerFactory from  CouchbaseEnvironment"
  },
  {
    "id": 3581,
    "type": "Summary",
    "comment": "Tries to parse LCN-PCHK connection settings from the given openHAB configuration.",
    "code": "\tpublic static ConnectionSettings tryParse(Dictionary<String, ?> config, int counter) {\n\t    if(config==null) return null;\n\t\tString id = (String)config.get(\"id\" + (counter + 1));\n\t\tid = id == null ? \"\" : id.trim();\n\t\tString addressWithOptPort = (String)config.get(\"address\" + (counter + 1));\n\t\taddressWithOptPort = addressWithOptPort == null ? \"\" : addressWithOptPort.trim();\n\t\tString username = (String)config.get(\"username\" + (counter + 1));\n\t\tusername = username == null ? \"\" : username.trim();\n\t\tString password = (String)config.get(\"password\" + (counter + 1));\n\t\tpassword = password == null ? \"\" : password.trim();\n\t\tString mode = (String)config.get(\"mode\" + (counter + 1));\n\t\tmode = mode == null ? \"\" : mode.trim();\n\t\tif (id.isEmpty() || addressWithOptPort.isEmpty() || username.isEmpty() || password.isEmpty() || mode.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tString dataRequestTimeout = (String)config.get(\"timeout\" + (counter + 1));\n\t\tdataRequestTimeout = dataRequestTimeout == null ? Long.valueOf(DEFAULT_TIMEOUT_MSEC).toString() : dataRequestTimeout.trim();\n\t\ttry {\n\t\t\tString address = addressWithOptPort.contains(\":\") ? addressWithOptPort.split(\":\")[0] : addressWithOptPort;\n\t\t\tint port = addressWithOptPort.contains(\":\") ? Integer.parseInt(addressWithOptPort.split(\":\")[1]) : 4114;\n\t\t\tLcnDefs.OutputPortDimMode dimMode =\n\t\t\t\tmode.equalsIgnoreCase(\"percent200\") || mode.equalsIgnoreCase(\"native200\") ?\n\t\t\t\tLcnDefs.OutputPortDimMode.STEPS200 : LcnDefs.OutputPortDimMode.STEPS50;\n\t\t\tLcnDefs.OutputPortStatusMode statusMode =\n\t\t\t\tmode.equalsIgnoreCase(\"percent50\") || mode.equalsIgnoreCase(\"percent200\") ?\n\t\t\t\tLcnDefs.OutputPortStatusMode.PERCENT : LcnDefs.OutputPortStatusMode.NATIVE;\n\t\t\tint timeout = Integer.parseInt(dataRequestTimeout);\n\t\t\treturn new ConnectionSettings(id, address, port, username, password, dimMode, statusMode, timeout);\n\t\t} catch (NumberFormatException ex) { }\n\t\treturn null;\t\t\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3582,
    "type": "Summary",
    "comment": "First authenticates the  AuthenticationToken argument, and if successful, constructs a  Subject instance representing the authenticated account's identity.",
    "code": "    public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info;\n        try {\n            info = authenticate(token);\n        } catch (AuthenticationException ae) {\n            try {\n                onFailedLogin(token, ae, subject);\n            } catch (Exception e) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" +\n                            \"exception.  Logging and propagating original AuthenticationException.\", e);\n                }\n            }\n            throw ae; //propagate\n        }\n\n        Subject loggedIn = createSubject(token, info, subject);\n        //TODO - is binding necessary anymore?  Shouldn't the Builders or Builder callers do this now?\n        bind(loggedIn);\n\n        onSuccessfulLogin(token, info, loggedIn);\n        return loggedIn;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3583,
    "type": "Summary",
    "comment": "Gets the number of blocks.",
    "code": "\tpublic int getBlockCount() {\n\t\treturn blockCount;\n\t}\n\n",
    "label": 1,
    "rec": "Gets the number of blocks that have been added to the buffer."
  },
  {
    "id": 3584,
    "type": "Summary",
    "comment": "Executor service that is in charge of processing outgoing GGFS messages.",
    "code": "    public int getGgfsExecutorService() {\n        return ggfsPoolSz;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3585,
    "type": "Summary",
    "comment": "Gets error code based on exception class.",
    "code": "    private int errorCode(GridException e, boolean checkIo) {\n        if (X.hasCause(e, GridGgfsFileNotFoundException.class))\n            return ERR_FILE_NOT_FOUND;\n        else if (GridGgfsPathAlreadyExistsException.class.isInstance(e))\n            return ERR_PATH_ALREADY_EXISTS;\n        else if (GridGgfsDirectoryNotEmptyException.class.isInstance(e))\n            return ERR_DIRECTORY_NOT_EMPTY;\n        else if (GridGgfsParentNotDirectoryException.class.isInstance(e))\n            return ERR_PARENT_NOT_DIRECTORY;\n        else if (GridGgfsInvalidHdfsVersionException.class.isInstance(e))\n            return ERR_INVALID_HDFS_VERSION;\n        else if (X.hasCause(e, GridGgfsCorruptedFileException.class))\n            return ERR_CORRUPTED_FILE;\n            // This check should be the last.\n        else if (GridGgfsException.class.isInstance(e)) {\n            if (checkIo && e.hasCause(IOException.class)) {\n                IOException e0 = e.getCause(IOException.class);\n\n                return errorCode(GridGgfsHadoopUtils.cast(e0), false);\n            }\n\n            return ERR_GGFS_GENERIC;\n        }\n\n        return ERR_GENERIC;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3586,
    "type": "Summary",
    "comment": "Runs task.",
    "code": "    public void run(Collection<GridHadoopTask> tasks) {\n        for (final GridHadoopTask task : tasks)\n            ctx.kernalContext().closure().callLocalSafe(new GridPlainCallable<GridFuture<?>>() {\n                @Override public GridFuture<?> call() throws Exception {\n                    GridHadoopTaskInfo info = task.info();\n\n                    try (GridHadoopTaskOutput out = createOutput(info);\n                         GridHadoopTaskInput in = createInput(info)) {\n                        GridHadoopTaskContext ctx = null;\n\n                        task.run(ctx);\n\n                        return out.finish();\n                    }\n                }\n            }, false);\n    }\n",
    "label": 1,
    "rec": "Runs tasks."
  },
  {
    "id": 3587,
    "type": "Summary",
    "comment": "Creates a mock using the Generics Metadata.",
    "code": "    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mockitoCore.mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3588,
    "type": "Summary",
    "comment": "adds a job directory to the Engine jobConfigs if not extant",
    "code": "\tpublic boolean addJobDirectory(File dir) {\n\t    if(dir==null) {\n\t        return false; \n\t    }\n        File[] candidateConfigs = dir.listFiles(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n                return name.endsWith(\".cxml\");\n            }});\n        if(candidateConfigs.length == 0) {\n            // no CXML file found!\n            return false; \n        }\n        if(jobConfigs.containsKey(dir.getName())) {\n            // same-name job already exists\n            return false; \n        }\n        for (File cxml : candidateConfigs) {\n            try {\n                CrawlJob cj = new CrawlJob(cxml);            \n                if(!cj.getJobDir().getParentFile().equals(getJobsDir())) {\n                    writeJobPathFile(cj);\n                }\n                jobConfigs.put(cj.getShortName(),cj);\n                LOGGER.log(Level.INFO,\"added crawl job: \" + cj.getShortName());\n                return true;\n            } catch (IOException iae) {\n                LOGGER.log(Level.SEVERE,\"unable to add job directory\"+dir,iae);\n            } catch (IllegalArgumentException iae) {\n                LOGGER.log(Level.SEVERE,\"bad cxml: \"+cxml,iae);\n            }\n        }\n        // path rejected for some reason\n        return false; \n    }\n\n",
    "label": 1,
    "rec": "Adds a job directory to the Engine known jobConfigs if not extant."
  },
  {
    "id": 3589,
    "type": "Summary",
    "comment": "Get login name of configured account",
    "code": "    public static String getLogin(final Context context) {\n        final Account account = getAccount(context);\n        return account != null ? account.name : null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3590,
    "type": "Summary",
    "comment": "Matrix multiplication with a sparse matrix",
    "code": "\tpublic DenseVector mult(DenseVector vec) {\n\t\tassert this.numColumns == vec.size;\n\n\t\tDenseVector result = new DenseVector(this.numRows);\n\t\tfor (int i = 0; i < this.numRows; i++)\n\t\t\tresult.set(i, row(i, false).inner(vec));\n\n\t\treturn result;\n\t}\n",
    "label": 1,
    "rec": "Do  matrix x vector between current matrix and a given vector"
  },
  {
    "id": 3591,
    "type": "Summary",
    "comment": "get every label for a given dashboard",
    "code": "    public JSONArray labelsShowList(long idDashboard, String since) throws ApiServiceException, IOException {\n        return getResponse(callAuthenticated(\"labels/show_list.json\",\n                \"token\", token,\n                \"id_dashboard\", idDashboard,\n                \"since\", since), \"labels\");\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3592,
    "type": "Summary",
    "comment": "Returns the  BytesRef value for the given ord.",
    "code": "  public BytesRef get(int ord, BytesRef ref) {\n    assert bytesStart != null : \"bytesStart is null - not initialized\";\n    assert ord < bytesStart.length: \"ord exceeeds byteStart len: \" + bytesStart.length;\n    return pool.setBytesRef(ref, bytesStart[ord]);\n  }\n\n",
    "label": 1,
    "rec": "Populates and returns a  BytesRef with the bytes for the given ord."
  },
  {
    "id": 3593,
    "type": "Summary",
    "comment": "get deadline in producteev format",
    "code": "    private String createDeadline(Task task) {\n        if(!task.hasDueDate())\n            return \"\";\n        if(!task.hasDueTime())\n            return ApiUtilities.unixDateToProducteev(task.getValue(Task.DUE_DATE));\n        String time = ApiUtilities.unixTimeToProducteev(task.getValue(Task.DUE_DATE));\n        return time.substring(0, time.lastIndexOf(' '));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3594,
    "type": "Summary",
    "comment": "Any byte, Byte or null.",
    "code": "    public static byte anyByte() {\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3595,
    "type": "Summary",
    "comment": "Points which should be removed will get the EMPTY value",
    "code": "    public int simplify(PointList points) {\n        int deleted = simplify(points, 0, points.size() - 1);\n        // compress list: move points into EMPTY slots\n        int freeIndex = -1;\n        for (int currentIndex = 0; currentIndex < points.size(); currentIndex++) {\n            if (Double.isNaN(points.latitude(currentIndex))) {\n                if (freeIndex < 0)\n                    freeIndex = currentIndex;\n                continue;\n            }\n\n            if (freeIndex < 0)\n                continue;\n            points.set(freeIndex, points.latitude(currentIndex), points.longitude(currentIndex));\n            // find next free index\n            int max = currentIndex;\n            for (int searchIndex = freeIndex; searchIndex < max; searchIndex++) {\n                if (Double.isNaN(points.latitude(searchIndex))) {\n                    freeIndex = searchIndex;\n                    break;\n                }\n            }\n        }\n        points.setSize(points.size() - deleted);\n        return deleted;\n    }\n",
    "label": 1,
    "rec": "This method removes points which are close to the line (defined by maxDist)."
  },
  {
    "id": 3596,
    "type": "Summary",
    "comment": "Gets per-thread-unique ID for this thread.",
    "code": "    public static UUID uuid() {\n        return UUIDS.get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3597,
    "type": "Summary",
    "comment": "This is a convenience method to set the request's options for host, port and path with a URI object.",
    "code": "\tpublic Request setURI(final URI uri) {\n\n\t\tif (uri == null) {\n\t\t\tthrow new NullPointerException(\"URI must not be null\");\n\t\t}\n\n\t\tfinal String host = uri.getHost() == null ? \"localhost\" : uri.getHost();\n\n\t\ttry {\n\n\t\t\tInetAddress destAddress = InetAddress.getByName(host);\n\t\t\tsetDestination(destAddress);\n\n\t\t\treturn setOptions(new URI(uri.getScheme(), null, host, uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment()));\n\n\t\t} catch (UnknownHostException e) {\n\t\t\tthrow new IllegalArgumentException(\"cannot resolve host name: \" + host);\n\t\t} catch (URISyntaxException e) {\n\t\t\t// should not happen because we are creating the URI from an existing URI object\n\t\t\tLOGGER.log(Level.WARNING, \"cannot set URI on request\", e);\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t}\n\n",
    "label": 1,
    "rec": "Sets the destination address and port and options from a given URI."
  },
  {
    "id": 3598,
    "type": "Summary",
    "comment": "long argument greater than the given value.",
    "code": "    public static long gt(long value) {\n        reportMatcher(new GreaterThan<Long>(value));\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3599,
    "type": "Summary",
    "comment": "Reconstructs object on unmarshalling.",
    "code": "    private Object readResolve() throws ObjectStreamException {\n        try {\n            return stash.get().grid().scheduler();\n        }\n        catch (Exception e) {\n            throw U.withCause(new InvalidObjectException(e.getMessage()), e);\n        }\n        finally {\n            stash.remove();\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3600,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_ORIG_FILENAME;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3601,
    "type": "Summary",
    "comment": "Called by the RequestQueueManager when the queue has expired",
    "code": "\tpublic long processRequestQueue(long timeNow) {\n\t\tsynchronized (m_requestQueue) {\n\t\t\tif (m_requestQueue.isEmpty()) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\tif (m_featureQueried != null) {\n\t\t\t\t// A feature has been queried, but\n\t\t\t\t// the response has not been digested yet.\n\t\t\t\t// Must wait for the query to be processed.\n\t\t\t\tlong dt = timeNow - (m_lastQueryTime + TIMEOUT_DIRECT_MESSAGE_REPLY);\n\t\t\t\tif (dt < 0) {\n\t\t\t\t\tlogger.debug(\"still waiting for query reply from {} for another {} usec\",\n\t\t\t\t\t\t\tm_address, -dt);\n\t\t\t\t\treturn (timeNow + 2000L); // retry soon\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"gave up waiting for query reply from device {}\", m_address);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQEntry qe = m_requestQueue.poll(); // take it off the queue!\n\t\t\tif (!qe.getMsg().isBroadcast()) {\n\t\t\t\tlogger.debug(\"qe taken off direct: {} {}\", qe.getFeature(), qe.getMsg());\n\t\t\t\tm_lastQueryTime = timeNow;\n\t\t\t\t// mark feature as pending\n\t\t\t\tqe.getFeature().setQueryStatus(DeviceFeature.QueryStatus.QUERY_PENDING);\n\t\t\t\t// also mark this queue as pending so there is no doubt\n\t\t\t\tm_featureQueried = qe.getFeature();\n\t\t\t} else {\n\t\t\t\tlogger.debug(\"qe taken off bcast: {} {}\", qe.getFeature(), qe.getMsg());\n\t\t\t}\n\t\t\tlong quietTime = qe.getMsg().getQuietTime();\n\t\t\tqe.getMsg().setQuietTime(500L); // rate limiting downstream!\n\t\t\ttry {\n\t\t\t\twriteMessage(qe.getMsg());\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(\"message write failed for msg {}\", qe.getMsg(), e);\n\t\t\t}\n\t\t\t// figure out when the request queue should be checked next\n\t\t\tQEntry qnext = m_requestQueue.peek();\n\t\t\tlong nextExpTime = (qnext == null ? 0L : qnext.getExpirationTime());\n\t\t\tlong nextTime = Math.max(timeNow + quietTime, nextExpTime);\n\t\t\tlogger.debug(\"next request queue processed in {} msec, quiettime = {}\",\n\t\t\t\t\t\t nextTime - timeNow, quietTime);\n\t\t\treturn (nextTime);\n\t\t}\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3602,
    "type": "Summary",
    "comment": "Changes the shared count only if its value has not changed since the version specified by newCount.",
    "code": "    public boolean  trySetCount(int newCount) throws Exception\n    {\n        return sharedValue.trySetValue(toBytes(newCount));\n    }\n",
    "label": 1,
    "rec": "Changes the shared count only if its value has not changed since this client last read it."
  },
  {
    "id": 3603,
    "type": "Summary",
    "comment": "Build a  DistributedQueue from the current builder values",
    "code": "    public DistributedQueue<T>      buildQueue()\n    {\n        return new DistributedQueue<T>\n        (\n            client,\n            consumer,\n            serializer,\n            queuePath,\n            factory,\n            executor,\n            Integer.MAX_VALUE,\n            false,\n            lockPath\n        );\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3604,
    "type": "Summary",
    "comment": "Compares the two columns and returns the changes necessary to create the second column from the first one.",
    "code": "    protected ColumnDefinitionChange compareColumns(Table  sourceTable,\r\n                                                    Column sourceColumn,\r\n                                                    Table  targetTable,\r\n                                                    Column targetColumn)\r\n    {\r\n        if (ColumnDefinitionChange.isChanged(getPlatformInfo(), sourceColumn, targetColumn))\r\n        {\r\n            Column  newColumnDef   = _cloneHelper.clone(sourceColumn, true);\r\n            int     targetTypeCode = _platformInfo.getTargetJdbcType(targetColumn.getTypeCode());\r\n            boolean sizeMatters    = _platformInfo.hasSize(targetTypeCode);\r\n            boolean scaleMatters   = _platformInfo.hasPrecisionAndScale(targetTypeCode);\r\n\r\n            newColumnDef.setTypeCode(targetColumn.getTypeCode());\r\n            newColumnDef.setSize(sizeMatters || scaleMatters ? targetColumn.getSize() : null);\r\n            newColumnDef.setAutoIncrement(targetColumn.isAutoIncrement());\r\n            newColumnDef.setRequired(targetColumn.isRequired());\r\n            newColumnDef.setDescription(targetColumn.getDescription());\r\n            newColumnDef.setDefaultValue(targetColumn.getDefaultValue());\r\n            return new ColumnDefinitionChange(sourceTable.getName(), sourceColumn.getName(), newColumnDef);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\n",
    "label": 1,
    "rec": "Compares the two columns and returns the change necessary to create the second column from the first one if they differe."
  },
  {
    "id": 3605,
    "type": "Summary",
    "comment": "Validate the SAML2 Document",
    "code": "    public boolean validate(Document signedDocument, KeyLocator keyLocator) throws ProcessingException {\n        try {\n            configureIdAttribute(signedDocument);\n            return XMLSignatureUtil.validate(signedDocument, keyLocator);\n        } catch (MarshalException | XMLSignatureException me) {\n            throw new ProcessingException(logger.signatureError(me));\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3606,
    "type": "Summary",
    "comment": "Builds a project using Gradle.",
    "code": "  @NotNull\n  @Override\n  public ExitCode build(CompileContext context,\n                        ModuleChunk chunk,\n                        DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                        OutputConsumer outputConsumer) {\n    JpsAndroidGradleModuleExtension extension = AndroidGradleJps.getFirstExtension(chunk);\n    if (extension == null) {\n      return ExitCode.NOTHING_DONE;\n    }\n    return ExitCode.OK;\n  }\n\n",
    "label": 1,
    "rec": "It does nothing."
  },
  {
    "id": 3607,
    "type": "Summary",
    "comment": "Gets affinity nodes for partition.",
    "code": "    private Iterable<ClusterNode> nodes(List<List<ClusterNode>> assignment, GridCacheAffinityFunction aff, Object key) {\n        return assignment.get(aff.partition(key));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3608,
    "type": "Summary",
    "comment": "Splits the given secret into  n shares, of which any  k or more can be combined to recover the original secret.",
    "code": "  public Set<Part> split(ByteString secret) {\n    checkNotNull(secret, \"Secret must not be null\");\n\n    // generate part values\n    final byte[][] values = new byte[n][secret.size()];\n    for (int i = 0; i < secret.size(); i++) {\n      // for each byte, generate a random polynomial, p\n      final byte[] p = GF256.generate(random, k - 1, secret.getByte(i));\n      for (int x = 1; x <= n; x++) {\n        // each part's byte is p(partId)\n        values[x - 1][i] = GF256.eval(p, (byte) x);\n      }\n    }\n\n    // return as a set of objects\n    final Set<Part> parts = new HashSet<>(n);\n    for (int i = 0; i < values.length; i++) {\n      parts.add(Part.of(i + 1, ByteString.of(values[i])));\n    }\n    return Collections.unmodifiableSet(parts);\n  }\n\n",
    "label": 1,
    "rec": "Splits the given secret into  n parts, of which any  k or more can be combined to recover the original secret."
  },
  {
    "id": 3609,
    "type": "Summary",
    "comment": "Gets length for the given memory chunk.",
    "code": "    public static int length(long memPtr) {\n        return GridUnsafe.getInt(memPtr + MEM_HDR_OFF_LEN);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3610,
    "type": "Summary",
    "comment": "Gets the build platform.",
    "code": "    public PlatformType getPlatform()\n    {\n        return this.platform;\n    }\n\n",
    "label": 1,
    "rec": "Gets the operating system you are building for."
  },
  {
    "id": 3611,
    "type": "Summary",
    "comment": "Whether the response was returned successfully either by executing run() or from cache.",
    "code": "    public boolean isSuccessfulExecution() {\n        return executionResult.getEventCounts().contains(HystrixEventType.SUCCESS);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3612,
    "type": "Summary",
    "comment": "Connects to Google-Calendar Service and returns the specified Calender-Feed url, username and password are taken from the corresponding config parameter in openhab.cfg.",
    "code": "\tpublic static CalendarEventFeed downloadEventFeed(String username, String password, String url, int refreshInterval) {\n\t\t// TODO: teichsta: there could be more than one calender url in openHAB.cfg\n\t\t// for now we accept this limitation of downloading just one feed ...\n\t\t\n\t\tif (StringUtils.isBlank(username) || StringUtils.isBlank(password) || StringUtils.isBlank(url)) {\n\t\t\tlogger.warn(\"username, password and url must not be blank -> gcal calendar login aborted\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tURL feedUrl = new URL(url);\n\t\t\t\n\t\t\tCalendarService myService = new CalendarService(\"openHAB\");\n\t\t\t\tmyService.setUserCredentials(username, password);\n\t\t\tCalendarQuery myQuery = new CalendarQuery(feedUrl);\n\t\t\t\tmyQuery.setMinimumStartTime(DateTime.now());\n\t\t\t\tmyQuery.setMaximumStartTime(new DateTime(DateTime.now().getValue() + (2 * refreshInterval)));\n\t\t\t\n\t\t\t// add the fulltext filter if it has been configured\n\t\t\tif (StringUtils.isNotBlank(filter)) {\n\t\t\t\tmyQuery.setFullTextQuery(filter);\n\t\t\t}\n\t\n\t\t\tCalendarEventFeed feed = myService.getFeed(myQuery, CalendarEventFeed.class);\n\t\t\tif (feed != null) {\n\t\t\t\tcheckIfFullCalendarFeed(feed.getEntries());\n\t\t\t}\n\t\t\t\n\t\t\treturn feed;\n\t\t}\n\t\tcatch (AuthenticationException ae) {\n\t\t\tlogger.error(\"authentication failed: {}\", ae.getMessage());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlogger.error(\"downloading CalenerEventFeed throws exception: {}\", e.getMessage());\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3613,
    "type": "Summary",
    "comment": "Returns the selected working of this part.",
    "code": "\tpublic IWorkingSet getSelectedWorkingSet() {\r\n\t\tif (getSelectedScope() == WORKING_SET_SCOPE)\r\n\t\t\treturn fWorkingSet;\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Returns the selected working set of this part."
  },
  {
    "id": 3614,
    "type": "Summary",
    "comment": "Solves A x = b by iterative biconjugate gradient method.",
    "code": "    public static double solve(Matrix A, Preconditioner Ap, double[] b, double[] x, double tol, int itol) {\n        return solve(A, Ap, b, x, tol, itol, 2 * Math.max(A.nrows(), A.ncols()));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3615,
    "type": "Summary",
    "comment": "Return the number of requests queued up for a given pool.",
    "code": "    public int getRegisteredResourceRequestCount(K key) {\n        int rc = 0;\n        if(!requestQueueMap.containsKey(key)) {\n            return rc;\n        }\n        try {\n            Queue<AsyncResourceRequest<V>> requestQueue = getRequestQueueForExistingKey(key);\n            // FYI: .size() is not constant time in the next call. ;)\n            rc = requestQueue.size();\n        } catch(IllegalArgumentException iae) {\n            logger.debug(\"getRegisteredResourceRequestCount called on invalid key: \", iae);\n        }\n        return rc;\n    }\n\n",
    "label": 1,
    "rec": "Count the number of queued resource requests for a specific pool."
  },
  {
    "id": 3616,
    "type": "Summary",
    "comment": "Extracts offset in bytes from the given page link.",
    "code": "    public static int bytesOffset(long link) {\n        return (int)((link >> (PAGE_IDX_SIZE + FILE_ID_SIZE)) & OFFSET_MASK) << 3;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3617,
    "type": "Summary",
    "comment": "This implementation attempts to resolve any session ID that may exist in the context by passing it to the  #resolveSession(SubjectContext) method.",
    "code": "    public Subject createSubject(SubjectContext subjectContext) {\n        //create a copy so we don't modify the argument's backing map:\n        SubjectContext context = copy(subjectContext);\n\n        //ensure that the context has a SecurityManager instance, and if not, add one:\n        context = ensureSecurityManager(context);\n\n        //Resolve an associated Session (usually based on a referenced session ID), and place it in the context before\n        //sending to the SubjectFactory.  The SubjectFactory should not need to know how to acquire sessions as the\n        //process is often environment specific - better to shield the SF from these details:\n        context = resolveSession(context);\n\n        //Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first\n        //if possible before handing off to the SubjectFactory:\n        context = resolvePrincipals(context);\n\n        Subject subject = doCreateSubject(context);\n\n        //save this subject for future reference if necessary:\n        //(this is needed here in case rememberMe principals were resolved and they need to be stored in the\n        //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).\n        //Added in 1.2:\n        save(subject);\n\n        return subject;\n    }\n",
    "label": 1,
    "rec": "This implementation functions as follows:   Ensures the  SubjectContext is as populated as it can be, using heuristics to acquire data that may not have already been available to it (such as a referenced session or remembered principals). Calls  #doCreateSubject(org.apache.shiro.subject.SubjectContext) to actually perform the  Subject instance creation. calls  #save(org.apache.shiro.subject.Subject) save(subject) to ensure the constructed  Subject's state is accessible for future requests/invocations if necessary. returns the constructed  Subject instance. "
  },
  {
    "id": 3618,
    "type": "Summary",
    "comment": "Sets the logo on the  ActionBar to the user's avatar.",
    "code": "    public AvatarLoader bind(final ActionBar actionBar, final AtomicReference<User> userReference) {\n        if (userReference == null)\n            return this;\n\n        final User user = userReference.get();\n        if (user == null)\n            return this;\n\n        final String avatarUrl = user.getAvatarUrl();\n        if (TextUtils.isEmpty(avatarUrl))\n            return this;\n\n        final Integer userId = Integer.valueOf(user.getId());\n\n        BitmapDrawable loadedImage = loaded.get(userId);\n        if (loadedImage != null) {\n            actionBar.setLogo(loadedImage);\n            return this;\n        }\n\n        new FetchAvatarTask(context) {\n\n            @Override\n            public BitmapDrawable call() throws Exception {\n                final BitmapDrawable image = getImage(user);\n                if (image != null)\n                    return image;\n                else\n                    return fetchAvatar(avatarUrl, userId);\n            }\n\n            @Override\n            protected void onSuccess(BitmapDrawable image) throws Exception {\n                final User current = userReference.get();\n                if (current != null && userId.equals(current.getId()))\n                    actionBar.setLogo(image);\n            }\n        }.execute();\n\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3619,
    "type": "Summary",
    "comment": "Returns the pack name of a fully qualified type.",
    "code": "    private static String getPackage(String baseQualifiedName) {\n        StringBuilder sb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(baseQualifiedName, \".\"); //$NON-NLS-1$\n        while (st.hasMoreTokens()) {\n            String s = st.nextToken();\n            if (Character.isUpperCase(s.charAt(0))) {\n                break;\n            } else {\n                if (sb.length() > 0) {\n                    sb.append('.');\n                }\n                sb.append(s);\n            }\n        }\n        \n        if (baseQualifiedName.equals(sb.toString())) {\n            // no upper case elements found in the name.  So,\n            // do an alternative parse where we assume that the\n            // last element is the class name\n            int i = baseQualifiedName.lastIndexOf('.');\n            \n            if (i == -1) {\n                // no package\n                return \"\"; //$NON-NLS-1$\n            } else {\n                return baseQualifiedName.substring(0, i);\n            }\n        }\n\n        return sb.toString();\n    }\n",
    "label": 1,
    "rec": "Returns the package name of a fully qualified type."
  },
  {
    "id": 3620,
    "type": "Summary",
    "comment": "Fetches a commit with it's comments.",
    "code": "    public Single<FullCommit> refresh() {\n        return store.refreshCommit(repository, id)\n                .flatMap(commit -> RxPageUtil.getAllPages((page) ->\n                        service.getCommitComments(repository.owner().login(),\n                                repository.name(), commit.sha(), page), 1)\n                        .flatMap(page -> Observable.fromIterable(page.items()))\n                        .map(comment -> {\n                            imageGetter.encode(comment, comment.bodyHtml());\n                            return comment;\n                        })\n                        .toList()\n                        .map(comments -> new FullCommit(commit, comments)));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3621,
    "type": "Summary",
    "comment": "Will not clear link bits.",
    "code": "    private static int hashCode0(int cacheId, long effectivePageId) {\n        int result = (int)(effectivePageId ^ (effectivePageId >>> 32));\n\n        result = 31 * result + cacheId;\n\n        return result;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3622,
    "type": "Summary",
    "comment": "Returns a  Callable object that, when called, runs the given privileged action and returns its result.",
    "code": "    public static Callable<Object> callable(Runnable task) {\n        if (task == null) {\n            throw new NullPointerException();\n        }\n        return new RunnableAdapter<Object>(task, null);\n    }\n",
    "label": 1,
    "rec": "Returns a  Callable object that, when called, runs the given task and returns null."
  },
  {
    "id": 3623,
    "type": "Summary",
    "comment": "1.",
    "code": "    public CompletableFuture<Void> splitAndOwnBundle(NamespaceBundle bundle, boolean unload)\n        throws Exception {\n\n        final CompletableFuture<Void> unloadFuture = new CompletableFuture<>();\n        final AtomicInteger counter = new AtomicInteger(BUNDLE_SPLIT_RETRY_LIMIT);\n\n        splitAndOwnBundleOnceAndRetry(bundle, unload, counter, unloadFuture);\n\n        return unloadFuture;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3624,
    "type": "Summary",
    "comment": "Determines if the passed class has  SocketImpl as a direct or indirect superclass",
    "code": "\tprotected boolean isSocketImpl(CtClass clazz) throws NotFoundException {\n\t\tif(Modifier.isAbstract(clazz.getModifiers())) return false;\t\t\n\t\tCtClass parent = clazz.getSuperclass();\n\t\twhile(parent!=null && !parent.getName().equals(objectCtClass.getName())) {\n\t\t\tif(parent.getName().equals(SOCK_NAME)) return true;\n\t\t\tparent = parent.getSuperclass();\n\t\t}\n\t\treturn false;\n\t}\n\n",
    "label": 1,
    "rec": "Determines if the passed class has  SocketImpl as a direct or indirect superclass, is not abstract and does not already implement  ISocketImpl"
  },
  {
    "id": 3625,
    "type": "Summary",
    "comment": "Extends the tree by calculating the requested child for the given path.",
    "code": "    public DeterministicKey deriveChild(List<ChildNumber> parentPath, boolean relative, boolean createParent, ChildNumber createChildNumber) {\n        return deriveChild(get(parentPath, relative, createParent), createChildNumber);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3626,
    "type": "Summary",
    "comment": "Adds the specified observe relation",
    "code": "\tpublic boolean add(ObserveRelation relation) {\r\n\t\tif (relation == null)\r\n\t\t\tthrow new NullPointerException();\r\n\t\tObserveRelation previous = observeRelations.put(relation.getKey(), relation);\n\t\tif (null != previous) {\r\n\t\t\tprevious.cancel();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\r\n\n",
    "label": 1,
    "rec": "Adds the specified observe relation."
  },
  {
    "id": 3627,
    "type": "Summary",
    "comment": "Create cache configuration.",
    "code": "    private static CacheConfiguration cacheConfiguration(String name, GridCacheAtomicityMode atomicityMode) {\n        CacheConfiguration ccfg = new CacheConfiguration();\n\n        ccfg.setName(name);\n        ccfg.setCacheMode(PARTITIONED);\n        ccfg.setAtomicityMode(atomicityMode);\n        ccfg.setWriteSynchronizationMode(FULL_SYNC);\n\n        return ccfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3628,
    "type": "Summary",
    "comment": "Renames this file to  newPath.",
    "code": "    public boolean renameTo(java.io.File dest) {\n        if (path.length() == 0 || dest.path.length() == 0) {\n            return false;\n        }\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkWrite(path);\n            security.checkWrite(dest.path);\n        }\n        return renameToImpl(pathBytes, dest.pathBytes);\n    }\n\n",
    "label": 1,
    "rec": "Renames this file to the name represented by the  dest file."
  },
  {
    "id": 3629,
    "type": "Summary",
    "comment": "create a label",
    "code": "    public JSONObject labelsCreate(long idDashboard, String title) throws ApiServiceException, IOException {\n        return callAuthenticated(\"labels/create.json\",\n                \"token\", token,\n                \"id_dashboard\", idDashboard,\n                \"title\", title);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3630,
    "type": "Summary",
    "comment": "Constructs a page link by the given page ID and 8-byte words within the page.",
    "code": "    public static long linkFromDwordOffset(long pageId, int dwordOffset) {\n        assert (pageId >> (PAGE_IDX_SIZE + FILE_ID_SIZE)) == 0;\n\n        return pageId | (((long)dwordOffset) << (PAGE_IDX_SIZE + FILE_ID_SIZE));\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3631,
    "type": "Summary",
    "comment": "Removes  XML tag in speechOutput",
    "code": "    private String trimOutputSpeech(final String outputSpeech) {\n        if (outputSpeech == null) {\n            return \"\";\n        }\n        String trimmedOutputSpeech = outputSpeech.trim();\n        if (trimmedOutputSpeech.startsWith(SPEAK_OPEN_TAG) && trimmedOutputSpeech.endsWith(SPEAK_CLOSE_TAG)) {\n            return trimmedOutputSpeech.substring(SPEAK_OPEN_TAG.length(), trimmedOutputSpeech.length() - SPEAK_CLOSE_TAG.length())\n                    .trim();\n        }\n        return trimmedOutputSpeech;\n    }\n",
    "label": 1,
    "rec": "Removes  opening and closing XML tags in speechOutput."
  },
  {
    "id": 3632,
    "type": "Summary",
    "comment": "Initializes logger.",
    "code": "    protected IgniteLogger initLogger(String log) throws GridException {\n        Logger impl = Logger.getRootLogger();\n\n        impl.removeAllAppenders();\n\n        String fileName =  U.getGridGainHome() + \"/work/log/\" + log;\n\n        // Configure output that should go to System.out\n        RollingFileAppender fileApp;\n\n        String fmt = \"[%d{ABSOLUTE}][%-5p][%t][%c{1}] %m%n\";\n\n        try {\n            fileApp = new RollingFileAppender(new PatternLayout(fmt), fileName);\n\n            fileApp.setMaxBackupIndex(0);\n            fileApp.setAppend(false);\n\n            // fileApp.rollOver();\n\n            fileApp.activateOptions();\n        }\n        catch (IOException e) {\n            throw new GridException(\"Unable to initialize file appender.\", e);\n        }\n\n        LevelRangeFilter lvlFilter = new LevelRangeFilter();\n\n        lvlFilter.setLevelMin(Level.DEBUG);\n\n        fileApp.addFilter(lvlFilter);\n\n        impl.addAppender(fileApp);\n\n        // Configure output that should go to System.out\n        ConsoleAppender conApp = new ConsoleAppender(new PatternLayout(fmt), ConsoleAppender.SYSTEM_OUT);\n\n        lvlFilter = new LevelRangeFilter();\n\n        lvlFilter.setLevelMin(Level.DEBUG);\n        lvlFilter.setLevelMax(Level.INFO);\n\n        conApp.addFilter(lvlFilter);\n\n        conApp.activateOptions();\n\n        impl.addAppender(conApp);\n\n        // Configure output that should go to System.err\n        conApp = new ConsoleAppender(new PatternLayout(fmt), ConsoleAppender.SYSTEM_ERR);\n\n        conApp.setThreshold(Level.WARN);\n\n        conApp.activateOptions();\n\n        impl.addAppender(conApp);\n\n        impl.setLevel(Level.INFO);\n\n        //Logger.getLogger(\"org.gridgain\").setLevel(Level.INFO);\n        //Logger.getLogger(GridCacheVersionManager.class).setLevel(Level.DEBUG);\n\n        return new GridTestLog4jLogger(false);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3633,
    "type": "Summary",
    "comment": "Returns the value of the named property off this entry.",
    "code": "  public String getProperty(String name) {\n    // We assume that each Property object has unique non null name.  This code\n    // will ignore Property\n    // with null name and if there are two Property objects with the same name,\n    // it will return the\n    // first one it found.\n    if (hasProperties()) {\n      for (Property property : getProperties()) {\n        if (property.hasName() && property.getName().equalsIgnoreCase(name)) {\n          return property.getValue();\n        }\n      }\n    }\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Returns the value of the named property of this entry."
  },
  {
    "id": 3634,
    "type": "Summary",
    "comment": "The name of the Archaius property to disable this filter.",
    "code": "    public String disablePropertyName() {\n        return \"zuul.\" + baseName + \".disable\";\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3635,
    "type": "Summary",
    "comment": "Compares two  GridNode instances for equality.",
    "code": "    public static boolean eqNodes(Object n1, Object n2) {\n        return n1 == n2 || !(n1 == null || n2 == null) && !(!(n1 instanceof ClusterNode) || !(n2 instanceof ClusterNode))\n            && ((ClusterNode)n1).id().equals(((ClusterNode)n2).id());\n    }\n",
    "label": 1,
    "rec": "Compares two  org.gridgain.grid.ClusterNode instances for equality."
  },
  {
    "id": 3636,
    "type": "Summary",
    "comment": "This method should be overridden by subclasses to change configuration parameters.",
    "code": "    protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = getConfiguration(gridName, getTestResources());\n\n        cfg.setNodeId(null);\n\n        return cfg;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3637,
    "type": "Summary",
    "comment": "Gets a valid number for the specified country and number type.",
    "code": "  public PhoneNumber getExampleNumberForType(String regionCode, PhoneNumberType type) {\n    // Check the region code is valid.\n    if (!isValidRegionCode(regionCode)) {\n      LOGGER.log(Level.WARNING, \"Invalid or unknown region code provided.\");\n      return null;\n    }\n    PhoneNumberDesc desc = getNumberDescByType(getMetadataForRegion(regionCode), type);\n    try {\n      if (desc.hasExampleNumber()) {\n        return parse(desc.getExampleNumber(), regionCode);\n      }\n    } catch (NumberParseException e) {\n      LOGGER.log(Level.SEVERE, e.toString());\n    }\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Gets a valid number for the specified region and number type."
  },
  {
    "id": 3638,
    "type": "Summary",
    "comment": "Gets the secondary file system.",
    "code": "    public IgniteFsFileSystem getSecondaryFileSystem() {\n        return secondaryFs;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3639,
    "type": "Summary",
    "comment": "Handle invalid helper data without exception details or because none was thrown.",
    "code": "    protected String handleError(final String message) {\n        notifier().error(formatMessage(message));\n        return formatMessage(message);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3640,
    "type": "Summary",
    "comment": "Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.",
    "code": "    public ECKey getConnectedKey(KeyBag keyBag) throws ScriptException {\n        TransactionOutput connectedOutput = getConnectedOutput();\n        checkNotNull(connectedOutput, \"Input is not connected so cannot retrieve key\");\n        Script connectedScript = connectedOutput.getScriptPubKey();\n        if (connectedScript.isSentToAddress()) {\n            byte[] addressBytes = connectedScript.getPubKeyHash();\n            return keyBag.findKeyFromPubHash(addressBytes);\n        } else if (connectedScript.isSentToRawPubKey()) {\n            byte[] pubkeyBytes = connectedScript.getPubKey();\n            return keyBag.findKeyFromPubKey(pubkeyBytes);\n        } else if (connectedScript.isPayToScriptHash()) {\n            byte[] scriptHash = connectedScript.getPubKeyHash();\n            RedeemData redeemData = keyBag.findRedeemDataFromScriptHash(scriptHash);\n            if (redeemData == null)\n                return null;\n            return redeemData.getFullKey();\n        } else {\n            throw new ScriptException(\"Could not understand form of connected output script: \" + connectedScript);\n        }\n    }\n",
    "label": 1,
    "rec": "Returns the ECKey identified in the connected output, for either pay-to-address scripts, pay-to-key or P2SH scripts."
  },
  {
    "id": 3641,
    "type": "Summary",
    "comment": "Get the squared distance between this vector and another.",
    "code": "    public double distanceSquared(Vector o) {\n        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3642,
    "type": "Summary",
    "comment": "Return a HGHandle array of all HGLinks pointing to the atom referred by the passed in handle.",
    "code": "    public IncidenceSet getIncidenceSet(HGHandle handle)\r\n    {\r\n    \treturn cache.getIncidenceCache().get(getPersistentHandle(handle));\r\n    }\r\n\n",
    "label": 1,
    "rec": "Return the IncidenceSet, that is the set ofall HGLinks pointing to, the atom referred by the passed in handle."
  },
  {
    "id": 3643,
    "type": "Summary",
    "comment": "Method make wrapper predicate for existing value.",
    "code": "    private IgnitePredicate<T> wrapperPredicate(final T val) {\n        return new IgnitePredicate<T>() {\n            @Override public boolean apply(T e) {\n                return F.eq(val, e);\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3644,
    "type": "Summary",
    "comment": "Converts given closure to a grid job.",
    "code": "    private static ComputeJob job(final Runnable r) {\n        A.notNull(r, \"job\");\n\n        if (r instanceof GridComputeJobMasterLeaveAware) {\n            return new GridMasterLeaveAwareComputeJobAdapter() {\n                @Nullable @Override public Object execute() {\n                    r.run();\n\n                    return null;\n                }\n\n                @Override public void onMasterNodeLeft(GridComputeTaskSession ses) throws GridException {\n                    ((GridComputeJobMasterLeaveAware)r).onMasterNodeLeft(ses);\n                }\n            };\n        }\n        else {\n            return new GridComputeJobAdapter() {\n                @Nullable @Override public Object execute() {\n                    r.run();\n\n                    return null;\n                }\n            };\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3645,
    "type": "Summary",
    "comment": "Creates and returns a new empty context with the given parent and strategy.",
    "code": "\tstatic public IEclipseContext create(String name) {\n\t\tIEclipseContext result = create();\n\t\tresult.set(EclipseContext.DEBUG_STRING, name);\n\t\treturn result;\n\t}\n\n",
    "label": 1,
    "rec": "Creates and returns a new empty context."
  },
  {
    "id": 3646,
    "type": "Summary",
    "comment": "Starts grid with default configuration.",
    "code": "    public static Ignite start() throws IgniteCheckedException {\n        return GridGainEx.start();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3647,
    "type": "Summary",
    "comment": "Query the server for any resource with the matching arguments.",
    "code": "                public List<ResourceRepresentation> call() {\n                    return (List<ResourceRepresentation>) createFindRequest(id, name, uri, owner, type, scope, matchingUri, exactName, deep, firstResult, maxResult).response().json(new TypeReference<List<ResourceRepresentation>>() {\n                    }).execute();\n                }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3648,
    "type": "Summary",
    "comment": "Requests  AffinityFunction and  AffinityKeyMapper from remote node.",
    "code": "    private AffinityInfo affinityInfoFromNode(@Nullable String cacheName, long topVer, ClusterNode n)\n        throws IgniteCheckedException {\n        GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = ctx.closure()\n            .callAsyncNoFailover(BALANCE, affinityJob(cacheName, topVer), F.asList(n), true/*system pool*/).get();\n\n        CacheAffinityFunction f = (CacheAffinityFunction)unmarshall(ctx, n.id(), t.get1());\n        CacheAffinityKeyMapper m = (CacheAffinityKeyMapper)unmarshall(ctx, n.id(), t.get2());\n\n        assert m != null;\n\n        // Bring to initial state.\n        f.reset();\n        m.reset();\n\n        return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(n, cacheName));\n    }\n",
    "label": 1,
    "rec": "Requests  CacheAffinityFunction and  CacheAffinityKeyMapper from remote node."
  },
  {
    "id": 3649,
    "type": "Summary",
    "comment": "Predicate to look for client node.",
    "code": "    public static IgnitePredicate<ClusterNode> clientNode() {\n        return new IgnitePredicate<ClusterNode>() {\n            @Override public boolean apply(ClusterNode node) {\n                return \"client\".equals(node.attribute(\"segment\"));\n            }\n        };\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3650,
    "type": "Summary",
    "comment": "Returns a set of URLs by expanding the specified URLs with Manifest information.",
    "code": "    public static Collection<URL> forManifest(final Iterable<URL> urls) {\n        Collection<URL> result = new ArrayList<URL>();\n        // determine if any of the URLs are JARs, and get any dependencies\n        for (URL url : urls) {\n            result.addAll(forManifest(url));\n        }\n        return distinctUrls(result);\n    }\n\n",
    "label": 1,
    "rec": "Returns a distinct collection of URLs by expanding the specified URLs with Manifest information."
  },
  {
    "id": 3651,
    "type": "Summary",
    "comment": "Bind text view to HTML string",
    "code": "    public HttpImageGetter bind(final TextView view, final String html, final Object id) {\n        view.setText(Html.encode(html, loading));\n        view.setTag(id);\n        new RoboAsyncTask<CharSequence>(context) {\n\n            public CharSequence call() throws Exception {\n                if (html.indexOf(\"<img\") != -1)\n                    return Html.encode(html, HttpImageGetter.this);\n                else\n                    return null;\n            }\n\n            protected void onSuccess(CharSequence html) throws Exception {\n                if (html == null)\n                    return;\n                if (!id.equals(view.getTag()))\n                    return;\n                view.setText(html);\n            }\n        }.execute();\n        return this;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3652,
    "type": "Summary",
    "comment": "Attempt to parse a  Repository from the given  Uri",
    "code": "    public static Repo getRepository(Uri uri) {\n        List<String> segments = uri.getPathSegments();\n        if (segments == null)\n            return null;\n        if (segments.size() < 2)\n            return null;\n\n        String repoOwner = segments.get(0);\n        if (!RepositoryUtils.isValidOwner(repoOwner))\n            return null;\n\n        String repoName = segments.get(1);\n        if (!RepositoryUtils.isValidRepo(repoName))\n            return null;\n\n        Repo repository = new Repo();\n        User owner = new User();\n        owner.login = repoOwner;\n        repository.name = repoName;\n        repository.owner = owner;\n        return repository;\n    }\n",
    "label": 1,
    "rec": "Attempt to parse a  Repo from the given  Uri"
  },
  {
    "id": 3653,
    "type": "Summary",
    "comment": "Filters rows from expired ones and using predicate.",
    "code": "    protected Iterator<GridH2Row> filter(Iterator<GridH2Row> iter) {\n        IgniteBiPredicate<Object, Object> p = null;\n\n        IndexingQueryFilter f = filters.get();\n\n        return new FilteringIterator(iter, U.currentTimeMillis(), f);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3654,
    "type": "Summary",
    "comment": "Get a list of file ids of this track.",
    "code": "\tpublic List<File> getFiles(){\n\t\treturn this.files;\n\t}\n\n",
    "label": 1,
    "rec": "Get a list of files of this track."
  },
  {
    "id": 3655,
    "type": "Summary",
    "comment": "Get image for user",
    "code": "    protected Bitmap getImage(final User user) {\n        File avatarFile = new File(avatarDir, Integer.toString(user.getId()));\n\n        if (!avatarFile.exists() || avatarFile.length() == 0)\n            return null;\n\n        Bitmap bitmap = BitmapFactory.decodeFile(avatarFile.getAbsolutePath());\n        if (bitmap != null)\n            return Image.roundCorners(bitmap, cornerRadius);\n\n        avatarFile.delete();\n        return null;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3656,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_MUSIC_CD_ID;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3657,
    "type": "Summary",
    "comment": "Gets pool by execution policy.",
    "code": "    private Executor pool(GridClosurePolicy plc) {\n        switch (plc) {\n            case PUBLIC_POOL:\n                return pubPool;\n\n            case SYSTEM_POOL:\n                return sysPool;\n\n            case IGFS_POOL:\n                return igfsPool;\n\n            default:\n                throw new IllegalArgumentException(\"Invalid closure execution policy: \" + plc);\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3658,
    "type": "Summary",
    "comment": "Asynchronously call  org.apache.curator.framework.CuratorFramework#createContainers(String) using the given executor",
    "code": "    public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, String path)\n    {\n        return ensure(client, path, ExistsOption.createParentsAsContainers);\n    }\n",
    "label": 1,
    "rec": "Asynchronously ensure that the parents of the given path are created as containers"
  },
  {
    "id": 3659,
    "type": "Summary",
    "comment": "Is reference a tag?",
    "code": "    public static boolean isTag(final Reference ref) {\n        return ref != null && isTag(ref.getRef());\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3660,
    "type": "Summary",
    "comment": "Gets the executable path of NodeJS on the given target system.",
    "code": "    public String getExecutable() throws IOException {\n        File exe = getExeFile(getPlatform());\n        if (exe.exists()) {\n            return exe.getPath();\n        }\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Gets the executable path of NodeJS on the target system."
  },
  {
    "id": 3661,
    "type": "Summary",
    "comment": "Invoke some processor and return new value.",
    "code": "    private IgfsEntryInfo invokeAndGet(IgniteUuid id, EntryProcessor<IgniteUuid, IgfsEntryInfo, IgfsEntryInfo> proc)\n        throws IgniteCheckedException {\n        validTxState(true);\n\n        return id2InfoPrj.invoke(id, proc).get();\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3662,
    "type": "Summary",
    "comment": "Gets the current zoom mode.",
    "code": "    public int getZoomMode() {\n        return 0;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3663,
    "type": "Summary",
    "comment": "Wrapper around ISchedulingService, adds a scheduled job to be run periodically.",
    "code": "    public String addScheduledJob(int interval, IScheduledJob job) {\n        if (schedulingService == null) {\n            schedulingService = (ISchedulingService) ScopeUtils.getScopeService(scope, ISchedulingService.class, JDKSchedulingService.class, false);\n        }\n        return schedulingService.addScheduledJob(interval, job);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3664,
    "type": "Summary",
    "comment": "Free space refers to a \"max row size (without any data page specific overhead) which is guaranteed to fit into this data page\".",
    "code": "    public int getFreeSpace(ByteBuffer buf) {\n        if (getFreeItemSlots(buf) == 0)\n            return 0;\n\n        int freeSpace = getFreeSpace0(buf);\n\n        if (freeSpace < 0) {\n            assert freeSpace >= -(ITEM_SIZE + PAYLOAD_LEN_SIZE + LINK_SIZE): freeSpace;\n\n            return 0;\n        }\n\n        return freeSpace;\n    }\n",
    "label": 1,
    "rec": "Public version (never return negative value)."
  },
  {
    "id": 3665,
    "type": "Summary",
    "comment": "If this command has completed execution either successfully, via fallback or failure.",
    "code": "    public boolean isExecutionComplete() {\n        return isExecutionComplete;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3666,
    "type": "Summary",
    "comment": "Return the default task ordering",
    "code": "    public static Order defaultTaskOrder() {\n        return Order.asc(Functions.caseStatement(Task.DUE_DATE.eq(0),\n                DateUtilities.now() + DateUtilities.ONE_WEEK,\n                Task.DUE_DATE) + \" + 200000000 * \" +\n                Task.IMPORTANCE + \" + 2*\" + Task.COMPLETION_DATE);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3667,
    "type": "Summary",
    "comment": "First tries to extract and load the library from the  Class resources, but if fails, continues to try loading from the paths (if not  null), and finally  System#loadLibrary(String).",
    "code": "    public static String loadLibrary(URL[] urls, String libnameversion) {\n        if (!loadLibraries) {\n            return null;\n        }\n\n        // If we do not already have the native library file ...\n        String filename = loadedLibraries.get(libnameversion);\n        if (filename != null) {\n            return filename;\n        }\n\n        File tempFile = null;\n        UnsatisfiedLinkError loadError = null;\n        try {\n            for (URL url : urls) {\n                File file;\n                try {\n                    // ... if the URL is not already a file ...\n                    file = new File(url.toURI());\n                } catch (Exception e) {\n                    if (tempFile != null && tempFile.exists()) {\n                        tempFile.deleteOnExit();\n                    }\n                    // ... then extract it from our resources ...\n                    file = tempFile = extractResource(url, getTempDir(), null, null);\n                }\n                if (file != null && file.exists()) {\n                    filename = file.getAbsolutePath();\n                    try {\n                        // ... and load it!\n                        loadedLibraries.put(libnameversion, filename);\n                        System.load(filename);\n                        return filename;\n                    } catch (UnsatisfiedLinkError e) {\n                        loadError = e;\n                        loadedLibraries.remove(libnameversion);\n                    }\n                }\n            }\n            // ... or as last resort, try to load it via the system.\n            String libname = libnameversion.split(\"@\")[0];\n            loadedLibraries.put(libnameversion, libname);\n            System.loadLibrary(libname);\n            return libname;\n        } catch (UnsatisfiedLinkError e) {\n            loadedLibraries.remove(libnameversion);\n            if (loadError != null) {\n                e.initCause(loadError);\n            }\n            throw e;\n        } catch (IOException ex) {\n            loadedLibraries.remove(libnameversion);\n            if (loadError != null) {\n                ex.initCause(loadError);\n            }\n            Error e = new UnsatisfiedLinkError(ex.toString());\n            e.initCause(ex);\n            throw e;\n        } finally {\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.deleteOnExit();\n            }\n            // But under Windows, it won't get deleted!\n        }\n    }\n",
    "label": 1,
    "rec": "Tries to load the library from the URLs in order, extracting resources as necessary."
  },
  {
    "id": 3668,
    "type": "Summary",
    "comment": "Creates a new FilterChain based on the specified configured url filter chain and original chain.",
    "code": "    protected FilterChain createChain(List<Filter> filters, FilterChain originalChain) {\n        return new ProxiedFilterChain(originalChain, filters);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3669,
    "type": "Summary",
    "comment": "Generate a nonce for the given  SecurityAlgorithm.",
    "code": "    public static ByteString generateNonce(SecurityPolicy securityPolicy) {\n        return generateNonce(getNonceLength(securityPolicy));\n    }\n\n",
    "label": 1,
    "rec": "Generate a nonce for the given  SecurityPolicy."
  },
  {
    "id": 3670,
    "type": "Summary",
    "comment": "Encrypts the  plaintext with Poly1305 authentication based on  additionalData.",
    "code": "  public byte[] encrypt(final byte[] plaintext, final byte[] additionalData)\n      throws GeneralSecurityException {\n    ByteBuffer ciphertext = ByteBuffer.allocate(\n        nonceSizeInBytes() + plaintext.length + MAC_TAG_SIZE_IN_BYTES);\n    encrypt(ciphertext, plaintext, additionalData);\n    return ciphertext.array();\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3671,
    "type": "Summary",
    "comment": "Decrypts the byte array according to the current connection state.",
    "code": "\tprivate byte[] decryptFragment(byte[] ciphertextFragment) throws GeneralSecurityException {\r\n\t\tif (session == null) {\r\n\t\t\treturn ciphertextFragment;\r\n\t\t}\r\n\r\n\t\tbyte[] fragment = ciphertextFragment;\r\n\r\n\t\tCipherSuite cipherSuite = session.getReadState().getCipherSuite();\r\n\t\tLOGGER.log(Level.FINER, \"Decrypting record fragment using current read state\\n{0}\", session.getReadState());\r\n\t\t\r\n\t\tswitch (cipherSuite.getCipherType()) {\r\n\t\tcase NULL:\r\n\t\t\t// do nothing\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase AEAD:\r\n\t\t\tfragment = decryptAEAD(ciphertextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase BLOCK:\r\n\t\t\tfragment = decryptBlockCipher(ciphertextFragment);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase STREAM:\r\n\t\t\t// Currently, Scandium does not support any stream ciphers\r\n\t\t\t// RC4 is explicitly ruled out from being used in DTLS\r\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.2\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn fragment;\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Decrypts a TLSCiphertext.fragment according to the current DTLS connection state."
  },
  {
    "id": 3672,
    "type": "Summary",
    "comment": "Retrieve the total end-to-end execution time (in milliseconds) for  HystrixCommand#execute() or  HystrixCommand#queue() at a given percentile.",
    "code": "    public int getTotalTimePercentile(double percentile) {\n        if (rollingLatencyDistribution.hasValue()) {\n            return (int) rollingLatencyDistribution.getValue().getTotalLatencyPercentile(percentile);\n        } else {\n            return 0;\n        }\n        //return percentileTotal.getPercentile(percentile);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3673,
    "type": "Summary",
    "comment": "Checks if there are activities that have been matched to the plug-in in which the provider has been contributed and if those activities are enabled.",
    "code": "    private boolean areActivitiesEnabled(final String itemID) {\n        if (!WorkbenchActivityHelper.isFiltering())\n            return true;\n\n        IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI\n            .getWorkbench().getActivitySupport();\n\n        // check if the provider has been matched to a disabled activity id\n        IIdentifier id = workbenchActivitySupport.getActivityManager()\n            .getIdentifier(\n                WorkbenchActivityHelper\n                    .createUnifiedId(getPluginContribution()));\n        if (id != null && !id.isEnabled()) {\n            return false;\n        }\n\n        // now check if the item has been matched to a disabled activity id\n        id = workbenchActivitySupport.getActivityManager().getIdentifier(\n            WorkbenchActivityHelper.createUnifiedId(new IPluginContribution() {\n\n                public String getLocalId() {\n                    return itemID;\n                }\n\n                public String getPluginId() {\n                    return getPluginContribution().getPluginId();\n                }\n            }));\n        if (id != null && !id.isEnabled()) {\n            return false;\n        }\n\n        return true;\n    }\n\n",
    "label": 1,
    "rec": "Checks if there are activities that have been matched to the plug-in or id in which the item has been contributed and if at least one of those matching activities are enabled."
  },
  {
    "id": 3674,
    "type": "Summary",
    "comment": "Returns the sampling rate for stochastic gradient tree boosting.",
    "code": "    public double getSamplingRate() {\n        return subsample;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3675,
    "type": "Summary",
    "comment": "A utility method to return the active part if it implements the IDiagramWorkbenchPart interface",
    "code": "\tprotected IDiagramWorkbenchPart getDiagramWorkbenchPart() {\n\t\tIDiagramWorkbenchPart diagramPart = null;\n\t\tIWorkbenchPart part = getWorkbenchPart();\n\t\t\n\t\tif (part instanceof IDiagramWorkbenchPart) {\n\t\t\tdiagramPart = (IDiagramWorkbenchPart) part;\n\t\t\t\n\t\t} else {\n\t\t\tdiagramPart = (IDiagramWorkbenchPart) part\n\t\t\t\t\t.getAdapter(IDiagramWorkbenchPart.class);\n\t\t}\n\n\t\treturn diagramPart;\n\t}\n\n",
    "label": 1,
    "rec": "A utility method to return the active part if it implements or adapts to the IDiagramWorkbenchPart interface"
  },
  {
    "id": 3676,
    "type": "Summary",
    "comment": "Execute getFallback() within protection of a semaphore that limits number of concurrent executions.",
    "code": "    private Observable<R> getFallbackOrThrowException(final HystrixEventType eventType, final FailureType failureType, final String message, final Exception originalException) {\n        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();\n\n        if (properties.fallbackEnabled().get()) {\n            /* fallback behavior is permitted so attempt */\n            // record the executionResult\n            // do this before executing fallback so it can be queried from within getFallback (see See https://github.com/Netflix/Hystrix/pull/144)\n            executionResult = executionResult.addEvents(eventType);\n            final AbstractCommand<R> _cmd = this;\n\n            final TryableSemaphore fallbackSemaphore = getFallbackSemaphore();\n\n            Observable<R> fallbackExecutionChain;\n\n            // acquire a permit\n            if (fallbackSemaphore.tryAcquire()) {\n                executionHook.onFallbackStart(this);\n\n                try {\n                    fallbackExecutionChain = getFallbackObservable();\n                } catch (Throwable t) {\n                    // getFallback() is user provided and can throw so we catch it and turn it into Observable.error\n                    fallbackExecutionChain = Observable.error(t);\n                }\n\n                fallbackExecutionChain =  fallbackExecutionChain\n                        .lift(new FallbackHookApplication(_cmd))\n                        .lift(new DeprecatedOnFallbackHookApplication(_cmd))\n                        .doOnTerminate(new Action0() {\n\n                            @Override\n                            public void call() {\n                                fallbackSemaphore.release();\n                            }\n                        });\n            } else {\n                metrics.markFallbackRejection();\n                executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_REJECTION);\n                logger.debug(\"HystrixCommand Fallback Rejection.\"); // debug only since we're throwing the exception and someone higher will do something with it\n                // if we couldn't acquire a permit, we \"fail fast\" by throwing an exception\n                return Observable.error(new HystrixRuntimeException(FailureType.REJECTED_SEMAPHORE_FALLBACK, this.getClass(), getLogMessagePrefix() + \" fallback execution rejected.\", null, null));\n            }\n\n            return fallbackExecutionChain.doOnNext(new Action1<R>() {\n                @Override\n                public void call(R r) {\n                    if (shouldOutputOnNextEvents()) {\n                        executionResult = executionResult.addEmission(HystrixEventType.FALLBACK_EMIT);\n                        metrics.markFallbackEmit();\n                    }\n                }\n            }).doOnCompleted(new Action0() {\n\n                @Override\n                public void call() {\n                    // mark fallback on counter\n                    metrics.markFallbackSuccess();\n                    // record the executionResult\n                    executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_SUCCESS);\n                }\n\n            }).onErrorResumeNext(new Func1<Throwable, Observable<R>>() {\n\n                @Override\n                public Observable<R> call(Throwable t) {\n                    Exception e = originalException;\n                    Exception fe = getExceptionFromThrowable(t);\n\n\n                    if (fe instanceof UnsupportedOperationException) {\n                        logger.debug(\"No fallback for HystrixCommand. \", fe); // debug only since we're throwing the exception and someone higher will do something with it\n                        /* executionHook for all errors */\n                        e = wrapWithOnErrorHook(failureType, e);\n\n                        return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and no fallback available.\", e, fe));\n                    } else {\n                        logger.debug(\"HystrixCommand execution \" + failureType.name() + \" and fallback failed.\", fe);\n                        metrics.markFallbackFailure();\n                        // record the executionResult\n                        executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_FAILURE);\n\n                        /* executionHook for all errors */\n                        e = wrapWithOnErrorHook(failureType, e);\n\n                        return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback failed.\", e, fe));\n                    }\n                }\n\n            }).doOnTerminate(new Action0() {\n\n                @Override\n                public void call() {\n                    // record that we're completed (to handle non-successful events we do it here as well as at the end of executeCommand\n                    isExecutionComplete.set(true);\n                }\n\n            }).doOnEach(new Action1<Notification<? super R>>() {\n\n                @Override\n                public void call(Notification<? super R> n) {\n                    setRequestContextIfNeeded(currentRequestContext);\n                }\n\n            });\n        } else {\n            /* fallback is disabled so throw HystrixRuntimeException */\n            Exception e = originalException;\n\n            logger.debug(\"Fallback disabled for HystrixCommand so will throw HystrixRuntimeException. \", e); // debug only since we're throwing the exception and someone higher will do something with it\n            // record the executionResult\n            executionResult = executionResult.addEvents(eventType);\n\n            /* executionHook for all errors */\n            e = wrapWithOnErrorHook(failureType, e);\n            return Observable.<R> error(new HystrixRuntimeException(failureType, this.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback disabled.\", e, null)).doOnTerminate(new Action0() {\n\n                @Override\n                public void call() {\n                    // record that we're completed (to handle non-successful events we do it here as well as at the end of executeCommand\n                    isExecutionComplete.set(true);\n                }\n\n            }).doOnEach(new Action1<Notification<? super R>>() {\n\n                @Override\n                public void call(Notification<? super R> n) {\n                    setRequestContextIfNeeded(currentRequestContext);\n                }\n\n            });\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3677,
    "type": "Summary",
    "comment": "Return the number of resources for the given key that are currently sitting idle in the pool waiting to be checked out.",
    "code": "    public int getCheckedInResourcesCount(K key) {\n        int rc = 0;\n        if(!resourcePoolMap.containsKey(key)) {\n            return rc;\n        }\n        try {\n            Pool<V> resourcePool = getResourcePoolForExistingKey(key);\n            rc = resourcePool.queue.size();\n        } catch(IllegalArgumentException iae) {\n            logger.debug(\"getCheckedInResourceCount called on invalid key: \", iae);\n        }\n        return rc;\n    }\n\n",
    "label": 1,
    "rec": "Count the number of checked in (idle) resources for a specific pool."
  },
  {
    "id": 3678,
    "type": "Summary",
    "comment": "Returns whether the camera has started showing its preview.",
    "code": "    public boolean isStarted() {\n        return mCameraController.getState() >= CameraController.STATE_STARTED;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3679,
    "type": "Summary",
    "comment": "Creates a  LifecycleScopeProvider for Android Views.",
    "code": "  public static ScopeProvider from(View view) {\n    if (view == null) {\n      throw new NullPointerException(\"view == null\");\n    }\n    return new ViewScopeProvider(view);\n  }\n",
    "label": 1,
    "rec": "Creates a  ScopeProvider for Android Views."
  },
  {
    "id": 3680,
    "type": "Summary",
    "comment": "Predict the class of an instance.",
    "code": "    public int predict(SparseArray x, double[] posteriori) {\n        if (!isGoodInstance(x)) {\n            return Integer.MIN_VALUE;\n        }\n\n        for (int i = 0; i < k; i++) {\n            double logprob;\n\n            switch (model) {\n                case MULTINOMIAL:\n                case POLYAURN:\n                    logprob = Math.log(priori[i]);\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += e.x * logcondprob[i][e.i];\n                        }\n                    }\n                    break;\n\n                case BERNOULLI:\n                    logprob = Math.log(priori[i]);\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob += logcondprob[i][e.i];\n                        } else {\n                            logprob += Math.log(1.0 - Math.exp(logcondprob[i][e.i]));\n                        }\n                    }\n                    break;\n\n                case CNB:\n                case WCNB:\n                case TWCNB:\n                    logprob = 0.0;\n                    for (SparseArray.Entry e : x) {\n                        if (e.x > 0) {\n                            logprob -= e.x * logcondprob[i][e.i];\n                        }\n                    }\n                    break;\n\n                default:\n                    // we should never reach here\n                    throw new IllegalStateException(\"Unknown model: \" + model);\n            }\n\n            posteriori[i] = logprob;\n        }\n\n        MathEx.softmax(posteriori);\n        return MathEx.whichMax(posteriori);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3681,
    "type": "Summary",
    "comment": "Gets all alive remote nodes with at least one cache configured.",
    "code": "        Collection<ClusterNode> aliveNodesWithCaches(final long topVer) {\n            return filter(topVer, aliveNodesWithCaches);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3682,
    "type": "Summary",
    "comment": "Returns whether the type is a member of the union.",
    "code": "  public boolean contains(String memberKey)\n  {\n    return _memberKeyToIndexMap.containsKey(memberKey);\n  }\n\n",
    "label": 1,
    "rec": "Returns whether the passed in member key maps to one of the members of the union."
  },
  {
    "id": 3683,
    "type": "Summary",
    "comment": "OAuth grant page.",
    "code": "    public Response processConsent(final MultivaluedMap<String, String> formData) {\n        event.event(EventType.LOGIN).detail(Details.RESPONSE_TYPE, \"code\");\n\n\n        if (!checkSsl()) {\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, headers, Messages.HTTPS_REQUIRED);\n        }\n\n        String code = formData.getFirst(\"code\");\n\n        ClientSessionCode accessCode = ClientSessionCode.parse(code, session, realm);\n        if (accessCode == null || !accessCode.isValid(ClientSessionModel.Action.OAUTH_GRANT)) {\n            event.error(Errors.INVALID_CODE);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, headers, Messages.INVALID_ACCESS_CODE);\n        }\n        ClientSessionModel clientSession = accessCode.getClientSession();\n        event.detail(Details.CODE_ID, clientSession.getId());\n\n        String redirect = clientSession.getRedirectUri();\n\n        event.client(clientSession.getClient())\n                .user(clientSession.getUserSession().getUser())\n                .detail(Details.RESPONSE_TYPE, \"code\")\n                .detail(Details.REDIRECT_URI, redirect);\n\n        UserSessionModel userSession = clientSession.getUserSession();\n        if (userSession != null) {\n            event.detail(Details.AUTH_METHOD, userSession.getAuthMethod());\n            event.detail(Details.USERNAME, userSession.getLoginUsername());\n            if (userSession.isRememberMe()) {\n                event.detail(Details.REMEMBER_ME, \"true\");\n            }\n        }\n\n        if (!AuthenticationManager.isSessionValid(realm, userSession)) {\n            AuthenticationManager.logout(session, realm, userSession, uriInfo, clientConnection, headers);\n            event.error(Errors.INVALID_CODE);\n            return Flows.forwardToSecurityFailurePage(session, realm, uriInfo, headers, Messages.SESSION_NOT_ACTIVE);\n        }\n        event.session(userSession);\n\n        LoginProtocol protocol = session.getProvider(LoginProtocol.class, clientSession.getAuthMethod());\n        protocol.setRealm(realm)\n                .setHttpHeaders(headers)\n                .setUriInfo(uriInfo);\n        if (formData.containsKey(\"cancel\")) {\n            event.error(Errors.REJECTED_BY_USER);\n            return protocol.consentDenied(clientSession);\n        }\n\n        event.success();\n\n        return authManager.redirectAfterSuccessfulFlow(session, realm, userSession, clientSession, request, uriInfo, clientConnection);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3684,
    "type": "Summary",
    "comment": "Resolve the  Repo referenced by the given intent",
    "code": "    public static Repository repoFrom(Intent intent) {\n        String repoName = intent.getStringExtra(EXTRA_REPOSITORY_NAME);\n        String repoOwner = intent.getStringExtra(EXTRA_REPOSITORY_OWNER);\n        return InfoUtils.createRepoFromData(repoOwner, repoName);\n    }\n",
    "label": 1,
    "rec": "Resolve the  Repository referenced by the given intent"
  },
  {
    "id": 3685,
    "type": "Summary",
    "comment": "Execute getFallback() within protection of a semaphore that limits number of concurrent executions.",
    "code": "    private Observable<R> getFallbackOrThrowException(final AbstractCommand<R> _cmd, final HystrixEventType eventType, final FailureType failureType, final String message, final Exception originalException) {\n        final HystrixRequestContext requestContext = HystrixRequestContext.getContextForCurrentThread();\n        long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n        // record the executionResult\n        // do this before executing fallback so it can be queried from within getFallback (see See https://github.com/Netflix/Hystrix/pull/144)\n        executionResult = executionResult.addEvent((int) latency, eventType);\n\n        if (isUnrecoverable(originalException)) {\n            Exception e = originalException;\n            logger.error(\"Unrecoverable Error for HystrixCommand so will throw HystrixRuntimeException and not apply fallback. \", e);\n\n            /* executionHook for all errors */\n            e = wrapWithOnErrorHook(failureType, e);\n            return Observable.error(new HystrixRuntimeException(failureType, this.getClass(), getLogMessagePrefix() + \" \" + message + \" and encountered unrecoverable error.\", e, null));\n        } else {\n            if (isRecoverableError(originalException)) {\n                logger.warn(\"Recovered from java.lang.Error by serving Hystrix fallback\", originalException);\n            }\n\n            if (properties.fallbackEnabled().get()) {\n                /* fallback behavior is permitted so attempt */\n\n                final Action1<Notification<? super R>> setRequestContext = new Action1<Notification<? super R>>() {\n                    @Override\n                    public void call(Notification<? super R> rNotification) {\n                        setRequestContextIfNeeded(requestContext);\n                    }\n                };\n\n                final Action1<R> markFallbackEmit = new Action1<R>() {\n                    @Override\n                    public void call(R r) {\n                        if (shouldOutputOnNextEvents()) {\n                            executionResult = executionResult.addEvent(HystrixEventType.FALLBACK_EMIT);\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_EMIT, commandKey);\n                        }\n                    }\n                };\n\n                final Action0 markFallbackCompleted = new Action0() {\n                    @Override\n                    public void call() {\n                        long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n                        eventNotifier.markEvent(HystrixEventType.FALLBACK_SUCCESS, commandKey);\n                        executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_SUCCESS);\n                    }\n                };\n\n                final Func1<Throwable, Observable<R>> handleFallbackError = new Func1<Throwable, Observable<R>>() {\n                    @Override\n                    public Observable<R> call(Throwable t) {\n                        Exception e = originalException;\n                        Exception fe = getExceptionFromThrowable(t);\n\n                        if (fe instanceof UnsupportedOperationException) {\n                            long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n                            logger.debug(\"No fallback for HystrixCommand. \", fe); // debug only since we're throwing the exception and someone higher will do something with it\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_MISSING, commandKey);\n                            executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_MISSING);\n\n                            /* executionHook for all errors */\n                            e = wrapWithOnErrorHook(failureType, e);\n\n                            return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and no fallback available.\", e, fe));\n                        } else {\n                            long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();\n                            logger.debug(\"HystrixCommand execution \" + failureType.name() + \" and fallback failed.\", fe);\n                            eventNotifier.markEvent(HystrixEventType.FALLBACK_FAILURE, commandKey);\n                            executionResult = executionResult.addEvent((int) latency, HystrixEventType.FALLBACK_FAILURE);\n\n                            /* executionHook for all errors */\n                            e = wrapWithOnErrorHook(failureType, e);\n\n                            return Observable.error(new HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + \" \" + message + \" and fallback failed.\", e, fe));\n                        }\n                    }\n                };\n\n                final TryableSemaphore fallbackSemaphore = getFallbackSemaphore();\n                final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false);\n                final Action0 singleSemaphoreRelease = new Action0() {\n                    @Override\n                    public void call() {\n                        if (semaphoreHasBeenReleased.compareAndSet(false, true)) {\n                            fallbackSemaphore.release();\n                        }\n                    }\n                };\n\n                Observable<R> fallbackExecutionChain;\n\n                // acquire a permit\n                if (fallbackSemaphore.tryAcquire()) {\n                    try {\n                        if (isFallbackUserSupplied(this)) {\n                            executionHook.onFallbackStart(this);\n                            fallbackExecutionChain = getFallbackObservable();\n                        } else {\n                            //same logic as above without the hook invocation\n                            fallbackExecutionChain = getFallbackObservable();\n                        }\n                    } catch (Throwable ex) {\n                        //If hook or user-fallback throws, then use that as the result of the fallback lookup\n                        fallbackExecutionChain = Observable.error(ex);\n                    }\n\n                    return fallbackExecutionChain\n                            .doOnEach(setRequestContext)\n                            .lift(new FallbackHookApplication(_cmd))\n                            .lift(new DeprecatedOnFallbackHookApplication(_cmd))\n                            .doOnNext(markFallbackEmit)\n                            .doOnCompleted(markFallbackCompleted)\n                            .onErrorResumeNext(handleFallbackError)\n                            .doOnTerminate(singleSemaphoreRelease)\n                            .doOnUnsubscribe(singleSemaphoreRelease);\n                } else {\n                   return handleFallbackRejectionByEmittingError();\n                }\n            } else {\n                return handleFallbackDisabledByEmittingError(originalException, failureType, message);\n            }\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3686,
    "type": "Summary",
    "comment": "Invalidates and then revalidates the auth token for the currently logged in user",
    "code": "    public static String validateAuthToken(Context c, String token) throws GoogleTasksException {\n        GoogleAccountManager accountManager = new GoogleAccountManager(ContextManager.getContext());\n\n        GtasksService testService = new GtasksService(token);\n        try {\n            testService.ping();\n            return token;\n        } catch (IOException i) { //If fail, token may have expired -- get a new one and return that\n            String accountName = Preferences.getStringValue(GtasksPreferenceService.PREF_USER_NAME);\n            Account a = accountManager.getAccountByName(accountName);\n            if (a == null) {\n                throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountNotFound, accountName));\n            }\n\n            accountManager.invalidateAuthToken(token);\n            AccountManagerFuture<Bundle> future = accountManager.manager.getAuthToken(a, GtasksService.AUTH_TOKEN_TYPE, false, null, null);\n\n            try {\n                if (future.getResult().containsKey(AccountManager.KEY_AUTHTOKEN)) {\n                    Bundle result = future.getResult();\n                    token = result.getString(AccountManager.KEY_AUTHTOKEN);\n                    testService = new GtasksService(token);\n                    try { //Make sure the new token works--if not, we may have network problems\n                        testService.ping();\n                        return token;\n                    } catch (IOException i2) {\n                        i2.printStackTrace();\n                        String manufacturer = android.os.Build.MANUFACTURER.toLowerCase();\n                        if (!manufacturer.contains(\"samsung\")) { // Try with the notifyAuthFailure set to true in case it was that that broke things\n                            accountManager.invalidateAuthToken(token);\n                            future = accountManager.manager.getAuthToken(a, GtasksService.AUTH_TOKEN_TYPE, true, null, null);\n                            try {\n                                if (future.getResult().containsKey(AccountManager.KEY_AUTHTOKEN)) {\n                                    result = future.getResult();\n                                    token = result.getString(AccountManager.KEY_AUTHTOKEN);\n                                    testService = new GtasksService(token);\n                                    try {\n                                        testService.ping();\n                                        return token;\n                                    } catch (IOException i3) {\n                                        i3.printStackTrace();\n                                        throw new GoogleTasksException(c.getString(R.string.gtasks_error_authRefresh));\n                                    }\n                                } else {\n                                    throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountManager));\n                                }\n                            } catch (Exception e) {\n                                throw new GoogleTasksException(e.getLocalizedMessage());\n                            }\n                        } else {\n                            throw new GoogleTasksException(c.getString(R.string.gtasks_error_authRefresh));\n                        }\n                    }\n                } else {\n                    throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountManager));\n                }\n            } catch (Exception e) {\n                throw new GoogleTasksException(e.getLocalizedMessage());\n            }\n\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3687,
    "type": "Summary",
    "comment": "Returns the username and password given by the user.",
    "code": "\tpublic AuthenticationInfo getResult() {\n\t\treturn result;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the authentication information given by the user, or null if the user cancelled"
  },
  {
    "id": 3688,
    "type": "Summary",
    "comment": "Convenience method that can decode a QR Code represented as a 2D array of booleans.",
    "code": "  public DecoderResult decode(boolean[][] image) throws ReaderException {\n    int dimension = image.length;\n    BitMatrix bits = new BitMatrix(dimension);\n    for (int i = 0; i < dimension; i++) {\n      for (int j = 0; j < dimension; j++) {\n        if (image[i][j]) {\n          bits.set(i, j);\n        }\n      }\n    }\n    return decode(bits);\n  }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3689,
    "type": "Summary",
    "comment": "Read the whole array of entries",
    "code": "\tpublic ArrayList<Word> getWords()\n\t{\n\t\treturn words;\n\t}\n\n",
    "label": 1,
    "rec": "Read the whole array of words"
  },
  {
    "id": 3690,
    "type": "Summary",
    "comment": "Number of emissions of the execution of a fallback.",
    "code": "    public int getNumberFallbackEmissions() {\n        return executionResult.getEventCounts().getCount(HystrixEventType.FALLBACK_EMIT);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3691,
    "type": "Summary",
    "comment": "Converts this string to lowercase, using the rules of the user's default locale.",
    "code": "    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n",
    "label": 1,
    "rec": "Converts the characters in this string to lowercase, using the default"
  },
  {
    "id": 3692,
    "type": "Summary",
    "comment": "Gets configured dispatch-rate from namespace policies.",
    "code": "    public DispatchRate getPoliciesDispatchRate() {\n        final NamespaceName namespace = TopicName.get(this.topicName).getNamespaceObject();\n        final String cluster = brokerService.pulsar().getConfiguration().getClusterName();\n        final String path = path(POLICIES, namespace.toString());\n        Optional<Policies> policies = Optional.empty();\n        try {\n            policies = brokerService.pulsar().getConfigurationCache().policiesCache().getAsync(path)\n                    .get(cacheTimeOutInSec, SECONDS);\n        } catch (Exception e) {\n            log.warn(\"Failed to get message-rate for {} subscription {}\", this.topicName, this.subscriptionName, e);\n        }\n        // return policy-dispatch rate only if it's enabled in policies\n        return policies.map(p -> {\n            DispatchRate dispatchRate;\n            if (subscriptionName == null) {\n                dispatchRate = p.clusterDispatchRate.get(cluster);\n            } else {\n                dispatchRate = p.subscriptionDispatchRate.get(cluster);\n            }\n            return isDispatchRateEnabled(dispatchRate) ? dispatchRate : null;\n        }).orElse(null);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3693,
    "type": "Summary",
    "comment": "Gets collection of nodes with at least one cache configured.",
    "code": "        Collection<ClusterNode> allNodesWithCaches(final long topVer) {\n            return filter(topVer, allNodesWithCaches);\n        }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3694,
    "type": "Summary",
    "comment": "Returns the default response for method calls on the mock object.",
    "code": "  public IDefaultResponse getDefaultResponse() {\n    return defaultResponse;\n  }\n\n",
    "label": 1,
    "rec": "Returns the default response strategy for the mock object."
  },
  {
    "id": 3695,
    "type": "Summary",
    "comment": "Replacer for remote filter.",
    "code": "    Object writeReplace() throws ObjectStreamException {\n        if (javaFilter != null)\n            return javaFilter;\n\n        return filter == null ? null : platformCtx.createContinuousQueryFilter(filter);\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3696,
    "type": "Summary",
    "comment": "Create a  Claimer on this RingBuffer that tracks dependent  EntryConsumers.",
    "code": "    public ProducerBarrier<T> createClaimer(final int bufferReserve, final EntryConsumer... entryConsumers)\n    {\n        return new RingBufferProducerBarrier<T>(this, bufferReserve, entryConsumers);\n    }\n\n",
    "label": 1,
    "rec": "Create a  ProducerBarrier on this RingBuffer that tracks dependent  EntryConsumers."
  },
  {
    "id": 3697,
    "type": "Summary",
    "comment": "boolean argument that matches both given matchers.",
    "code": "    public static boolean and(boolean first, boolean second) {\n        MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd(); \n        return false;\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3698,
    "type": "Summary",
    "comment": "Gets pool name by execution policy.",
    "code": "    private String poolName(byte plc) {\n        switch (plc) {\n            case PUBLIC_POOL:\n                return \"public\";\n\n            case SYSTEM_POOL:\n                return \"system\";\n\n            case IGFS_POOL:\n                return \"igfs\";\n\n            default:\n                return \"unknown\";\n        }\n    }\n",
    "label": 0,
    "rec": ""
  },
  {
    "id": 3699,
    "type": "Summary",
    "comment": "Read a property.",
    "code": "    public Object getValue(Object object) {\n        return propagation.getValue(object);\n    }\n\n",
    "label": 1,
    "rec": "Gets property's value."
  },
  {
    "id": 3700,
    "type": "Summary",
    "comment": "This method uses a substring to check case-insensitive equality.",
    "code": "    public static boolean startsWithIgnoreCase(final String string, final String prefix) throws IllegalArgumentException, NullPointerException {\n        Validate.notNull(string, \"Cannot check a null string for a match\");\n        if (string.length() < prefix.length()) {\n            return false;\n        }\n        return string.regionMatches(true, 0, prefix, 0, prefix.length());\n    }\n",
    "label": 1,
    "rec": "This method uses a region to check case-insensitive equality."
  },
  {
    "id": 3701,
    "type": "Summary",
    "comment": "Indicates whether this parent node has child nodes.",
    "code": "\tpublic boolean hasChildren() {\r\n\t\treturn children().iterator().hasNext();\r\n\t}\r\n\n",
    "label": 1,
    "rec": "Indicates whether this parent node has child nodes, including text nodes."
  },
  {
    "id": 3702,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_BPM  ;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3703,
    "type": "Summary",
    "comment": "Returns a data holder for the given file",
    "code": "    public static WorldDataHolder load(String worldName, File groupsFile, File usersFile) throws FileNotFoundException, IOException {\n    \tWorldDataHolder ph = new WorldDataHolder(worldName);\n    \t\n    \tGroupManager.setLoaded(false);\n    \tloadGroups(ph, groupsFile);\n    \tloadUsers(ph, usersFile);\n    \tGroupManager.setLoaded(true);\n    \t\n    \treturn ph;\n    }\n",
    "label": 1,
    "rec": "Returns a NEW data holder containing data read from the files"
  },
  {
    "id": 3704,
    "type": "Summary",
    "comment": "randomly choose one node from scope if scope starts with ~, choose one from the all datanodes except for the ones in scope; otherwise, choose one from scope",
    "code": "  public Node chooseRandom(String scope) {\n    netlock.readLock().lock();\n    try {\n      if (scope.startsWith(\"~\")) {\n        return chooseRandom(NodeBase.ROOT, scope.substring(1));\n      } else {\n        return chooseRandom(scope, null);\n      }\n    } finally {\n      netlock.readLock().unlock();\n    }\n  }\n\n",
    "label": 1,
    "rec": "randomly choose one node from scope if scope starts with ~, choose one from the all nodes except for the ones in scope; otherwise, choose one from scope"
  },
  {
    "id": 3705,
    "type": "Summary",
    "comment": "Asynchronously renders the given resource value (which should refer to a drawable) and returns it as an image.",
    "code": "  @Nullable\n  public BufferedImage renderDrawable(ResourceValue drawableResourceValue) {\n    if (drawableResourceValue == null) {\n      return null;\n    }\n\n    HardwareConfig hardwareConfig = myHardwareConfigHelper.getConfig();\n\n    Module module = myRenderService.getModule();\n    final DrawableParams params =\n      new DrawableParams(drawableResourceValue, module, hardwareConfig, getResourceResolver(), myLayoutlibCallback,\n                         myMinSdkVersion.getApiLevel(), myTargetSdkVersion.getApiLevel(), myLogger);\n    params.setForceNoDecor();\n    params.setAssetRepository(myAssetRepository);\n\n    try {\n      Result result = RenderService.runRenderAction(new Callable<Result>() {\n        @Override\n        public Result call() throws Exception {\n          return myLayoutLib.renderDrawable(params);\n        }\n      });\n\n      if (result != null && result.isSuccess()) {\n        Object data = result.getData();\n        if (data instanceof BufferedImage) {\n          return (BufferedImage)data;\n        }\n      }\n    }\n    catch (final Exception e) {\n      // ignore\n    }\n\n    return null;\n  }\n\n",
    "label": 1,
    "rec": "Renders the given resource value (which should refer to a drawable) and returns it as an image"
  },
  {
    "id": 3706,
    "type": "Summary",
    "comment": "Post each iteration, we do things:  print debug information adjust learning rate check if converged ",
    "code": "\tprotected boolean isConverged(int iter) {\n\n\t\t// print out debug info\n\t\tif (verbose) {\n\t\t\tLogs.debug(\"{}{} iter {}: errs = {}, delta_errs = {}, loss = {}, delta_loss = {}, learn_rate = {}\",\n\t\t\t\t\tnew Object[] { algoName, foldInfo, iter, (float) errs, (float) (last_errs - errs), (float) loss,\n\t\t\t\t\t\t\t(float) (Math.abs(last_loss) - Math.abs(loss)), (float) lRate });\n\t\t}\n\n\t\tif (Double.isNaN(loss)) {\n\t\t\tLogs.error(\"Loss = NaN: current settings cannot train the recommender! Try other settings instead!\");\n\t\t\tSystem.exit(-1);\n\t\t}\n\n\t\t// check if converged\n\t\tboolean cond1 = (errs < 1e-5);\n\t\tboolean cond2 = (last_errs >= errs && last_errs - errs < 1e-5);\n\t\tboolean converged = cond1 || cond2;\n\t\t\n\t\t// if not converged, update learning rate\n\t\tif(!converged)\n\t\t\tupdateLRate(iter);\n\t\t\n\t\treturn converged;\n\t}\n",
    "label": 1,
    "rec": "Post each iteration, we do things:  print debug information check if converged if not, adjust learning rate "
  },
  {
    "id": 3707,
    "type": "Summary",
    "comment": "Calculates the calories expenditure between two locations.",
    "code": "  public static double getCalories(Location start, Location stop, double grade, int weight,\n      ActivityType activityType) {\n    if (ActivityType.CYCLING == activityType) {\n      return calculateCaloriesCycling(start, stop, grade, weight);\n    } else {\n      return calculateCaloriesFoot(start, stop, grade, weight);\n    }\n  }\n\n",
    "label": 1,
    "rec": "Calculates the calories between two locations."
  },
  {
    "id": 3708,
    "type": "Summary",
    "comment": "Finds all Customers and returns a  PagedCollection for paging through them starting at the first page.",
    "code": "    public ResourceCollection<Customer> all() {\n        return all(1);\n    }\n\n",
    "label": 1,
    "rec": "Finds all Customers and returns a  ResourceCollection for paging through them starting at the first page."
  },
  {
    "id": 3709,
    "type": "Summary",
    "comment": "Check is the clicked happened in the miniature  DesignSurface representation",
    "code": "    public boolean isInDesignSurfaceRectangle(MouseEvent e) {\n      assert myDesignSurface != null;\n      return e.getX() > myDesignSurfaceOffset.x + myCenterOffset.x\n             && e.getX() < myDesignSurfaceOffset.x + myCenterOffset.x + myDesignSurface.getWidth() * myScreenViewScale\n             && e.getY() > myDesignSurfaceOffset.y + myCenterOffset.y\n             && e.getY() < myDesignSurfaceOffset.y + myCenterOffset.y + myDesignSurface.getHeight() * myScreenViewScale;\n    }\n\n",
    "label": 1,
    "rec": "Check is the clicked happened in the miniature  NlDesignSurface representation"
  },
  {
    "id": 3710,
    "type": "Summary",
    "comment": "Returns the auto increment column in this table if there is one.",
    "code": "    public Column[] getAutoIncrementColumn()\n    {\n        Collection autoIncrColumns = CollectionUtils.select(_columns, new Predicate() {\n            public boolean evaluate(Object input) {\n                return ((Column)input).isAutoIncrement();\n            }\n        });\n\n        return (Column[])autoIncrColumns.toArray(new Column[autoIncrColumns.size()]);\n    }\n\n",
    "label": 1,
    "rec": "Returns the auto increment columns in this table."
  },
  {
    "id": 3711,
    "type": "Summary",
    "comment": "Look up the email address for a user in the directory.",
    "code": "    protected String findMailAddressFor(String userName) {\n        if (configuration.isValid()) {\n            Matcher matcher = configuration.getUserNamePattern().matcher(userName);\n            if (matcher.matches()) {\n                int groupCount = matcher.groupCount();\n                // This array is declared as an Object[] to ensure it's passed\n                // correctly via varargs.\n                Object[] parts = new String[groupCount + 1];\n                for (int i = 0; i < groupCount; i++) {\n                    parts[i] = matcher.group(i + 1);\n                }\n                return String.format(configuration.getEmailAddressPattern(), parts);\n            }\n        }\n        return null;\n    }\n\n",
    "label": 1,
    "rec": "Transform a username into a email address using regular expressions and java.lang.String.format()."
  },
  {
    "id": 3712,
    "type": "Summary",
    "comment": "Parse the output from the compiler into a list of CompilerError objects",
    "code": "    protected static List<CompilerMessage> parseModernStream(BufferedReader input) throws IOException {\n        List<CompilerMessage> messages = new ArrayList<CompilerMessage>();\n        String type = null;\n        String file = null;\n        int lineNr = -1;\n        StringBuilder messageBuffer = new StringBuilder();\n        for (String line = input.readLine(); line != null; line = input.readLine()) {\n            Matcher matcher = LINE_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                addMessageIfFound(messages, type, file, lineNr, messageBuffer.toString());\n                /* String errorNr = */matcher.group(1);\n                type = matcher.group(2);\n                file = matcher.group(3);\n                String lineNumberString = matcher.group(5);\n                if (lineNumberString != null) {\n                    lineNr = Integer.parseInt(lineNumberString);\n                } else {\n                    lineNr = -1;\n                }\n                messageBuffer = new StringBuilder();\n            } else {\n                // context line\n                if (!SEPARATOR.equals(line) && line.trim().length() > 0) {\n                    messageBuffer.append(EOL).append(line);\n                }\n            }\n        }\n        addMessageIfFound(messages, type, file, lineNr, messageBuffer.toString());\n        return messages;\n    }\n\n",
    "label": 1,
    "rec": "Parse the output from the compiler into a list of CompilerMessage objects"
  },
  {
    "id": 3713,
    "type": "Summary",
    "comment": "Return one of the managed queues - the selection method cannot be relied one.",
    "code": "    public T    getQueue()\n    {\n        Preconditions.checkState(state.get() == State.STARTED, \"Not started\");\n\n        List<String>    localPreferredQueues = Lists.newArrayList(preferredQueues);\n        if ( localPreferredQueues.size() > 0 )\n        {\n            String      key = localPreferredQueues.get(random.nextInt(localPreferredQueues.size()));\n            return queues.get(key);\n        }\n\n        List<String>    keys = Lists.newArrayList(queues.keySet());\n        String          key = keys.get(random.nextInt(keys.size()));\n        return queues.get(key);\n    }\n",
    "label": 1,
    "rec": "Return one of the managed queues - the selection method cannot be relied on."
  },
  {
    "id": 3714,
    "type": "Summary",
    "comment": "Returns the annotations infos.",
    "code": "    public AnnotationElement.Annotation[] getAnnotations() {\r\n        return getAnnotationReader().getAnnotationElements();\r\n    }\r\n\n",
    "label": 1,
    "rec": "Returns the annotations."
  },
  {
    "id": 3715,
    "type": "Summary",
    "comment": "Get the  Symbol value for the class of the given object, generally a  Descriptor, if the annotation is present.",
    "code": "    public static Set<String> getSymbolValue(Object o) {\n        if (o instanceof Describable) {\n            return getSymbolValue(((Describable) o).getDescriptor().getClass());\n        } else {\n            return getSymbolValue(o.getClass());\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get the  Symbol value(s) for the class of the given object, generally a  Descriptor, if the annotation is present."
  },
  {
    "id": 3716,
    "type": "Summary",
    "comment": "Get definition factory from appropriate servlet context.",
    "code": "    public DefinitionsFactory getDefinitionsFactory() {\n\n        return (DefinitionsFactory) applicationContext.getApplicationScope().get(DEFINITIONS_FACTORY);\n    }\n\n",
    "label": 1,
    "rec": "Get definition impl from appropriate servlet context."
  },
  {
    "id": 3717,
    "type": "Summary",
    "comment": "ReadContact",
    "code": "    @Processor\n    @InvalidateConnectionOn(exception = NotAuthenticatedException.class)\n    public Contact readContact(String objectId) {\n        return (Contact) read(ServiceSourceCollection.Contacts, objectId);\n    }\n\n",
    "label": 1,
    "rec": "Fetches the contact identified by the object id in the collection."
  },
  {
    "id": 3718,
    "type": "Summary",
    "comment": "Get the combined  ContentDeliveryUnitConfigMap list for the supplied list of selector strings.",
    "code": "    public List<ContentHandlerConfigMap> getMappings(String[] selectors) {\n        List<ContentHandlerConfigMap> combinedList = new ArrayList<ContentHandlerConfigMap>();\n\n        for(String selector : selectors) {\n            List<ContentHandlerConfigMap> selectorList = targetMapTable.get(selector.toLowerCase());\n            if(selectorList != null) {\n                combinedList.addAll(selectorList);\n            }\n        }\n\n        return combinedList;\n    }\n\n",
    "label": 1,
    "rec": "Get the combined  ContentHandlerConfigMap list for the supplied list of selector strings."
  },
  {
    "id": 3719,
    "type": "Summary",
    "comment": "Returns true if the method has a JSecurity RolesRequired or PermissionRequired annotation, false otherwise.",
    "code": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n",
    "label": 1,
    "rec": "Returns true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise."
  },
  {
    "id": 3720,
    "type": "Summary",
    "comment": "Return the total number of resources for the given key whether they are currently checked in or checked out.",
    "code": "    public int getTotalResourceCount(K key) {\n        int rc = 0;\n        if(!resourcePoolMap.containsKey(key)) {\n            return rc;\n        }\n        try {\n            Pool<V> resourcePool = getResourcePoolForExistingKey(key);\n            rc = resourcePool.size.get();\n        } catch(IllegalArgumentException iae) {\n            logger.debug(\"getTotalResourceCount called on invalid key: \", iae);\n        }\n        return rc;\n    }\n\n",
    "label": 1,
    "rec": "Count the number of existing resources for a specific pool."
  },
  {
    "id": 3721,
    "type": "Summary",
    "comment": "Find next broke  LoadReport in round-robin fashion.",
    "code": "    LoadManagerReport nextBroker() throws PulsarServerException {\n        List<LoadManagerReport> availableBrokers = localZkCache.getAvailableBrokers();\n\n        if (availableBrokers.isEmpty()) {\n            throw new PulsarServerException(\"No active broker is available\");\n        } else {\n            int brokersCount = availableBrokers.size();\n            int nextIdx = signSafeMod(counter.getAndIncrement(), brokersCount);\n            return availableBrokers.get(nextIdx);\n        }\n    }\n",
    "label": 1,
    "rec": "Find next broker  LoadManagerReport in round-robin fashion."
  },
  {
    "id": 3722,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ENCODEDBY;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3723,
    "type": "Summary",
    "comment": "Register the registration token with BaaS.",
    "code": "    private Task<Void> registerWithServer(final String registrationToken) {\n        final Map<String, Object> request = getRegisterPushDeviceRequest(registrationToken);\n        return getStitchClient().executePipeline(new PipelineStage(\n                Actions.REGISTER_PUSH, request))\n                .continueWith(new Continuation<List<Object>, Void>() {\n                    @Override\n                    public Void then(@NonNull Task<List<Object>> task) throws Exception {\n                        if (!task.isSuccessful()) {\n                            throw task.getException();\n                        }\n\n                        addInfoToConfigs(_info);\n                        return null;\n                    }\n                });\n    }\n\n",
    "label": 1,
    "rec": "Register the registration token with Stitch."
  },
  {
    "id": 3724,
    "type": "Summary",
    "comment": "Retrieve the dir pointed to by 'latest' symbolic-link or the current version dir",
    "code": "    private File getCurrentVersion() {\n        File latestSymLink = new File(storeDir, \"latest\");\n        if(latestSymLink.exists() && Utils.isSymLink(latestSymLink)) {\n            File canonicalLatestVersion = null;\n            try {\n                canonicalLatestVersion = latestSymLink.getCanonicalFile();\n            } catch(IOException e) {}\n\n            if(canonicalLatestVersion != null\n               && ReadOnlyUtils.checkVersionDirName(canonicalLatestVersion))\n                return canonicalLatestVersion;\n        }\n        File[] versionDirs = ReadOnlyUtils.getVersionDirs(storeDir);\n\n        if(versionDirs == null || versionDirs.length == 0) {\n            return null;\n        } else {\n            return ReadOnlyUtils.findKthVersionedDir(versionDirs,\n                                                     versionDirs.length - 1,\n                                                     versionDirs.length - 1)[0];\n        }\n    }\n",
    "label": 1,
    "rec": "Retrieve the dir pointed to by 'latest' symbolic-link or the max version dir"
  },
  {
    "id": 3725,
    "type": "Summary",
    "comment": "Returns the output lop of maxpool operation with same parameters as this hop.",
    "code": "\tprivate Lop getMaxPoolOutputLop() throws HopsException, LopsException {\n\t\tif(op == ConvOp.MAX_POOLING_BACKWARD || op == ConvOp.AVG_POOLING_BACKWARD) {\n\t\t\tConvOp opType = (op == ConvOp.MAX_POOLING_BACKWARD) ? ConvOp.MAX_POOLING : ConvOp.AVG_POOLING;\n\t\t\tHop inputImage = getInput().get(0);\n\t\t\tfor(Hop tmpParent : inputImage.getParent()) {\n\t\t\t\tif(!(tmpParent instanceof ConvolutionOp))\n\t\t\t\t\tcontinue;\n\t\t\t\tConvolutionOp parent = (ConvolutionOp) tmpParent;\n\t\t\t\tif(parent.getOp() == opType && isPoolingParametersEqualAndKnown(parent._cachedParams, _cachedParams)) {\n\t\t\t\t\treturn parent.constructLops();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the output lop of max_pool/avg_pool operation with same parameters as this hop."
  },
  {
    "id": 3726,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_PRIVATE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3727,
    "type": "Summary",
    "comment": "Lookup  RestLiMethodAdapter by  ResourceMethod.",
    "code": "  public static RestLiArgumentBuilder getMethodAdapter(final ResourceMethod resourceMethod)\n  {\n    return _adapters.get(resourceMethod);\n  }\n\n",
    "label": 1,
    "rec": "Lookup  RestLiArgumentBuilder by  ResourceMethod."
  },
  {
    "id": 3728,
    "type": "Summary",
    "comment": "Returns the URL to the store page for this game",
    "code": "    public String getStoreUrl() {\n        return \"http://store.steampowered.com/app/\" + this.appId;\n    }\n\n",
    "label": 1,
    "rec": "Returns the URL of this game's page in the Steam Store"
  },
  {
    "id": 3729,
    "type": "Summary",
    "comment": "Broadcast a transaction to all connected peers.",
    "code": "    public Future<Transaction> broadcastTransaction(final Transaction tx) {\n        FutureTask<Transaction> future = new FutureTask<Transaction>(new Runnable() {\n            public void run() {\n                // This is run with the peer group already locked.\n                for (Peer peer : peers) {\n                    try {\n                        peer.sendMessage(tx);\n                    } catch (IOException e) {\n                        log.warn(\"Caught IOException whilst sending transaction: {}\", e.getMessage());\n                    }\n                }\n            }\n        }, tx);\n        peerGroupThread.addTask(future);\n        return future;\n    }\n\n",
    "label": 1,
    "rec": "Queues a transaction for asynchronous broadcast."
  },
  {
    "id": 3730,
    "type": "Summary",
    "comment": "Returns any nested exceptions included in this exception.",
    "code": "    public Throwable getCause() {\n        return cause;\n    }\n\n",
    "label": 1,
    "rec": "Returns the cause of this exception or null if the cause was specified when this exception was created."
  },
  {
    "id": 3731,
    "type": "Summary",
    "comment": "Gets the managed exclusions to apply to the dependency.",
    "code": "    public Collection<Exclusion> getExclusions()\n    {\n        return exclusions;\n    }\n\n",
    "label": 1,
    "rec": "Gets the new exclusions to apply to the dependency."
  },
  {
    "id": 3732,
    "type": "Summary",
    "comment": "if property exampleTargetPackage specified for example ,use the specified value .",
    "code": "    protected String calculateJavaModelExamplePackage() {\n        JavaModelGeneratorConfiguration config = context.getJavaModelGeneratorConfiguration();\n        String exampleTargetPackage = config.getProperty(PropertyRegistry.MODEL_GENERATOR_EXAMPLE_PACKAGE);\n        if (!stringHasValue(exampleTargetPackage)) {\n            return calculateJavaModelPackage();\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        sb.append(exampleTargetPackage);\n        sb.append(fullyQualifiedTable.getSubPackageForModel(isSubPackagesEnabled(config)));\n        return sb.toString();\n    }\n",
    "label": 1,
    "rec": "if property exampleTargetPackage specified for example use the specified value, else use default value (targetPackage)"
  },
  {
    "id": 3733,
    "type": "Summary",
    "comment": "Finds all Transactions that match the query and returns a  PagedCollection for paging through them starting at the first page.",
    "code": "    public ResourceCollection<Transaction> search(String query) {\n        return search(query, 1);\n    }\n\n",
    "label": 1,
    "rec": "Finds all Transactions that match the query and returns a  ResourceCollection for paging through them starting at the first page."
  },
  {
    "id": 3734,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_MEDIA_TYPE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3735,
    "type": "Summary",
    "comment": "Registers a command with the given name is possible, otherwise uses fallbackPrefix to create a unique name if its not an alias",
    "code": "    private synchronized boolean register(String label, Command command, boolean isAlias) {\n        if (isAlias && knownCommands.containsKey(label)) {\n            // Request is for an alias and it conflicts with a existing command or previous alias ignore it\n            // Note: This will mean it gets removed from the commands list of active aliases\n            return false;\n        }\n\n        boolean registered = true;\n\n        // If the command exists but is an alias we overwrite it, otherwise we return\n        Command conflict = knownCommands.get(label);\n        if (conflict != null && conflict.getLabel().equals(label)) {\n            return false;\n        }\n\n        if (!isAlias) {\n            command.setLabel(label);\n        }\n        knownCommands.put(label, command);\n\n        return registered;\n    }\n\n",
    "label": 1,
    "rec": "Registers a command with the given name is possible."
  },
  {
    "id": 3736,
    "type": "Summary",
    "comment": "Return ahe  org.apache.tez.dag.api.EdgeManagerContext for this specific instance of the vertex manager.",
    "code": "  public EdgeManagerPluginContext getContext() {\n    return this.context;\n  }\n\n",
    "label": 1,
    "rec": "Return ahe  org.apache.tez.dag.api.EdgeManagerPluginContext for this specific instance of the vertex manager."
  },
  {
    "id": 3737,
    "type": "Summary",
    "comment": "Create an intent to show gists with an initial selected filed",
    "code": "    public static Intent createIntent(List<Gist> gists, int position) {\n        List<String> ids = new ArrayList<String>(gists.size());\n        for (Gist gist : gists)\n            ids.add(gist.getId());\n        return new Builder(\"gists.VIEW\").add(EXTRA_GIST_IDS, (Serializable) ids).add(EXTRA_POSITION, position)\n                .toIntent();\n    }\n",
    "label": 1,
    "rec": "Create an intent to show gists with an initial selected Gist"
  },
  {
    "id": 3738,
    "type": "Summary",
    "comment": "Returns the location of the platform working directory (also known as instance data).",
    "code": "\tpublic static Location getInstanceLocation() {\n\t\treturn InternalPlatform.getDefault().getInstanceLocation();\n\t}\n\n",
    "label": 1,
    "rec": "Returns the location of the platform's working directory (also known as the instance data area)."
  },
  {
    "id": 3739,
    "type": "Summary",
    "comment": "Finds all Transactions that match the query and returns a  PagedCollection for paging through them starting with the given page.",
    "code": "    public ResourceCollection<Transaction> search(String query, int pageNumber) {\n        String queryString = new QueryString().append(\"q\", query).append(\"page\", pageNumber).toString();\n        NodeWrapper response = http.get(\"/transactions/all/search?\" + queryString);\n        return new ResourceCollection<Transaction>(new TransactionPager(this, query), response, Transaction.class);\n    }\n\n",
    "label": 1,
    "rec": "Finds all Transactions that match the query and returns a  ResourceCollection for paging through them starting with the given page."
  },
  {
    "id": 3740,
    "type": "Summary",
    "comment": "Returns the list of contributed  TeamRepositoryProvider.",
    "code": "\tpublic List<AbstractTeamRepositoryProvider> getProviders() {\n\t\treturn provider;\n\t}\n\n",
    "label": 1,
    "rec": "Returns the list of contributed  AbstractTeamRepositoryProvider."
  },
  {
    "id": 3741,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_ORIGARTIST;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3742,
    "type": "Summary",
    "comment": "Returns the identifiers of the properties this entity provides.",
    "code": "    public Set<String> getPropertyNames() {\n        return getProperties().keySet();\n    }\n\n",
    "label": 1,
    "rec": "Returns the names of the properties of this entity."
  },
  {
    "id": 3743,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return ID3v24Frames.FRAME_ID_PLAYLIST_DELAY;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3744,
    "type": "Summary",
    "comment": "Return ahe  org.apache.tez.runtime.api.TezOutputContext for this specific instance of the LogicalOutput",
    "code": "  public final OutputContext getContext() {\n    return outputContext;\n  }\n\n",
    "label": 1,
    "rec": "Return ahe  org.apache.tez.runtime.api.OutputContext for this specific instance of the LogicalOutput"
  },
  {
    "id": 3745,
    "type": "Summary",
    "comment": "Parse request.",
    "code": "    public CallbackRequest handle(String signature, String payload)\n            throws LineBotCallbackException, IOException {\n        try {\n            return parser.handle(signature, payload.getBytes(StandardCharsets.UTF_8));\n        } catch (WebhookParseException e) {\n            throw new LineBotCallbackException(e.getMessage());\n        }\n    }\n",
    "label": 1,
    "rec": "Parses a request."
  },
  {
    "id": 3746,
    "type": "Summary",
    "comment": "Get the filter string used by this Filtered listener.",
    "code": "\tpublic String toString() {\n\t\tString filterString = getFilter();\n\t\tif (filterString == null) {\n\t\t\tfilterString = \"\"; //$NON-NLS-1$\n\t\t}\n\t\treturn listener.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(listener)) + filterString; //$NON-NLS-1$\n\t}\n\n",
    "label": 1,
    "rec": "The string representation of this Filtered listener."
  },
  {
    "id": 3747,
    "type": "Summary",
    "comment": "Creates an instance type for the local machine that calls this method.",
    "code": "\tpublic static final InstanceType createDefaultInstanceType() {\n\n\t\tfinal HardwareDescription hardwareDescription = HardwareDescriptionFactory.extractFromSystem();\n\n\t\tint diskCapacityInGB = 0;\n\t\tfinal String tempDir = GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,\n\t\t\tConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);\n\t\tif (tempDir != null) {\n\t\t\tFile f = new File(tempDir);\n\t\t\tdiskCapacityInGB = (int) (f.getFreeSpace() / (1024L * 1024L * 1024L));\n\t\t}\n\n\t\tfinal int physicalMemory = (int) (hardwareDescription.getSizeOfPhysicalMemory() / (1024L * 1024L));\n\n\t\treturn InstanceTypeFactory.construct(\"default\", hardwareDescription.getNumberOfCPUCores(),\n\t\t\thardwareDescription.getNumberOfCPUCores(), physicalMemory, diskCapacityInGB, 0);\n\t}\n\n",
    "label": 1,
    "rec": "Creates a default instance type based on the hardware characteristics of the machine that calls this method."
  },
  {
    "id": 3748,
    "type": "Summary",
    "comment": "Get an AssertionWrapper object from parsing a SecurityTokenReference that uses a KeyIdentifier that points to a SAML Assertion.",
    "code": "    public static SamlAssertionWrapper getAssertionFromKeyIdentifier(\n        SecurityTokenReference secRef,\n        Element strElement,\n        RequestData request,\n        WSDocInfo wsDocInfo\n    ) throws WSSecurityException {\n        String keyIdentifierValue = secRef.getKeyIdentifierValue();\n        String type = secRef.getKeyIdentifierValueType();\n        WSSecurityEngineResult result = wsDocInfo.getResult(keyIdentifierValue);\n\n        SamlAssertionWrapper samlAssertion = null;\n        Element token = null;\n        if (result != null) {\n            samlAssertion =\n                (SamlAssertionWrapper)result.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n            return samlAssertion;\n        } else {\n            token = \n                secRef.findProcessedTokenElement(\n                    strElement.getOwnerDocument(), wsDocInfo,\n                    request.getCallbackHandler(),\n                    keyIdentifierValue, type\n                );\n            if (token != null) {\n                if (!\"Assertion\".equals(token.getLocalName())) {\n                    throw new WSSecurityException(\n                        WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\"\n                    );\n                }\n                return new SamlAssertionWrapper(token);\n            }\n            token = \n                secRef.findUnprocessedTokenElement(\n                    strElement.getOwnerDocument(), wsDocInfo,\n                    request.getCallbackHandler(), keyIdentifierValue, type\n                );\n            \n            if (token == null || !\"Assertion\".equals(token.getLocalName())) {\n                throw new WSSecurityException(\n                    WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\"\n                );\n            }\n            Processor proc = request.getWssConfig().getProcessor(WSSecurityEngine.SAML_TOKEN);\n            List<WSSecurityEngineResult> samlResult =\n                proc.handleToken(token, request, wsDocInfo);\n            return \n                (SamlAssertionWrapper)samlResult.get(0).get(\n                    WSSecurityEngineResult.TAG_SAML_ASSERTION\n                );\n        }\n    }\n\n",
    "label": 1,
    "rec": "Get an SamlAssertionWrapper object from parsing a SecurityTokenReference that uses a KeyIdentifier that points to a SAML Assertion."
  },
  {
    "id": 3749,
    "type": "Summary",
    "comment": "predict a ranking score for user u on item j: default case using the predicted rating values",
    "code": "\tprotected double ranking(int u, int j) {\n\t\treturn predict(u, j, false);\n\t}\n",
    "label": 1,
    "rec": "predict a ranking score for user u on item j: default case using the unbounded predicted rating values"
  },
  {
    "id": 3750,
    "type": "Summary",
    "comment": "DOCUMENT ME!",
    "code": "    public String getIdentifier()\n    {\n        return  ID3v24Frames.FRAME_ID_ORIG_TITLE;\n    }\n\n",
    "label": 1,
    "rec": "The ID3v2 frame identifier"
  },
  {
    "id": 3751,
    "type": "Summary",
    "comment": "Gets the costs for secondary storage.",
    "code": "\tpublic long getSecondaryStorageCost() {\n\t\treturn diskCost;\n\t}\n\n",
    "label": 1,
    "rec": "Gets the costs for disk."
  },
  {
    "id": 3752,
    "type": "Summary",
    "comment": "Union of given String arrays.",
    "code": "  public static String[] union(String[] a, String[] b) {\n    assert a!=null && b!=null : \"Union expect non-null input!\";\n    String[] r = new String[a.length+b.length];\n    int ia = 0, ib = 0, i = 0;\n    while (ia < a.length && ib < b.length) {\n      int c = a[ia].compareTo(b[ib]);\n      if ( c < 0) r[i++] = a[ia++];\n      else if (c == 0) { r[i++] = a[ia++]; ib++; }\n      else r[i++] = b[ib++];\n    }\n    if (ia < a.length) while (ia<a.length) r[i++] = a[ia++];\n    if (ib < b.length) while (ib<b.length) r[i++] = b[ib++];\n    return Arrays.copyOf(r, i);\n  }\n",
    "label": 1,
    "rec": "Union of given arrays."
  },
  {
    "id": 3753,
    "type": "Summary",
    "comment": "Toggles the facing value between  CameraConstants#FACING_BACK and  CameraConstants#FACING_FRONT.",
    "code": "    public Facing toggleFacing() {\n        Facing facing = mCameraController.getFacing();\n        switch (facing) {\n            case BACK:\n                setFacing(Facing.FRONT);\n                break;\n\n            case FRONT:\n                setFacing(Facing.BACK);\n                break;\n        }\n\n        return mCameraController.getFacing();\n    }\n",
    "label": 1,
    "rec": "Toggles the facing value between  Facing#BACK and  Facing#FRONT."
  },
  {
    "id": 3754,
    "type": "Summary",
    "comment": "Returns the name of the class corresponding to this type.",
    "code": "    public String getClassName() {\n        switch (sort) {\n        case VOID:\n            return \"void\";\n        case BOOLEAN:\n            return \"boolean\";\n        case CHAR:\n            return \"char\";\n        case BYTE:\n            return \"byte\";\n        case SHORT:\n            return \"short\";\n        case INT:\n            return \"int\";\n        case FLOAT:\n            return \"float\";\n        case LONG:\n            return \"long\";\n        case DOUBLE:\n            return \"double\";\n        case ARRAY:\n            StringBuffer b = new StringBuffer(getElementType().getClassName());\n            for (int i = getDimensions(); i > 0; --i) {\n                b.append(\"[]\");\n            }\n            return b.toString();\n        case OBJECT:\n            return new String(buf, off, len).replace('/', '.');\n        default:\n            return null;\n        }\n    }\n\n",
    "label": 1,
    "rec": "Returns the binary name of the class corresponding to this type."
  },
  {
    "id": 3755,
    "type": "Summary",
    "comment": "Connect to a peer by creating a Netty channel to the destination address.",
    "code": "    public Peer connectTo(InetSocketAddress address) {\n        return connectTo(address, true);\n    }\n\n",
    "label": 1,
    "rec": "Connect to a peer by creating a channel to the destination address."
  }
]